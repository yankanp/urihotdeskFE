(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["layouts-admin-layout-admin-layout-module"],{

/***/ "./node_modules/@agm/core/fesm2015/agm-core.js":
/*!*****************************************************!*\
  !*** ./node_modules/@agm/core/fesm2015/agm-core.js ***!
  \*****************************************************/
/*! exports provided: AgmBicyclingLayer, AgmCircle, AgmCoreModule, AgmDataLayer, AgmFitBounds, AgmGeocoder, AgmInfoWindow, AgmKmlLayer, AgmMap, AgmMarker, AgmPolygon, AgmPolyline, AgmPolylineIcon, AgmPolylinePoint, AgmRectangle, AgmTransitLayer, CircleManager, ControlPosition, DataLayerManager, FitBoundsAccessor, GeocoderLocationType, GeocoderStatus, GoogleMapsAPIWrapper, GoogleMapsScriptProtocol, InfoWindowManager, KmlLayerManager, LAZY_MAPS_API_CONFIG, LayerManager, LazyMapsAPILoader, MapTypeId, MapsAPILoader, MarkerManager, NoOpMapsAPILoader, PolygonManager, PolylineManager, RectangleManager, ScaleControlStyle, ZoomControlStyle, ɵa, ɵb, ɵc, ɵd, ɵe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmBicyclingLayer", function() { return AgmBicyclingLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmCircle", function() { return AgmCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmCoreModule", function() { return AgmCoreModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmDataLayer", function() { return AgmDataLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmFitBounds", function() { return AgmFitBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmGeocoder", function() { return AgmGeocoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmInfoWindow", function() { return AgmInfoWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmKmlLayer", function() { return AgmKmlLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmMap", function() { return AgmMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmMarker", function() { return AgmMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmPolygon", function() { return AgmPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmPolyline", function() { return AgmPolyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmPolylineIcon", function() { return AgmPolylineIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmPolylinePoint", function() { return AgmPolylinePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmRectangle", function() { return AgmRectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgmTransitLayer", function() { return AgmTransitLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleManager", function() { return CircleManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ControlPosition", function() { return ControlPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataLayerManager", function() { return DataLayerManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FitBoundsAccessor", function() { return FitBoundsAccessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeocoderLocationType", function() { return GeocoderLocationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeocoderStatus", function() { return GeocoderStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleMapsAPIWrapper", function() { return GoogleMapsAPIWrapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleMapsScriptProtocol", function() { return GoogleMapsScriptProtocol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InfoWindowManager", function() { return InfoWindowManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KmlLayerManager", function() { return KmlLayerManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAZY_MAPS_API_CONFIG", function() { return LAZY_MAPS_API_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerManager", function() { return LayerManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LazyMapsAPILoader", function() { return LazyMapsAPILoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapTypeId", function() { return MapTypeId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapsAPILoader", function() { return MapsAPILoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkerManager", function() { return MarkerManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoOpMapsAPILoader", function() { return NoOpMapsAPILoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonManager", function() { return PolygonManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylineManager", function() { return PolylineManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectangleManager", function() { return RectangleManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleControlStyle", function() { return ScaleControlStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomControlStyle", function() { return ZoomControlStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return FitBoundsService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return coreDirectives; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return WindowRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return DocumentRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function() { return BROWSER_GLOBALS_PROVIDERS; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");






let MapsAPILoader = class MapsAPILoader {
};
MapsAPILoader = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])()
], MapsAPILoader);

/**
 * Wrapper class that handles the communication with the Google Maps Javascript
 * API v3
 */
let GoogleMapsAPIWrapper = class GoogleMapsAPIWrapper {
    constructor(_loader, _zone) {
        this._loader = _loader;
        this._zone = _zone;
        this._map =
            new Promise((resolve) => { this._mapResolver = resolve; });
    }
    createMap(el, mapOptions) {
        return this._zone.runOutsideAngular(() => {
            return this._loader.load().then(() => {
                const map = new google.maps.Map(el, mapOptions);
                this._mapResolver(map);
                return;
            });
        });
    }
    setMapOptions(options) {
        return this._zone.runOutsideAngular(() => {
            this._map.then((m) => { m.setOptions(options); });
        });
    }
    /**
     * Creates a google map marker with the map context
     */
    createMarker(options = {}, addToMap = true) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => {
                if (addToMap) {
                    options.map = map;
                }
                return new google.maps.Marker(options);
            });
        });
    }
    createInfoWindow(options) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then(() => { return new google.maps.InfoWindow(options); });
        });
    }
    /**
     * Creates a google.map.Circle for the current map.
     */
    createCircle(options) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => {
                if (typeof options.strokePosition === 'string') {
                    options.strokePosition = google.maps.StrokePosition[options.strokePosition];
                }
                options.map = map;
                return new google.maps.Circle(options);
            });
        });
    }
    /**
     * Creates a google.map.Rectangle for the current map.
     */
    createRectangle(options) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => {
                options.map = map;
                return new google.maps.Rectangle(options);
            });
        });
    }
    createPolyline(options) {
        return this._zone.runOutsideAngular(() => {
            return this.getNativeMap().then((map) => {
                let line = new google.maps.Polyline(options);
                line.setMap(map);
                return line;
            });
        });
    }
    createPolygon(options) {
        return this._zone.runOutsideAngular(() => {
            return this.getNativeMap().then((map) => {
                let polygon = new google.maps.Polygon(options);
                polygon.setMap(map);
                return polygon;
            });
        });
    }
    /**
     * Creates a new google.map.Data layer for the current map
     */
    createDataLayer(options) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then(m => {
                let data = new google.maps.Data(options);
                data.setMap(m);
                return data;
            });
        });
    }
    /**
     * Creates a TransitLayer instance for a map
     * @param {TransitLayerOptions} options - used for setting layer options
     * @returns {Promise<TransitLayer>} a new transit layer object
     */
    createTransitLayer(options) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => {
                let newLayer = new google.maps.TransitLayer();
                newLayer.setMap(options.visible ? map : null);
                return newLayer;
            });
        });
    }
    /**
     * Creates a BicyclingLayer instance for a map
     * @param {BicyclingLayerOptions} options - used for setting layer options
     * @returns {Promise<BicyclingLayer>} a new bicycling layer object
     */
    createBicyclingLayer(options) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => {
                let newLayer = new google.maps.BicyclingLayer();
                newLayer.setMap(options.visible ? map : null);
                return newLayer;
            });
        });
    }
    /**
     * Determines if given coordinates are insite a Polygon path.
     */
    containsLocation(latLng, polygon) {
        return google.maps.geometry.poly.containsLocation(latLng, polygon);
    }
    subscribeToMapEvent(eventName) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._map.then((m) => {
                m.addListener(eventName, (arg) => { this._zone.run(() => observer.next(arg)); });
            });
        });
    }
    clearInstanceListeners() {
        return this._zone.runOutsideAngular(() => {
            this._map.then((map) => {
                google.maps.event.clearInstanceListeners(map);
            });
        });
    }
    setCenter(latLng) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.setCenter(latLng));
        });
    }
    getZoom() {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.getZoom());
        });
    }
    getBounds() {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.getBounds());
        });
    }
    getMapTypeId() {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.getMapTypeId());
        });
    }
    setZoom(zoom) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.setZoom(zoom));
        });
    }
    getCenter() {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.getCenter());
        });
    }
    panTo(latLng) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.panTo(latLng));
        });
    }
    panBy(x, y) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.panBy(x, y));
        });
    }
    fitBounds(latLng, padding) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.fitBounds(latLng, padding));
        });
    }
    panToBounds(latLng, padding) {
        return this._zone.runOutsideAngular(() => {
            return this._map.then((map) => map.panToBounds(latLng, padding));
        });
    }
    /**
     * Returns the native Google Maps Map instance. Be careful when using this instance directly.
     */
    getNativeMap() { return this._map; }
    /**
     * Triggers the given event name on the map instance.
     */
    triggerMapEvent(eventName) {
        return this._map.then((m) => google.maps.event.trigger(m, eventName));
    }
};
GoogleMapsAPIWrapper.ctorParameters = () => [
    { type: MapsAPILoader },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
GoogleMapsAPIWrapper = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [MapsAPILoader, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], GoogleMapsAPIWrapper);

/**
 * This class manages Transit and Bicycling Layers for a Google Map instance.
 */
let LayerManager = class LayerManager {
    constructor(_wrapper) {
        this._wrapper = _wrapper;
        this._layers = new Map();
    }
    /**
     * Adds a transit layer to a map instance.
     * @param {AgmTransitLayer} layer - a TransitLayer object
     * @param {TransitLayerOptions} options - TransitLayerOptions options
     * @returns void
     */
    addTransitLayer(layer, options) {
        const newLayer = this._wrapper.createTransitLayer(options);
        this._layers.set(layer, newLayer);
    }
    /**
     * Adds a bicycling layer to a map instance.
     * @param {AgmBicyclingLayer} layer - a bicycling layer object
     * @param {BicyclingLayerOptions} options - BicyclingLayer options
     * @returns void
     */
    addBicyclingLayer(layer, options) {
        const newLayer = this._wrapper.createBicyclingLayer(options);
        this._layers.set(layer, newLayer);
    }
    /**
     * Deletes a map layer
     * @param {AgmTransitLayer|AgmBicyclingLayer} layer - the layer to delete
     * @returns  Promise<void>
     */
    deleteLayer(layer) {
        return this._layers.get(layer).then(currentLayer => {
            currentLayer.setMap(null);
            this._layers.delete(layer);
        });
    }
    /**
     * Hide/Show a google map layer
     * @param { AgmTransitLayer|AgmBicyclingLayer} layer - the layer to hide/show
     * @param {TransitLayerOptions|BicyclingLayerOptions} options - used to set visibility of the layer
     * @returns Promise<void>
     */
    toggleLayerVisibility(layer, options) {
        return this._layers.get(layer).then(currentLayer => {
            if (!options.visible) {
                currentLayer.setMap(null);
                return;
            }
            else {
                return this._wrapper.getNativeMap().then((map) => {
                    currentLayer.setMap(map);
                });
            }
        });
    }
};
LayerManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper }
];
LayerManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper])
], LayerManager);

let layerId = 0;
/*
 * This directive adds a bicycling layer to a google map instance
 * <agm-bicycling-layer [visible]="true|false"> <agm-bicycling-layer>
 * */
let AgmBicyclingLayer = class AgmBicyclingLayer {
    constructor(_manager) {
        this._manager = _manager;
        this._addedToManager = false;
        this._id = (layerId++).toString();
        /**
         * Hide/show bicycling layer
         */
        this.visible = true;
    }
    ngOnInit() {
        if (this._addedToManager) {
            return;
        }
        this._manager.addBicyclingLayer(this, { visible: this.visible });
        this._addedToManager = true;
    }
    ngOnChanges(changes) {
        if (!this._addedToManager) {
            return;
        }
        if (changes['visible'] != null) {
            this._manager.toggleLayerVisibility(this, { visible: changes['visible'].currentValue });
        }
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    toString() { return `AgmBicyclingLayer-${this._id.toString()}`; }
    /** @internal */
    ngOnDestroy() {
        this._manager.deleteLayer(this);
    }
};
AgmBicyclingLayer.ctorParameters = () => [
    { type: LayerManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmBicyclingLayer.prototype, "visible", void 0);
AgmBicyclingLayer = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-bicycling-layer',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [LayerManager])
], AgmBicyclingLayer);

let CircleManager = class CircleManager {
    constructor(_apiWrapper, _zone) {
        this._apiWrapper = _apiWrapper;
        this._zone = _zone;
        this._circles = new Map();
    }
    addCircle(circle) {
        this._circles.set(circle, this._apiWrapper.createCircle({
            center: { lat: circle.latitude, lng: circle.longitude },
            clickable: circle.clickable,
            draggable: circle.draggable,
            editable: circle.editable,
            fillColor: circle.fillColor,
            fillOpacity: circle.fillOpacity,
            radius: circle.radius,
            strokeColor: circle.strokeColor,
            strokeOpacity: circle.strokeOpacity,
            strokePosition: circle.strokePosition,
            strokeWeight: circle.strokeWeight,
            visible: circle.visible,
            zIndex: circle.zIndex,
        }));
    }
    /**
     * Removes the given circle from the map.
     */
    removeCircle(circle) {
        return this._circles.get(circle).then((c) => {
            c.setMap(null);
            this._circles.delete(circle);
        });
    }
    setOptions(circle, options) {
        return this._circles.get(circle).then((c) => {
            if (typeof options.strokePosition === 'string') {
                options.strokePosition = google.maps.StrokePosition[options.strokePosition];
            }
            c.setOptions(options);
        });
    }
    getBounds(circle) {
        return this._circles.get(circle).then((c) => c.getBounds());
    }
    getCenter(circle) {
        return this._circles.get(circle).then((c) => c.getCenter());
    }
    getRadius(circle) {
        return this._circles.get(circle).then((c) => c.getRadius());
    }
    setCenter(circle) {
        return this._circles.get(circle).then((c) => { return c.setCenter({ lat: circle.latitude, lng: circle.longitude }); });
    }
    setEditable(circle) {
        return this._circles.get(circle).then((c) => { return c.setEditable(circle.editable); });
    }
    setDraggable(circle) {
        return this._circles.get(circle).then((c) => { return c.setDraggable(circle.draggable); });
    }
    setVisible(circle) {
        return this._circles.get(circle).then((c) => { return c.setVisible(circle.visible); });
    }
    setRadius(circle) {
        return this._circles.get(circle).then((c) => { return c.setRadius(circle.radius); });
    }
    getNativeCircle(circle) {
        return this._circles.get(circle);
    }
    createEventObservable(eventName, circle) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            let listener = null;
            this._circles.get(circle).then((c) => {
                listener = c.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
            return () => {
                if (listener !== null) {
                    listener.remove();
                }
            };
        });
    }
};
CircleManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
CircleManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], CircleManager);

var AgmCircle_1;
let AgmCircle = AgmCircle_1 = class AgmCircle {
    constructor(_manager) {
        this._manager = _manager;
        /**
         * Indicates whether this Circle handles mouse events. Defaults to true.
         */
        this.clickable = true;
        /**
         * If set to true, the user can drag this circle over the map. Defaults to false.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = false;
        /**
         * If set to true, the user can edit this circle by dragging the control points shown at
         * the center and around the circumference of the circle. Defaults to false.
         */
        this.editable = false;
        /**
         * The radius in meters on the Earth's surface.
         */
        this.radius = 0;
        /**
         * The stroke position. Defaults to CENTER.
         * This property is not supported on Internet Explorer 8 and earlier.
         */
        this.strokePosition = 'CENTER';
        /**
         * The stroke width in pixels.
         */
        this.strokeWeight = 0;
        /**
         * Whether this circle is visible on the map. Defaults to true.
         */
        this.visible = true;
        /**
         * This event is fired when the circle's center is changed.
         */
        this.centerChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user clicks on the circle.
         */
        this.circleClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user clicks on the circle.
         */
        this.circleDblClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is repeatedly fired while the user drags the circle.
         */
        this.drag = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user stops dragging the circle.
         */
        this.dragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user starts dragging the circle.
         */
        this.dragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousedown event is fired on the circle.
         */
        this.mouseDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousemove event is fired on the circle.
         */
        this.mouseMove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on circle mouseout.
         */
        this.mouseOut = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on circle mouseover.
         */
        this.mouseOver = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mouseup event is fired on the circle.
         */
        this.mouseUp = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the circle's radius is changed.
         */
        this.radiusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the circle is right-clicked on.
         */
        this.rightClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._circleAddedToManager = false;
        this._eventSubscriptions = [];
    }
    /** @internal */
    ngOnInit() {
        this._manager.addCircle(this);
        this._circleAddedToManager = true;
        this._registerEventListeners();
    }
    /** @internal */
    ngOnChanges(changes) {
        if (!this._circleAddedToManager) {
            return;
        }
        if (changes['latitude'] || changes['longitude']) {
            this._manager.setCenter(this);
        }
        if (changes['editable']) {
            this._manager.setEditable(this);
        }
        if (changes['draggable']) {
            this._manager.setDraggable(this);
        }
        if (changes['visible']) {
            this._manager.setVisible(this);
        }
        if (changes['radius']) {
            this._manager.setRadius(this);
        }
        this._updateCircleOptionsChanges(changes);
    }
    _updateCircleOptionsChanges(changes) {
        let options = {};
        let optionKeys = Object.keys(changes).filter(k => AgmCircle_1._mapOptions.indexOf(k) !== -1);
        optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });
        if (optionKeys.length > 0) {
            this._manager.setOptions(this, options);
        }
    }
    _registerEventListeners() {
        let events = new Map();
        events.set('center_changed', this.centerChange);
        events.set('click', this.circleClick);
        events.set('dblclick', this.circleDblClick);
        events.set('drag', this.drag);
        events.set('dragend', this.dragEnd);
        events.set('dragstart', this.dragStart);
        events.set('mousedown', this.mouseDown);
        events.set('mousemove', this.mouseMove);
        events.set('mouseout', this.mouseOut);
        events.set('mouseover', this.mouseOver);
        events.set('mouseup', this.mouseUp);
        events.set('radius_changed', this.radiusChange);
        events.set('rightclick', this.rightClick);
        events.forEach((eventEmitter, eventName) => {
            this._eventSubscriptions.push(this._manager.createEventObservable(eventName, this).subscribe((value) => {
                switch (eventName) {
                    case 'radius_changed':
                        this._manager.getRadius(this).then((radius) => eventEmitter.emit(radius));
                        break;
                    case 'center_changed':
                        this._manager.getCenter(this).then((center) => eventEmitter.emit({ lat: center.lat(), lng: center.lng() }));
                        break;
                    default:
                        eventEmitter.emit({ coords: { lat: value.latLng.lat(), lng: value.latLng.lng() } });
                }
            }));
        });
    }
    /** @internal */
    ngOnDestroy() {
        this._eventSubscriptions.forEach(function (s) { s.unsubscribe(); });
        this._eventSubscriptions = null;
        this._manager.removeCircle(this);
    }
    /**
     * Gets the LatLngBounds of this Circle.
     */
    getBounds() { return this._manager.getBounds(this); }
    getCenter() { return this._manager.getCenter(this); }
};
AgmCircle._mapOptions = [
    'fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',
    'visible', 'zIndex', 'clickable',
];
AgmCircle.ctorParameters = () => [
    { type: CircleManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmCircle.prototype, "latitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmCircle.prototype, "longitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmCircle.prototype, "clickable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('circleDraggable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmCircle.prototype, "draggable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmCircle.prototype, "editable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmCircle.prototype, "fillColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmCircle.prototype, "fillOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmCircle.prototype, "radius", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmCircle.prototype, "strokeColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmCircle.prototype, "strokeOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmCircle.prototype, "strokePosition", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmCircle.prototype, "strokeWeight", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmCircle.prototype, "visible", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmCircle.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "centerChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "circleClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "circleDblClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "drag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "dragEnd", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "dragStart", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "mouseDown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "mouseMove", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "mouseOut", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "mouseOver", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "mouseUp", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "radiusChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmCircle.prototype, "rightClick", void 0);
AgmCircle = AgmCircle_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-circle',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [CircleManager])
], AgmCircle);

/**
 * Manages all Data Layers for a Google Map instance.
 */
let DataLayerManager = class DataLayerManager {
    constructor(_wrapper, _zone) {
        this._wrapper = _wrapper;
        this._zone = _zone;
        this._layers = new Map();
    }
    /**
     * Adds a new Data Layer to the map.
     */
    addDataLayer(layer) {
        const newLayer = this._wrapper.createDataLayer({
            style: layer.style,
        })
            .then(d => {
            if (layer.geoJson) {
                this.getDataFeatures(d, layer.geoJson).then(features => d.features = features);
            }
            return d;
        });
        this._layers.set(layer, newLayer);
    }
    deleteDataLayer(layer) {
        this._layers.get(layer).then(l => {
            l.setMap(null);
            this._layers.delete(layer);
        });
    }
    updateGeoJson(layer, geoJson) {
        this._layers.get(layer).then(l => {
            l.forEach(function (feature) {
                l.remove(feature);
                var index = l.features.indexOf(feature, 0);
                if (index > -1) {
                    l.features.splice(index, 1);
                }
            });
            this.getDataFeatures(l, geoJson).then(features => l.features = features);
        });
    }
    setDataOptions(layer, options) {
        this._layers.get(layer).then(l => {
            l.setControlPosition(options.controlPosition);
            l.setControls(options.controls);
            l.setDrawingMode(options.drawingMode);
            l.setStyle(options.style);
        });
    }
    /**
     * Creates a Google Maps event listener for the given DataLayer as an Observable
     */
    createEventObservable(eventName, layer) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._layers.get(layer).then((d) => {
                d.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
    /**
     * Extract features from a geoJson using google.maps Data Class
     * @param d : google.maps.Data class instance
     * @param geoJson : url or geojson object
     */
    getDataFeatures(d, geoJson) {
        return new Promise((resolve, reject) => {
            if (typeof geoJson === 'object') {
                try {
                    const features = d.addGeoJson(geoJson);
                    resolve(features);
                }
                catch (e) {
                    reject(e);
                }
            }
            else if (typeof geoJson === 'string') {
                d.loadGeoJson(geoJson, null, resolve);
            }
            else {
                reject(`Impossible to extract features from geoJson: wrong argument type`);
            }
        });
    }
};
DataLayerManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
DataLayerManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], DataLayerManager);

var AgmDataLayer_1;
let layerId$1 = 0;
/**
 * AgmDataLayer enables the user to add data layers to the map.
 *
 * ### Example
 * ```typescript
 * import { Component } from 'angular2/core';
 * import { AgmMap, AgmDataLayer } from
 * 'angular-google-maps/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  directives: [AgmMap, AgmDataLayer],
 *  styles: [`
 *    .agm-container {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 * <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 * 	  <agm-data-layer [geoJson]="geoJsonObject" (layerClick)="clicked($event)" [style]="styleFunc">
 * 	  </agm-data-layer>
 * </agm-map>
 *  `
 * })
 * export class MyMapCmp {
 *   lat: number = -25.274449;
 *   lng: number = 133.775060;
 *   zoom: number = 5;
 *
 * clicked(clickEvent) {
 *    console.log(clickEvent);
 *  }
 *
 *  styleFunc(feature) {
 *    return ({
 *      clickable: false,
 *      fillColor: feature.getProperty('color'),
 *      strokeWeight: 1
 *    });
 *  }
 *
 *  geoJsonObject: Object = {
 *    "type": "FeatureCollection",
 *    "features": [
 *      {
 *        "type": "Feature",
 *        "properties": {
 *          "letter": "G",
 *          "color": "blue",
 *          "rank": "7",
 *          "ascii": "71"
 *        },
 *        "geometry": {
 *          "type": "Polygon",
 *          "coordinates": [
 *            [
 *              [123.61, -22.14], [122.38, -21.73], [121.06, -21.69], [119.66, -22.22], [119.00, -23.40],
 *              [118.65, -24.76], [118.43, -26.07], [118.78, -27.56], [119.22, -28.57], [120.23, -29.49],
 *              [121.77, -29.87], [123.57, -29.64], [124.45, -29.03], [124.71, -27.95], [124.80, -26.70],
 *              [124.80, -25.60], [123.61, -25.64], [122.56, -25.64], [121.72, -25.72], [121.81, -26.62],
 *              [121.86, -26.98], [122.60, -26.90], [123.57, -27.05], [123.57, -27.68], [123.35, -28.18],
 *              [122.51, -28.38], [121.77, -28.26], [121.02, -27.91], [120.49, -27.21], [120.14, -26.50],
 *              [120.10, -25.64], [120.27, -24.52], [120.67, -23.68], [121.72, -23.32], [122.43, -23.48],
 *              [123.04, -24.04], [124.54, -24.28], [124.58, -23.20], [123.61, -22.14]
 *            ]
 *          ]
 *        }
 *      },
 *      {
 *        "type": "Feature",
 *        "properties": {
 *          "letter": "o",
 *          "color": "red",
 *          "rank": "15",
 *          "ascii": "111"
 *        },
 *        "geometry": {
 *          "type": "Polygon",
 *          "coordinates": [
 *            [
 *              [128.84, -25.76], [128.18, -25.60], [127.96, -25.52], [127.88, -25.52], [127.70, -25.60],
 *              [127.26, -25.79], [126.60, -26.11], [126.16, -26.78], [126.12, -27.68], [126.21, -28.42],
 *              [126.69, -29.49], [127.74, -29.80], [128.80, -29.72], [129.41, -29.03], [129.72, -27.95],
 *              [129.68, -27.21], [129.33, -26.23], [128.84, -25.76]
 *            ],
 *            [
 *              [128.45, -27.44], [128.32, -26.94], [127.70, -26.82], [127.35, -27.05], [127.17, -27.80],
 *              [127.57, -28.22], [128.10, -28.42], [128.49, -27.80], [128.45, -27.44]
 *            ]
 *          ]
 *        }
 *      },
 *      {
 *        "type": "Feature",
 *        "properties": {
 *          "letter": "o",
 *          "color": "yellow",
 *          "rank": "15",
 *          "ascii": "111"
 *        },
 *        "geometry": {
 *          "type": "Polygon",
 *          "coordinates": [
 *            [
 *              [131.87, -25.76], [131.35, -26.07], [130.95, -26.78], [130.82, -27.64], [130.86, -28.53],
 *              [131.26, -29.22], [131.92, -29.76], [132.45, -29.87], [133.06, -29.76], [133.72, -29.34],
 *              [134.07, -28.80], [134.20, -27.91], [134.07, -27.21], [133.81, -26.31], [133.37, -25.83],
 *              [132.71, -25.64], [131.87, -25.76]
 *            ],
 *            [
 *              [133.15, -27.17], [132.71, -26.86], [132.09, -26.90], [131.74, -27.56], [131.79, -28.26],
 *              [132.36, -28.45], [132.93, -28.34], [133.15, -27.76], [133.15, -27.17]
 *            ]
 *          ]
 *        }
 *      },
 *      {
 *        "type": "Feature",
 *        "properties": {
 *          "letter": "g",
 *          "color": "blue",
 *          "rank": "7",
 *          "ascii": "103"
 *        },
 *        "geometry": {
 *          "type": "Polygon",
 *          "coordinates": [
 *            [
 *              [138.12, -25.04], [136.84, -25.16], [135.96, -25.36], [135.26, -25.99], [135, -26.90],
 *              [135.04, -27.91], [135.26, -28.88], [136.05, -29.45], [137.02, -29.49], [137.81, -29.49],
 *              [137.94, -29.99], [137.90, -31.20], [137.85, -32.24], [136.88, -32.69], [136.45, -32.36],
 *              [136.27, -31.80], [134.95, -31.84], [135.17, -32.99], [135.52, -33.43], [136.14, -33.76],
 *              [137.06, -33.83], [138.12, -33.65], [138.86, -33.21], [139.30, -32.28], [139.30, -31.24],
 *              [139.30, -30.14], [139.21, -28.96], [139.17, -28.22], [139.08, -27.41], [139.08, -26.47],
 *              [138.99, -25.40], [138.73, -25.00], [138.12, -25.04]
 *            ],
 *            [
 *              [137.50, -26.54], [136.97, -26.47], [136.49, -26.58], [136.31, -27.13], [136.31, -27.72],
 *              [136.58, -27.99], [137.50, -28.03], [137.68, -27.68], [137.59, -26.78], [137.50, -26.54]
 *            ]
 *          ]
 *        }
 *      },
 *      {
 *        "type": "Feature",
 *        "properties": {
 *          "letter": "l",
 *          "color": "green",
 *          "rank": "12",
 *          "ascii": "108"
 *        },
 *        "geometry": {
 *          "type": "Polygon",
 *          "coordinates": [
 *            [
 *              [140.14, -21.04], [140.31, -29.42], [141.67, -29.49], [141.59, -20.92], [140.14, -21.04]
 *            ]
 *          ]
 *        }
 *      },
 *      {
 *        "type": "Feature",
 *        "properties": {
 *          "letter": "e",
 *          "color": "red",
 *          "rank": "5",
 *          "ascii": "101"
 *        },
 *        "geometry": {
 *          "type": "Polygon",
 *          "coordinates": [
 *            [
 *              [144.14, -27.41], [145.67, -27.52], [146.86, -27.09], [146.82, -25.64], [146.25, -25.04],
 *              [145.45, -24.68], [144.66, -24.60], [144.09, -24.76], [143.43, -25.08], [142.99, -25.40],
 *              [142.64, -26.03], [142.64, -27.05], [142.64, -28.26], [143.30, -29.11], [144.18, -29.57],
 *              [145.41, -29.64], [146.46, -29.19], [146.64, -28.72], [146.82, -28.14], [144.84, -28.42],
 *              [144.31, -28.26], [144.14, -27.41]
 *            ],
 *            [
 *              [144.18, -26.39], [144.53, -26.58], [145.19, -26.62], [145.72, -26.35], [145.81, -25.91],
 *              [145.41, -25.68], [144.97, -25.68], [144.49, -25.64], [144, -25.99], [144.18, -26.39]
 *            ]
 *          ]
 *        }
 *      }
 *    ]
 *  };
 * }
 * ```
 */
let AgmDataLayer = AgmDataLayer_1 = class AgmDataLayer {
    constructor(_manager) {
        this._manager = _manager;
        this._addedToManager = false;
        this._id = (layerId$1++).toString();
        this._subscriptions = [];
        /**
         * This event is fired when a feature in the layer is clicked.
         */
        this.layerClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The geoJson to be displayed
         */
        this.geoJson = null;
    }
    ngOnInit() {
        if (this._addedToManager) {
            return;
        }
        this._manager.addDataLayer(this);
        this._addedToManager = true;
        this._addEventListeners();
    }
    _addEventListeners() {
        const listeners = [
            { name: 'click', handler: (ev) => this.layerClick.emit(ev) },
        ];
        listeners.forEach((obj) => {
            const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);
            this._subscriptions.push(os);
        });
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    toString() { return `AgmDataLayer-${this._id.toString()}`; }
    /** @internal */
    ngOnDestroy() {
        this._manager.deleteDataLayer(this);
        // unsubscribe all registered observable subscriptions
        this._subscriptions.forEach(s => s.unsubscribe());
    }
    /** @internal */
    ngOnChanges(changes) {
        if (!this._addedToManager) {
            return;
        }
        var geoJsonChange = changes['geoJson'];
        if (geoJsonChange) {
            this._manager.updateGeoJson(this, geoJsonChange.currentValue);
        }
        let dataOptions = {};
        AgmDataLayer_1._dataOptionsAttributes.forEach(k => dataOptions[k] = changes.hasOwnProperty(k) ? changes[k].currentValue : this[k]);
        this._manager.setDataOptions(this, dataOptions);
    }
};
AgmDataLayer._dataOptionsAttributes = ['style'];
AgmDataLayer.ctorParameters = () => [
    { type: DataLayerManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmDataLayer.prototype, "layerClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmDataLayer.prototype, "geoJson", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function)
], AgmDataLayer.prototype, "style", void 0);
AgmDataLayer = AgmDataLayer_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-data-layer',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [DataLayerManager])
], AgmDataLayer);

/**
 * Class to implement when you what to be able to make it work with the auto fit bounds feature
 * of AGM.
 */
class FitBoundsAccessor {
}
/**
 * The FitBoundsService is responsible for computing the bounds of the a single map.
 */
let FitBoundsService = class FitBoundsService {
    constructor(loader) {
        this._boundsChangeSampleTime$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](200);
        this._includeInBounds$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](new Map());
        this.bounds$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(loader.load()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["flatMap"])(() => this._includeInBounds$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["sample"])(this._boundsChangeSampleTime$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(time => Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["timer"])(0, time)))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(includeInBounds => this._generateBounds(includeInBounds)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["shareReplay"])(1));
    }
    _generateBounds(includeInBounds) {
        const bounds = new google.maps.LatLngBounds();
        includeInBounds.forEach(b => bounds.extend(b));
        return bounds;
    }
    addToBounds(latLng) {
        const id = this._createIdentifier(latLng);
        if (this._includeInBounds$.value.has(id)) {
            return;
        }
        const map = this._includeInBounds$.value;
        map.set(id, latLng);
        this._includeInBounds$.next(map);
    }
    removeFromBounds(latLng) {
        const map = this._includeInBounds$.value;
        map.delete(this._createIdentifier(latLng));
        this._includeInBounds$.next(map);
    }
    changeFitBoundsChangeSampleTime(timeMs) {
        this._boundsChangeSampleTime$.next(timeMs);
    }
    getBounds$() {
        return this.bounds$;
    }
    _createIdentifier(latLng) {
        return `${latLng.lat}+${latLng.lng}`;
    }
};
FitBoundsService.ctorParameters = () => [
    { type: MapsAPILoader }
];
FitBoundsService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [MapsAPILoader])
], FitBoundsService);

/**
 * Adds the given directive to the auto fit bounds feature when the value is true.
 * To make it work with you custom AGM component, you also have to implement the {@link FitBoundsAccessor} abstract class.
 * @example
 * <agm-marker [agmFitBounds]="true"></agm-marker>
 */
let AgmFitBounds = class AgmFitBounds {
    constructor(_fitBoundsAccessor, _fitBoundsService) {
        this._fitBoundsAccessor = _fitBoundsAccessor;
        this._fitBoundsService = _fitBoundsService;
        /**
         * If the value is true, the element gets added to the bounds of the map.
         * Default: true.
         */
        this.agmFitBounds = true;
        this._destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        this._latestFitBoundsDetails = null;
    }
    /**
     * @internal
     */
    ngOnChanges() {
        this._updateBounds();
    }
    /**
     * @internal
     */
    ngOnInit() {
        this._fitBoundsAccessor
            .getFitBoundsDetails$()
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["distinctUntilChanged"])((x, y) => x.latLng.lat === y.latLng.lat && x.latLng.lng === y.latLng.lng), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed$))
            .subscribe(details => this._updateBounds(details));
    }
    /*
     Either the location changed, or visible status changed.
     Possible state changes are
     invisible -> visible
     visible -> invisible
     visible -> visible (new location)
    */
    _updateBounds(newFitBoundsDetails) {
        // either visibility will change, or location, so remove the old one anyway
        if (this._latestFitBoundsDetails) {
            this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);
            // don't set latestFitBoundsDetails to null, because we can toggle visibility from
            // true -> false -> true, in which case we still need old value cached here
        }
        if (newFitBoundsDetails) {
            this._latestFitBoundsDetails = newFitBoundsDetails;
        }
        if (!this._latestFitBoundsDetails) {
            return;
        }
        if (this.agmFitBounds === true) {
            this._fitBoundsService.addToBounds(this._latestFitBoundsDetails.latLng);
        }
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this._destroyed$.next();
        this._destroyed$.complete();
        if (this._latestFitBoundsDetails !== null) {
            this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);
        }
    }
};
AgmFitBounds.ctorParameters = () => [
    { type: FitBoundsAccessor, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }] },
    { type: FitBoundsService }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmFitBounds.prototype, "agmFitBounds", void 0);
AgmFitBounds = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: '[agmFitBounds]',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"])()),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [FitBoundsAccessor,
        FitBoundsService])
], AgmFitBounds);

let MarkerManager = class MarkerManager {
    constructor(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._markers = new Map();
    }
    convertAnimation(uiAnim) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            if (uiAnim === null) {
                return null;
            }
            else {
                return this._mapsWrapper.getNativeMap().then(() => google.maps.Animation[uiAnim]);
            }
        });
    }
    deleteMarker(marker) {
        const m = this._markers.get(marker);
        if (m == null) {
            // marker already deleted
            return Promise.resolve();
        }
        return m.then((m) => {
            return this._zone.run(() => {
                m.setMap(null);
                this._markers.delete(marker);
            });
        });
    }
    updateMarkerPosition(marker) {
        return this._markers.get(marker).then((m) => m.setPosition({ lat: marker.latitude, lng: marker.longitude }));
    }
    updateTitle(marker) {
        return this._markers.get(marker).then((m) => m.setTitle(marker.title));
    }
    updateLabel(marker) {
        return this._markers.get(marker).then((m) => { m.setLabel(marker.label); });
    }
    updateDraggable(marker) {
        return this._markers.get(marker).then((m) => m.setDraggable(marker.draggable));
    }
    updateIcon(marker) {
        return this._markers.get(marker).then((m) => m.setIcon(marker.iconUrl));
    }
    updateOpacity(marker) {
        return this._markers.get(marker).then((m) => m.setOpacity(marker.opacity));
    }
    updateVisible(marker) {
        return this._markers.get(marker).then((m) => m.setVisible(marker.visible));
    }
    updateZIndex(marker) {
        return this._markers.get(marker).then((m) => m.setZIndex(marker.zIndex));
    }
    updateClickable(marker) {
        return this._markers.get(marker).then((m) => m.setClickable(marker.clickable));
    }
    updateAnimation(marker) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const m = yield this._markers.get(marker);
            m.setAnimation(yield this.convertAnimation(marker.animation));
        });
    }
    addMarker(marker) {
        const markerPromise = new Promise((resolve) => Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            return this._mapsWrapper.createMarker({
                position: { lat: marker.latitude, lng: marker.longitude },
                label: marker.label,
                draggable: marker.draggable,
                icon: marker.iconUrl,
                opacity: marker.opacity,
                visible: marker.visible,
                zIndex: marker.zIndex,
                title: marker.title,
                clickable: marker.clickable,
                animation: yield this.convertAnimation(marker.animation),
            }).then(resolve);
        }));
        this._markers.set(marker, markerPromise);
    }
    getNativeMarker(marker) {
        return this._markers.get(marker);
    }
    createEventObservable(eventName, marker) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._markers.get(marker).then((m) => {
                m.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
};
MarkerManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
MarkerManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], MarkerManager);

let InfoWindowManager = class InfoWindowManager {
    constructor(_mapsWrapper, _zone, _markerManager) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._markerManager = _markerManager;
        this._infoWindows = new Map();
    }
    deleteInfoWindow(infoWindow) {
        const iWindow = this._infoWindows.get(infoWindow);
        if (iWindow == null) {
            // info window already deleted
            return Promise.resolve();
        }
        return iWindow.then((i) => {
            return this._zone.run(() => {
                i.close();
                this._infoWindows.delete(infoWindow);
            });
        });
    }
    setPosition(infoWindow) {
        return this._infoWindows.get(infoWindow).then((i) => i.setPosition({
            lat: infoWindow.latitude,
            lng: infoWindow.longitude,
        }));
    }
    setZIndex(infoWindow) {
        return this._infoWindows.get(infoWindow)
            .then((i) => i.setZIndex(infoWindow.zIndex));
    }
    open(infoWindow) {
        return this._infoWindows.get(infoWindow).then((w) => {
            if (infoWindow.hostMarker != null) {
                return this._markerManager.getNativeMarker(infoWindow.hostMarker).then((marker) => {
                    return this._mapsWrapper.getNativeMap().then((map) => w.open(map, marker));
                });
            }
            return this._mapsWrapper.getNativeMap().then((map) => w.open(map));
        });
    }
    close(infoWindow) {
        return this._infoWindows.get(infoWindow).then((w) => w.close());
    }
    setOptions(infoWindow, options) {
        return this._infoWindows.get(infoWindow).then((i) => i.setOptions(options));
    }
    addInfoWindow(infoWindow) {
        const options = {
            content: infoWindow.content,
            maxWidth: infoWindow.maxWidth,
            zIndex: infoWindow.zIndex,
            disableAutoPan: infoWindow.disableAutoPan,
        };
        if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {
            options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };
        }
        const infoWindowPromise = this._mapsWrapper.createInfoWindow(options);
        this._infoWindows.set(infoWindow, infoWindowPromise);
    }
    /**
     * Creates a Google Maps event listener for the given InfoWindow as an Observable
     */
    createEventObservable(eventName, infoWindow) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._infoWindows.get(infoWindow).then((i) => {
                i.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
};
InfoWindowManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: MarkerManager }
];
InfoWindowManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"],
        MarkerManager])
], InfoWindowManager);

var AgmInfoWindow_1;
let infoWindowId = 0;
/**
 * AgmInfoWindow renders a info window inside a {@link AgmMarker} or standalone.
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    .agm-map-container {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
 *        <agm-info-window [disableAutoPan]="true">
 *          Hi, this is the content of the <strong>info window</strong>
 *        </agm-info-window>
 *      </agm-marker>
 *    </agm-map>
 *  `
 * })
 * ```
 */
let AgmInfoWindow = AgmInfoWindow_1 = class AgmInfoWindow {
    constructor(_infoWindowManager, _el) {
        this._infoWindowManager = _infoWindowManager;
        this._el = _el;
        /**
         * Sets the open state for the InfoWindow. You can also call the open() and close() methods.
         */
        this.isOpen = false;
        /**
         * Emits an event when the info window is closed.
         */
        this.infoWindowClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._infoWindowAddedToManager = false;
        this._id = (infoWindowId++).toString();
    }
    ngOnInit() {
        this.content = this._el.nativeElement.querySelector('.agm-info-window-content');
        this._infoWindowManager.addInfoWindow(this);
        this._infoWindowAddedToManager = true;
        this._updateOpenState();
        this._registerEventListeners();
    }
    /** @internal */
    ngOnChanges(changes) {
        if (!this._infoWindowAddedToManager) {
            return;
        }
        if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' &&
            typeof this.longitude === 'number') {
            this._infoWindowManager.setPosition(this);
        }
        if (changes['zIndex']) {
            this._infoWindowManager.setZIndex(this);
        }
        if (changes['isOpen']) {
            this._updateOpenState();
        }
        this._setInfoWindowOptions(changes);
    }
    _registerEventListeners() {
        this._infoWindowManager.createEventObservable('closeclick', this).subscribe(() => {
            this.isOpen = false;
            this.infoWindowClose.emit();
        });
    }
    _updateOpenState() {
        this.isOpen ? this.open() : this.close();
    }
    _setInfoWindowOptions(changes) {
        let options = {};
        let optionKeys = Object.keys(changes).filter(k => AgmInfoWindow_1._infoWindowOptionsInputs.indexOf(k) !== -1);
        optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });
        this._infoWindowManager.setOptions(this, options);
    }
    /**
     * Opens the info window.
     */
    open() { return this._infoWindowManager.open(this); }
    /**
     * Closes the info window.
     */
    close() {
        return this._infoWindowManager.close(this).then(() => { this.infoWindowClose.emit(); });
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    toString() { return 'AgmInfoWindow-' + this._id.toString(); }
    /** @internal */
    ngOnDestroy() { this._infoWindowManager.deleteInfoWindow(this); }
};
AgmInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];
AgmInfoWindow.ctorParameters = () => [
    { type: InfoWindowManager },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmInfoWindow.prototype, "latitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmInfoWindow.prototype, "longitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], AgmInfoWindow.prototype, "disableAutoPan", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmInfoWindow.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmInfoWindow.prototype, "maxWidth", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmInfoWindow.prototype, "isOpen", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmInfoWindow.prototype, "infoWindowClose", void 0);
AgmInfoWindow = AgmInfoWindow_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'agm-info-window',
        template: `<div class='agm-info-window-content'>
      <ng-content></ng-content>
    </div>
  `
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [InfoWindowManager, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
], AgmInfoWindow);

/**
 * Manages all KML Layers for a Google Map instance.
 */
let KmlLayerManager = class KmlLayerManager {
    constructor(_wrapper, _zone) {
        this._wrapper = _wrapper;
        this._zone = _zone;
        this._layers = new Map();
    }
    /**
     * Adds a new KML Layer to the map.
     */
    addKmlLayer(layer) {
        const newLayer = this._wrapper.getNativeMap().then(m => {
            return new google.maps.KmlLayer({
                clickable: layer.clickable,
                map: m,
                preserveViewport: layer.preserveViewport,
                screenOverlays: layer.screenOverlays,
                suppressInfoWindows: layer.suppressInfoWindows,
                url: layer.url,
                zIndex: layer.zIndex,
            });
        });
        this._layers.set(layer, newLayer);
    }
    setOptions(layer, options) {
        this._layers.get(layer).then(l => l.setOptions(options));
    }
    deleteKmlLayer(layer) {
        this._layers.get(layer).then(l => {
            l.setMap(null);
            this._layers.delete(layer);
        });
    }
    /**
     * Creates a Google Maps event listener for the given KmlLayer as an Observable
     */
    createEventObservable(eventName, layer) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._layers.get(layer).then((m) => {
                m.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
};
KmlLayerManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
KmlLayerManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], KmlLayerManager);

var AgmKmlLayer_1;
let layerId$2 = 0;
let AgmKmlLayer = AgmKmlLayer_1 = class AgmKmlLayer {
    constructor(_manager) {
        this._manager = _manager;
        this._addedToManager = false;
        this._id = (layerId$2++).toString();
        this._subscriptions = [];
        /**
         * If true, the layer receives mouse events. Default value is true.
         */
        this.clickable = true;
        /**
         * By default, the input map is centered and zoomed to the bounding box of the contents of the
         * layer.
         * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom
         * were never set.
         */
        this.preserveViewport = false;
        /**
         * Whether to render the screen overlays. Default true.
         */
        this.screenOverlays = true;
        /**
         * Suppress the rendering of info windows when layer features are clicked.
         */
        this.suppressInfoWindows = false;
        /**
         * The URL of the KML document to display.
         */
        this.url = null;
        /**
         * The z-index of the layer.
         */
        this.zIndex = null;
        /**
         * This event is fired when a feature in the layer is clicked.
         */
        this.layerClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the KML layers default viewport has changed.
         */
        this.defaultViewportChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the KML layer has finished loading.
         * At this point it is safe to read the status property to determine if the layer loaded
         * successfully.
         */
        this.statusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    ngOnInit() {
        if (this._addedToManager) {
            return;
        }
        this._manager.addKmlLayer(this);
        this._addedToManager = true;
        this._addEventListeners();
    }
    ngOnChanges(changes) {
        if (!this._addedToManager) {
            return;
        }
        this._updatePolygonOptions(changes);
    }
    _updatePolygonOptions(changes) {
        const options = Object.keys(changes)
            .filter(k => AgmKmlLayer_1._kmlLayerOptions.indexOf(k) !== -1)
            .reduce((obj, k) => {
            obj[k] = changes[k].currentValue;
            return obj;
        }, {});
        if (Object.keys(options).length > 0) {
            this._manager.setOptions(this, options);
        }
    }
    _addEventListeners() {
        const listeners = [
            { name: 'click', handler: (ev) => this.layerClick.emit(ev) },
            { name: 'defaultviewport_changed', handler: () => this.defaultViewportChange.emit() },
            { name: 'status_changed', handler: () => this.statusChange.emit() },
        ];
        listeners.forEach((obj) => {
            const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);
            this._subscriptions.push(os);
        });
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    toString() { return `AgmKmlLayer-${this._id.toString()}`; }
    /** @internal */
    ngOnDestroy() {
        this._manager.deleteKmlLayer(this);
        // unsubscribe all registered observable subscriptions
        this._subscriptions.forEach(s => s.unsubscribe());
    }
};
AgmKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];
AgmKmlLayer.ctorParameters = () => [
    { type: KmlLayerManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmKmlLayer.prototype, "clickable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmKmlLayer.prototype, "preserveViewport", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmKmlLayer.prototype, "screenOverlays", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmKmlLayer.prototype, "suppressInfoWindows", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmKmlLayer.prototype, "url", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmKmlLayer.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmKmlLayer.prototype, "layerClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmKmlLayer.prototype, "defaultViewportChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmKmlLayer.prototype, "statusChange", void 0);
AgmKmlLayer = AgmKmlLayer_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-kml-layer',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [KmlLayerManager])
], AgmKmlLayer);

function createMVCEventObservable(array) {
    const eventNames = ['insert_at', 'remove_at', 'set_at'];
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEventPattern"])((handler) => eventNames.map(evName => array.addListener(evName, (index, previous) => handler.apply(array, [{ 'newArr': array.getArray(), evName, index, previous }]))), (_handler, evListeners) => evListeners.forEach(evListener => evListener.remove()));
}
class MvcArrayMock {
    constructor() {
        this.vals = [];
        this.listeners = {
            'remove_at': [],
            'insert_at': [],
            'set_at': [],
        };
    }
    clear() {
        for (let i = this.vals.length - 1; i >= 0; i--) {
            this.removeAt(i);
        }
    }
    getArray() {
        return [...this.vals];
    }
    getAt(i) {
        return this.vals[i];
    }
    getLength() {
        return this.vals.length;
    }
    insertAt(i, elem) {
        this.vals.splice(i, 0, elem);
        this.listeners.insert_at.map(listener => listener(i));
    }
    pop() {
        const deleted = this.vals.pop();
        this.listeners.remove_at.map(listener => listener(this.vals.length, deleted));
        return deleted;
    }
    push(elem) {
        this.vals.push(elem);
        this.listeners.insert_at.map(listener => listener(this.vals.length - 1));
        return this.vals.length;
    }
    removeAt(i) {
        const deleted = this.vals.splice(i, 1)[0];
        this.listeners.remove_at.map(listener => listener(i, deleted));
        return deleted;
    }
    setAt(i, elem) {
        const deleted = this.vals[i];
        this.vals[i] = elem;
        this.listeners.set_at.map(listener => listener(i, deleted));
    }
    forEach(callback) {
        this.vals.forEach(callback);
    }
    addListener(eventName, handler) {
        const listenerArr = this.listeners[eventName];
        listenerArr.push(handler);
        return {
            remove: () => {
                listenerArr.splice(listenerArr.indexOf(handler), 1);
            },
        };
    }
}

let PolygonManager = class PolygonManager {
    constructor(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polygons = new Map();
    }
    addPolygon(path) {
        const polygonPromise = this._mapsWrapper.createPolygon({
            clickable: path.clickable,
            draggable: path.draggable,
            editable: path.editable,
            fillColor: path.fillColor,
            fillOpacity: path.fillOpacity,
            geodesic: path.geodesic,
            paths: path.paths,
            strokeColor: path.strokeColor,
            strokeOpacity: path.strokeOpacity,
            strokeWeight: path.strokeWeight,
            visible: path.visible,
            zIndex: path.zIndex,
        });
        this._polygons.set(path, polygonPromise);
    }
    updatePolygon(polygon) {
        const m = this._polygons.get(polygon);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => this._zone.run(() => { l.setPaths(polygon.paths); }));
    }
    setPolygonOptions(path, options) {
        return this._polygons.get(path).then((l) => { l.setOptions(options); });
    }
    deletePolygon(paths) {
        const m = this._polygons.get(paths);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => {
            return this._zone.run(() => {
                l.setMap(null);
                this._polygons.delete(paths);
            });
        });
    }
    getPath(polygon) {
        return this._polygons.get(polygon)
            .then((polygon) => polygon.getPath().getArray());
    }
    getPaths(polygon) {
        return this._polygons.get(polygon)
            .then((polygon) => polygon.getPaths().getArray().map((p) => p.getArray()));
    }
    createEventObservable(eventName, path) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._polygons.get(path).then((l) => {
                l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
    createPathEventObservable(agmPolygon) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const polygon = yield this._polygons.get(agmPolygon);
            const paths = polygon.getPaths();
            const pathsChanges$ = createMVCEventObservable(paths);
            return pathsChanges$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])({ newArr: paths.getArray() }), // in order to subscribe to them all
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(parentMVEvent => Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["merge"])(... // rest parameter
            parentMVEvent.newArr.map((chMVC, index) => createMVCEventObservable(chMVC)
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(chMVCEvent => ({ parentMVEvent, chMVCEvent, pathIndex: index })))))
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])({ parentMVEvent, chMVCEvent: null, pathIndex: null }))), // start the merged ob with an event signinifing change to parent
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["skip"])(1), // skip the manually added event
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(({ parentMVEvent, chMVCEvent, pathIndex }) => {
                let retVal;
                if (!chMVCEvent) {
                    retVal = {
                        newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),
                        eventName: parentMVEvent.evName,
                        index: parentMVEvent.index,
                    };
                    if (parentMVEvent.previous) {
                        retVal.previous = parentMVEvent.previous.getArray();
                    }
                }
                else {
                    retVal = {
                        newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),
                        pathIndex,
                        eventName: chMVCEvent.evName,
                        index: chMVCEvent.index,
                    };
                    if (chMVCEvent.previous) {
                        retVal.previous = chMVCEvent.previous;
                    }
                }
                return retVal;
            }));
        });
    }
};
PolygonManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
PolygonManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], PolygonManager);

var PolylineManager_1;
let PolylineManager = PolylineManager_1 = class PolylineManager {
    constructor(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polylines = new Map();
    }
    static _convertPoints(line) {
        const path = line._getPoints().map((point) => {
            return { lat: point.latitude, lng: point.longitude };
        });
        return path;
    }
    static _convertPath(path) {
        const symbolPath = google.maps.SymbolPath[path];
        if (typeof symbolPath === 'number') {
            return symbolPath;
        }
        else {
            return path;
        }
    }
    static _convertIcons(line) {
        const icons = line._getIcons().map(agmIcon => ({
            fixedRotation: agmIcon.fixedRotation,
            offset: agmIcon.offset,
            repeat: agmIcon.repeat,
            icon: {
                anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),
                fillColor: agmIcon.fillColor,
                fillOpacity: agmIcon.fillOpacity,
                path: PolylineManager_1._convertPath(agmIcon.path),
                rotation: agmIcon.rotation,
                scale: agmIcon.scale,
                strokeColor: agmIcon.strokeColor,
                strokeOpacity: agmIcon.strokeOpacity,
                strokeWeight: agmIcon.strokeWeight,
            },
        }));
        // prune undefineds;
        icons.forEach(icon => {
            Object.entries(icon).forEach(([key, val]) => {
                if (typeof val === 'undefined') {
                    delete icon[key];
                }
            });
            if (typeof icon.icon.anchor.x === 'undefined' ||
                typeof icon.icon.anchor.y === 'undefined') {
                delete icon.icon.anchor;
            }
        });
        return icons;
    }
    addPolyline(line) {
        const polylinePromise = this._mapsWrapper.getNativeMap()
            .then(() => [PolylineManager_1._convertPoints(line),
            PolylineManager_1._convertIcons(line)])
            .then(([path, icons]) => this._mapsWrapper.createPolyline({
            clickable: line.clickable,
            draggable: line.draggable,
            editable: line.editable,
            geodesic: line.geodesic,
            strokeColor: line.strokeColor,
            strokeOpacity: line.strokeOpacity,
            strokeWeight: line.strokeWeight,
            visible: line.visible,
            zIndex: line.zIndex,
            path: path,
            icons: icons,
        }));
        this._polylines.set(line, polylinePromise);
    }
    updatePolylinePoints(line) {
        const path = PolylineManager_1._convertPoints(line);
        const m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => { return this._zone.run(() => { l.setPath(path); }); });
    }
    updateIconSequences(line) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            yield this._mapsWrapper.getNativeMap();
            const icons = PolylineManager_1._convertIcons(line);
            const m = this._polylines.get(line);
            if (m == null) {
                return;
            }
            return m.then(l => this._zone.run(() => l.setOptions({ icons: icons })));
        });
    }
    setPolylineOptions(line, options) {
        return this._polylines.get(line).then((l) => { l.setOptions(options); });
    }
    deletePolyline(line) {
        const m = this._polylines.get(line);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => {
            return this._zone.run(() => {
                l.setMap(null);
                this._polylines.delete(line);
            });
        });
    }
    getMVCPath(agmPolyline) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const polyline = yield this._polylines.get(agmPolyline);
            return polyline.getPath();
        });
    }
    getPath(agmPolyline) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            return (yield this.getMVCPath(agmPolyline)).getArray();
        });
    }
    createEventObservable(eventName, line) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"]((observer) => {
            this._polylines.get(line).then((l) => {
                l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
    createPathEventObservable(line) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const mvcPath = yield this.getMVCPath(line);
            return createMVCEventObservable(mvcPath);
        });
    }
};
PolylineManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
PolylineManager = PolylineManager_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], PolylineManager);

let RectangleManager = class RectangleManager {
    constructor(_apiWrapper, _zone) {
        this._apiWrapper = _apiWrapper;
        this._zone = _zone;
        this._rectangles = new Map();
    }
    addRectangle(rectangle) {
        this._rectangles.set(rectangle, this._apiWrapper.createRectangle({
            bounds: {
                north: rectangle.north,
                east: rectangle.east,
                south: rectangle.south,
                west: rectangle.west,
            },
            clickable: rectangle.clickable,
            draggable: rectangle.draggable,
            editable: rectangle.editable,
            fillColor: rectangle.fillColor,
            fillOpacity: rectangle.fillOpacity,
            strokeColor: rectangle.strokeColor,
            strokeOpacity: rectangle.strokeOpacity,
            strokePosition: rectangle.strokePosition,
            strokeWeight: rectangle.strokeWeight,
            visible: rectangle.visible,
            zIndex: rectangle.zIndex,
        }));
    }
    /**
     * Removes the given rectangle from the map.
     */
    removeRectangle(rectangle) {
        return this._rectangles.get(rectangle).then((r) => {
            r.setMap(null);
            this._rectangles.delete(rectangle);
        });
    }
    setOptions(rectangle, options) {
        return this._rectangles.get(rectangle).then((r) => r.setOptions(options));
    }
    getBounds(rectangle) {
        return this._rectangles.get(rectangle).then((r) => r.getBounds());
    }
    setBounds(rectangle) {
        return this._rectangles.get(rectangle).then((r) => {
            return r.setBounds({
                north: rectangle.north,
                east: rectangle.east,
                south: rectangle.south,
                west: rectangle.west,
            });
        });
    }
    setEditable(rectangle) {
        return this._rectangles.get(rectangle).then((r) => {
            return r.setEditable(rectangle.editable);
        });
    }
    setDraggable(rectangle) {
        return this._rectangles.get(rectangle).then((r) => {
            return r.setDraggable(rectangle.draggable);
        });
    }
    setVisible(rectangle) {
        return this._rectangles.get(rectangle).then((r) => {
            return r.setVisible(rectangle.visible);
        });
    }
    createEventObservable(eventName, rectangle) {
        return rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"].create((observer) => {
            let listener = null;
            this._rectangles.get(rectangle).then((r) => {
                listener = r.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
            return () => {
                if (listener !== null) {
                    listener.remove();
                }
            };
        });
    }
};
RectangleManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
RectangleManager = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [GoogleMapsAPIWrapper, _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], RectangleManager);

var AgmMap_1;
/**
 * AgmMap renders a Google Map.
 * **Important note**: To be able see a map in the browser, you have to define a height for the
 * element `agm-map`.
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    agm-map {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *    </agm-map>
 *  `
 * })
 * ```
 */
let AgmMap = AgmMap_1 = class AgmMap {
    constructor(_elem, _mapsWrapper, _platformId, _fitBoundsService, _zone) {
        this._elem = _elem;
        this._mapsWrapper = _mapsWrapper;
        this._platformId = _platformId;
        this._fitBoundsService = _fitBoundsService;
        this._zone = _zone;
        /**
         * The longitude that defines the center of the map.
         */
        this.longitude = 0;
        /**
         * The latitude that defines the center of the map.
         */
        this.latitude = 0;
        /**
         * The zoom level of the map. The default zoom level is 8.
         */
        this.zoom = 8;
        /**
         * Enables/disables if map is draggable.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = true;
        /**
         * Enables/disables zoom and center on double click. Enabled by default.
         */
        this.disableDoubleClickZoom = false;
        /**
         * Enables/disables all default UI of the Google map. Please note: When the map is created, this
         * value cannot get updated.
         */
        this.disableDefaultUI = false;
        /**
         * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.
         */
        this.scrollwheel = true;
        /**
         * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are
         * enabled by default.
         */
        this.keyboardShortcuts = true;
        /**
         * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain
         * modes, these styles will only apply to labels and geometry.
         */
        this.styles = [];
        /**
         * When true and the latitude and/or longitude values changes, the Google Maps panTo method is
         * used to
         * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map
         */
        this.usePanning = false;
        /**
         * Sets the viewport to contain the given bounds.
         * If this option to `true`, the bounds get automatically computed from all elements that use the {@link AgmFitBounds} directive.
         */
        this.fitBounds = false;
        /**
         * The initial enabled/disabled state of the Scale control. This is disabled by default.
         */
        this.scaleControl = false;
        /**
         * The initial enabled/disabled state of the Map type control.
         */
        this.mapTypeControl = false;
        /**
         * The initial enabled/disabled state of the Pan control.
         */
        this.panControl = false;
        /**
         * The initial enabled/disabled state of the Rotate control.
         */
        this.rotateControl = false;
        /**
         * The initial enabled/disabled state of the Fullscreen control.
         */
        this.fullscreenControl = false;
        /**
         * The map mapTypeId. Defaults to 'roadmap'.
         */
        this.mapTypeId = 'roadmap';
        /**
         * When false, map icons are not clickable. A map icon represents a point of interest,
         * also known as a POI. By default map icons are clickable.
         */
        this.clickableIcons = true;
        /**
         * A map icon represents a point of interest, also known as a POI.
         * When map icons are clickable by default, an info window is displayed.
         * When this property is set to false, the info window will not be shown but the click event
         * will still fire
         */
        this.showDefaultInfoWindow = true;
        /**
         * This setting controls how gestures on the map are handled.
         * Allowed values:
         * - 'cooperative' (Two-finger touch gestures pan and zoom the map. One-finger touch gestures are not handled by the map.)
         * - 'greedy'      (All touch gestures pan or zoom the map.)
         * - 'none'        (The map cannot be panned or zoomed by user gestures.)
         * - 'auto'        [default] (Gesture handling is either cooperative or greedy, depending on whether the page is scrollable or not.
         */
        this.gestureHandling = 'auto';
        /**
         * Controls the automatic switching behavior for the angle of incidence of
         * the map. The only allowed values are 0 and 45. The value 0 causes the map
         * to always use a 0° overhead view regardless of the zoom level and
         * viewport. The value 45 causes the tilt angle to automatically switch to
         * 45 whenever 45° imagery is available for the current zoom level and
         * viewport, and switch back to 0 whenever 45° imagery is not available
         * (this is the default behavior). 45° imagery is only available for
         * satellite and hybrid map types, within some locations, and at some zoom
         * levels. Note: getTilt returns the current tilt angle, not the value
         * specified by this option. Because getTilt and this option refer to
         * different things, do not bind() the tilt property; doing so may yield
         * unpredictable effects. (Default of AGM is 0 (disabled). Enable it with value 45.)
         */
        this.tilt = 0;
        this._observableSubscriptions = [];
        /**
         * This event emitter gets emitted when the user clicks on the map (but not when they click on a
         * marker or infoWindow).
         */
        this.mapClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user right-clicks on the map (but not when they click
         * on a marker or infoWindow).
         */
        this.mapRightClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user double-clicks on the map (but not when they click
         * on a marker or infoWindow).
         */
        this.mapDblClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter is fired when the map center changes.
         */
        this.centerChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the viewport bounds have changed.
         */
        this.boundsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the mapTypeId property changes.
         */
        this.mapTypeIdChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the map becomes idle after panning or zooming.
         */
        this.idle = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the zoom level has changed.
         */
        this.zoomChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the google map is fully initialized.
         * You get the google.maps.Map instance as a result of this EventEmitter.
         */
        this.mapReady = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the visible tiles have finished loading.
         */
        this.tilesLoaded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /** @internal */
    ngOnInit() {
        if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_4__["isPlatformServer"])(this._platformId)) {
            // The code is running on the server, do nothing
            return;
        }
        // todo: this should be solved with a new component and a viewChild decorator
        const container = this._elem.nativeElement.querySelector('.agm-map-container-inner');
        this._initMapInstance(container);
    }
    _initMapInstance(el) {
        this._mapsWrapper.createMap(el, {
            center: { lat: this.latitude || 0, lng: this.longitude || 0 },
            zoom: this.zoom,
            minZoom: this.minZoom,
            maxZoom: this.maxZoom,
            controlSize: this.controlSize,
            disableDefaultUI: this.disableDefaultUI,
            disableDoubleClickZoom: this.disableDoubleClickZoom,
            scrollwheel: this.scrollwheel,
            backgroundColor: this.backgroundColor,
            draggable: this.draggable,
            draggableCursor: this.draggableCursor,
            draggingCursor: this.draggingCursor,
            keyboardShortcuts: this.keyboardShortcuts,
            styles: this.styles,
            zoomControl: this.zoomControl,
            zoomControlOptions: this.zoomControlOptions,
            streetViewControl: this.streetViewControl,
            streetViewControlOptions: this.streetViewControlOptions,
            scaleControl: this.scaleControl,
            scaleControlOptions: this.scaleControlOptions,
            mapTypeControl: this.mapTypeControl,
            mapTypeControlOptions: this.mapTypeControlOptions,
            panControl: this.panControl,
            panControlOptions: this.panControlOptions,
            rotateControl: this.rotateControl,
            rotateControlOptions: this.rotateControlOptions,
            fullscreenControl: this.fullscreenControl,
            fullscreenControlOptions: this.fullscreenControlOptions,
            mapTypeId: this.mapTypeId,
            clickableIcons: this.clickableIcons,
            gestureHandling: this.gestureHandling,
            tilt: this.tilt,
            restriction: this.restriction,
        })
            .then(() => this._mapsWrapper.getNativeMap())
            .then(map => this.mapReady.emit(map));
        // register event listeners
        this._handleMapCenterChange();
        this._handleMapZoomChange();
        this._handleMapMouseEvents();
        this._handleBoundsChange();
        this._handleMapTypeIdChange();
        this._handleTilesLoadedEvent();
        this._handleIdleEvent();
    }
    /** @internal */
    ngOnDestroy() {
        // unsubscribe all registered observable subscriptions
        this._observableSubscriptions.forEach((s) => s.unsubscribe());
        // remove all listeners from the map instance
        this._mapsWrapper.clearInstanceListeners();
        if (this._fitBoundsSubscription) {
            this._fitBoundsSubscription.unsubscribe();
        }
    }
    /* @internal */
    ngOnChanges(changes) {
        this._updateMapOptionsChanges(changes);
        this._updatePosition(changes);
    }
    _updateMapOptionsChanges(changes) {
        let options = {};
        let optionKeys = Object.keys(changes).filter(k => AgmMap_1._mapOptionsAttributes.indexOf(k) !== -1);
        optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });
        this._mapsWrapper.setMapOptions(options);
    }
    /**
     * Triggers a resize event on the google map instance.
     * When recenter is true, the of the google map gets called with the current lat/lng values or fitBounds value to recenter the map.
     * Returns a promise that gets resolved after the event was triggered.
     */
    triggerResize(recenter = true) {
        // Note: When we would trigger the resize event and show the map in the same turn (which is a
        // common case for triggering a resize event), then the resize event would not
        // work (to show the map), so we trigger the event in a timeout.
        return new Promise((resolve) => {
            setTimeout(() => {
                return this._mapsWrapper.triggerMapEvent('resize').then(() => {
                    if (recenter) {
                        this.fitBounds != null ? this._fitBounds() : this._setCenter();
                    }
                    resolve();
                });
            });
        });
    }
    _updatePosition(changes) {
        if (changes['latitude'] == null && changes['longitude'] == null &&
            !changes['fitBounds']) {
            // no position update needed
            return;
        }
        // we prefer fitBounds in changes
        if ('fitBounds' in changes) {
            this._fitBounds();
            return;
        }
        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
            return;
        }
        this._setCenter();
    }
    _setCenter() {
        let newCenter = {
            lat: this.latitude,
            lng: this.longitude,
        };
        if (this.usePanning) {
            this._mapsWrapper.panTo(newCenter);
        }
        else {
            this._mapsWrapper.setCenter(newCenter);
        }
    }
    _fitBounds() {
        switch (this.fitBounds) {
            case true:
                this._subscribeToFitBoundsUpdates();
                break;
            case false:
                if (this._fitBoundsSubscription) {
                    this._fitBoundsSubscription.unsubscribe();
                }
                break;
            default:
                this._updateBounds(this.fitBounds, this.fitBoundsPadding);
        }
    }
    _subscribeToFitBoundsUpdates() {
        this._zone.runOutsideAngular(() => {
            this._fitBoundsSubscription = this._fitBoundsService.getBounds$().subscribe(b => {
                this._zone.run(() => this._updateBounds(b, this.fitBoundsPadding));
            });
        });
    }
    _updateBounds(bounds, padding) {
        if (!bounds) {
            return;
        }
        if (this._isLatLngBoundsLiteral(bounds) && typeof google !== 'undefined' && google && google.maps && google.maps.LatLngBounds) {
            const newBounds = new google.maps.LatLngBounds();
            newBounds.union(bounds);
            bounds = newBounds;
        }
        if (this.usePanning) {
            this._mapsWrapper.panToBounds(bounds, padding);
            return;
        }
        this._mapsWrapper.fitBounds(bounds, padding);
    }
    _isLatLngBoundsLiteral(bounds) {
        return bounds != null && bounds.extend === undefined;
    }
    _handleMapCenterChange() {
        const s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(() => {
            this._mapsWrapper.getCenter().then((center) => {
                this.latitude = center.lat();
                this.longitude = center.lng();
                this.centerChange.emit({ lat: this.latitude, lng: this.longitude });
            });
        });
        this._observableSubscriptions.push(s);
    }
    _handleBoundsChange() {
        const s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(() => {
            this._mapsWrapper.getBounds().then((bounds) => { this.boundsChange.emit(bounds); });
        });
        this._observableSubscriptions.push(s);
    }
    _handleMapTypeIdChange() {
        const s = this._mapsWrapper.subscribeToMapEvent('maptypeid_changed').subscribe(() => {
            this._mapsWrapper.getMapTypeId().then((mapTypeId) => { this.mapTypeIdChange.emit(mapTypeId); });
        });
        this._observableSubscriptions.push(s);
    }
    _handleMapZoomChange() {
        const s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(() => {
            this._mapsWrapper.getZoom().then((z) => {
                this.zoom = z;
                this.zoomChange.emit(z);
            });
        });
        this._observableSubscriptions.push(s);
    }
    _handleIdleEvent() {
        const s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(() => { this.idle.emit(void 0); });
        this._observableSubscriptions.push(s);
    }
    _handleTilesLoadedEvent() {
        const s = this._mapsWrapper.subscribeToMapEvent('tilesloaded').subscribe(() => this.tilesLoaded.emit(void 0));
        this._observableSubscriptions.push(s);
    }
    _handleMapMouseEvents() {
        const events = [
            { name: 'click', emitter: this.mapClick },
            { name: 'rightclick', emitter: this.mapRightClick },
            { name: 'dblclick', emitter: this.mapDblClick },
        ];
        events.forEach((e) => {
            const s = this._mapsWrapper.subscribeToMapEvent(e.name).subscribe((event) => {
                let value = {
                    coords: {
                        lat: event.latLng.lat(),
                        lng: event.latLng.lng(),
                    },
                    placeId: event.placeId,
                };
                // the placeId will be undefined in case the event was not an IconMouseEvent (google types)
                if (value.placeId && !this.showDefaultInfoWindow) {
                    event.stop();
                }
                e.emitter.emit(value);
            });
            this._observableSubscriptions.push(s);
        });
    }
};
/**
 * Map option attributes that can change over time
 */
AgmMap._mapOptionsAttributes = [
    'disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor',
    'keyboardShortcuts', 'zoomControl', 'zoomControlOptions', 'styles', 'streetViewControl',
    'streetViewControlOptions', 'zoom', 'mapTypeControl', 'mapTypeControlOptions', 'minZoom',
    'maxZoom', 'panControl', 'panControlOptions', 'rotateControl', 'rotateControlOptions',
    'fullscreenControl', 'fullscreenControlOptions', 'scaleControl', 'scaleControlOptions',
    'mapTypeId', 'clickableIcons', 'gestureHandling', 'tilt', 'restriction',
];
AgmMap.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: GoogleMapsAPIWrapper },
    { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["PLATFORM_ID"],] }] },
    { type: FitBoundsService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "longitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "latitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "zoom", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmMap.prototype, "minZoom", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmMap.prototype, "maxZoom", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmMap.prototype, "controlSize", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('mapDraggable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "draggable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "disableDoubleClickZoom", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "disableDefaultUI", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "scrollwheel", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMap.prototype, "backgroundColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMap.prototype, "draggableCursor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMap.prototype, "draggingCursor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "keyboardShortcuts", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], AgmMap.prototype, "zoomControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "zoomControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], AgmMap.prototype, "styles", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "usePanning", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], AgmMap.prototype, "streetViewControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "streetViewControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "fitBounds", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "fitBoundsPadding", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "scaleControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "scaleControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "mapTypeControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "mapTypeControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "panControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "panControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "rotateControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "rotateControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "fullscreenControl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "fullscreenControlOptions", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMap.prototype, "mapTypeId", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "clickableIcons", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "showDefaultInfoWindow", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMap.prototype, "gestureHandling", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "tilt", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMap.prototype, "restriction", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "mapClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "mapRightClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "mapDblClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "centerChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "boundsChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "mapTypeIdChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "idle", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "zoomChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "mapReady", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMap.prototype, "tilesLoaded", void 0);
AgmMap = AgmMap_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'agm-map',
        providers: [
            CircleManager,
            DataLayerManager,
            DataLayerManager,
            FitBoundsService,
            GoogleMapsAPIWrapper,
            InfoWindowManager,
            KmlLayerManager,
            LayerManager,
            MarkerManager,
            PolygonManager,
            PolylineManager,
            RectangleManager,
        ],
        host: {
            // todo: deprecated - we will remove it with the next version
            '[class.sebm-google-map-container]': 'true',
        },
        template: `
              <div class='agm-map-container-inner sebm-google-map-container-inner'></div>
              <div class='agm-map-content'>
                <ng-content></ng-content>
              </div>
  `,
        styles: [`
    .agm-map-container-inner {
      width: inherit;
      height: inherit;
    }
    .agm-map-content {
      display:none;
    }
  `]
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(2, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["PLATFORM_ID"])),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
        GoogleMapsAPIWrapper,
        Object,
        FitBoundsService,
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
], AgmMap);

var AgmMarker_1;
let markerId = 0;
/**
 * AgmMarker renders a map marker inside a {@link AgmMap}.
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    .agm-map-container {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
 *      </agm-marker>
 *    </agm-map>
 *  `
 * })
 * ```
 */
let AgmMarker = AgmMarker_1 = class AgmMarker {
    constructor(_markerManager) {
        this._markerManager = _markerManager;
        /**
         * If true, the marker can be dragged. Default value is false.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = false;
        /**
         * If true, the marker is visible
         */
        this.visible = true;
        /**
         * Whether to automatically open the child info window when the marker is clicked.
         */
        this.openInfoWindow = true;
        /**
         * The marker's opacity between 0.0 and 1.0.
         */
        this.opacity = 1;
        /**
         * All markers are displayed on the map in order of their zIndex, with higher values displaying in
         * front of markers with lower values. By default, markers are displayed according to their
         * vertical position on screen, with lower markers appearing in front of markers further up the
         * screen.
         */
        this.zIndex = 1;
        /**
         * If true, the marker can be clicked. Default value is true.
         */
        // tslint:disable-next-line:no-input-rename
        this.clickable = true;
        /**
         * This event is fired when the marker's animation property changes.
         *
         * @memberof AgmMarker
         */
        this.animationChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user clicks on the marker.
         */
        this.markerClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user clicks twice on the marker.
         */
        this.markerDblClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user rightclicks on the marker.
         */
        this.markerRightClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user starts dragging the marker.
         */
        this.dragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is repeatedly fired while the user drags the marker.
         */
        this.drag = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user stops dragging the marker.
         */
        this.dragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user mouses over the marker.
         */
        this.mouseOver = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user mouses outside the marker.
         */
        this.mouseOut = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /** @internal */
        this.infoWindow = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        this._markerAddedToManger = false;
        this._observableSubscriptions = [];
        this._fitBoundsDetails$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["ReplaySubject"](1);
        this._id = (markerId++).toString();
    }
    /* @internal */
    ngAfterContentInit() {
        this.handleInfoWindowUpdate();
        this.infoWindow.changes.subscribe(() => this.handleInfoWindowUpdate());
    }
    handleInfoWindowUpdate() {
        if (this.infoWindow.length > 1) {
            throw new Error('Expected no more than one info window.');
        }
        this.infoWindow.forEach(marker => {
            marker.hostMarker = this;
        });
    }
    /** @internal */
    ngOnChanges(changes) {
        if (typeof this.latitude === 'string') {
            this.latitude = Number(this.latitude);
        }
        if (typeof this.longitude === 'string') {
            this.longitude = Number(this.longitude);
        }
        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
            return;
        }
        if (!this._markerAddedToManger) {
            this._markerManager.addMarker(this);
            this._updateFitBoundsDetails();
            this._markerAddedToManger = true;
            this._addEventListeners();
            return;
        }
        if (changes['latitude'] || changes['longitude']) {
            this._markerManager.updateMarkerPosition(this);
            this._updateFitBoundsDetails();
        }
        if (changes['title']) {
            this._markerManager.updateTitle(this);
        }
        if (changes['label']) {
            this._markerManager.updateLabel(this);
        }
        if (changes['draggable']) {
            this._markerManager.updateDraggable(this);
        }
        if (changes['iconUrl']) {
            this._markerManager.updateIcon(this);
        }
        if (changes['opacity']) {
            this._markerManager.updateOpacity(this);
        }
        if (changes['visible']) {
            this._markerManager.updateVisible(this);
        }
        if (changes['zIndex']) {
            this._markerManager.updateZIndex(this);
        }
        if (changes['clickable']) {
            this._markerManager.updateClickable(this);
        }
        if (changes['animation']) {
            this._markerManager.updateAnimation(this);
        }
    }
    /** @internal */
    getFitBoundsDetails$() {
        return this._fitBoundsDetails$.asObservable();
    }
    _updateFitBoundsDetails() {
        this._fitBoundsDetails$.next({ latLng: { lat: this.latitude, lng: this.longitude } });
    }
    _addEventListeners() {
        const cs = this._markerManager.createEventObservable('click', this).subscribe(() => {
            if (this.openInfoWindow) {
                this.infoWindow.forEach(infoWindow => infoWindow.open());
            }
            this.markerClick.emit(this);
        });
        this._observableSubscriptions.push(cs);
        const dcs = this._markerManager.createEventObservable('dblclick', this).subscribe(() => {
            this.markerDblClick.emit(null);
        });
        this._observableSubscriptions.push(dcs);
        const rc = this._markerManager.createEventObservable('rightclick', this).subscribe(() => {
            this.markerRightClick.emit(null);
        });
        this._observableSubscriptions.push(rc);
        const ds = this._markerManager.createEventObservable('dragstart', this)
            .subscribe((e) => {
            this.dragStart.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
        });
        this._observableSubscriptions.push(ds);
        const d = this._markerManager.createEventObservable('drag', this)
            .subscribe((e) => {
            this.drag.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
        });
        this._observableSubscriptions.push(d);
        const de = this._markerManager.createEventObservable('dragend', this)
            .subscribe((e) => {
            this.dragEnd.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
        });
        this._observableSubscriptions.push(de);
        const mover = this._markerManager.createEventObservable('mouseover', this)
            .subscribe((e) => {
            this.mouseOver.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
        });
        this._observableSubscriptions.push(mover);
        const mout = this._markerManager.createEventObservable('mouseout', this)
            .subscribe((e) => {
            this.mouseOut.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
        });
        this._observableSubscriptions.push(mout);
        const anChng = this._markerManager.createEventObservable('animation_changed', this)
            .subscribe(() => {
            this.animationChange.emit(this.animation);
        });
        this._observableSubscriptions.push(anChng);
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    toString() { return 'AgmMarker-' + this._id.toString(); }
    /** @internal */
    ngOnDestroy() {
        this._markerManager.deleteMarker(this);
        // unsubscribe all registered observable subscriptions
        this._observableSubscriptions.forEach((s) => s.unsubscribe());
    }
};
AgmMarker.ctorParameters = () => [
    { type: MarkerManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmMarker.prototype, "latitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmMarker.prototype, "longitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMarker.prototype, "title", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "label", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('markerDraggable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "draggable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMarker.prototype, "iconUrl", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "visible", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "openInfoWindow", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "opacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('markerClickable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "clickable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmMarker.prototype, "animation", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmMarker.prototype, "animationChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "markerClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "markerDblClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "markerRightClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "dragStart", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "drag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "dragEnd", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "mouseOver", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmMarker.prototype, "mouseOut", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"])(AgmInfoWindow),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
], AgmMarker.prototype, "infoWindow", void 0);
AgmMarker = AgmMarker_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-marker',
        providers: [
            { provide: FitBoundsAccessor, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => AgmMarker_1) },
        ],
        inputs: [
            'latitude', 'longitude', 'title', 'label', 'draggable: markerDraggable', 'iconUrl',
            'openInfoWindow', 'opacity', 'visible', 'zIndex', 'animation',
        ],
        outputs: ['markerClick', 'dragStart', 'drag', 'dragEnd', 'mouseOver', 'mouseOut'],
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [MarkerManager])
], AgmMarker);

var AgmPolygon_1;
/**
 * AgmPolygon renders a polygon on a {@link AgmMap}
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    agm-map {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polygon [paths]="paths">
 *      </agm-polygon>
 *    </agm-map>
 *  `
 * })
 * export class MyMapCmp {
 *   lat: number = 0;
 *   lng: number = 0;
 *   zoom: number = 10;
 *   paths: Array<LatLngLiteral> = [
 *     { lat: 0,  lng: 10 },
 *     { lat: 0,  lng: 20 },
 *     { lat: 10, lng: 20 },
 *     { lat: 10, lng: 10 },
 *     { lat: 0,  lng: 10 }
 *   ]
 *   // Nesting paths will create a hole where they overlap;
 *   nestedPaths: Array<Array<LatLngLiteral>> = [[
 *     { lat: 0,  lng: 10 },
 *     { lat: 0,  lng: 20 },
 *     { lat: 10, lng: 20 },
 *     { lat: 10, lng: 10 },
 *     { lat: 0,  lng: 10 }
 *   ], [
 *     { lat: 0, lng: 15 },
 *     { lat: 0, lng: 20 },
 *     { lat: 5, lng: 20 },
 *     { lat: 5, lng: 15 },
 *     { lat: 0, lng: 15 }
 *   ]]
 * }
 * ```
 */
let AgmPolygon = AgmPolygon_1 = class AgmPolygon {
    constructor(_polygonManager) {
        this._polygonManager = _polygonManager;
        /**
         * Indicates whether this Polygon handles mouse events. Defaults to true.
         */
        this.clickable = true;
        /**
         * If set to true, the user can drag this shape over the map. The geodesic
         * property defines the mode of dragging. Defaults to false.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = false;
        /**
         * If set to true, the user can edit this shape by dragging the control
         * points shown at the vertices and on each segment. Defaults to false.
         */
        this.editable = false;
        /**
         * When true, edges of the polygon are interpreted as geodesic and will
         * follow the curvature of the Earth. When false, edges of the polygon are
         * rendered as straight lines in screen space. Note that the shape of a
         * geodesic polygon may appear to change when dragged, as the dimensions
         * are maintained relative to the surface of the earth. Defaults to false.
         */
        this.geodesic = false;
        /**
         * The ordered sequence of coordinates that designates a closed loop.
         * Unlike polylines, a polygon may consist of one or more paths.
         *  As a result, the paths property may specify one or more arrays of
         * LatLng coordinates. Paths are closed automatically; do not repeat the
         * first vertex of the path as the last vertex. Simple polygons may be
         * defined using a single array of LatLngs. More complex polygons may
         * specify an array of arrays. Any simple arrays are converted into Arrays.
         * Inserting or removing LatLngs from the Array will automatically update
         * the polygon on the map.
         */
        this.paths = [];
        /**
         * This event is fired when the DOM click event is fired on the Polygon.
         */
        this.polyClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM dblclick event is fired on the Polygon.
         */
        this.polyDblClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is repeatedly fired while the user drags the polygon.
         */
        this.polyDrag = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user stops dragging the polygon.
         */
        this.polyDragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user starts dragging the polygon.
         */
        this.polyDragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousedown event is fired on the Polygon.
         */
        this.polyMouseDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousemove event is fired on the Polygon.
         */
        this.polyMouseMove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on Polygon mouseout.
         */
        this.polyMouseOut = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on Polygon mouseover.
         */
        this.polyMouseOver = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired whe the DOM mouseup event is fired on the Polygon
         */
        this.polyMouseUp = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the Polygon is right-clicked on.
         */
        this.polyRightClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired after Polygon first path changes.
         */
        this.polyPathsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._polygonAddedToManager = false;
        this._subscriptions = [];
    }
    /** @internal */
    ngAfterContentInit() {
        if (!this._polygonAddedToManager) {
            this._init();
        }
    }
    ngOnChanges(changes) {
        if (!this._polygonAddedToManager) {
            this._init();
            return;
        }
        this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));
    }
    _init() {
        this._polygonManager.addPolygon(this);
        this._polygonAddedToManager = true;
        this._addEventListeners();
    }
    _addEventListeners() {
        const handlers = [
            { name: 'click', handler: (ev) => this.polyClick.emit(ev) },
            { name: 'dblclick', handler: (ev) => this.polyDblClick.emit(ev) },
            { name: 'drag', handler: (ev) => this.polyDrag.emit(ev) },
            { name: 'dragend', handler: (ev) => this.polyDragEnd.emit(ev) },
            { name: 'dragstart', handler: (ev) => this.polyDragStart.emit(ev) },
            { name: 'mousedown', handler: (ev) => this.polyMouseDown.emit(ev) },
            { name: 'mousemove', handler: (ev) => this.polyMouseMove.emit(ev) },
            { name: 'mouseout', handler: (ev) => this.polyMouseOut.emit(ev) },
            { name: 'mouseover', handler: (ev) => this.polyMouseOver.emit(ev) },
            { name: 'mouseup', handler: (ev) => this.polyMouseUp.emit(ev) },
            { name: 'rightclick', handler: (ev) => this.polyRightClick.emit(ev) },
        ];
        handlers.forEach((obj) => {
            const os = this._polygonManager.createEventObservable(obj.name, this).subscribe(obj.handler);
            this._subscriptions.push(os);
        });
        this._polygonManager.createPathEventObservable(this)
            .then(paths$ => {
            const os = paths$.subscribe(pathEvent => this.polyPathsChange.emit(pathEvent));
            this._subscriptions.push(os);
        });
    }
    _updatePolygonOptions(changes) {
        return Object.keys(changes)
            .filter(k => AgmPolygon_1._polygonOptionsAttributes.indexOf(k) !== -1)
            .reduce((obj, k) => {
            obj[k] = changes[k].currentValue;
            return obj;
        }, {});
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    ngOnDestroy() {
        this._polygonManager.deletePolygon(this);
        // unsubscribe all registered observable subscriptions
        this._subscriptions.forEach((s) => s.unsubscribe());
    }
    getPath() {
        return this._polygonManager.getPath(this);
    }
    getPaths() {
        return this._polygonManager.getPaths(this);
    }
};
AgmPolygon._polygonOptionsAttributes = [
    'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map',
    'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable',
    'editable', 'visible',
];
AgmPolygon.ctorParameters = () => [
    { type: PolygonManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolygon.prototype, "clickable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('polyDraggable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolygon.prototype, "draggable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolygon.prototype, "editable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolygon.prototype, "fillColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolygon.prototype, "fillOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolygon.prototype, "geodesic", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], AgmPolygon.prototype, "paths", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolygon.prototype, "strokeColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolygon.prototype, "strokeOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolygon.prototype, "strokeWeight", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], AgmPolygon.prototype, "visible", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolygon.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyDblClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyDrag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyDragEnd", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyDragStart", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyMouseDown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyMouseMove", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyMouseOut", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyMouseOver", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyMouseUp", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolygon.prototype, "polyRightClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolygon.prototype, "polyPathsChange", void 0);
AgmPolygon = AgmPolygon_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-polygon',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [PolygonManager])
], AgmPolygon);

/**
 * AgmPolylineIcon enables to add polyline sequences to add arrows, circle,
 * or custom icons either along the entire line, or in a specific part of it.
 * See https://developers.google.com/maps/documentation/javascript/shapes#polyline_customize
 *
 * ### Example
 * ```html
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polyline>
 *          <agm-icon-sequence [fixedRotation]="true" [path]="'FORWARD_OPEN_ARROW'">
 *          </agm-icon-sequence>
 *      </agm-polyline>
 *    </agm-map>
 * ```
 *
 * @export
 * @class AgmPolylineIcon
 */
let AgmPolylineIcon = class AgmPolylineIcon {
    ngOnInit() {
        if (this.path == null) {
            throw new Error('Icon Sequence path is required');
        }
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], AgmPolylineIcon.prototype, "fixedRotation", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolylineIcon.prototype, "offset", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolylineIcon.prototype, "repeat", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "anchorX", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "anchorY", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolylineIcon.prototype, "fillColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "fillOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolylineIcon.prototype, "path", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "rotation", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "scale", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolylineIcon.prototype, "strokeColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "strokeOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylineIcon.prototype, "strokeWeight", void 0);
AgmPolylineIcon = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: 'agm-polyline agm-icon-sequence' })
], AgmPolylineIcon);

var AgmPolylinePoint_1;
/**
 * AgmPolylinePoint represents one element of a polyline within a  {@link
 * AgmPolyline}
 */
let AgmPolylinePoint = AgmPolylinePoint_1 = class AgmPolylinePoint {
    constructor() {
        /**
         * This event emitter gets emitted when the position of the point changed.
         */
        this.positionChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    ngOnChanges(changes) {
        if (changes['latitude'] || changes['longitude']) {
            const position = {
                lat: changes['latitude'] ? changes['latitude'].currentValue : this.latitude,
                lng: changes['longitude'] ? changes['longitude'].currentValue : this.longitude,
            };
            this.positionChanged.emit(position);
        }
    }
    /** @internal */
    getFitBoundsDetails$() {
        return this.positionChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])({ lat: this.latitude, lng: this.longitude }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(position => ({ latLng: position })));
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylinePoint.prototype, "latitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolylinePoint.prototype, "longitude", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolylinePoint.prototype, "positionChanged", void 0);
AgmPolylinePoint = AgmPolylinePoint_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-polyline-point',
        providers: [
            { provide: FitBoundsAccessor, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => AgmPolylinePoint_1) },
        ],
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [])
], AgmPolylinePoint);

var AgmPolyline_1;
let polylineId = 0;
/**
 * AgmPolyline renders a polyline on a {@link AgmMap}
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    .agm-map-container {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polyline>
 *          <agm-polyline-point [latitude]="latA" [longitude]="lngA">
 *          </agm-polyline-point>
 *          <agm-polyline-point [latitude]="latB" [longitude]="lngB">
 *          </agm-polyline-point>
 *      </agm-polyline>
 *    </agm-map>
 *  `
 * })
 * ```
 */
let AgmPolyline = AgmPolyline_1 = class AgmPolyline {
    constructor(_polylineManager) {
        this._polylineManager = _polylineManager;
        /**
         * Indicates whether this Polyline handles mouse events. Defaults to true.
         */
        this.clickable = true;
        /**
         * If set to true, the user can drag this shape over the map. The geodesic property defines the
         * mode of dragging. Defaults to false.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = false;
        /**
         * If set to true, the user can edit this shape by dragging the control points shown at the
         * vertices and on each segment. Defaults to false.
         */
        this.editable = false;
        /**
         * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of
         * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.
         * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions
         * are maintained relative to the surface of the earth. Defaults to false.
         */
        this.geodesic = false;
        /**
         * Whether this polyline is visible on the map. Defaults to true.
         */
        this.visible = true;
        /**
         * This event is fired when the DOM click event is fired on the Polyline.
         */
        this.lineClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM dblclick event is fired on the Polyline.
         */
        this.lineDblClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is repeatedly fired while the user drags the polyline.
         */
        this.lineDrag = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user stops dragging the polyline.
         */
        this.lineDragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user starts dragging the polyline.
         */
        this.lineDragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousedown event is fired on the Polyline.
         */
        this.lineMouseDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousemove event is fired on the Polyline.
         */
        this.lineMouseMove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on Polyline mouseout.
         */
        this.lineMouseOut = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on Polyline mouseover.
         */
        this.lineMouseOver = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired whe the DOM mouseup event is fired on the Polyline
         */
        this.lineMouseUp = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the Polyline is right-clicked on.
         */
        this.lineRightClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired after Polyline's path changes.
         */
        this.polyPathChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._polylineAddedToManager = false;
        this._subscriptions = [];
        this._id = (polylineId++).toString();
    }
    /** @internal */
    ngAfterContentInit() {
        if (this.points.length) {
            this.points.forEach((point) => {
                const s = point.positionChanged.subscribe(() => { this._polylineManager.updatePolylinePoints(this); });
                this._subscriptions.push(s);
            });
        }
        if (!this._polylineAddedToManager) {
            this._init();
        }
        const pointSub = this.points.changes.subscribe(() => this._polylineManager.updatePolylinePoints(this));
        this._subscriptions.push(pointSub);
        this._polylineManager.updatePolylinePoints(this);
        const iconSub = this.iconSequences.changes.subscribe(() => this._polylineManager.updateIconSequences(this));
        this._subscriptions.push(iconSub);
    }
    ngOnChanges(changes) {
        if (!this._polylineAddedToManager) {
            this._init();
            return;
        }
        let options = {};
        const optionKeys = Object.keys(changes).filter(k => AgmPolyline_1._polylineOptionsAttributes.indexOf(k) !== -1);
        optionKeys.forEach(k => options[k] = changes[k].currentValue);
        this._polylineManager.setPolylineOptions(this, options);
    }
    getPath() {
        return this._polylineManager.getPath(this);
    }
    _init() {
        this._polylineManager.addPolyline(this);
        this._polylineAddedToManager = true;
        this._addEventListeners();
    }
    _addEventListeners() {
        const handlers = [
            { name: 'click', handler: (ev) => this.lineClick.emit(ev) },
            { name: 'dblclick', handler: (ev) => this.lineDblClick.emit(ev) },
            { name: 'drag', handler: (ev) => this.lineDrag.emit(ev) },
            { name: 'dragend', handler: (ev) => this.lineDragEnd.emit(ev) },
            { name: 'dragstart', handler: (ev) => this.lineDragStart.emit(ev) },
            { name: 'mousedown', handler: (ev) => this.lineMouseDown.emit(ev) },
            { name: 'mousemove', handler: (ev) => this.lineMouseMove.emit(ev) },
            { name: 'mouseout', handler: (ev) => this.lineMouseOut.emit(ev) },
            { name: 'mouseover', handler: (ev) => this.lineMouseOver.emit(ev) },
            { name: 'mouseup', handler: (ev) => this.lineMouseUp.emit(ev) },
            { name: 'rightclick', handler: (ev) => this.lineRightClick.emit(ev) },
        ];
        handlers.forEach((obj) => {
            const os = this._polylineManager.createEventObservable(obj.name, this).subscribe(obj.handler);
            this._subscriptions.push(os);
        });
        this._polylineManager.createPathEventObservable(this).then((ob$) => {
            const os = ob$.subscribe(pathEvent => this.polyPathChange.emit(pathEvent));
            this._subscriptions.push(os);
        });
    }
    /** @internal */
    _getPoints() {
        if (this.points) {
            return this.points.toArray();
        }
        return [];
    }
    _getIcons() {
        if (this.iconSequences) {
            return this.iconSequences.toArray();
        }
        return [];
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    ngOnDestroy() {
        this._polylineManager.deletePolyline(this);
        // unsubscribe all registered observable subscriptions
        this._subscriptions.forEach((s) => s.unsubscribe());
    }
};
AgmPolyline._polylineOptionsAttributes = [
    'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',
    'zIndex',
];
AgmPolyline.ctorParameters = () => [
    { type: PolylineManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolyline.prototype, "clickable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('polylineDraggable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolyline.prototype, "draggable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolyline.prototype, "editable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolyline.prototype, "geodesic", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmPolyline.prototype, "strokeColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolyline.prototype, "strokeOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolyline.prototype, "strokeWeight", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolyline.prototype, "visible", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmPolyline.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineDblClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineDrag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineDragEnd", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineDragStart", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineMouseDown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineMouseMove", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineMouseOut", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineMouseOver", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineMouseUp", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmPolyline.prototype, "lineRightClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmPolyline.prototype, "polyPathChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"])(AgmPolylinePoint),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
], AgmPolyline.prototype, "points", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"])(AgmPolylineIcon),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
], AgmPolyline.prototype, "iconSequences", void 0);
AgmPolyline = AgmPolyline_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-polyline',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [PolylineManager])
], AgmPolyline);

var AgmRectangle_1;
let AgmRectangle = AgmRectangle_1 = class AgmRectangle {
    constructor(_manager) {
        this._manager = _manager;
        /**
         * Indicates whether this Rectangle handles mouse events. Defaults to true.
         */
        this.clickable = true;
        /**
         * If set to true, the user can drag this rectangle over the map. Defaults to false.
         */
        // tslint:disable-next-line:no-input-rename
        this.draggable = false;
        /**
         * If set to true, the user can edit this rectangle by dragging the control points shown at
         * the center and around the circumference of the rectangle. Defaults to false.
         */
        this.editable = false;
        /**
         * The stroke position. Defaults to CENTER.
         * This property is not supported on Internet Explorer 8 and earlier.
         */
        this.strokePosition = 'CENTER';
        /**
         * The stroke width in pixels.
         */
        this.strokeWeight = 0;
        /**
         * Whether this rectangle is visible on the map. Defaults to true.
         */
        this.visible = true;
        /**
         * This event is fired when the rectangle's is changed.
         */
        this.boundsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user clicks on the rectangle.
         */
        this.rectangleClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event emitter gets emitted when the user clicks on the rectangle.
         */
        this.rectangleDblClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is repeatedly fired while the user drags the rectangle.
         */
        this.drag = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user stops dragging the rectangle.
         */
        this.dragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the user starts dragging the rectangle.
         */
        this.dragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousedown event is fired on the rectangle.
         */
        this.mouseDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mousemove event is fired on the rectangle.
         */
        this.mouseMove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on rectangle mouseout.
         */
        this.mouseOut = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired on rectangle mouseover.
         */
        this.mouseOver = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the DOM mouseup event is fired on the rectangle.
         */
        this.mouseUp = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is fired when the rectangle is right-clicked on.
         */
        this.rightClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._rectangleAddedToManager = false;
        this._eventSubscriptions = [];
    }
    /** @internal */
    ngOnInit() {
        this._manager.addRectangle(this);
        this._rectangleAddedToManager = true;
        this._registerEventListeners();
    }
    /** @internal */
    ngOnChanges(changes) {
        if (!this._rectangleAddedToManager) {
            return;
        }
        if (changes['north'] ||
            changes['east'] ||
            changes['south'] ||
            changes['west']) {
            this._manager.setBounds(this);
        }
        if (changes['editable']) {
            this._manager.setEditable(this);
        }
        if (changes['draggable']) {
            this._manager.setDraggable(this);
        }
        if (changes['visible']) {
            this._manager.setVisible(this);
        }
        this._updateRectangleOptionsChanges(changes);
    }
    _updateRectangleOptionsChanges(changes) {
        let options = {};
        let optionKeys = Object.keys(changes).filter(k => AgmRectangle_1._mapOptions.indexOf(k) !== -1);
        optionKeys.forEach(k => {
            options[k] = changes[k].currentValue;
        });
        if (optionKeys.length > 0) {
            this._manager.setOptions(this, options);
        }
    }
    _registerEventListeners() {
        let events = new Map();
        events.set('bounds_changed', this.boundsChange);
        events.set('click', this.rectangleClick);
        events.set('dblclick', this.rectangleDblClick);
        events.set('drag', this.drag);
        events.set('dragend', this.dragEnd);
        events.set('dragStart', this.dragStart);
        events.set('mousedown', this.mouseDown);
        events.set('mousemove', this.mouseMove);
        events.set('mouseout', this.mouseOut);
        events.set('mouseover', this.mouseOver);
        events.set('mouseup', this.mouseUp);
        events.set('rightclick', this.rightClick);
        events.forEach((eventEmitter, eventName) => {
            this._eventSubscriptions.push(this._manager
                .createEventObservable(eventName, this)
                .subscribe(value => {
                switch (eventName) {
                    case 'bounds_changed':
                        this._manager.getBounds(this).then(bounds => eventEmitter.emit({
                            north: bounds.getNorthEast().lat(),
                            east: bounds.getNorthEast().lng(),
                            south: bounds.getSouthWest().lat(),
                            west: bounds.getSouthWest().lng(),
                        }));
                        break;
                    default:
                        eventEmitter.emit({
                            coords: { lat: value.latLng.lat(), lng: value.latLng.lng() },
                        });
                }
            }));
        });
    }
    /** @internal */
    ngOnDestroy() {
        this._eventSubscriptions.forEach(function (s) {
            s.unsubscribe();
        });
        this._eventSubscriptions = null;
        this._manager.removeRectangle(this);
    }
    /**
     * Gets the LatLngBounds of this Rectangle.
     */
    getBounds() {
        return this._manager.getBounds(this);
    }
};
AgmRectangle._mapOptions = [
    'fillColor',
    'fillOpacity',
    'strokeColor',
    'strokeOpacity',
    'strokePosition',
    'strokeWeight',
    'visible',
    'zIndex',
    'clickable',
];
AgmRectangle.ctorParameters = () => [
    { type: RectangleManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "north", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "east", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "south", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "west", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmRectangle.prototype, "clickable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('rectangleDraggable'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmRectangle.prototype, "draggable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmRectangle.prototype, "editable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmRectangle.prototype, "fillColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "fillOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmRectangle.prototype, "strokeColor", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "strokeOpacity", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], AgmRectangle.prototype, "strokePosition", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmRectangle.prototype, "strokeWeight", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmRectangle.prototype, "visible", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], AgmRectangle.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "boundsChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "rectangleClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "rectangleDblClick", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "drag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "dragEnd", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "dragStart", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "mouseDown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "mouseMove", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "mouseOut", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "mouseOver", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "mouseUp", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], AgmRectangle.prototype, "rightClick", void 0);
AgmRectangle = AgmRectangle_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-rectangle',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [RectangleManager])
], AgmRectangle);

let layerId$3 = 0;
/*
 * This directive adds a transit layer to a google map instance
 * <agm-transit-layer [visible]="true|false"> <agm-transit-layer>
 * */
let AgmTransitLayer = class AgmTransitLayer {
    constructor(_manager) {
        this._manager = _manager;
        this._addedToManager = false;
        this._id = (layerId$3++).toString();
        /**
         * Hide/show transit layer
         */
        this.visible = true;
    }
    ngOnInit() {
        if (this._addedToManager) {
            return;
        }
        this._manager.addTransitLayer(this, { visible: this.visible });
        this._addedToManager = true;
    }
    ngOnChanges(changes) {
        if (!this._addedToManager) {
            return;
        }
        if (changes['visible'] != null) {
            this._manager.toggleLayerVisibility(this, { visible: changes['visible'].currentValue });
        }
    }
    /** @internal */
    id() { return this._id; }
    /** @internal */
    toString() { return `AgmTransitLayer-${this._id.toString()}`; }
    /** @internal */
    ngOnDestroy() {
        this._manager.deleteLayer(this);
    }
};
AgmTransitLayer.ctorParameters = () => [
    { type: LayerManager }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], AgmTransitLayer.prototype, "visible", void 0);
AgmTransitLayer = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'agm-transit-layer',
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [LayerManager])
], AgmTransitLayer);

var google$1;
var SymbolPath;
(function (SymbolPath) {
    SymbolPath[SymbolPath["BACKWARD_CLOSED_ARROW"] = 3] = "BACKWARD_CLOSED_ARROW";
    SymbolPath[SymbolPath["BACKWARD_OPEN_ARROW"] = 4] = "BACKWARD_OPEN_ARROW";
    SymbolPath[SymbolPath["CIRCLE"] = 0] = "CIRCLE";
    SymbolPath[SymbolPath["FORWARD_CLOSED_ARROW"] = 1] = "FORWARD_CLOSED_ARROW";
    SymbolPath[SymbolPath["FORWARD_OPEN_ARROW"] = 2] = "FORWARD_OPEN_ARROW";
})(SymbolPath || (SymbolPath = {}));
/**
 * Identifiers used to specify the placement of controls on the map. Controls are
 * positioned relative to other controls in the same layout position. Controls that
 * are added first are positioned closer to the edge of the map.
 */
var ControlPosition;
(function (ControlPosition) {
    ControlPosition[ControlPosition["RIGHT_BOTTOM"] = 0] = "RIGHT_BOTTOM";
    ControlPosition[ControlPosition["TOP_LEFT"] = 1] = "TOP_LEFT";
    ControlPosition[ControlPosition["TOP_CENTER"] = 2] = "TOP_CENTER";
    ControlPosition[ControlPosition["TOP_RIGHT"] = 3] = "TOP_RIGHT";
    ControlPosition[ControlPosition["LEFT_CENTER"] = 4] = "LEFT_CENTER";
    ControlPosition[ControlPosition["LEFT_TOP"] = 5] = "LEFT_TOP";
    ControlPosition[ControlPosition["LEFT_BOTTOM"] = 6] = "LEFT_BOTTOM";
    ControlPosition[ControlPosition["RIGHT_TOP"] = 7] = "RIGHT_TOP";
    ControlPosition[ControlPosition["RIGHT_CENTER"] = 8] = "RIGHT_CENTER";
    ControlPosition[ControlPosition["BOTTOM_RIGHT"] = 9] = "BOTTOM_RIGHT";
    ControlPosition[ControlPosition["BOTTOM_LEFT"] = 10] = "BOTTOM_LEFT";
    ControlPosition[ControlPosition["BOTTOM_CENTER"] = 11] = "BOTTOM_CENTER";
})(ControlPosition || (ControlPosition = {}));
var MapTypeId;
(function (MapTypeId) {
    /** This map type displays a transparent layer of major streets on satellite images. */
    MapTypeId[MapTypeId["HYBRID"] = 0] = "HYBRID";
    /** This map type displays a normal street map. */
    MapTypeId[MapTypeId["ROADMAP"] = 1] = "ROADMAP";
    /** This map type displays satellite images. */
    MapTypeId[MapTypeId["SATELLITE"] = 2] = "SATELLITE";
    /** This map type displays maps with physical features such as terrain and vegetation. */
    MapTypeId[MapTypeId["TERRAIN"] = 3] = "TERRAIN";
})(MapTypeId || (MapTypeId = {}));
var MapTypeControlStyle;
(function (MapTypeControlStyle) {
    MapTypeControlStyle[MapTypeControlStyle["DEFAULT"] = 0] = "DEFAULT";
    MapTypeControlStyle[MapTypeControlStyle["DROPDOWN_MENU"] = 2] = "DROPDOWN_MENU";
    MapTypeControlStyle[MapTypeControlStyle["HORIZONTAL_BAR"] = 1] = "HORIZONTAL_BAR";
})(MapTypeControlStyle || (MapTypeControlStyle = {}));
var ScaleControlStyle;
(function (ScaleControlStyle) {
    ScaleControlStyle[ScaleControlStyle["DEFAULT"] = 0] = "DEFAULT";
})(ScaleControlStyle || (ScaleControlStyle = {}));
var ZoomControlStyle;
(function (ZoomControlStyle) {
    ZoomControlStyle[ZoomControlStyle["DEFAULT"] = 0] = "DEFAULT";
    ZoomControlStyle[ZoomControlStyle["LARGE"] = 1] = "LARGE";
    ZoomControlStyle[ZoomControlStyle["SMALL"] = 2] = "SMALL";
})(ZoomControlStyle || (ZoomControlStyle = {}));
var GeocoderLocationType;
(function (GeocoderLocationType) {
    GeocoderLocationType["APPROXIMATE"] = "APPROXIMATE";
    GeocoderLocationType["GEOMETRIC_CENTER"] = "GEOMETRIC_CENTER";
    GeocoderLocationType["RANGE_INTERPOLATED"] = "RANGE_INTERPOLATED";
    GeocoderLocationType["ROOFTOP"] = "ROOFTOP";
})(GeocoderLocationType || (GeocoderLocationType = {}));
var GeocoderStatus;
(function (GeocoderStatus) {
    GeocoderStatus["ERROR"] = "ERROR";
    GeocoderStatus["INVALID_REQUEST"] = "INVALID_REQUEST";
    GeocoderStatus["OK"] = "OK";
    GeocoderStatus["OVER_QUERY_LIMIT"] = "OVER_QUERY_LIMIT";
    GeocoderStatus["REQUEST_DENIED"] = "REQUEST_DENIED";
    GeocoderStatus["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    GeocoderStatus["ZERO_RESULTS"] = "ZERO_RESULTS";
})(GeocoderStatus || (GeocoderStatus = {}));

let AgmGeocoder = class AgmGeocoder {
    constructor(loader) {
        const connectableGeocoder$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](subscriber => {
            loader.load().then(() => subscriber.next());
        })
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(() => this._createGeocoder()), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["multicast"])(new rxjs__WEBPACK_IMPORTED_MODULE_2__["ReplaySubject"](1)));
        connectableGeocoder$.connect(); // ignore the subscription
        // since we will remain subscribed till application exits
        this.geocoder$ = connectableGeocoder$;
    }
    geocode(request) {
        return this.geocoder$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])((geocoder) => this._getGoogleResults(geocoder, request)));
    }
    _getGoogleResults(geocoder, request) {
        const geocodeObservable = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["bindCallback"])(geocoder.geocode);
        return geocodeObservable(request).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(([results, status]) => {
            if (status === GeocoderStatus.OK) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(results);
            }
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["throwError"])(status);
        }));
    }
    _createGeocoder() {
        return new google.maps.Geocoder();
    }
};
AgmGeocoder.ctorParameters = () => [
    { type: MapsAPILoader }
];
AgmGeocoder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function AgmGeocoder_Factory() { return new AgmGeocoder(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(MapsAPILoader)); }, token: AgmGeocoder, providedIn: "root" });
AgmGeocoder = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [MapsAPILoader])
], AgmGeocoder);

class WindowRef {
    getNativeWindow() { return window; }
}
class DocumentRef {
    getNativeDocument() { return document; }
}
const BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];

var GoogleMapsScriptProtocol;
(function (GoogleMapsScriptProtocol) {
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
})(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));
/**
 * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
 * LazyMapsAPILoaderConfig}.
 */
const LAZY_MAPS_API_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('angular-google-maps LAZY_MAPS_API_CONFIG');
let LazyMapsAPILoader = class LazyMapsAPILoader extends MapsAPILoader {
    constructor(config = null, w, d, localeId) {
        super();
        this.localeId = localeId;
        this._SCRIPT_ID = 'agmGoogleMapsApiScript';
        this.callbackName = `agmLazyMapsAPILoader`;
        this._config = config || {};
        this._windowRef = w;
        this._documentRef = d;
    }
    load() {
        const window = this._windowRef.getNativeWindow();
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this._scriptLoadingPromise) {
            return this._scriptLoadingPromise;
        }
        // this can happen in HMR situations or Stackblitz.io editors.
        const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);
        if (scriptOnPage) {
            this._assignScriptLoadingPromise(scriptOnPage);
            return this._scriptLoadingPromise;
        }
        const script = this._documentRef.getNativeDocument().createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this._SCRIPT_ID;
        script.src = this._getScriptSrc(this.callbackName);
        this._assignScriptLoadingPromise(script);
        this._documentRef.getNativeDocument().body.appendChild(script);
        return this._scriptLoadingPromise;
    }
    _assignScriptLoadingPromise(scriptElem) {
        this._scriptLoadingPromise = new Promise((resolve, reject) => {
            this._windowRef.getNativeWindow()[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    _getScriptSrc(callbackName) {
        let protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
        let protocol;
        switch (protocolType) {
            case GoogleMapsScriptProtocol.AUTO:
                protocol = '';
                break;
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
        const queryParams = {
            v: this._config.apiVersion || 'quarterly',
            callback: callbackName,
            key: this._config.apiKey,
            client: this._config.clientId,
            channel: this._config.channel,
            libraries: this._config.libraries,
            region: this._config.region,
            language: this._config.language || this.localeId !== 'en-US' ? this.localeId : null,
        };
        const params = Object.keys(queryParams)
            .filter((k) => queryParams[k] != null)
            .filter((k) => {
            // remove empty arrays
            return !Array.isArray(queryParams[k]) ||
                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
        })
            .map((k) => {
            // join arrays as comma seperated strings
            let i = queryParams[k];
            if (Array.isArray(i)) {
                return { key: k, value: i.join(',') };
            }
            return { key: k, value: queryParams[k] };
        })
            .map((entry) => {
            return `${entry.key}=${entry.value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
};
LazyMapsAPILoader.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [LAZY_MAPS_API_CONFIG,] }] },
    { type: WindowRef },
    { type: DocumentRef },
    { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["LOCALE_ID"],] }] }
];
LazyMapsAPILoader = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"])()), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"])(LAZY_MAPS_API_CONFIG)),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(3, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["LOCALE_ID"])),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object, WindowRef, DocumentRef, String])
], LazyMapsAPILoader);

/**
 * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`
 * Tag.
 * It's important that the Google Maps API script gets loaded first on the page.
 */
class NoOpMapsAPILoader {
    load() {
        if (!window.google || !window.google.maps) {
            throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');
        }
        return Promise.resolve();
    }
}

// exported map types

var AgmCoreModule_1;
/**
 * @internal
 */
function coreDirectives() {
    return [
        AgmBicyclingLayer,
        AgmCircle,
        AgmDataLayer,
        AgmFitBounds,
        AgmInfoWindow,
        AgmKmlLayer,
        AgmMap,
        AgmMarker,
        AgmPolygon,
        AgmPolyline,
        AgmPolylineIcon,
        AgmPolylinePoint,
        AgmRectangle,
        AgmTransitLayer,
    ];
}
/**
 * The angular-google-maps core module. Contains all Directives/Services/Pipes
 * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.
 */
let AgmCoreModule = AgmCoreModule_1 = class AgmCoreModule {
    /**
     * Please use this method when you register the module at the root level.
     */
    static forRoot(lazyMapsAPILoaderConfig) {
        return {
            ngModule: AgmCoreModule_1,
            providers: [
                ...BROWSER_GLOBALS_PROVIDERS, { provide: MapsAPILoader, useClass: LazyMapsAPILoader },
                { provide: LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig },
            ],
        };
    }
};
AgmCoreModule = AgmCoreModule_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({ declarations: coreDirectives(), exports: coreDirectives() })
], AgmCoreModule);

// main modules

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=agm-core.js.map


/***/ }),

/***/ "./node_modules/igniteui-angular/fesm2015/igniteui-angular.js":
/*!********************************************************************!*\
  !*** ./node_modules/igniteui-angular/fesm2015/igniteui-angular.js ***!
  \********************************************************************/
/*! exports provided: AbsoluteScrollStrategy, AutoPositionStrategy, AvatarType, BaseFilteringStrategy, BaseProgress, BlockScrollStrategy, ButtonGroupAlignment, Calendar, CalendarHammerConfig, CalendarView, CloseScrollStrategy, ColumnDisplayOrder, ConnectedPositioningStrategy, ContainerPositionStrategy, CsvFileTypes, DataType, DataUtil, DateRangeType, DefaultSortingStrategy, Direction, DisplayDensity, DisplayDensityBase, DisplayDensityToken, DropPosition, ElasticPositionStrategy, FilterMode, FilteringExpressionsTree, FilteringExpressionsTreeType, FilteringLogic, FilteringStrategy, GlobalPositionStrategy, GridBaseAPIService, GridKeydownTargetType, GridSelectionMode, GridSummaryCalculationMode, GridSummaryPosition, GroupedRecords, HorizontalAlignment, IGX_CHECKBOX_REQUIRED_VALIDATOR, IGX_SWITCH_REQUIRED_VALIDATOR, IgxActionIconDirective, IgxAppendDropStrategy, IgxAutocompleteDirective, IgxAutocompleteModule, IgxAvatarComponent, IgxAvatarModule, IgxBadgeComponent, IgxBadgeModule, IgxBannerComponent, IgxBannerModule, IgxBaseExporter, IgxBaseTransactionService, IgxBooleanFilteringOperand, IgxBottomNavComponent, IgxBottomNavModule, IgxButtonDirective, IgxButtonGroupComponent, IgxButtonGroupModule, IgxButtonModule, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarModule, IgxCalendarMonthDirective, IgxCalendarScrollMonthDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarYearDirective, IgxCardActionsComponent, IgxCardActionsLayout, IgxCardComponent, IgxCardContentDirective, IgxCardFooterDirective, IgxCardHeaderComponent, IgxCardHeaderSubtitleDirective, IgxCardHeaderTitleDirective, IgxCardMediaDirective, IgxCardModule, IgxCardThumbnailDirective, IgxCardType, IgxCarouselComponent, IgxCarouselModule, IgxCellEditorTemplateDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxCheckboxComponent, IgxCheckboxModule, IgxCheckboxRequiredDirective, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxCircularProgressBarComponent, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnHidingComponent, IgxColumnHidingModule, IgxColumnLayoutComponent, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxColumnMovingService, IgxColumnPinningComponent, IgxColumnPinningItemDirective, IgxColumnPinningModule, IgxColumnResizerDirective, IgxComboComponent, IgxComboModule, IgxComboState, IgxCsvExporterOptions, IgxCsvExporterService, IgxDataLoadingTemplateDirective, IgxDataRecordSorting, IgxDateFilteringOperand, IgxDatePickerComponent, IgxDatePickerModule, IgxDatePipeComponent, IgxDateSummaryOperand, IgxDaysViewComponent, IgxDecimalPipeComponent, IgxDefaultDropStrategy, IgxDialogComponent, IgxDialogModule, IgxDividerDirective, IgxDividerModule, IgxDividerType, IgxDragDirective, IgxDragDropModule, IgxDragLocation, IgxDropDirective, IgxDropDownBase, IgxDropDownComponent, IgxDropDownGroupComponent, IgxDropDownItemBase, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownModule, IgxEmptyListTemplateDirective, IgxExcelExporterOptions, IgxExcelExporterService, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelModule, IgxExporterOptionsBase, IgxFilterCellTemplateDirective, IgxFilterDirective, IgxFilterModule, IgxFilterOptions, IgxFilterPipe, IgxFilteringOperand, IgxFlexDirective, IgxFocusDirective, IgxFocusModule, IgxForOfContext, IgxForOfDirective, IgxForOfModule, IgxGridAPIService, IgxGridBaseComponent, IgxGridBodyDirective, IgxGridCellComponent, IgxGridCommonModule, IgxGridComponent, IgxGridForOfDirective, IgxGridGroupByRowComponent, IgxGridModule, IgxGridRowComponent, IgxGridTransaction, IgxGroupAreaDropDirective, IgxGroupByRowTemplateDirective, IgxGrouping, IgxHeaderCollapseIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHierarchicalGridAPIService, IgxHierarchicalGridBaseComponent, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalRowComponent, IgxHierarchicalTransactionService, IgxHierarchicalTransactionServiceFactory, IgxHintDirective, IgxIconComponent, IgxIconModule, IgxIconService, IgxInputDirective, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInsertDropStrategy, IgxLabelDirective, IgxLayoutDirective, IgxLayoutModule, IgxLeftButtonStyleDirective, IgxLinearProgressBarComponent, IgxListActionDirective, IgxListBase, IgxListComponent, IgxListItemComponent, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListLineDirective, IgxListLineSubTitleDirective, IgxListLineTitleDirective, IgxListModule, IgxListPanState, IgxListThumbnailDirective, IgxMaskDirective, IgxMaskModule, IgxMonthPickerBase, IgxMonthPickerComponent, IgxMonthsViewComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavigationCloseDirective, IgxNavigationDrawerComponent, IgxNavigationDrawerModule, IgxNavigationModule, IgxNavigationService, IgxNavigationToggleDirective, IgxNumberFilteringOperand, IgxNumberSummaryOperand, IgxOverlayOutletDirective, IgxOverlayService, IgxPaginatorComponent, IgxPaginatorModule, IgxPrefixDirective, IgxPrefixModule, IgxPrependDropStrategy, IgxProgressBarModule, IgxProgressType, IgxRadioComponent, IgxRadioGroupDirective, IgxRadioModule, IgxResizeHandleDirective, IgxRightButtonStyleDirective, IgxRippleDirective, IgxRippleModule, IgxRowCollapsedIndicatorDirective, IgxRowComponent, IgxRowExpandedIndicatorDirective, IgxRowIslandAPIService, IgxRowIslandComponent, IgxSelectComponent, IgxSelectGroupComponent, IgxSelectItemComponent, IgxSelectModule, IgxSelectToggleIconDirective, IgxSlideComponent, IgxSliderComponent, IgxSliderModule, IgxSnackbarComponent, IgxSnackbarModule, IgxSorting, IgxStringFilteringOperand, IgxSuffixDirective, IgxSuffixModule, IgxSummaryOperand, IgxSwitchComponent, IgxSwitchModule, IgxSwitchRequiredDirective, IgxTabComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxTabPanelComponent, IgxTabTemplateDirective, IgxTabsComponent, IgxTabsGroupComponent, IgxTabsModule, IgxTextAlign, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTimePickerComponent, IgxTimePickerModule, IgxToastComponent, IgxToastModule, IgxToastPosition, IgxToggleActionDirective, IgxToggleDirective, IgxToggleModule, IgxTooltipDirective, IgxTooltipModule, IgxTooltipTargetDirective, IgxTransactionService, IgxTreeGridAPIService, IgxTreeGridCellComponent, IgxTreeGridComponent, IgxTreeGridModule, IgxTreeGridRowComponent, IgxYearsViewComponent, InteractionMode, LabelPosition, NoOpScrollStrategy, PagingError, Point, PredefinedFormatOptions, RadioLabelPosition, RestrictDrag, RowEditPositionStrategy, ScrollStrategy, Size, SliderHandle, SliderType, SortingDirection, SwitchLabelPosition, TabsType, TimePickerHammerConfig, TransactionType, Type, VerticalAlignment, WEEKDAYS, blink, changei18n, convertInPercentage, fadeIn, fadeOut, filteringStateDefaults, flipBottom, flipHorBck, flipHorFwd, flipLeft, flipRight, flipTop, flipVerBck, flipVerFwd, getCurrentResourceStrings, getTypeNameForDebugging, getValueInProperRange, growVerIn, growVerOut, heartbeat, hierarchicalTransactionServiceFactory, isDateInRanges, isLeap, monthRange, pulsateBck, pulsateFwd, range, rotateInBl, rotateInBottom, rotateInBr, rotateInCenter, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInLeft, rotateInRight, rotateInTl, rotateInTop, rotateInTr, rotateInVer, rotateOutBl, rotateOutBottom, rotateOutBr, rotateOutCenter, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutLeft, rotateOutRight, rotateOutTl, rotateOutTop, rotateOutTr, rotateOutVer, scaleInBl, scaleInBottom, scaleInBr, scaleInCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleInLeft, scaleInRight, scaleInTl, scaleInTop, scaleInTr, scaleInVerBottom, scaleInVerCenter, scaleInVerTop, scaleOutBl, scaleOutBottom, scaleOutBr, scaleOutCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, scaleOutLeft, scaleOutRight, scaleOutTl, scaleOutTop, scaleOutTr, scaleOutVerBottom, scaleOutVerCenter, scaleOutVerTop, shakeBl, shakeBottom, shakeBr, shakeCenter, shakeHor, shakeLeft, shakeRight, shakeTl, shakeTop, shakeTr, shakeVer, slideInBl, slideInBottom, slideInBr, slideInLeft, slideInRight, slideInTl, slideInTop, slideInTr, slideOutBl, slideOutBottom, slideOutBr, slideOutLeft, slideOutRight, slideOutTl, slideOutTop, slideOutTr, swingInBottomBck, swingInBottomFwd, swingInLeftBck, swingInLeftFwd, swingInRightBck, swingInRightFwd, swingInTopBck, swingInTopFwd, swingOutBottomBck, swingOutBottomFwd, swingOutLeftBck, swingOutLefttFwd, swingOutRightBck, swingOutRightFwd, swingOutTopBck, swingOutTopFwd, weekDay, ɵa, ɵba, ɵbb, ɵbc, ɵbd, ɵbe, ɵbf, ɵbg, ɵbi, ɵbj, ɵbk, ɵbl, ɵbm, ɵbn, ɵbo, ɵbp, ɵbq, ɵbr, ɵbs, ɵbt, ɵbu, ɵbv, ɵbw, ɵbx, ɵby, ɵbz, ɵc, ɵca, ɵcb, ɵcc, ɵce, ɵcf, ɵcg, ɵch, ɵci, ɵcj, ɵck, ɵcl, ɵcm, ɵcn, ɵco, ɵcp, ɵcq, ɵcr, ɵcs, ɵct, ɵcu, ɵcv, ɵcw, ɵcx, ɵcy, ɵcz, ɵd, ɵda, ɵdb, ɵdc, ɵdd, ɵde, ɵdf, ɵdg, ɵdh, ɵdi, ɵdj, ɵdk, ɵdl, ɵdm, ɵdn, ɵdo, ɵdp, ɵdq, ɵdr, ɵds, ɵdt, ɵdu, ɵdv, ɵdw, ɵdx, ɵdy, ɵdz, ɵea, ɵeb, ɵec, ɵed, ɵee, ɵef, ɵeg, ɵeh, ɵei, ɵej, ɵek, ɵel, ɵem, ɵen, ɵeo, ɵep, ɵeq, ɵer, ɵes, ɵet, ɵeu, ɵev, ɵew, ɵex, ɵey, ɵez, ɵf, ɵfa, ɵfb, ɵfc, ɵfd, ɵfe, ɵff, ɵfg, ɵfh, ɵfi, ɵfj, ɵfk, ɵfl, ɵfm, ɵfn, ɵfo, ɵfp, ɵfq, ɵfr, ɵfs, ɵfu, ɵfv, ɵfw, ɵfx, ɵfy, ɵfz, ɵg, ɵga, ɵgb, ɵh, ɵi, ɵj, ɵk, ɵl, ɵm, ɵn, ɵo, ɵp, ɵq, ɵr, ɵs, ɵt, ɵu, ɵv, ɵw, ɵx, ɵy, ɵz */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbsoluteScrollStrategy", function() { return AbsoluteScrollStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutoPositionStrategy", function() { return AutoPositionStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AvatarType", function() { return AvatarType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseFilteringStrategy", function() { return BaseFilteringStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseProgress", function() { return BaseProgress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockScrollStrategy", function() { return BlockScrollStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonGroupAlignment", function() { return ButtonGroupAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Calendar", function() { return Calendar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CalendarHammerConfig", function() { return CalendarHammerConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CalendarView", function() { return CalendarView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CloseScrollStrategy", function() { return CloseScrollStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnDisplayOrder", function() { return ColumnDisplayOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectedPositioningStrategy", function() { return ConnectedPositioningStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContainerPositionStrategy", function() { return ContainerPositionStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CsvFileTypes", function() { return CsvFileTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return DataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataUtil", function() { return DataUtil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateRangeType", function() { return DateRangeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultSortingStrategy", function() { return DefaultSortingStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Direction", function() { return Direction$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayDensity", function() { return DisplayDensity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayDensityBase", function() { return DisplayDensityBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayDensityToken", function() { return DisplayDensityToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropPosition", function() { return DropPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ElasticPositionStrategy", function() { return ElasticPositionStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilterMode", function() { return FilterMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilteringExpressionsTree", function() { return FilteringExpressionsTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilteringExpressionsTreeType", function() { return FilteringExpressionsTreeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilteringLogic", function() { return FilteringLogic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilteringStrategy", function() { return FilteringStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlobalPositionStrategy", function() { return GlobalPositionStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridBaseAPIService", function() { return GridBaseAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridKeydownTargetType", function() { return GridKeydownTargetType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridSelectionMode", function() { return GridSelectionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridSummaryCalculationMode", function() { return GridSummaryCalculationMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridSummaryPosition", function() { return GridSummaryPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupedRecords", function() { return GroupedRecords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HorizontalAlignment", function() { return HorizontalAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IGX_CHECKBOX_REQUIRED_VALIDATOR", function() { return IGX_CHECKBOX_REQUIRED_VALIDATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IGX_SWITCH_REQUIRED_VALIDATOR", function() { return IGX_SWITCH_REQUIRED_VALIDATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxActionIconDirective", function() { return IgxActionIconDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxAppendDropStrategy", function() { return IgxAppendDropStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxAutocompleteDirective", function() { return IgxAutocompleteDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxAutocompleteModule", function() { return IgxAutocompleteModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxAvatarComponent", function() { return IgxAvatarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxAvatarModule", function() { return IgxAvatarModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBadgeComponent", function() { return IgxBadgeComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBadgeModule", function() { return IgxBadgeModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBannerComponent", function() { return IgxBannerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBannerModule", function() { return IgxBannerModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBaseExporter", function() { return IgxBaseExporter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBaseTransactionService", function() { return IgxBaseTransactionService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBooleanFilteringOperand", function() { return IgxBooleanFilteringOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBottomNavComponent", function() { return IgxBottomNavComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxBottomNavModule", function() { return IgxBottomNavModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxButtonDirective", function() { return IgxButtonDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxButtonGroupComponent", function() { return IgxButtonGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxButtonGroupModule", function() { return IgxButtonGroupModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxButtonModule", function() { return IgxButtonModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarComponent", function() { return IgxCalendarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarHeaderTemplateDirective", function() { return IgxCalendarHeaderTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarModule", function() { return IgxCalendarModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarMonthDirective", function() { return IgxCalendarMonthDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarScrollMonthDirective", function() { return IgxCalendarScrollMonthDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarSubheaderTemplateDirective", function() { return IgxCalendarSubheaderTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCalendarYearDirective", function() { return IgxCalendarYearDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardActionsComponent", function() { return IgxCardActionsComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardActionsLayout", function() { return IgxCardActionsLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardComponent", function() { return IgxCardComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardContentDirective", function() { return IgxCardContentDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardFooterDirective", function() { return IgxCardFooterDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardHeaderComponent", function() { return IgxCardHeaderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardHeaderSubtitleDirective", function() { return IgxCardHeaderSubtitleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardHeaderTitleDirective", function() { return IgxCardHeaderTitleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardMediaDirective", function() { return IgxCardMediaDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardModule", function() { return IgxCardModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardThumbnailDirective", function() { return IgxCardThumbnailDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCardType", function() { return IgxCardType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCarouselComponent", function() { return IgxCarouselComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCarouselModule", function() { return IgxCarouselModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCellEditorTemplateDirective", function() { return IgxCellEditorTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCellFooterTemplateDirective", function() { return IgxCellFooterTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCellHeaderTemplateDirective", function() { return IgxCellHeaderTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCellTemplateDirective", function() { return IgxCellTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCheckboxComponent", function() { return IgxCheckboxComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCheckboxModule", function() { return IgxCheckboxModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCheckboxRequiredDirective", function() { return IgxCheckboxRequiredDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxChipComponent", function() { return IgxChipComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxChipsAreaComponent", function() { return IgxChipsAreaComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxChipsModule", function() { return IgxChipsModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCircularProgressBarComponent", function() { return IgxCircularProgressBarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnComponent", function() { return IgxColumnComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnGroupComponent", function() { return IgxColumnGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnHidingComponent", function() { return IgxColumnHidingComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnHidingModule", function() { return IgxColumnHidingModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnLayoutComponent", function() { return IgxColumnLayoutComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnMovingDragDirective", function() { return IgxColumnMovingDragDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnMovingDropDirective", function() { return IgxColumnMovingDropDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnMovingService", function() { return IgxColumnMovingService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnPinningComponent", function() { return IgxColumnPinningComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnPinningItemDirective", function() { return IgxColumnPinningItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnPinningModule", function() { return IgxColumnPinningModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxColumnResizerDirective", function() { return IgxColumnResizerDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxComboComponent", function() { return IgxComboComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxComboModule", function() { return IgxComboModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxComboState", function() { return IgxComboState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCsvExporterOptions", function() { return IgxCsvExporterOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxCsvExporterService", function() { return IgxCsvExporterService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDataLoadingTemplateDirective", function() { return IgxDataLoadingTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDataRecordSorting", function() { return IgxDataRecordSorting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDateFilteringOperand", function() { return IgxDateFilteringOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDatePickerComponent", function() { return IgxDatePickerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDatePickerModule", function() { return IgxDatePickerModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDatePipeComponent", function() { return IgxDatePipeComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDateSummaryOperand", function() { return IgxDateSummaryOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDaysViewComponent", function() { return IgxDaysViewComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDecimalPipeComponent", function() { return IgxDecimalPipeComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDefaultDropStrategy", function() { return IgxDefaultDropStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDialogComponent", function() { return IgxDialogComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDialogModule", function() { return IgxDialogModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDividerDirective", function() { return IgxDividerDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDividerModule", function() { return IgxDividerModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDividerType", function() { return IgxDividerType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDragDirective", function() { return IgxDragDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDragDropModule", function() { return IgxDragDropModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDragLocation", function() { return IgxDragLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDirective", function() { return IgxDropDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownBase", function() { return IgxDropDownBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownComponent", function() { return IgxDropDownComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownGroupComponent", function() { return IgxDropDownGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownItemBase", function() { return IgxDropDownItemBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownItemComponent", function() { return IgxDropDownItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownItemNavigationDirective", function() { return IgxDropDownItemNavigationDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxDropDownModule", function() { return IgxDropDownModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxEmptyListTemplateDirective", function() { return IgxEmptyListTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExcelExporterOptions", function() { return IgxExcelExporterOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExcelExporterService", function() { return IgxExcelExporterService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelBodyComponent", function() { return IgxExpansionPanelBodyComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelComponent", function() { return IgxExpansionPanelComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelHeaderComponent", function() { return IgxExpansionPanelHeaderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelModule", function() { return IgxExpansionPanelModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxExporterOptionsBase", function() { return IgxExporterOptionsBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFilterCellTemplateDirective", function() { return IgxFilterCellTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFilterDirective", function() { return IgxFilterDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFilterModule", function() { return IgxFilterModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFilterOptions", function() { return IgxFilterOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFilterPipe", function() { return IgxFilterPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFilteringOperand", function() { return IgxFilteringOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFlexDirective", function() { return IgxFlexDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFocusDirective", function() { return IgxFocusDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxFocusModule", function() { return IgxFocusModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxForOfContext", function() { return IgxForOfContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxForOfDirective", function() { return IgxForOfDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxForOfModule", function() { return IgxForOfModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridAPIService", function() { return IgxGridAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridBaseComponent", function() { return IgxGridBaseComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridBodyDirective", function() { return IgxGridBodyDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridCellComponent", function() { return IgxGridCellComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridCommonModule", function() { return IgxGridCommonModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridComponent", function() { return IgxGridComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridForOfDirective", function() { return IgxGridForOfDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridGroupByRowComponent", function() { return IgxGridGroupByRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridModule", function() { return IgxGridModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridRowComponent", function() { return IgxGridRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGridTransaction", function() { return IgxGridTransaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGroupAreaDropDirective", function() { return IgxGroupAreaDropDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGroupByRowTemplateDirective", function() { return IgxGroupByRowTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxGrouping", function() { return IgxGrouping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHeaderCollapseIndicatorDirective", function() { return IgxHeaderCollapseIndicatorDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHeaderExpandIndicatorDirective", function() { return IgxHeaderExpandIndicatorDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridAPIService", function() { return IgxHierarchicalGridAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridBaseComponent", function() { return IgxHierarchicalGridBaseComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridComponent", function() { return IgxHierarchicalGridComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridModule", function() { return IgxHierarchicalGridModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalRowComponent", function() { return IgxHierarchicalRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalTransactionService", function() { return IgxHierarchicalTransactionService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHierarchicalTransactionServiceFactory", function() { return IgxHierarchicalTransactionServiceFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxHintDirective", function() { return IgxHintDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxIconComponent", function() { return IgxIconComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxIconModule", function() { return IgxIconModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxIconService", function() { return IgxIconService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxInputDirective", function() { return IgxInputDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxInputGroupComponent", function() { return IgxInputGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxInputGroupModule", function() { return IgxInputGroupModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxInputState", function() { return IgxInputState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxInsertDropStrategy", function() { return IgxInsertDropStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxLabelDirective", function() { return IgxLabelDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxLayoutDirective", function() { return IgxLayoutDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxLayoutModule", function() { return IgxLayoutModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxLeftButtonStyleDirective", function() { return IgxLeftButtonStyleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxLinearProgressBarComponent", function() { return IgxLinearProgressBarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListActionDirective", function() { return IgxListActionDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListBase", function() { return IgxListBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListComponent", function() { return IgxListComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListItemComponent", function() { return IgxListItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListItemLeftPanningTemplateDirective", function() { return IgxListItemLeftPanningTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListItemRightPanningTemplateDirective", function() { return IgxListItemRightPanningTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListLineDirective", function() { return IgxListLineDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListLineSubTitleDirective", function() { return IgxListLineSubTitleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListLineTitleDirective", function() { return IgxListLineTitleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListModule", function() { return IgxListModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListPanState", function() { return IgxListPanState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxListThumbnailDirective", function() { return IgxListThumbnailDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxMaskDirective", function() { return IgxMaskDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxMaskModule", function() { return IgxMaskModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxMonthPickerBase", function() { return IgxMonthPickerBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxMonthPickerComponent", function() { return IgxMonthPickerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxMonthsViewComponent", function() { return IgxMonthsViewComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavDrawerItemDirective", function() { return IgxNavDrawerItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavDrawerMiniTemplateDirective", function() { return IgxNavDrawerMiniTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavDrawerTemplateDirective", function() { return IgxNavDrawerTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavbarComponent", function() { return IgxNavbarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavbarModule", function() { return IgxNavbarModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavigationCloseDirective", function() { return IgxNavigationCloseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavigationDrawerComponent", function() { return IgxNavigationDrawerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavigationDrawerModule", function() { return IgxNavigationDrawerModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavigationModule", function() { return IgxNavigationModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavigationService", function() { return IgxNavigationService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNavigationToggleDirective", function() { return IgxNavigationToggleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNumberFilteringOperand", function() { return IgxNumberFilteringOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxNumberSummaryOperand", function() { return IgxNumberSummaryOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxOverlayOutletDirective", function() { return IgxOverlayOutletDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxOverlayService", function() { return IgxOverlayService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxPaginatorComponent", function() { return IgxPaginatorComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxPaginatorModule", function() { return IgxPaginatorModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxPrefixDirective", function() { return IgxPrefixDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxPrefixModule", function() { return IgxPrefixModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxPrependDropStrategy", function() { return IgxPrependDropStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxProgressBarModule", function() { return IgxProgressBarModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxProgressType", function() { return IgxProgressType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRadioComponent", function() { return IgxRadioComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRadioGroupDirective", function() { return IgxRadioGroupDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRadioModule", function() { return IgxRadioModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxResizeHandleDirective", function() { return IgxResizeHandleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRightButtonStyleDirective", function() { return IgxRightButtonStyleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRippleDirective", function() { return IgxRippleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRippleModule", function() { return IgxRippleModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRowCollapsedIndicatorDirective", function() { return IgxRowCollapsedIndicatorDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRowComponent", function() { return IgxRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRowExpandedIndicatorDirective", function() { return IgxRowExpandedIndicatorDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRowIslandAPIService", function() { return IgxRowIslandAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxRowIslandComponent", function() { return IgxRowIslandComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSelectComponent", function() { return IgxSelectComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSelectGroupComponent", function() { return IgxSelectGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSelectItemComponent", function() { return IgxSelectItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSelectModule", function() { return IgxSelectModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSelectToggleIconDirective", function() { return IgxSelectToggleIconDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSlideComponent", function() { return IgxSlideComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSliderComponent", function() { return IgxSliderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSliderModule", function() { return IgxSliderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSnackbarComponent", function() { return IgxSnackbarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSnackbarModule", function() { return IgxSnackbarModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSorting", function() { return IgxSorting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxStringFilteringOperand", function() { return IgxStringFilteringOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSuffixDirective", function() { return IgxSuffixDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSuffixModule", function() { return IgxSuffixModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSummaryOperand", function() { return IgxSummaryOperand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSwitchComponent", function() { return IgxSwitchComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSwitchModule", function() { return IgxSwitchModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxSwitchRequiredDirective", function() { return IgxSwitchRequiredDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabComponent", function() { return IgxTabComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabItemComponent", function() { return IgxTabItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabItemTemplateDirective", function() { return IgxTabItemTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabPanelComponent", function() { return IgxTabPanelComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabTemplateDirective", function() { return IgxTabTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabsComponent", function() { return IgxTabsComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabsGroupComponent", function() { return IgxTabsGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTabsModule", function() { return IgxTabsModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTextAlign", function() { return IgxTextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTextHighlightDirective", function() { return IgxTextHighlightDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTextHighlightModule", function() { return IgxTextHighlightModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTextSelectionDirective", function() { return IgxTextSelectionDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTextSelectionModule", function() { return IgxTextSelectionModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxThumbFromTemplateDirective", function() { return IgxThumbFromTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxThumbToTemplateDirective", function() { return IgxThumbToTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTimePickerComponent", function() { return IgxTimePickerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTimePickerModule", function() { return IgxTimePickerModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxToastComponent", function() { return IgxToastComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxToastModule", function() { return IgxToastModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxToastPosition", function() { return IgxToastPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxToggleActionDirective", function() { return IgxToggleActionDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxToggleDirective", function() { return IgxToggleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxToggleModule", function() { return IgxToggleModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTooltipDirective", function() { return IgxTooltipDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTooltipModule", function() { return IgxTooltipModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTooltipTargetDirective", function() { return IgxTooltipTargetDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTransactionService", function() { return IgxTransactionService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTreeGridAPIService", function() { return IgxTreeGridAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTreeGridCellComponent", function() { return IgxTreeGridCellComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTreeGridComponent", function() { return IgxTreeGridComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTreeGridModule", function() { return IgxTreeGridModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxTreeGridRowComponent", function() { return IgxTreeGridRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IgxYearsViewComponent", function() { return IgxYearsViewComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InteractionMode", function() { return InteractionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelPosition", function() { return LabelPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoOpScrollStrategy", function() { return NoOpScrollStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PagingError", function() { return PagingError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredefinedFormatOptions", function() { return PredefinedFormatOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadioLabelPosition", function() { return RadioLabelPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RestrictDrag", function() { return RestrictDrag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RowEditPositionStrategy", function() { return RowEditPositionStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollStrategy", function() { return ScrollStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Size", function() { return Size; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliderHandle", function() { return SliderHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliderType", function() { return SliderType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SortingDirection", function() { return SortingDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SwitchLabelPosition", function() { return SwitchLabelPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabsType", function() { return TabsType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimePickerHammerConfig", function() { return TimePickerHammerConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransactionType", function() { return TransactionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalAlignment", function() { return VerticalAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEEKDAYS", function() { return WEEKDAYS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blink", function() { return blink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changei18n", function() { return changei18n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertInPercentage", function() { return convertInPercentage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fadeIn", function() { return fadeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fadeOut", function() { return fadeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filteringStateDefaults", function() { return filteringStateDefaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipBottom", function() { return flipBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipHorBck", function() { return flipHorBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipHorFwd", function() { return flipHorFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipLeft", function() { return flipLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipRight", function() { return flipRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipTop", function() { return flipTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipVerBck", function() { return flipVerBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipVerFwd", function() { return flipVerFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentResourceStrings", function() { return getCurrentResourceStrings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypeNameForDebugging", function() { return getTypeNameForDebugging; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValueInProperRange", function() { return getValueInProperRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "growVerIn", function() { return growVerIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "growVerOut", function() { return growVerOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "heartbeat", function() { return heartbeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hierarchicalTransactionServiceFactory", function() { return hierarchicalTransactionServiceFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDateInRanges", function() { return isDateInRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLeap", function() { return isLeap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monthRange", function() { return monthRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pulsateBck", function() { return pulsateBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pulsateFwd", function() { return pulsateFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInBl", function() { return rotateInBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInBottom", function() { return rotateInBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInBr", function() { return rotateInBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInCenter", function() { return rotateInCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInDiagonal1", function() { return rotateInDiagonal1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInDiagonal2", function() { return rotateInDiagonal2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInHor", function() { return rotateInHor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInLeft", function() { return rotateInLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInRight", function() { return rotateInRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInTl", function() { return rotateInTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInTop", function() { return rotateInTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInTr", function() { return rotateInTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInVer", function() { return rotateInVer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutBl", function() { return rotateOutBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutBottom", function() { return rotateOutBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutBr", function() { return rotateOutBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutCenter", function() { return rotateOutCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutDiagonal1", function() { return rotateOutDiagonal1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutDiagonal2", function() { return rotateOutDiagonal2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutHor", function() { return rotateOutHor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutLeft", function() { return rotateOutLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutRight", function() { return rotateOutRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutTl", function() { return rotateOutTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutTop", function() { return rotateOutTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutTr", function() { return rotateOutTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateOutVer", function() { return rotateOutVer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInBl", function() { return scaleInBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInBottom", function() { return scaleInBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInBr", function() { return scaleInBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInCenter", function() { return scaleInCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInHorCenter", function() { return scaleInHorCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInHorLeft", function() { return scaleInHorLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInHorRight", function() { return scaleInHorRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInLeft", function() { return scaleInLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInRight", function() { return scaleInRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInTl", function() { return scaleInTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInTop", function() { return scaleInTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInTr", function() { return scaleInTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInVerBottom", function() { return scaleInVerBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInVerCenter", function() { return scaleInVerCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleInVerTop", function() { return scaleInVerTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutBl", function() { return scaleOutBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutBottom", function() { return scaleOutBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutBr", function() { return scaleOutBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutCenter", function() { return scaleOutCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutHorCenter", function() { return scaleOutHorCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutHorLeft", function() { return scaleOutHorLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutHorRight", function() { return scaleOutHorRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutLeft", function() { return scaleOutLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutRight", function() { return scaleOutRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutTl", function() { return scaleOutTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutTop", function() { return scaleOutTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutTr", function() { return scaleOutTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutVerBottom", function() { return scaleOutVerBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutVerCenter", function() { return scaleOutVerCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleOutVerTop", function() { return scaleOutVerTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeBl", function() { return shakeBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeBottom", function() { return shakeBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeBr", function() { return shakeBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeCenter", function() { return shakeCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeHor", function() { return shakeHor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeLeft", function() { return shakeLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeRight", function() { return shakeRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeTl", function() { return shakeTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeTop", function() { return shakeTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeTr", function() { return shakeTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shakeVer", function() { return shakeVer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInBl", function() { return slideInBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInBottom", function() { return slideInBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInBr", function() { return slideInBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInLeft", function() { return slideInLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInRight", function() { return slideInRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInTl", function() { return slideInTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInTop", function() { return slideInTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideInTr", function() { return slideInTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutBl", function() { return slideOutBl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutBottom", function() { return slideOutBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutBr", function() { return slideOutBr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutLeft", function() { return slideOutLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutRight", function() { return slideOutRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutTl", function() { return slideOutTl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutTop", function() { return slideOutTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideOutTr", function() { return slideOutTr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInBottomBck", function() { return swingInBottomBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInBottomFwd", function() { return swingInBottomFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInLeftBck", function() { return swingInLeftBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInLeftFwd", function() { return swingInLeftFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInRightBck", function() { return swingInRightBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInRightFwd", function() { return swingInRightFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInTopBck", function() { return swingInTopBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingInTopFwd", function() { return swingInTopFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutBottomBck", function() { return swingOutBottomBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutBottomFwd", function() { return swingOutBottomFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutLeftBck", function() { return swingOutLeftBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutLefttFwd", function() { return swingOutLefttFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutRightBck", function() { return swingOutRightBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutRightFwd", function() { return swingOutRightFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutTopBck", function() { return swingOutTopBck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swingOutTopFwd", function() { return swingOutTopFwd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "weekDay", function() { return weekDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return IGX_DROPDOWN_BASE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵba", function() { return IgxExpansionPanelDescriptionDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbb", function() { return IgxExpansionPanelIconDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbc", function() { return IgxCalendarBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbd", function() { return IgxDaysViewNavigationService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbe", function() { return IgxDayItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbf", function() { return IgxComboAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbg", function() { return IGX_COMBO_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbi", function() { return IgxComboDropDownComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbj", function() { return IgxComboItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbk", function() { return IgxComboHeaderDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbl", function() { return IgxComboFooterDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbm", function() { return IgxComboItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbn", function() { return IgxComboEmptyDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbo", function() { return IgxComboHeaderItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbp", function() { return IgxComboAddItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbq", function() { return IgxComboToggleIconDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbr", function() { return IgxComboClearIconDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbs", function() { return IgxComboFilteringPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbt", function() { return IgxComboSortingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbu", function() { return IgxComboGroupingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbv", function() { return IgxComboFilterConditionPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbw", function() { return IgxComboAddItemComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbx", function() { return IgxDatePickerTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵby", function() { return IgxDatePickerActionsDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbz", function() { return IgxCalendarContainerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return ColumnChooserBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵca", function() { return DatePickerDisplayValuePipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcb", function() { return DatePickerInputValuePipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcc", function() { return IGX_DATE_PICKER_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵce", function() { return IgxDialogTitleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcf", function() { return IgxDialogActionsDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcg", function() { return HammerGesturesManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵch", function() { return IgxGridCRUDService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵci", function() { return IgxGridSelectionService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcj", function() { return WatchChanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵck", function() { return notifyChanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcl", function() { return IgxGridColumnResizerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcm", function() { return IgxColumnResizingService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcn", function() { return IgxExcelStyleSortingTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵco", function() { return IgxExcelStyleMovingTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcp", function() { return IgxExcelStyleHidingTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcq", function() { return IgxExcelStylePinningTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcr", function() { return IgxGridExcelStyleFilteringComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcs", function() { return IgxExcelStyleLoadingValuesTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵct", function() { return IgxExcelStyleSearchComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcu", function() { return IgxGridHeaderGroupComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcv", function() { return IgxGridHeaderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcw", function() { return IgxFilteringService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcx", function() { return IgxGridFilteringCellComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcy", function() { return IgxChipsAreaComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcz", function() { return IgxChipComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return IgxColumnHidingItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵda", function() { return IgxGridNavigationService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdb", function() { return IgxSummaryRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdc", function() { return IgxSummaryCellComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdd", function() { return IgxGridToolbarComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵde", function() { return IgxGridToolbarCustomContentDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdf", function() { return IgxRowSelectorDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdg", function() { return IgxHeadSelectorDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdh", function() { return IgxRowSelectorsModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdi", function() { return IgxGridFilteringRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdj", function() { return IgxTemplateOutletDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdk", function() { return IgxTemplateOutletModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdl", function() { return IgxRowEditTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdm", function() { return IgxRowEditTextDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdn", function() { return IgxRowEditActionsDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdo", function() { return IgxRowEditTabStopDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdp", function() { return IgxGridSummaryService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdq", function() { return ConnectedPositioningStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdr", function() { return IgxSummaryDataPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵds", function() { return IgxGridDragSelectDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdt", function() { return IgxGridFooterComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdu", function() { return IgxAdvancedFilteringDialogComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdv", function() { return ItemPropertyValueChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdw", function() { return ColumnChooserItemBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdx", function() { return IgxProcessBarTextTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdy", function() { return IgxGridPipesModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵdz", function() { return IgxGridCellStyleClassesPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵea", function() { return IgxGridCellStylesPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵeb", function() { return IgxGridNotGroupedPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵec", function() { return IgxGridTopLevelColumns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵed", function() { return IgxGridFilterConditionPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵee", function() { return IgxGridTransactionPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵef", function() { return IgxGridPaginatorOptionsPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵeg", function() { return IgxHasVisibleColumnsPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵeh", function() { return IgxGridExcelStyleFilteringModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵei", function() { return IgxDropDownComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵej", function() { return IgxExcelStyleCustomDialogComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵek", function() { return IgxExcelStyleDefaultExpressionComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵel", function() { return IgxExcelStyleDateExpressionComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵem", function() { return IgxExcelStyleSortingComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵen", function() { return IgxExcelStyleColumnMovingComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵeo", function() { return IgxExcelStyleSearchFilterPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵep", function() { return IgxRowDragDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵeq", function() { return IgxDragIndicatorIconDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵer", function() { return IgxRowDragModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵes", function() { return IgxSelectItemNavigationDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵet", function() { return IgxGridSortingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵeu", function() { return IgxGridGroupingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵev", function() { return IgxGridPagingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵew", function() { return IgxGridFilteringPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵex", function() { return IgxGridSummaryPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵey", function() { return IgxTreeGridNavigationService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵez", function() { return IgxRowLoadingIndicatorTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function() { return IGX_EXPANSION_PANEL_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfa", function() { return IgxTreeGridHierarchizingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfb", function() { return IgxTreeGridFlatteningPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfc", function() { return IgxTreeGridSortingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfd", function() { return IgxTreeGridPagingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfe", function() { return IgxTreeGridTransactionPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵff", function() { return IgxTreeGridFilteringPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfg", function() { return IgxTreeGridSummaryPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfh", function() { return IgxHierarchicalGridNavigationService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfi", function() { return GridBaseAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfj", function() { return IgxChildGridRowComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfk", function() { return IgxHierarchicalGridCellComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfl", function() { return IgxGridHierarchicalPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfm", function() { return IgxGridHierarchicalPagingPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfn", function() { return IgxSliderThumbComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfo", function() { return IgxThumbLabelComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfp", function() { return IgxTabsBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfq", function() { return IgxTabItemBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfr", function() { return IgxTabsGroupBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfs", function() { return IGX_TIME_PICKER_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfu", function() { return IgxItemListDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfv", function() { return IgxHourItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfw", function() { return IgxMinuteItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfx", function() { return IgxAmPmItemDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfy", function() { return IgxTimePickerTemplateDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵfz", function() { return IgxTimePickerActionsDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function() { return PlatformUtil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵga", function() { return TimeDisplayFormatPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵgb", function() { return TimeInputFormatPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh", function() { return EaseIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵi", function() { return EaseOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵj", function() { return IgxInputGroupBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵk", function() { return IgxForOfSyncService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵl", function() { return IgxForOfScrollSyncService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵm", function() { return DeprecateMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵn", function() { return DeprecateProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵo", function() { return IgxSelectionAPIService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵp", function() { return IgxDragHandleDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵq", function() { return DisplayContainerComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵr", function() { return VirtualHelperComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵs", function() { return VirtualHelperBaseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵt", function() { return HVirtualHelperComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵu", function() { return IgxScrollInertiaDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵv", function() { return IgxScrollInertiaModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵw", function() { return isHierarchyMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵx", function() { return getHierarchy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵy", function() { return IgxBannerActionsDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵz", function() { return IgxExpansionPanelTitleDirective; });
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jszip/dist/jszip */ "./node_modules/jszip/dist/jszip.js");
/* harmony import */ var jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");











/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const EaseIn = {
    quad: (/** @type {?} */ (`cubic-bezier(0.550, 0.085, 0.680, 0.530)`)),
    cubic: (/** @type {?} */ (`cubic-bezier(0.550, 0.055, 0.675, 0.190)`)),
    quart: (/** @type {?} */ (`cubic-bezier(0.895, 0.030, 0.685, 0.220)`)),
    quint: (/** @type {?} */ (`cubic-bezier(0.755, 0.050, 0.855, 0.060)`)),
    sine: (/** @type {?} */ (`cubic-bezier(0.470, 0.000, 0.745, 0.715)`)),
    expo: (/** @type {?} */ (`cubic-bezier(0.950, 0.050, 0.795, 0.035)`)),
    circ: (/** @type {?} */ (`cubic-bezier(0.600, 0.040, 0.980, 0.335)`)),
    back: (/** @type {?} */ (`cubic-bezier(0.600, -0.280, 0.735, 0.045)`)),
};
/** @enum {string} */
const EaseOut = {
    quad: (/** @type {?} */ (`cubic-bezier(0.250, 0.460, 0.450, 0.940)`)),
    cubic: (/** @type {?} */ (`cubic-bezier(0.215, 0.610, 0.355, 1.000)`)),
    quart: (/** @type {?} */ (`cubic-bezier(0.165, 0.840, 0.440, 1.000)`)),
    quint: (/** @type {?} */ (`cubic-bezier(0.230, 1.000, 0.320, 1.000)`)),
    sine: (/** @type {?} */ (`cubic-bezier(0.390, 0.575, 0.565, 1.000)`)),
    expo: (/** @type {?} */ (`cubic-bezier(0.190, 1.000, 0.220, 1.000)`)),
    circ: (/** @type {?} */ (`cubic-bezier(0.075, 0.820, 0.165, 1.000)`)),
    back: (/** @type {?} */ (`cubic-bezier(0.175, 0.885, 0.320, 1.275)`)),
};
/** @enum {string} */
const EaseInOut = {
    quad: (/** @type {?} */ (`cubic-bezier(0.455, 0.030, 0.515, 0.955)`)),
    cubic: (/** @type {?} */ (`cubic-bezier(0.645, 0.045, 0.355, 1.000)`)),
    quart: (/** @type {?} */ (`cubic-bezier(0.770, 0.000, 0.175, 1.000)`)),
    quint: (/** @type {?} */ (`cubic-bezier(0.860, 0.000, 0.070, 1.000)`)),
    sine: (/** @type {?} */ (`cubic-bezier(0.445, 0.050, 0.550, 0.950)`)),
    expo: (/** @type {?} */ (`cubic-bezier(1.000, 0.000, 0.000, 1.000)`)),
    circ: (/** @type {?} */ (`cubic-bezier(0.785, 0.135, 0.150, 0.860)`)),
    back: (/** @type {?} */ (`cubic-bezier(0.680, -0.550, 0.265, 1.550)`)),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const base = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{startOpacity}}`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{endOpacity}}`
    }))
];
/** @type {?} */
const baseParams = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.sine,
    endOpacity: 1,
    startOpacity: 0
};
/** @type {?} */
const fadeIn = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base, {
    params: baseParams
});
/** @type {?} */
const fadeOut = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.sine,
        endOpacity: 0,
        startOpacity: 1
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const baseRecipe = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        backfaceVisibility: 'hidden',
        transformStyle: 'preserve-3d'
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0,
            transform: `translateZ({{startDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 1,
            transform: `translateZ({{endDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)`
        })
    ]))
];
/** @type {?} */
const baseParams$1 = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 180,
    endDistance: '0px',
    rotateX: 1,
    rotateY: 0,
    rotateZ: 0,
    startAngle: 0,
    startDistance: '0px'
};
/** @type {?} */
const flipTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1)
});
/** @type {?} */
const flipBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { endAngle: -180 })
});
/** @type {?} */
const flipLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { rotateX: 0, rotateY: 1 })
});
/** @type {?} */
const flipRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { endAngle: -180, rotateX: 0, rotateY: 1 })
});
/** @type {?} */
const flipHorFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { endDistance: '170px' })
});
/** @type {?} */
const flipHorBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { endDistance: '-170px' })
});
/** @type {?} */
const flipVerFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { endDistance: '170px', rotateX: 0, rotateY: 1 })
});
/** @type {?} */
const flipVerBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
    params: Object.assign({}, baseParams$1, { endDistance: '-170px', rotateX: 0, rotateY: 1 })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const baseRecipe$1 = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{startOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        offset: 0,
        opacity: `{{endOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
/** @type {?} */
const baseInParams = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 0,
    endOpacity: 1,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 1,
    startAngle: -360,
    startOpacity: 0,
    xPos: 'center',
    yPos: 'center'
};
/** @type {?} */
const baseOutParams = Object.assign({}, baseInParams, { easing: EaseIn.quad, endOpacity: 0, startOpacity: 1 });
/** @type {?} */
const rotateInCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams)
});
/** @type {?} */
const rotateOutCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams)
});
/** @type {?} */
const rotateInTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'top' })
});
/** @type {?} */
const rotateOutTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'top' })
});
/** @type {?} */
const rotateInRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'right' })
});
/** @type {?} */
const rotateOutRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'right' })
});
/** @type {?} */
const rotateInBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'bottom' })
});
/** @type {?} */
const rotateOutBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'bottom' })
});
/** @type {?} */
const rotateInLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'left' })
});
/** @type {?} */
const rotateOutLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'left' })
});
/** @type {?} */
const rotateInTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'right', yPos: 'top' })
});
/** @type {?} */
const rotateOutTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'right', yPos: 'top' })
});
/** @type {?} */
const rotateInBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'right', yPos: 'bottom' })
});
/** @type {?} */
const rotateOutBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'right', yPos: 'bottom' })
});
/** @type {?} */
const rotateInBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'left', yPos: 'bottom' })
});
/** @type {?} */
const rotateOutBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'left', yPos: 'bottom' })
});
/** @type {?} */
const rotateInTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { xPos: 'left', yPos: 'top' })
});
/** @type {?} */
const rotateOutTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { xPos: 'left', yPos: 'top' })
});
/** @type {?} */
const rotateInDiagonal1 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
const rotateOutDiagonal1 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
const rotateInDiagonal2 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
const rotateOutDiagonal2 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
const rotateInHor = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
const rotateOutHor = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
const rotateInVer = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseInParams, { rotateX: 1, rotateY: 0, rotateZ: 0 })
});
/** @type {?} */
const rotateOutVer = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
    params: Object.assign({}, baseOutParams, { rotateX: 1, rotateY: 0, rotateZ: 0 })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const baseRecipe$2 = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.1,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.2,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.3,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.4,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.5,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.6,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.7,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.8,
            transform: `rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.9,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 1,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        })
    ]))
];
/** @type {?} */
const baseParams$2 = {
    delay: '0s',
    direction: 'X',
    duration: '800ms',
    easing: EaseInOut.quad,
    endAngle: 0,
    endDistance: '8px',
    startAngle: 0,
    startDistance: '10px',
    xPos: 'center',
    yPos: 'center'
};
/** @type {?} */
const shakeHor = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'X' })
});
/** @type {?} */
const shakeVer = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y' })
});
/** @type {?} */
const shakeTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
});
/** @type {?} */
const shakeBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
});
/** @type {?} */
const shakeRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
});
/** @type {?} */
const shakeLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
});
/** @type {?} */
const shakeCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
});
/** @type {?} */
const shakeTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
});
/** @type {?} */
const shakeBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
});
/** @type {?} */
const shakeBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
});
/** @type {?} */
const shakeTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
    params: Object.assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const heartbeatBase = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        animationTimingFunction: `ease-out`,
        transform: `scale(1)`,
        transformOrigin: `center center`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            animationTimingFunction: `ease-in`,
            offset: 0.1,
            transform: `scale(0.91)`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            animationTimingFunction: `ease-out`,
            offset: 0.17,
            transform: `scale(0.98)`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            animationTimingFunction: `ease-in`,
            offset: 0.33,
            transform: `scale(0.87)`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            animationTimingFunction: `ease-out`,
            offset: 0.45,
            transform: `scale(1)`
        })
    ]))
];
/** @type {?} */
const heartbeatParams = {
    delay: '0s',
    duration: '1.5s',
    easing: 'ease-in-out'
};
/** @type {?} */
const pulsateBase = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0,
            transform: `scale({{fromScale}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.5,
            transform: `scale({{toScale}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 1,
            transform: `scale({{fromScale}})`
        })
    ]))
];
/** @type {?} */
const pulsateParams = {
    delay: '0s',
    duration: '.5s',
    easing: 'ease-in-out',
    fromScale: 1,
    toScale: 1.1
};
/** @type {?} */
const blinkBase = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0,
            opacity: .8,
            transform: `scale({{fromScale}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 0.8,
            opacity: 0,
            transform: `scale({{midScale}})`
        }),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            offset: 1,
            opacity: 0,
            transform: `scale({{toScale}})`
        })
    ]))
];
/** @type {?} */
const blinkParams = {
    delay: '0s',
    duration: '.8s',
    easing: 'ease-in-out',
    fromScale: .2,
    midScale: 1.2,
    toScale: 2.2
};
/** @type {?} */
const pulsateFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(pulsateBase, {
    params: Object.assign({}, pulsateParams)
});
/** @type {?} */
const pulsateBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(pulsateBase, {
    params: Object.assign({}, pulsateParams, { toScale: .9 })
});
/** @type {?} */
const heartbeat = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(heartbeatBase, {
    params: Object.assign({}, heartbeatParams)
});
/** @type {?} */
const blink = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(blinkBase, {
    params: Object.assign({}, blinkParams)
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const base$1 = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{startOpacity}}`,
        transform: `scale{{direction}}({{fromScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{endOpacity}}`,
        transform: `scale{{direction}}({{toScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
/** @type {?} */
const baseInParams$1 = {
    delay: '0s',
    direction: '',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromScale: .5,
    startOpacity: 0,
    toScale: 1,
    xPos: '50%',
    yPos: '50%'
};
/** @type {?} */
const baseOutParams$1 = Object.assign({}, baseInParams$1, { easing: EaseOut.sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
/** @type {?} */
const scaleInCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, { params: baseInParams$1 });
/** @type {?} */
const scaleInBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '0', yPos: '100%' })
});
/** @type {?} */
const scaleInVerCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { direction: 'Y', fromScale: .4 })
});
/** @type {?} */
const scaleInTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '50%', yPos: '0' })
});
/** @type {?} */
const scaleInLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '0', yPos: '50%' })
});
/** @type {?} */
const scaleInVerTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
});
/** @type {?} */
const scaleInTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '100%', yPos: '0' })
});
/** @type {?} */
const scaleInTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '0', yPos: '0' })
});
/** @type {?} */
const scaleInVerBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
});
/** @type {?} */
const scaleInRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '100%', yPos: '50%' })
});
/** @type {?} */
const scaleInHorCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { direction: 'X', fromScale: .4 })
});
/** @type {?} */
const scaleInBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '100%', yPos: '100%' })
});
/** @type {?} */
const scaleInHorLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
});
/** @type {?} */
const scaleInBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { xPos: '50%', yPos: '100%' })
});
/** @type {?} */
const scaleInHorRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseInParams$1, { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
});
/** @type {?} */
const scaleOutCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, { params: baseOutParams$1 });
/** @type {?} */
const scaleOutBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '0', yPos: '100%' })
});
/** @type {?} */
const scaleOutBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '100%', yPos: '100%' })
});
/** @type {?} */
const scaleOutVerCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { direction: 'Y', toScale: .3 })
});
/** @type {?} */
const scaleOutVerTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
});
/** @type {?} */
const scaleOutVerBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
});
/** @type {?} */
const scaleOutTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '50%', yPos: '0' })
});
/** @type {?} */
const scaleOutLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '0', yPos: '50%' })
});
/** @type {?} */
const scaleOutTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '100%', yPos: '0' })
});
/** @type {?} */
const scaleOutTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '0', yPos: '0' })
});
/** @type {?} */
const scaleOutRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '100%', yPos: '50%' })
});
/** @type {?} */
const scaleOutBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { xPos: '50%', yPos: '100%' })
});
/** @type {?} */
const scaleOutHorCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { direction: 'X', toScale: .3 })
});
/** @type {?} */
const scaleOutHorLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
});
/** @type {?} */
const scaleOutHorRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
    params: Object.assign({}, baseOutParams$1, { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const base$2 = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{startOpacity}}`,
        transform: `{{fromPosition}}`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{endOpacity}}`,
        transform: `{{toPosition}}`
    }))
];
/** @type {?} */
const baseInParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromPosition: 'translateY(-500px)',
    startOpacity: 0,
    toPosition: 'translateY(0)'
};
/** @type {?} */
const baseOutParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    endOpacity: 0,
    fromPosition: 'translateY(0)',
    startOpacity: 1,
    toPosition: 'translateY(-500px)'
};
/** @type {?} */
const slideInTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, { params: baseInParams$2 });
/** @type {?} */
const slideInLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
/** @type {?} */
const slideInRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
/** @type {?} */
const slideInBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateY(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
/** @type {?} */
const slideInTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseInParams$2, { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
const slideInTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseInParams$2, { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
const slideInBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseInParams$2, { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
const slideInBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseInParams$2, { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
const slideOutTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, { params: baseOutParams$2 });
/** @type {?} */
const slideOutRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseOutParams$2, { toPosition: 'translateX(500px)' })
});
/** @type {?} */
const slideOutBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseIn.quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(500px)'
    }
});
/** @type {?} */
const slideOutLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseOutParams$2, { toPosition: 'translateX(-500px)' })
});
/** @type {?} */
const slideOutTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
});
/** @type {?} */
const slideOutBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
});
/** @type {?} */
const slideOutBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
});
/** @type {?} */
const slideOutTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
    params: Object.assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const swingBase = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{startOpacity}}`,
        transform: `rotate{{direction}}({{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{endOpacity}}`,
        transform: `rotate{{direction}}({{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
/** @type {?} */
const swingParams = {
    delay: '0s',
    direction: 'X',
    duration: '.5s',
    easing: EaseOut.back,
    endAngle: 0,
    endOpacity: 1,
    startAngle: -100,
    startOpacity: 0,
    xPos: 'top',
    yPos: 'center'
};
/** @type {?} */
const swingOutParams = Object.assign({}, swingParams, { duration: '.55s', easing: EaseIn.back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
/** @type {?} */
const swingInTopFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams)
});
/** @type {?} */
const swingInRightFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { direction: 'Y', xPos: 'center', yPos: 'right' })
});
/** @type {?} */
const swingInBottomFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { startAngle: 100, xPos: 'bottom' })
});
/** @type {?} */
const swingInLeftFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
});
/** @type {?} */
const swingInTopBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { duration: '.6s', startAngle: 70 })
});
/** @type {?} */
const swingInRightBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
});
/** @type {?} */
const swingInBottomBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { duration: '.6s', startAngle: -70, xPos: 'bottom' })
});
/** @type {?} */
const swingInLeftBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingParams, { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
});
/** @type {?} */
const swingOutTopFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams)
});
/** @type {?} */
const swingOutRightFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { direction: 'Y', xPos: 'center', yPos: 'right' })
});
/** @type {?} */
const swingOutBottomFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { endAngle: -70, xPos: 'bottom' })
});
/** @type {?} */
const swingOutLefttFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
});
/** @type {?} */
const swingOutTopBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { duration: '.45s', endAngle: -100 })
});
/** @type {?} */
const swingOutRightBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
});
/** @type {?} */
const swingOutBottomBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { duration: '.45s', endAngle: 100, xPos: 'bottom' })
});
/** @type {?} */
const swingOutLeftBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
    params: Object.assign({}, swingOutParams, { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const base$3 = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{ startOpacity }}`,
        height: `{{ startHeight }}`
    }),
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(`{{duration}} {{delay}} {{easing}}`, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: `{{ endOpacity }}`,
        height: `{{ endHeight }}`
    }))
];
/** @type {?} */
const baseParams$3 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    startOpacity: 0,
    endOpacity: 1,
    startHeight: '',
    endHeight: ''
};
/** @type {?} */
const growVerIn = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$3, {
    params: Object.assign({}, baseParams$3, { easing: EaseOut.quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
});
/** @type {?} */
const growVerOut = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$3, {
    params: Object.assign({}, baseParams$3, { easing: EaseOut.quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Common service to be injected between components where those implementing common
 * ToggleView interface can register and toggle directives can call their methods.
 * TODO: Track currently active? Events?
 */
class IgxNavigationService {
    constructor() {
        this.navs = {};
    }
    /**
     * @param {?} id
     * @param {?} navItem
     * @return {?}
     */
    add(id, navItem) {
        this.navs[id] = navItem;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    remove(id) {
        delete this.navs[id];
    }
    /**
     * @param {?} id
     * @return {?}
     */
    get(id) {
        if (id) {
            return this.navs[id];
        }
    }
    /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    toggle(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].toggle(...args);
        }
    }
    /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    open(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].open(...args);
        }
    }
    /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    close(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].close(...args);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive that can toggle targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavToggle="ID"> Toggle </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
class IgxNavigationToggleDirective {
    /**
     * @param {?} nav
     */
    constructor(nav) {
        this.state = nav;
    }
    /**
     * @return {?}
     */
    toggleNavigationDrawer() {
        this.state.toggle(this.target, true);
    }
}
IgxNavigationToggleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[igxNavToggle]' },] }
];
/** @nocollapse */
IgxNavigationToggleDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
IgxNavigationToggleDirective.propDecorators = {
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxNavToggle',] }],
    toggleNavigationDrawer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }]
};
/**
 * Directive that can close targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavClose="ID"> Close </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
class IgxNavigationCloseDirective {
    /**
     * @param {?} nav
     */
    constructor(nav) {
        this.state = nav;
    }
    /**
     * @return {?}
     */
    closeNavigationDrawer() {
        this.state.close(this.target, true);
    }
}
IgxNavigationCloseDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[igxNavClose]' },] }
];
/** @nocollapse */
IgxNavigationCloseDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
IgxNavigationCloseDirective.propDecorators = {
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxNavClose',] }],
    closeNavigationDrawer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }]
};
/**
 * @hidden
 */
class IgxNavigationModule {
}
IgxNavigationModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                providers: [IgxNavigationService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
function cloneArray(array, deep) {
    /** @type {?} */
    const arr = [];
    if (!array) {
        return arr;
    }
    /** @type {?} */
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
function cloneHierarchicalArray(array, childDataKey) {
    /** @type {?} */
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        /** @type {?} */
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
function mergeObjects(obj1, obj2) {
    if (!isObject(obj1)) {
        throw new Error(`Cannot merge into ${obj1}. First param must be an object.`);
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    for (const key of Object.keys(obj2)) {
        obj1[key] = cloneValue(obj2[key]);
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        /** @type {?} */
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
function getNodeSizeViaRange(range, node) {
    /** @type {?} */
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    /** @type {?} */
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * @return {?}
 */
function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
function isEdge() {
    /** @type {?} */
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @return {?}
 */
function isFirefox() {
    /** @type {?} */
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
class PlatformUtil {
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = Object(_angular_common__WEBPACK_IMPORTED_MODULE_3__["isPlatformBrowser"])(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
}
PlatformUtil.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
PlatformUtil.ctorParameters = () => [
    { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["PLATFORM_ID"],] }] }
];
/** @nocollapse */ PlatformUtil.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function PlatformUtil_Factory() { return new PlatformUtil(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["PLATFORM_ID"])); }, token: PlatformUtil, providedIn: "root" });
/**
 * @hidden
 * @param {?} event
 * @return {?}
 */
function isLeftClick(event) {
    return event.button === 0;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 * @param {?} arr
 * @return {?}
 */
function flatten(arr) {
    /** @type {?} */
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            /** @type {?} */
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
/** @type {?} */
const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
/** @type {?} */
const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
/** @type {?} */
const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
/** @type {?} */
const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'tab', 'enter', 'f2', 'escape', 'esc']);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const SortingDirection = {
    None: 0,
    Asc: 1,
    Desc: 2,
};
SortingDirection[SortingDirection.None] = 'None';
SortingDirection[SortingDirection.Asc] = 'Asc';
SortingDirection[SortingDirection.Desc] = 'Desc';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} h1
 * @param {?} h2
 * @return {?}
 */
function isHierarchyMatch(h1, h2) {
    if (h1.length !== h2.length) {
        return false;
    }
    return h1.every((level, index) => {
        return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
    });
}
/**
 * @param {?} gRow
 * @return {?}
 */
function getHierarchy(gRow) {
    /** @type {?} */
    const hierarchy = [];
    if (gRow !== undefined && gRow.expression) {
        hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
        while (gRow.groupParent) {
            gRow = gRow.groupParent;
            hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
        }
    }
    return hierarchy;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultSortingStrategy {
    /**
     * @protected
     */
    constructor() { }
    /**
     * @return {?}
     */
    static instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * @param {?} data
     * @param {?} fieldName
     * @param {?} dir
     * @param {?} ignoreCase
     * @param {?} valueResolver
     * @return {?}
     */
    sort(data, fieldName, dir, ignoreCase, valueResolver) {
        /** @type {?} */
        const key = fieldName;
        /** @type {?} */
        const reverse = (dir === SortingDirection.Desc ? -1 : 1);
        /** @type {?} */
        const cmpFunc = (obj1, obj2) => {
            return this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver);
        };
        return this.arraySort(data, cmpFunc);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    compareValues(a, b) {
        /** @type {?} */
        const an = (a === null || a === undefined);
        /** @type {?} */
        const bn = (b === null || b === undefined);
        if (an) {
            if (bn) {
                return 0;
            }
            return -1;
        }
        else if (bn) {
            return 1;
        }
        return a > b ? 1 : a < b ? -1 : 0;
    }
    /**
     * @protected
     * @param {?} obj1
     * @param {?} obj2
     * @param {?} key
     * @param {?} reverse
     * @param {?} ignoreCase
     * @param {?} valueResolver
     * @return {?}
     */
    compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver) {
        /** @type {?} */
        let a = valueResolver(obj1, key);
        /** @type {?} */
        let b = valueResolver(obj2, key);
        if (ignoreCase) {
            a = a && a.toLowerCase ? a.toLowerCase() : a;
            b = b && b.toLowerCase ? b.toLowerCase() : b;
        }
        return reverse * this.compareValues(a, b);
    }
    /**
     * @protected
     * @param {?} data
     * @param {?=} compareFn
     * @return {?}
     */
    arraySort(data, compareFn) {
        return data.sort(compareFn);
    }
}
DefaultSortingStrategy._instance = null;
class IgxSorting {
    /**
     * @param {?} data
     * @param {?} expressions
     * @return {?}
     */
    sort(data, expressions) {
        return this.sortDataRecursive(data, expressions);
    }
    /**
     * @private
     * @param {?} data
     * @param {?} index
     * @param {?} expression
     * @return {?}
     */
    groupedRecordsByExpression(data, index, expression) {
        /** @type {?} */
        let i;
        /** @type {?} */
        let groupval;
        /** @type {?} */
        const res = [];
        /** @type {?} */
        const key = expression.fieldName;
        /** @type {?} */
        const len = data.length;
        res.push(data[index]);
        groupval = this.getFieldValue(data[index], key);
        index++;
        /** @type {?} */
        const comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (i = index; i < len; i++) {
            if (comparer(this.getFieldValue(data[i], key), groupval) === 0) {
                res.push(data[i]);
            }
            else {
                break;
            }
        }
        return res;
    }
    /**
     * @private
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} expressionIndex
     * @return {?}
     */
    sortDataRecursive(data, expressions, expressionIndex = 0) {
        /** @type {?} */
        let i;
        /** @type {?} */
        let j;
        /** @type {?} */
        let expr;
        /** @type {?} */
        let gbData;
        /** @type {?} */
        let gbDataLen;
        /** @type {?} */
        const exprsLen = expressions.length;
        /** @type {?} */
        const dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    }
    /**
     * @protected
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?} level
     * @param {?} parent
     * @param {?} metadata
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @param {?=} fullResult
     * @return {?}
     */
    groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        /** @type {?} */
        const expressions = state.expressions;
        /** @type {?} */
        const expansion = state.expansion;
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let result = [];
        while (i < data.length) {
            /** @type {?} */
            const group = this.groupedRecordsByExpression(data, i, expressions[level]);
            /** @type {?} */
            const groupRow = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: group[0][expressions[level].fieldName],
                groupParent: parent,
                groups: [],
                height: grid ? grid.renderedRowHeight : null
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            /** @type {?} */
            const hierarchy = getHierarchy(groupRow);
            /** @type {?} */
            const expandState = expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
            /** @type {?} */
            const expanded = expandState ? expandState.expanded : state.defaultExpanded;
            /** @type {?} */
            let recursiveResult;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);
            if (level < expressions.length - 1) {
                recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                if (expanded) {
                    result = result.concat(recursiveResult);
                }
            }
            else {
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow);
                    fullResult.data.push(groupItem);
                }
                if (expanded) {
                    metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));
                    result.push(...fullResult.data.slice(fullResult.data.length - group.length));
                }
            }
            i += group.length;
        }
        return result;
    }
    /**
     * @protected
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    getFieldValue(obj, key) {
        return obj[key];
    }
}
class IgxDataRecordSorting extends IgxSorting {
    /**
     * @protected
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    getFieldValue(obj, key) {
        return obj.data[key];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGrouping extends IgxSorting {
    /**
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @param {?=} fullResult
     * @return {?}
     */
    groupBy(data, state, grid, groupsRecords, fullResult = { data: [], metadata: [] }) {
        /** @type {?} */
        const metadata = [];
        /** @type {?} */
        const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
        return {
            data: grouping,
            metadata: metadata
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const PagingError = {
    None: 0,
    IncorrectPageIndex: 1,
    IncorrectRecordsPerPage: 2,
};
PagingError[PagingError.None] = 'None';
PagingError[PagingError.IncorrectPageIndex] = 'IncorrectPageIndex';
PagingError[PagingError.IncorrectRecordsPerPage] = 'IncorrectRecordsPerPage';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const FilteringLogic = {
    And: 0,
    Or: 1,
};
FilteringLogic[FilteringLogic.And] = 'And';
FilteringLogic[FilteringLogic.Or] = 'Or';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const FilteringExpressionsTreeType = {
    Regular: 0,
    Advanced: 1,
};
FilteringExpressionsTreeType[FilteringExpressionsTreeType.Regular] = 'Regular';
FilteringExpressionsTreeType[FilteringExpressionsTreeType.Advanced] = 'Advanced';
class FilteringExpressionsTree {
    /**
     * @param {?} operator
     * @param {?=} fieldName
     */
    constructor(operator, fieldName) {
        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         * \@memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
    }
    /**
     * Checks if filtering expressions tree is empty.
     * @param {?} expressionTree filtering expressions tree.
     * @return {?}
     */
    static empty(expressionTree) {
        return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
    }
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    find(fieldName) {
        /** @type {?} */
        const index = this.findIndex(fieldName);
        if (index > -1) {
            return this.filteringOperands[index];
        }
        return null;
    }
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    findIndex(fieldName) {
        /** @type {?} */
        let expr;
        for (let i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];
            if (expr instanceof FilteringExpressionsTree) {
                if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                    return i;
                }
            }
            else {
                if (((/** @type {?} */ (expr))).fieldName === fieldName) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * @protected
     * @param {?} expressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {
        if (expressionsTree.fieldName === fieldName) {
            return true;
        }
        /** @type {?} */
        let expr;
        for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
            expr = expressionsTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            }
            else {
                return ((/** @type {?} */ (expr))).fieldName === fieldName;
            }
        }
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class BaseFilteringStrategy {
    /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    findMatchByExpression(rec, expr) {
        /** @type {?} */
        const cond = expr.condition;
        /** @type {?} */
        const val = this.getFieldValue(rec, expr.fieldName);
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    }
    /**
     * @param {?} rec
     * @param {?} expressions
     * @return {?}
     */
    matchRecord(rec, expressions) {
        if (expressions) {
            if (expressions instanceof FilteringExpressionsTree) {
                /** @type {?} */
                const expressionsTree = (/** @type {?} */ (expressions));
                /** @type {?} */
                const operator = (/** @type {?} */ (expressionsTree.operator));
                /** @type {?} */
                let matchOperand;
                /** @type {?} */
                let operand;
                if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                    for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                        operand = expressionsTree.filteringOperands[i];
                        matchOperand = this.matchRecord(rec, operand);
                        // Return false if at least one operand does not match and the filtering logic is And
                        if (!matchOperand && operator === FilteringLogic.And) {
                            return false;
                        }
                        // Return true if at least one operand matches and the filtering logic is Or
                        if (matchOperand && operator === FilteringLogic.Or) {
                            return true;
                        }
                    }
                    return matchOperand;
                }
                return true;
            }
            else {
                /** @type {?} */
                const expression = (/** @type {?} */ (expressions));
                return this.findMatchByExpression(rec, expression);
            }
        }
        return true;
    }
}
class FilteringStrategy extends BaseFilteringStrategy {
    constructor() { super(); }
    /**
     * @return {?}
     */
    static instance() {
        return this._instace || (this._instace = new this());
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} expressionsTree
     * @param {?=} advancedExpressionsTree
     * @return {?}
     */
    filter(data, expressionsTree, advancedExpressionsTree) {
        /** @type {?} */
        let i;
        /** @type {?} */
        let rec;
        /** @type {?} */
        const len = data.length;
        /** @type {?} */
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = data[i];
            if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
                res.push(rec);
            }
        }
        return res;
    }
    /**
     * @protected
     * @param {?} rec
     * @param {?} fieldName
     * @return {?}
     */
    getFieldValue(rec, fieldName) {
        return rec[fieldName];
    }
}
FilteringStrategy._instace = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const TransactionType = {
    ADD: 'add',
    DELETE: 'delete',
    UPDATE: 'update',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
};
/**
 * @hidden
 */
class DataUtil {
    /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    static sort(data, expressions, sorting = new IgxSorting()) {
        return sorting.sort(data, expressions);
    }
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    static treeGridSort(hierarchicalData, expressions, parent) {
        /** @type {?} */
        let res = [];
        hierarchicalData.forEach((hr) => {
            /** @type {?} */
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, new IgxDataRecordSorting());
        return res;
    }
    /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    static cloneTreeGridRecord(hierarchicalRecord) {
        /** @type {?} */
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @param {?=} fullResult
     * @return {?}
     */
    static group(data, state, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        /** @type {?} */
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    static page(data, state) {
        if (!state) {
            return data;
        }
        /** @type {?} */
        const len = data.length;
        /** @type {?} */
        const index = state.index;
        /** @type {?} */
        const res = [];
        /** @type {?} */
        const recordsPerPage = state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    static filter(data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    }
    /**
     * @param {?} state
     * @param {?} length
     * @return {?}
     */
    static correctPagingState(state, length) {
        /** @type {?} */
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    /**
     * @param {?} gRow
     * @return {?}
     */
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    static isHierarchyMatch(h1, h2) {
        return isHierarchyMatch(h1, h2);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            /** @type {?} */
            const rowId = primaryKey ? item[primaryKey] : item;
            /** @type {?} */
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                /** @type {?} */
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                /** @type {?} */
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                /** @type {?} */
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        /** @type {?} */
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            /** @type {?} */
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        /** @type {?} */
        let collection = data;
        /** @type {?} */
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class ExportUtilities {
    /**
     * @param {?} data
     * @return {?}
     */
    static getKeysFromData(data) {
        /** @type {?} */
        const length = data.length;
        if (length === 0) {
            return [];
        }
        /** @type {?} */
        const dataEntry = data[0];
        /** @type {?} */
        const dataEntryMiddle = data[Math.floor(length / 2)];
        /** @type {?} */
        const dataEntryLast = data[length - 1];
        /** @type {?} */
        const keys1 = Object.keys(dataEntry);
        /** @type {?} */
        const keys2 = Object.keys(dataEntryMiddle);
        /** @type {?} */
        const keys3 = Object.keys(dataEntryLast);
        /** @type {?} */
        const keys = new Set(keys1.concat(keys2).concat(keys3));
        return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
    }
    /**
     * @param {?} blob
     * @param {?} fileName
     * @return {?}
     */
    static saveBlobToFile(blob, fileName) {
        /** @type {?} */
        const a = document.createElement('a');
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        }
        else {
            /** @type {?} */
            const url = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    }
    /**
     * @param {?} s
     * @return {?}
     */
    static stringToArrayBuffer(s) {
        /** @type {?} */
        const buf = new ArrayBuffer(s.length);
        /** @type {?} */
        const view = new Uint8Array(buf);
        for (let i = 0; i !== s.length; ++i) {
            /* tslint:disable no-bitwise */
            view[i] = s.charCodeAt(i) & 0xFF;
            /* tslint:enable no-bitwise */
        }
        return buf;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static isSpecialData(data) {
        /** @type {?} */
        const dataEntry = data[0];
        return (typeof dataEntry === 'string' ||
            typeof dataEntry === 'number' ||
            dataEntry instanceof Date);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static hasValue(value) {
        return value !== undefined && value !== null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isNullOrWhitespaces(value) {
        return value === undefined || value === null || !value.trim();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @template T
 */
class GridBaseAPIService {
    constructor() {
        this.editCellState = new Map();
        this.editRowState = new Map();
        this.destroyMap = new Map();
    }
    /**
     * @param {?} name
     * @return {?}
     */
    get_column_by_name(name) {
        return this.grid.columnList.find((col) => col.field === name);
    }
    /**
     * @return {?}
     */
    get_summary_data() {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        let data = grid.filteredData;
        if (!data) {
            if (grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                /** @type {?} */
                const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
                deletedRows.forEach(rowID => {
                    /** @type {?} */
                    const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                    /** @type {?} */
                    const index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            else {
                data = grid.data;
            }
        }
        return data;
    }
    /**
     * @hidden
     * \@internal
     * @param {?} rowID
     * @return {?}
     */
    getRowData(rowID) {
        /** @type {?} */
        const data = this.get_all_data(this.grid.transactions.enabled);
        /** @type {?} */
        const index = this.get_row_index_in_data(rowID);
        return data[index];
    }
    // TODO: Refactor
    /**
     * @return {?}
     */
    escape_editMode() {
        this.grid.crudService.end();
    }
    // TODO: Refactor
    /**
     * @return {?}
     */
    get_cell_inEditMode() {
        return this.grid.crudService.cell;
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    get_row_index_in_data(rowID) {
        /** @type {?} */
        const grid = (/** @type {?} */ (this.grid));
        if (!grid) {
            return -1;
        }
        /** @type {?} */
        const data = this.get_all_data(grid.transactions.enabled);
        return grid.primaryKey ? data.findIndex(record => record[grid.primaryKey] === rowID) : data.indexOf(rowID);
    }
    /**
     * @param {?} rowSelector
     * @return {?}
     */
    get_row_by_key(rowSelector) {
        /** @type {?} */
        const primaryKey = this.grid.primaryKey;
        if (primaryKey !== undefined && primaryKey !== null) {
            return this.grid.dataRowList.find((row) => row.rowData[primaryKey] === rowSelector);
        }
        else {
            return this.grid.dataRowList.find((row) => row.rowData === rowSelector);
        }
    }
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    get_row_by_index(rowIndex) {
        return this.grid.rowList.find((row) => row.index === rowIndex);
    }
    /**
     * @param {?} rowSelector
     * @param {?} field
     * @return {?}
     */
    get_cell_by_key(rowSelector, field) {
        /** @type {?} */
        const row = this.get_row_by_key(rowSelector);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.column.field === field);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    get_cell_by_index(rowIndex, columnIndex) {
        /** @type {?} */
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.columnIndex === columnIndex);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    get_cell_by_visible_index(rowIndex, columnIndex) {
        /** @type {?} */
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.visibleColumnIndex === columnIndex);
        }
    }
    /**
     * @return {?}
     */
    submit_value() {
        /** @type {?} */
        const cell = this.grid.crudService.cell;
        if (cell) {
            /** @type {?} */
            const args = this.update_cell(cell, cell.editValue);
            if (args.cancel) {
                return;
            }
            this.escape_editMode();
        }
    }
    /**
     * @param {?} cell
     * @param {?} value
     * @return {?}
     */
    update_cell(cell, value) {
        /** @type {?} */
        const data = this.get_all_data(this.grid.transactions.enabled);
        /** @type {?} */
        const index = this.get_row_index_in_data(cell.id.rowID);
        cell.editValue = value;
        /** @type {?} */
        const args = cell.createEditEventArgs();
        this.grid.onCellEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        // Cast to number after emit
        // TODO: Clean up this
        args.newValue = cell.castToNumber(args.newValue);
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.summaryService.clearSummaryCache(args);
        this.updateData(this.grid, cell.id.rowID, data[index], cell.rowData, { [cell.column.field]: args.newValue });
        if (this.grid.primaryKey === cell.column.field) {
            if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
                this.grid.selectionService.deselectRow(cell.id.rowID);
                this.grid.selectionService.selectRowById(args.newValue);
            }
            if (this.grid.hasSummarizedColumns) {
                this.grid.summaryService.removeSummaries(cell.id.rowID);
            }
        }
        if (!this.grid.rowEditable || !this.grid.crudService.row ||
            this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
            this.grid.summaryService.clearSummaryCache(args);
            ((/** @type {?} */ (this.grid)))._pipeTrigger++;
        }
        return args;
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @protected
     * @param {?} grid Grid to update data for
     * @param {?} rowID ID of the row to update
     * @param {?} rowValueInDataSource Initial value of the row as it is in data source
     * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param {?} rowNewValue New value of the row
     * @return {?}
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            /** @type {?} */
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    /**
     * @param {?} row
     * @param {?=} value
     * @return {?}
     */
    _update_row(row, value) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const rowInEditMode = grid.crudService.row;
        row.newData = value ? value : grid.transactions.getAggregatedValue(row.id, true);
        if (rowInEditMode && row.id === rowInEditMode.id) {
            row.data = Object.assign({}, row.data, rowInEditMode.transactionState);
            // TODO: Workaround for updating a row in edit mode through the API
        }
        else if (this.grid.transactions.enabled) {
            /** @type {?} */
            const state = grid.transactions.getState(row.id);
            row.data = state ? Object.assign({}, row.data, state.value) : row.data;
        }
    }
    /**
     * @param {?} row
     * @param {?} value
     * @return {?}
     */
    update_row(row, value) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const selected = grid.selectionService.isRowSelected(row.id);
        /** @type {?} */
        const rowInEditMode = grid.crudService.row;
        /** @type {?} */
        const data = this.get_all_data(grid.transactions.enabled);
        /** @type {?} */
        const index = this.get_row_index_in_data(row.id);
        /** @type {?} */
        const hasSummarized = grid.hasSummarizedColumns;
        this._update_row(row, value);
        /** @type {?} */
        const args = row.createEditEventArgs();
        // If no valid row is found
        if (index === -1) {
            return args;
        }
        grid.onRowEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        if (rowInEditMode) {
            /** @type {?} */
            const hasChanges = grid.transactions.getState(args.rowID, true);
            grid.transactions.endPending(false);
            if (!hasChanges) {
                return args;
            }
        }
        if (!args.newValue) {
            return args;
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(args.rowID);
        }
        this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
        /** @type {?} */
        const newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
        if (selected) {
            grid.selectionService.deselectRow(row.id);
            grid.selectionService.selectRowById(newId);
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(newId);
        }
        ((/** @type {?} */ (grid)))._pipeTrigger++;
        return args;
    }
    /**
     * @protected
     * @param {?} value
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    update_row_in_array(value, rowID, index) {
        /** @type {?} */
        const grid = this.grid;
        grid.data[index] = value;
    }
    /**
     * @param {?} expression
     * @return {?}
     */
    sort(expression) {
        if (expression.dir === SortingDirection.None) {
            this.remove_grouping_expression(expression.fieldName);
        }
        /** @type {?} */
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState], expression);
        this.grid.sortingExpressions = sortingState;
    }
    /**
     * @param {?} expressions
     * @return {?}
     */
    sort_multiple(expressions) {
        /** @type {?} */
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            if (each.dir === SortingDirection.None) {
                this.remove_grouping_expression(each.fieldName);
            }
            this.prepare_sorting_expression([sortingState], each);
        }
        this.grid.sortingExpressions = sortingState;
    }
    /**
     * @param {?} fieldName
     * @param {?} term
     * @param {?} conditionOrExpressionsTree
     * @param {?} ignoreCase
     * @return {?}
     */
    filter(fieldName, term, conditionOrExpressionsTree, ignoreCase) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        /** @type {?} */
        const fieldFilterIndex = filteringTree.findIndex(fieldName);
        if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
        }
        this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
        grid.filteringExpressionsTree = filteringTree;
    }
    /**
     * @param {?} term
     * @param {?} condition
     * @param {?} ignoreCase
     * @return {?}
     */
    filter_global(term, condition, ignoreCase) {
        if (!condition) {
            return;
        }
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        filteringTree.filteringOperands = [];
        for (const column of grid.columns) {
            this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
        }
        grid.filteringExpressionsTree = filteringTree;
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    clear_filter(fieldName) {
        /** @type {?} */
        const grid = this.grid;
        grid.endEdit(false);
        /** @type {?} */
        const filteringState = grid.filteringExpressionsTree;
        /** @type {?} */
        const index = filteringState.findIndex(fieldName);
        if (index > -1) {
            filteringState.filteringOperands.splice(index, 1);
        }
        else if (!fieldName) {
            filteringState.filteringOperands = [];
        }
        grid.filteringExpressionsTree = filteringState;
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    clear_sort(fieldName) {
        /** @type {?} */
        const sortingState = this.grid.sortingExpressions;
        /** @type {?} */
        const index = sortingState.findIndex((expr) => expr.fieldName === fieldName);
        if (index > -1) {
            sortingState.splice(index, 1);
            this.grid.sortingExpressions = sortingState;
        }
    }
    /**
     * @protected
     * @param {?} filteringState
     * @param {?} fieldName
     * @param {?} searchVal
     * @param {?} conditionOrExpressionsTree
     * @param {?} ignoreCase
     * @param {?=} insertAtIndex
     * @return {?}
     */
    prepare_filtering_expression(filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex = -1) {
        /** @type {?} */
        let newExpressionsTree;
        /** @type {?} */
        const oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
        /** @type {?} */
        const expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            (/** @type {?} */ (conditionOrExpressionsTree)) : null;
        /** @type {?} */
        const condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            null : (/** @type {?} */ (conditionOrExpressionsTree));
        /** @type {?} */
        const newExpression = { fieldName, searchVal, condition, ignoreCase };
        if (oldExpressionsTreeIndex === -1) {
            // no expressions tree found for this field
            if (expressionsTree) {
                if (insertAtIndex > -1) {
                    filteringState.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                }
                else {
                    filteringState.filteringOperands.push(expressionsTree);
                }
            }
            else if (condition) {
                // create expressions tree for this field and add the new expression to it
                newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                newExpressionsTree.filteringOperands.push(newExpression);
                filteringState.filteringOperands.push(newExpressionsTree);
            }
        }
    }
    /**
     * @protected
     * @param {?} stateCollections
     * @param {?} expression
     * @return {?}
     */
    prepare_sorting_expression(stateCollections, expression) {
        if (expression.dir === SortingDirection.None) {
            stateCollections.forEach(state => {
                state.splice(state.findIndex((expr) => expr.fieldName === expression.fieldName), 1);
            });
            return;
        }
        /**
         * We need to make sure the states in each collection with same fields point to the same object reference.
         * If the different state collections provided have different sizes we need to get the largest one.
         * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
         * @type {?}
         */
        let maxCollection = stateCollections[0];
        for (let i = 1; i < stateCollections.length; i++) {
            if (maxCollection.length < stateCollections[i].length) {
                maxCollection = stateCollections[i];
            }
        }
        /** @type {?} */
        const maxExpr = maxCollection.find((expr) => expr.fieldName === expression.fieldName);
        stateCollections.forEach(collection => {
            /** @type {?} */
            const myExpr = collection.find((expr) => expr.fieldName === expression.fieldName);
            if (!myExpr && !maxExpr) {
                // Expression with this fieldName is missing from the current and the max collection.
                collection.push(expression);
            }
            else if (!myExpr && maxExpr) {
                // Expression with this fieldName is missing from the current and but the max collection has.
                collection.push(maxExpr);
                Object.assign(maxExpr, expression);
            }
            else {
                // The current collection has the expression so just update it.
                Object.assign(myExpr, expression);
            }
        });
    }
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    remove_grouping_expression(fieldName) {
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    clear_groupby(name) {
    }
    /**
     * @param {?} column
     * @return {?}
     */
    should_apply_number_style(column) {
        return column.dataType === DataType.Number;
    }
    /**
     * @return {?}
     */
    get_data() {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const data = grid.data ? grid.data : [];
        return data;
    }
    /**
     * @param {?=} includeTransactions
     * @return {?}
     */
    get_all_data(includeTransactions = false) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        let data = grid.data ? grid.data : [];
        data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
        return data;
    }
    /**
     * @return {?}
     */
    get_filtered_data() {
        return this.grid.filteredData;
    }
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    getSortStrategyPerColumn(fieldName) {
        return this.get_column_by_name(fieldName) ?
            this.get_column_by_name(fieldName).sortStrategy : undefined;
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    addRowToData(rowData) {
        // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
        // If there is a row in edit - > commit and close
        /** @type {?} */
        const grid = this.grid;
        if (grid.transactions.enabled) {
            /** @type {?} */
            const transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
            /** @type {?} */
            const transaction = { id: transactionId, type: TransactionType.ADD, newValue: rowData };
            grid.transactions.add(transaction);
        }
        else {
            grid.data.push(rowData);
        }
    }
    /**
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        /** @type {?} */
        const grid = this.grid;
        if (index !== -1) {
            if (grid.transactions.enabled) {
                /** @type {?} */
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                grid.transactions.add(transaction, grid.data[index]);
            }
            else {
                grid.data.splice(index, 1);
            }
        }
        else {
            /** @type {?} */
            const state = grid.transactions.getState(rowID);
            grid.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    /**
     * @param {?} rowId
     * @return {?}
     */
    deleteRowById(rowId) {
        /** @type {?} */
        let index;
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const data = this.get_all_data();
        if (grid.primaryKey) {
            index = data.map((record) => record[grid.primaryKey]).indexOf(rowId);
        }
        else {
            index = data.indexOf(rowId);
        }
        /** @type {?} */
        const state = grid.transactions.getState(rowId);
        /** @type {?} */
        const hasRowInNonDeletedState = state && state.type !== TransactionType.DELETE;
        //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
        //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
        //  Otherwise just exit - there is nothing to delete
        if (index !== -1 || hasRowInNonDeletedState) {
            // Always exit edit when row is deleted
            grid.endEdit(true);
        }
        else {
            return;
        }
        //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
        grid.onRowDeleted.emit({ data: data[index] });
        this.deleteRowFromData(rowId, index);
        grid.selectionService.isRowSelected(rowId) ? grid.selectionService.deselectRow(rowId) : grid.selectionService.clearHeaderCBState();
        ((/** @type {?} */ (grid)))._pipeTrigger++;
        grid.notifyChanges();
        // Data needs to be recalculated if transactions are in place
        // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
        /** @type {?} */
        const dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
        grid.refreshSearch();
        if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
            grid.page--;
        }
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    get_row_id(rowData) {
        return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    row_deleted_transaction(rowID) {
        /** @type {?} */
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if (!grid.transactions.enabled) {
            return false;
        }
        /** @type {?} */
        const state = grid.transactions.getState(rowID);
        if (state) {
            return state.type === TransactionType.DELETE;
        }
        return false;
    }
    /**
     * @return {?}
     */
    atInexistingPage() {
        return this.grid.totalPages - 1 > this.grid.page;
    }
}
GridBaseAPIService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class TreeGridFilteringStrategy extends BaseFilteringStrategy {
    /**
     * @param {?} data
     * @param {?} expressionsTree
     * @param {?=} advancedExpressionsTree
     * @return {?}
     */
    filter(data, expressionsTree, advancedExpressionsTree) {
        return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined);
    }
    /**
     * @private
     * @param {?} data
     * @param {?} expressionsTree
     * @param {?} advancedExpressionsTree
     * @param {?} parent
     * @return {?}
     */
    filterImpl(data, expressionsTree, advancedExpressionsTree, parent) {
        /** @type {?} */
        let i;
        /** @type {?} */
        let rec;
        /** @type {?} */
        const len = data.length;
        /** @type {?} */
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = DataUtil.cloneTreeGridRecord(data[i]);
            rec.parent = parent;
            if (rec.children) {
                /** @type {?} */
                const filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec);
                rec.children = filteredChildren.length > 0 ? filteredChildren : null;
            }
            if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
                res.push(rec);
            }
            else if (rec.children && rec.children.length > 0) {
                rec.isFilteredOutParent = true;
                res.push(rec);
            }
        }
        return res;
    }
    /**
     * @protected
     * @param {?} rec
     * @param {?} fieldName
     * @return {?}
     */
    getFieldValue(rec, fieldName) {
        /** @type {?} */
        const hierarchicalRecord = (/** @type {?} */ (rec));
        return hierarchicalRecord.data[fieldName];
    }
}
/**
 * @hidden
 */
class IgxTreeGridFilteringPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} hierarchyData
     * @param {?} expressionsTree
     * @param {?} filterStrategy
     * @param {?} advancedFilteringExpressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const state = {
            expressionsTree: expressionsTree,
            advancedExpressionsTree: advancedFilteringExpressionsTree,
            strategy: new TreeGridFilteringStrategy()
        };
        if (filterStrategy) {
            state.strategy = filterStrategy;
        }
        this.resetFilteredOutProperty(grid.records);
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            grid.filteredData = null;
            return hierarchyData;
        }
        /** @type {?} */
        const result = this.filter(hierarchyData, state);
        /** @type {?} */
        const filteredData = [];
        this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
        grid.filteredData = filteredData;
        return result;
    }
    /**
     * @private
     * @param {?} map
     * @return {?}
     */
    resetFilteredOutProperty(map) {
        /** @type {?} */
        const keys = Array.from(map.keys());
        for (let i = 0; i < keys.length; i++) {
            map.get(keys[i]).isFilteredOutParent = undefined;
        }
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} data
     * @param {?} expandedStates
     * @param {?} filteredData
     * @return {?}
     */
    expandAllRecursive(grid, data, expandedStates, filteredData) {
        for (let i = 0; i < data.length; i++) {
            /** @type {?} */
            const rec = data[i];
            filteredData.push(rec.data);
            this.updateNonProcessedRecord(grid, rec);
            if (rec.children && rec.children.length > 0) {
                expandedStates.set(rec.rowID, true);
                this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
            }
        }
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} record
     * @return {?}
     */
    updateNonProcessedRecord(grid, record) {
        /** @type {?} */
        const rec = grid.records.get(record.rowID);
        rec.isFilteredOutParent = record.isFilteredOutParent;
    }
    /**
     * @private
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    filter(data, state) {
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    }
}
IgxTreeGridFilteringPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridFiltering',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class IgxBaseExporter {
    constructor() {
        this.flatRecords = [];
        this._isTreeGrid = false;
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        /**
         * This event is emitted when a row is exported.
         * ```typescript
         * this.exporterService.onRowExport.subscribe((args: IRowExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxBaseExporter
         */
        this.onRowExport = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is emitted when a column is exported.
         * ```typescript
         * this.exporterService.onColumnExport.subscribe((args: IColumnExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxBaseExporter
         */
        this.onColumnExport = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     * \@memberof IgxBaseExporter
     * @param {?} grid
     * @param {?} options
     * @return {?}
     */
    export(grid, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        /** @type {?} */
        const columns = grid.columnList.toArray();
        this._columnList = new Array(columns.length);
        /** @type {?} */
        const hiddenColumns = [];
        /** @type {?} */
        let lastVisbleColumnIndex = -1;
        columns.forEach((column) => {
            /** @type {?} */
            const columnHeader = column.header !== '' ? column.header : column.field;
            /** @type {?} */
            const exportColumn = !column.hidden || options.ignoreColumnsVisibility;
            /** @type {?} */
            const index = options.ignoreColumnsOrder ? column.index : column.visibleIndex;
            /** @type {?} */
            const columnInfo = {
                header: columnHeader,
                field: column.field,
                skip: !exportColumn,
                formatter: column.formatter,
                skipFormatter: false
            };
            if (index !== -1) {
                this._columnList[index] = columnInfo;
                lastVisbleColumnIndex = Math.max(lastVisbleColumnIndex, index);
            }
            else {
                hiddenColumns.push(columnInfo);
            }
            if (column.pinned && exportColumn) {
                this._indexOfLastPinnedColumn = index;
            }
        });
        // Append the hidden columns to the end of the list
        hiddenColumns.forEach((hiddenColumn) => {
            this._columnList[++lastVisbleColumnIndex] = hiddenColumn;
        });
        /** @type {?} */
        const data = this.prepareData(grid, options);
        this.exportData(data, options);
    }
    /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     * \@memberof IgxBaseExporter
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    exportData(data, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        if (!this._columnList || this._columnList.length === 0) {
            /** @type {?} */
            const keys = ExportUtilities.getKeysFromData(data);
            this._columnList = keys.map((k) => ({ header: k, field: k, skip: false }));
        }
        /** @type {?} */
        let skippedPinnedColumnsCount = 0;
        /** @type {?} */
        let columnsWithoutHeaderCount = 1;
        this._columnList.forEach((column, index) => {
            if (!column.skip) {
                /** @type {?} */
                const columnExportArgs = {
                    header: ExportUtilities.isNullOrWhitespaces(column.header) ?
                        'Column' + columnsWithoutHeaderCount++ : column.header,
                    field: column.field,
                    columnIndex: index,
                    cancel: false,
                    skipFormatter: false
                };
                this.onColumnExport.emit(columnExportArgs);
                column.header = columnExportArgs.header;
                column.skip = columnExportArgs.cancel;
                column.skipFormatter = columnExportArgs.skipFormatter;
                if (column.skip && index <= this._indexOfLastPinnedColumn) {
                    skippedPinnedColumnsCount++;
                }
                if (this._sort && this._sort.fieldName === column.field) {
                    if (column.skip) {
                        this._sort = null;
                    }
                    else {
                        this._sort.fieldName = column.header;
                    }
                }
            }
        });
        this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
        /** @type {?} */
        const dataToExport = new Array();
        /** @type {?} */
        const isSpecialData = ExportUtilities.isSpecialData(data);
        data.forEach((row, index) => {
            this.exportRow(dataToExport, row, index, isSpecialData);
        });
        this.exportDataImplementation(dataToExport, options);
        this.resetDefaults();
    }
    /**
     * @private
     * @param {?} data
     * @param {?} rowData
     * @param {?} index
     * @param {?} isSpecialData
     * @return {?}
     */
    exportRow(data, rowData, index, isSpecialData) {
        /** @type {?} */
        let row;
        if (!isSpecialData) {
            row = this._columnList.reduce((a, e) => {
                if (!e.skip) {
                    /** @type {?} */
                    const rawValue = this._isTreeGrid ? rowData.data[e.field] : rowData[e.field];
                    a[e.header] = e.formatter && !e.skipFormatter ? e.formatter(rawValue) : rawValue;
                }
                return a;
            }, {});
        }
        else {
            row = this._isTreeGrid ? rowData.data : rowData;
        }
        /** @type {?} */
        const rowArgs = {
            rowData: row,
            rowIndex: index,
            cancel: false
        };
        this.onRowExport.emit(rowArgs);
        if (!rowArgs.cancel) {
            data.push({ rowData: rowArgs.rowData, originalRowData: rowData });
        }
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} options
     * @return {?}
     */
    prepareData(grid, options) {
        this.flatRecords = [];
        /** @type {?} */
        let rootRecords = grid.rootRecords;
        this._isTreeGrid = rootRecords !== undefined;
        if (this._isTreeGrid) {
            this.prepareHierarchicalData(rootRecords);
        }
        /** @type {?} */
        let data = this._isTreeGrid ? this.flatRecords : grid.data;
        if (grid.filteringExpressionsTree &&
            grid.filteringExpressionsTree.filteringOperands.length > 0 &&
            !options.ignoreFiltering) {
            /** @type {?} */
            const filteringState = {
                expressionsTree: grid.filteringExpressionsTree,
                advancedExpressionsTree: grid.advancedExpressionsTree,
                logic: grid.filteringLogic
            };
            if (this._isTreeGrid) {
                this.flatRecords = [];
                filteringState.strategy = new TreeGridFilteringStrategy();
                rootRecords = filteringState.strategy.filter(rootRecords, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                data = DataUtil.filter(data, filteringState);
            }
        }
        if (grid.sortingExpressions &&
            grid.sortingExpressions.length > 0 &&
            !options.ignoreSorting) {
            this._sort = cloneValue(grid.sortingExpressions[0]);
            if (this._isTreeGrid) {
                this.flatRecords = [];
                rootRecords = DataUtil.treeGridSort(rootRecords, grid.sortingExpressions);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                data = DataUtil.sort(data, grid.sortingExpressions);
            }
        }
        return data;
    }
    /**
     * @private
     * @param {?} records
     * @return {?}
     */
    prepareHierarchicalData(records) {
        if (!records) {
            return;
        }
        for (let i = 0; i < records.length; i++) {
            /** @type {?} */
            const hierarchicalRecord = records[i];
            this.flatRecords.push(hierarchicalRecord);
            this.prepareHierarchicalData(hierarchicalRecord.children);
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetDefaults() {
        this._columnList = [];
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.flatRecords = [];
    }
}
IgxBaseExporter.propDecorators = {
    onRowExport: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnExport: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class CharSeparatedValueData {
    /**
     * @param {?} _data
     * @param {?} valueDelimiter
     */
    constructor(_data, valueDelimiter) {
        this._data = _data;
        this._headerRecord = '';
        this._dataRecords = '';
        this._eor = '\r\n';
        this._escapeCharacters = ['\r', '\n', '\r\n'];
        this._delimiterLength = 1;
        this._isSpecialData = false;
        this.setDelimiter(valueDelimiter);
    }
    /**
     * @return {?}
     */
    prepareData() {
        if (!this._data || this._data.length === 0) {
            return '';
        }
        /** @type {?} */
        const keys = ExportUtilities.getKeysFromData(this._data);
        if (keys.length === 0) {
            return '';
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
        this._dataRecords = this.processDataRecords(this._data, keys, this._escapeCharacters);
        return this._headerRecord + this._dataRecords;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} escapeChars
     * @return {?}
     */
    processField(value, escapeChars) {
        /** @type {?} */
        let safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
        if (escapeChars.some((v) => safeValue.includes(v))) {
            safeValue = `"${safeValue}"`;
        }
        return safeValue + this._delimiter;
    }
    /**
     * @private
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    processHeaderRecord(keys, escapeChars) {
        /** @type {?} */
        let recordData = '';
        for (const keyName of keys) {
            recordData += this.processField(keyName, this._escapeCharacters);
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    }
    /**
     * @private
     * @param {?} record
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    processRecord(record, keys, escapeChars) {
        /** @type {?} */
        let recordData = '';
        for (const keyName of keys) {
            /** @type {?} */
            const value = (record[keyName] !== undefined) ? record[keyName] : this._isSpecialData ? record : '';
            recordData += this.processField(value, this._escapeCharacters);
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    }
    /**
     * @private
     * @param {?} currentData
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    processDataRecords(currentData, keys, escapeChars) {
        /** @type {?} */
        let dataRecords = '';
        for (const row of currentData) {
            dataRecords += this.processRecord(row, keys, escapeChars);
        }
        return dataRecords;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setDelimiter(value) {
        this._delimiter = value;
        this._delimiterLength = value.length;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class IgxExporterOptionsBase {
    /**
     * @param {?} fileName
     * @param {?} _fileExtension
     */
    constructor(fileName, _fileExtension) {
        this._fileExtension = _fileExtension;
        /**
         * Specifies whether hidden columns should be exported.
         * ```typescript
         * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
         * this.exportOptions.ignoreColumnsVisibility = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsVisibility = false;
        /**
         * Specifies whether filtered out rows should be exported.
         * ```typescript
         * let ignoreFiltering = this.exportOptions.ignoreFiltering;
         * this.exportOptions.ignoreFiltering = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreFiltering = false;
        /**
         * Specifies if the exporter should ignore the current column order in the IgxGrid.
         * ```typescript
         * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
         * this.exportOptions.ignoreColumnsOrder = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsOrder = false;
        /**
         * Specifies whether the exported data should be sorted as in the provided IgxGrid.
         * ```typescript
         * let ignoreSorting = this.exportOptions.ignoreSorting;
         * this.exportOptions.ignoreSorting = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreSorting = false;
        this.setFileName(fileName);
    }
    /**
     * @private
     * @param {?} fileName
     * @return {?}
     */
    setFileName(fileName) {
        this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
    }
    /**
     * Gets the file name which will be used for the exporting operation.
     * ```typescript
     * let fileName = this.exportOptions.fileName;
     * ```
     * \@memberof IgxExporterOptionsBase
     * @return {?}
     */
    get fileName() {
        return this._fileName;
    }
    /**
     * Sets the file name which will be used for the exporting operation.
     * ```typescript
     * this.exportOptions.fileName = 'exportedData01';
     * ```
     * \@memberof IgxExporterOptionsBase
     * @param {?} value
     * @return {?}
     */
    set fileName(value) {
        this.setFileName(value);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Objects of this class are used to configure the CSV exporting process.
 */
class IgxCsvExporterOptions extends IgxExporterOptionsBase {
    /**
     * @param {?} fileName
     * @param {?} fileType
     */
    constructor(fileName, fileType) {
        super(fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType));
        this.setFileType(fileType);
        this.setDelimiter();
    }
    /**
     * @private
     * @param {?} fType
     * @return {?}
     */
    static getExtensionFromFileType(fType) {
        /** @type {?} */
        let extension = '';
        switch (fType) {
            case CsvFileTypes.CSV:
                extension = '.csv';
                break;
            case CsvFileTypes.TSV:
                extension = '.tsv';
                break;
            case CsvFileTypes.TAB:
                extension = '.tab';
                break;
            default:
                throw Error('Unsupported CSV file type!');
        }
        return extension;
    }
    /**
     * Gets the value delimiter which will be used for the exporting operation.
     * ```typescript
     * let delimiter = this.exportOptions.valueDelimiter;
     * ```
     * \@memberof IgxCsvExporterOptions
     * @return {?}
     */
    get valueDelimiter() {
        return this._valueDelimiter;
    }
    /**
     * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
     * ```typescript
     * this.exportOptions.valueDelimiter = '|';
     * ```
     * \@memberof IgxCsvExporterOptions
     * @param {?} value
     * @return {?}
     */
    set valueDelimiter(value) {
        this.setDelimiter(value);
    }
    /**
     * Gets the CSV export format.
     * ```typescript
     * let filetype = this.exportOptions.fileType;
     * ```
     * \@memberof IgxCsvExporterOptions
     * @return {?}
     */
    get fileType() {
        return this._fileType;
    }
    /**
     * Sets the CSV export format.
     * ```typescript
     * this.exportOptions.fileType = CsvFileTypes.TAB;
     * ```
     * \@memberof IgxCsvExporterOptions
     * @param {?} value
     * @return {?}
     */
    set fileType(value) {
        this.setFileType(value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setFileType(value) {
        if (value !== undefined && value !== null && value !== this._fileType) {
            this._fileType = value;
            /** @type {?} */
            const extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
            if (!this.fileName.endsWith(extension)) {
                /** @type {?} */
                const oldExt = '.' + this.fileName.split('.').pop();
                /** @type {?} */
                const newName = this.fileName.replace(oldExt, extension);
                this._fileExtension = extension;
                this.fileName = newName;
            }
        }
    }
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    setDelimiter(value) {
        if (value !== undefined && value !== '' && value !== null) {
            this._valueDelimiter = value;
        }
        else {
            switch (this.fileType) {
                case CsvFileTypes.CSV:
                    this._valueDelimiter = ',';
                    break;
                case CsvFileTypes.TSV:
                case CsvFileTypes.TAB:
                    this._valueDelimiter = '\t';
                    break;
            }
        }
    }
}
/** @enum {number} */
const CsvFileTypes = {
    /**
     * Character Separated Values, default separator is "comma", default file extension is .csv
     */
    CSV: 0,
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tsv
     */
    TSV: 1,
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tab
     */
    TAB: 2,
};
CsvFileTypes[CsvFileTypes.CSV] = 'CSV';
CsvFileTypes[CsvFileTypes.TSV] = 'TSV';
CsvFileTypes[CsvFileTypes.TAB] = 'TAB';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular CSV Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_csv.html)
 *
 * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
 * both raw data (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private csvExportService: IgxCsvExporterService) {
 * }
 *
 * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
 * this.csvExportService.exportData(this.localData, opt);
 * ```
 */
class IgxCsvExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxCsvExporterService
         */
        this.onExportEnded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @protected
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    exportDataImplementation(data, options) {
        data = data.map((item) => item.rowData);
        /** @type {?} */
        const csvData = new CharSeparatedValueData(data, options.valueDelimiter);
        this._stringData = csvData.prepareData();
        this.saveFile(options);
        this.onExportEnded.emit({ csvData: this._stringData });
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    saveFile(options) {
        switch (options.fileType) {
            case CsvFileTypes.CSV:
                this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                break;
            case CsvFileTypes.TSV:
            case CsvFileTypes.TAB:
                this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                break;
        }
    }
    /**
     * @private
     * @param {?} data
     * @param {?} fileName
     * @param {?} fileType
     * @return {?}
     */
    exportFile(data, fileName, fileType) {
        /** @type {?} */
        const blob = new Blob(['\ufeff', data], { type: fileType });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxCsvExporterService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
IgxCsvExporterService.propDecorators = {
    onExportEnded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ExcelFolderTypes = {
    RootExcelFolder: 0,
    RootRelsExcelFolder: 1,
    DocPropsExcelFolder: 2,
    XLExcelFolder: 3,
    XLRelsExcelFolder: 4,
    ThemeExcelFolder: 5,
    WorksheetsExcelFolder: 6,
    WorksheetsRelsExcelFolder: 7,
    TablesExcelFolder: 8,
};
ExcelFolderTypes[ExcelFolderTypes.RootExcelFolder] = 'RootExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.RootRelsExcelFolder] = 'RootRelsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.DocPropsExcelFolder] = 'DocPropsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.XLExcelFolder] = 'XLExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.XLRelsExcelFolder] = 'XLRelsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.ThemeExcelFolder] = 'ThemeExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.WorksheetsExcelFolder] = 'WorksheetsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.WorksheetsRelsExcelFolder] = 'WorksheetsRelsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.TablesExcelFolder] = 'TablesExcelFolder';
/** @enum {number} */
const ExcelFileTypes = {
    RootRelsFile: 0,
    AppFile: 1,
    CoreFile: 2,
    WorkbookRelsFile: 3,
    ThemeFile: 4,
    WorksheetFile: 5,
    StyleFile: 6,
    WorkbookFile: 7,
    ContentTypesFile: 8,
    SharedStringsFile: 9,
    WorksheetRelsFile: 10,
    TablesFile: 11,
};
ExcelFileTypes[ExcelFileTypes.RootRelsFile] = 'RootRelsFile';
ExcelFileTypes[ExcelFileTypes.AppFile] = 'AppFile';
ExcelFileTypes[ExcelFileTypes.CoreFile] = 'CoreFile';
ExcelFileTypes[ExcelFileTypes.WorkbookRelsFile] = 'WorkbookRelsFile';
ExcelFileTypes[ExcelFileTypes.ThemeFile] = 'ThemeFile';
ExcelFileTypes[ExcelFileTypes.WorksheetFile] = 'WorksheetFile';
ExcelFileTypes[ExcelFileTypes.StyleFile] = 'StyleFile';
ExcelFileTypes[ExcelFileTypes.WorkbookFile] = 'WorkbookFile';
ExcelFileTypes[ExcelFileTypes.ContentTypesFile] = 'ContentTypesFile';
ExcelFileTypes[ExcelFileTypes.SharedStringsFile] = 'SharedStringsFile';
ExcelFileTypes[ExcelFileTypes.WorksheetRelsFile] = 'WorksheetRelsFile';
ExcelFileTypes[ExcelFileTypes.TablesFile] = 'TablesFile';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class ExcelStrings {
    /**
     * @return {?}
     */
    static getRels() {
        return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
    }
    /**
     * @return {?}
     */
    static getApp() {
        return ExcelStrings.XML_STRING + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>';
    }
    /**
     * @return {?}
     */
    static getCore() {
        return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
    }
    /**
     * @return {?}
     */
    static getTheme() {
        return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
    }
    /**
     * @param {?} hasNonStringValues
     * @return {?}
     */
    static getStyles(hasNonStringValues) {
        /** @type {?} */
        const additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
        /** @type {?} */
        const cellXFCount = hasNonStringValues ? 2 : 1;
        return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
    }
    /**
     * @return {?}
     */
    static getWorkbook() {
        return ExcelStrings.XML_STRING + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>';
    }
    /**
     * @return {?}
     */
    static getWorksheetRels() {
        return ExcelStrings.XML_STRING + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/></Relationships>`;
    }
    /**
     * @param {?} hasSharedStrings
     * @return {?}
     */
    static getWorkbookRels(hasSharedStrings) {
        /** @type {?} */
        let retVal = ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>';
        if (hasSharedStrings) {
            retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
        }
        retVal += '</Relationships>';
        return retVal;
    }
    /**
     * @param {?} dimension
     * @param {?} freezePane
     * @param {?} cols
     * @param {?} sheetData
     * @param {?} hasTable
     * @param {?=} hasGroupedRows
     * @param {?=} outlineLevel
     * @return {?}
     */
    static getSheetXML(dimension, freezePane, cols, sheetData, hasTable, hasGroupedRows = false, outlineLevel = 0) {
        /** @type {?} */
        const tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
        /** @type {?} */
        const sheetOutlineProp = hasGroupedRows ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
        /** @type {?} */
        const sOutlineLevel = outlineLevel > 0 ? `outlineLevelRow="${outlineLevel}"` : '';
        // return ExcelStrings.XML_STRING +
        //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
        return `${ExcelStrings.XML_STRING}
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">
${sheetOutlineProp}
<dimension ref="${dimension}"/>
<sheetViews><sheetView tabSelected="1" workbookViewId="0">${freezePane}</sheetView></sheetViews>
<sheetFormatPr defaultRowHeight="15" ${sOutlineLevel} x14ac:dyDescent="0.25"/>
${cols}
${sheetData}
<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>
${tableParts}</worksheet>`;
    }
    /**
     * @param {?} count
     * @param {?} uniqueCount
     * @param {?} table
     * @return {?}
     */
    static getSharedStringXML(count, uniqueCount, table) {
        return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
    }
    /**
     * @param {?} hasSharedStrings
     * @param {?} hasTable
     * @return {?}
     */
    static getContentTypesXML(hasSharedStrings, hasTable) {
        /** @type {?} */
        let contentTypes = ExcelStrings.XML_STRING +
            `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types\">
            <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
            <Default Extension="xml" ContentType="application/xml"/>
            <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
            <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
            <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>
            <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
            <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
            <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>`;
        contentTypes += hasSharedStrings ?
            `	<Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>` : '';
        contentTypes += hasTable ?
            `<Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>` : '';
        contentTypes += `</Types>`;
        return contentTypes;
    }
    /**
     * @param {?} dimension
     * @param {?} tableColumns
     * @param {?} sort
     * @return {?}
     */
    static getTablesXML(dimension, tableColumns, sort) {
        return `${ExcelStrings.XML_STRING}<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="${dimension}" totalsRowShown="0">
    <autoFilter ref="${dimension}"/>${sort}${tableColumns}<tableStyleInfo name="TableStyleMedium2" showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>
</table>`;
    }
    /* tslint:enable max-line-length */
    /**
     * @param {?} index
     * @return {?}
     */
    static getExcelColumn(index) {
        // Returns the excel column name for given 0-based index
        // For example 27 should return "AB"
        /** @type {?} */
        let returnString = '';
        while (index >= 0) {
            /** @type {?} */
            const char = index % 26;
            returnString = String.fromCharCode(65 + char) + returnString;
            index = Math.floor(index / 26) - 1;
        }
        return returnString;
    }
}
/* tslint:disable max-line-length */
ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class RootRelsFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('.rels', ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
class AppFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp());
    }
}
/**
 * @hidden
 */
class CoreFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('core.xml', ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
class WorkbookRelsFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        /** @type {?} */
        const hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
class ThemeFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
class WorksheetFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        /** @type {?} */
        const sheetData = [];
        /** @type {?} */
        const cols = [];
        /** @type {?} */
        let dimension;
        /** @type {?} */
        const dictionary = worksheetData.dataDictionary;
        /** @type {?} */
        let freezePane = '';
        /** @type {?} */
        let maxOutlineLevel = 0;
        if (worksheetData.isEmpty) {
            sheetData.push('<sheetData/>');
            dimension = 'A1';
        }
        else {
            sheetData.push('<sheetData>');
            /** @type {?} */
            const height = worksheetData.options.rowHeight;
            /** @type {?} */
            const rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData.push(`<row r="1"${rowHeight}>`);
            for (let i = 0; i < worksheetData.columnCount; i++) {
                /** @type {?} */
                const column = ExcelStrings.getExcelColumn(i) + 1;
                /** @type {?} */
                const value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData.push(`<c r="${column}" t="s"><v>${value}</v></c>`);
            }
            sheetData.push('</row>');
            for (let i = 1; i < worksheetData.rowCount; i++) {
                if (!worksheetData.isTreeGridData) {
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}>`);
                }
                else {
                    /** @type {?} */
                    const rowData = worksheetData.data[i - 1].originalRowData;
                    /** @type {?} */
                    const sCollapsed = (!rowData.expanded) ? '' : (rowData.expanded === true) ? '' : ` collapsed="1"`;
                    /** @type {?} */
                    const sHidden = (rowData.parent && this.hasCollapsedParent(rowData)) ? ` hidden="1"` : '';
                    /** @type {?} */
                    const rowOutlineLevel = rowData.level ? rowData.level : 0;
                    /** @type {?} */
                    const sOutlineLevel = rowOutlineLevel > 0 ? ` outlineLevel="${rowOutlineLevel}"` : '';
                    maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}${sOutlineLevel}${sCollapsed}${sHidden}>`);
                }
                for (let j = 0; j < worksheetData.columnCount; j++) {
                    /** @type {?} */
                    const cellData = WorksheetFile.getCellData(worksheetData, i, j);
                    sheetData.push(cellData);
                }
                sheetData.push('</row>');
            }
            sheetData.push('</sheetData>');
            dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols.push('<cols>');
            for (let i = 0; i < worksheetData.columnCount; i++) {
                /** @type {?} */
                const width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                /** @type {?} */
                const widthInTwips = worksheetData.options.columnWidth ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                cols.push(`<col min="${(i + 1)}" max="${(i + 1)}" width="${widthInTwips}" customWidth="1"/>`);
            }
            cols.push('</cols>');
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                /** @type {?} */
                const frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                /** @type {?} */
                const firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                freezePane = `<pane xSplit="${frozenColumnCount}" topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
            }
        }
        /** @type {?} */
        const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
        folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
    }
    /**
     * @private
     * @param {?} rowData
     * @return {?}
     */
    hasCollapsedParent(rowData) {
        /** @type {?} */
        let result = !rowData.parent.expanded;
        while (rowData.parent) {
            result = result || !rowData.parent.expanded;
            rowData = rowData.parent;
        }
        return result;
    }
    /* tslint:disable member-ordering */
    /**
     * @private
     * @param {?} worksheetData
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    static getCellData(worksheetData, row, column) {
        /** @type {?} */
        const dictionary = worksheetData.dataDictionary;
        /** @type {?} */
        const columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
        /** @type {?} */
        const columnHeader = worksheetData.keys[column];
        /** @type {?} */
        const rowData = worksheetData.data[row - 1].rowData;
        /** @type {?} */
        const cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];
        if (cellValue === undefined || cellValue === null) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else {
            /** @type {?} */
            const savedValue = dictionary.saveValue(cellValue, column, false);
            /** @type {?} */
            const isSavedAsString = savedValue !== -1;
            /** @type {?} */
            const value = isSavedAsString ? savedValue : cellValue;
            /** @type {?} */
            const type = isSavedAsString ? ` t="s"` : '';
            /** @type {?} */
            const format = isSavedAsString ? '' : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
    }
}
WorksheetFile.MIN_WIDTH = 8.34;
/**
 * @hidden
 */
class StyleFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
    }
}
/**
 * @hidden
 */
class WorkbookFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook());
    }
}
/**
 * @hidden
 */
class ContentTypesFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
class SharedStringsFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        /** @type {?} */
        const dict = worksheetData.dataDictionary;
        /** @type {?} */
        const sortedValues = dict.getKeys();
        /** @type {?} */
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
class TablesFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        /** @type {?} */
        const columnCount = worksheetData.columnCount;
        /** @type {?} */
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        /** @type {?} */
        const dimension = 'A1:' + lastColumn;
        /** @type {?} */
        const values = worksheetData.keys;
        /** @type {?} */
        let sortString = '';
        /** @type {?} */
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            /** @type {?} */
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            /** @type {?} */
            const sortingExpression = worksheetData.sort;
            /** @type {?} */
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            /** @type {?} */
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
class WorksheetRelsFile {
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    writeElement(folder, worksheetData) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class RootExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return '';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.ContentTypesFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [
            ExcelFolderTypes.RootRelsExcelFolder,
            ExcelFolderTypes.DocPropsExcelFolder,
            ExcelFolderTypes.XLExcelFolder
        ];
    }
}
/**
 * @hidden
 */
class RootRelsExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return '_rels';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.RootRelsFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [];
    }
}
/**
 * @hidden
 */
class DocPropsExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return 'docProps';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [
            ExcelFileTypes.AppFile,
            ExcelFileTypes.CoreFile
        ];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [];
    }
}
/**
 * @hidden
 */
class XLExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return 'xl';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        /** @type {?} */
        const retVal = [
            ExcelFileTypes.StyleFile,
            ExcelFileTypes.WorkbookFile
        ];
        if (!data.isEmpty) {
            retVal.push(ExcelFileTypes.SharedStringsFile);
        }
        return retVal;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        /** @type {?} */
        const retVal = [
            ExcelFolderTypes.XLRelsExcelFolder,
            ExcelFolderTypes.ThemeExcelFolder,
            ExcelFolderTypes.WorksheetsExcelFolder
        ];
        if (!data.isEmpty && data.options.exportAsTable) {
            retVal.push(ExcelFolderTypes.TablesExcelFolder);
        }
        return retVal;
    }
}
/**
 * @hidden
 */
class XLRelsExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return '_rels';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.WorkbookRelsFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [];
    }
}
/**
 * @hidden
 */
class ThemeExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return 'theme';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.ThemeFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [];
    }
}
/**
 * @hidden
 */
class WorksheetsExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return 'worksheets';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.WorksheetFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
    }
}
/**
 * @hidden
 */
class TablesExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return 'tables';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.TablesFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [];
    }
}
/**
 * @hidden
 */
class WorksheetsRelsExcelFolder {
    /**
     * @return {?}
     */
    get folderName() {
        return '_rels';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFiles(data) {
        return [ExcelFileTypes.WorksheetRelsFile];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    childFolders(data) {
        return [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class ExcelElementsFactory {
    /**
     * @param {?} type
     * @return {?}
     */
    static getExcelFolder(type) {
        switch (type) {
            case ExcelFolderTypes.RootExcelFolder:
                return new RootExcelFolder();
            case ExcelFolderTypes.RootRelsExcelFolder:
                return new RootRelsExcelFolder();
            case ExcelFolderTypes.DocPropsExcelFolder:
                return new DocPropsExcelFolder();
            case ExcelFolderTypes.XLExcelFolder:
                return new XLExcelFolder();
            case ExcelFolderTypes.XLRelsExcelFolder:
                return new XLRelsExcelFolder();
            case ExcelFolderTypes.ThemeExcelFolder:
                return new ThemeExcelFolder();
            case ExcelFolderTypes.WorksheetsExcelFolder:
                return new WorksheetsExcelFolder();
            case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                return new WorksheetsRelsExcelFolder();
            case ExcelFolderTypes.TablesExcelFolder:
                return new TablesExcelFolder();
            default:
                throw new Error('Unknown excel folder type!');
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static getExcelFile(type) {
        switch (type) {
            case ExcelFileTypes.RootRelsFile:
                return new RootRelsFile();
            case ExcelFileTypes.AppFile:
                return new AppFile();
            case ExcelFileTypes.CoreFile:
                return new CoreFile();
            case ExcelFileTypes.WorkbookRelsFile:
                return new WorkbookRelsFile();
            case ExcelFileTypes.ThemeFile:
                return new ThemeFile();
            case ExcelFileTypes.WorksheetFile:
                return new WorksheetFile();
            case ExcelFileTypes.StyleFile:
                return new StyleFile();
            case ExcelFileTypes.WorkbookFile:
                return new WorkbookFile();
            case ExcelFileTypes.ContentTypesFile:
                return new ContentTypesFile();
            case ExcelFileTypes.SharedStringsFile:
                return new SharedStringsFile();
            case ExcelFileTypes.WorksheetRelsFile:
                return new WorksheetRelsFile();
            case ExcelFileTypes.TablesFile:
                return new TablesFile();
            default:
                throw Error('Unknown excel file type!');
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class WorksheetDataDictionary {
    /**
     * @param {?} columnCount
     * @param {?} columnWidth
     */
    constructor(columnCount, columnWidth) {
        this.hasNonStringValues = false;
        this._dictionary = {};
        this._widthsDictionary = {};
        this._counter = 0;
        this.dirtyKeyCollections();
        this._calculateColumnWidth = !columnWidth;
        this._columnWidths = new Array(columnCount);
        this._columnTypeInfo = new Array(columnCount);
        if (!this._calculateColumnWidth) {
            this._columnWidths.fill(columnWidth);
        }
        this.stringsCount = 0;
    }
    /**
     * @return {?}
     */
    get columnWidths() {
        return this._columnWidths;
    }
    /**
     * @param {?} value
     * @param {?} column
     * @param {?} isHeader
     * @return {?}
     */
    saveValue(value, column, isHeader) {
        if (this._columnTypeInfo[column] === undefined && isHeader === false) {
            this._columnTypeInfo[column] = typeof value === 'string' ||
                typeof value === 'boolean' ||
                value instanceof Date;
        }
        /** @type {?} */
        let sanitizedValue = '';
        /** @type {?} */
        const isSavedAsString = this._columnTypeInfo[column] || isHeader;
        if (isSavedAsString) {
            sanitizedValue = this.sanitizeValue(value);
            if (this._dictionary[sanitizedValue] === undefined) {
                this._dictionary[sanitizedValue] = this._counter++;
                this.dirtyKeyCollections();
            }
            this.stringsCount++;
        }
        else {
            this.hasNonStringValues = true;
        }
        if (this._calculateColumnWidth) {
            /** @type {?} */
            const width = this.getTextWidth(value);
            /** @type {?} */
            const maxWidth = Math.max(this._columnWidths[column] || 0, width);
            this._columnWidths[column] = maxWidth;
        }
        return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getValue(value) {
        return this.getSanitizedValue(this.sanitizeValue(value));
    }
    /**
     * @param {?} sanitizedValue
     * @return {?}
     */
    getSanitizedValue(sanitizedValue) {
        return this._dictionary[sanitizedValue];
    }
    /**
     * @return {?}
     */
    getKeys() {
        if (!this._keysAreValid) {
            this._keys = Object.keys(this._dictionary);
            this._keysAreValid = true;
        }
        return this._keys;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    getTextWidth(value) {
        if (this._widthsDictionary[value] === undefined) {
            /** @type {?} */
            const context = this.getContext();
            /** @type {?} */
            const metrics = context.measureText(value);
            this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
        }
        return this._widthsDictionary[value];
    }
    /**
     * @private
     * @return {?}
     */
    getContext() {
        if (!this._context) {
            /** @type {?} */
            const canvas = document.createElement('canvas');
            this._context = canvas.getContext('2d');
            this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
        }
        return this._context;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    sanitizeValue(value) {
        if (ExportUtilities.hasValue(value) === false) {
            return '';
        }
        else {
            /** @type {?} */
            const stringValue = String(value);
            return stringValue.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    }
    /**
     * @private
     * @return {?}
     */
    dirtyKeyCollections() {
        this._keysAreValid = false;
    }
}
WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
WorksheetDataDictionary.TEXT_PADDING = 5;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class WorksheetData {
    /**
     * @param {?} _data
     * @param {?} options
     * @param {?} indexOfLastPinnedColumn
     * @param {?} sort
     * @param {?=} isTreeGridData
     */
    constructor(_data, options, indexOfLastPinnedColumn, sort, isTreeGridData = false) {
        this._data = _data;
        this.options = options;
        this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
        this.sort = sort;
        this.isTreeGridData = isTreeGridData;
        this.initializeData();
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    get columnCount() {
        return this._columnCount;
    }
    /**
     * @return {?}
     */
    get rowCount() {
        return this._rowCount;
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return !this.rowCount || !this._columnCount;
    }
    /**
     * @return {?}
     */
    get keys() {
        return this._keys;
    }
    /**
     * @return {?}
     */
    get isSpecialData() {
        return this._isSpecialData;
    }
    /**
     * @return {?}
     */
    get dataDictionary() {
        return this._dataDictionary;
    }
    /**
     * @private
     * @return {?}
     */
    initializeData() {
        if (!this._data || this._data.length === 0) {
            return;
        }
        /** @type {?} */
        const actualData = this._data.map((item) => item.rowData);
        this._keys = ExportUtilities.getKeysFromData(actualData);
        if (this._keys.length === 0) {
            return;
        }
        this._isSpecialData = ExportUtilities.isSpecialData(actualData);
        this._columnCount = this._keys.length;
        this._rowCount = this._data.length + 1;
        this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Excel Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
 *
 * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
 * (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private excelExportService: IgxExcelExporterService) {
 * }
 *
 * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
 * ```
 */
class IgxExcelExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxExcelExporterService
         */
        this.onExportEnded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @private
     * @param {?} folder
     * @param {?} zip
     * @param {?} worksheetData
     * @return {?}
     */
    static populateFolder(folder, zip, worksheetData) {
        for (const childFolder of folder.childFolders(worksheetData)) {
            /** @type {?} */
            const folderIntance = ExcelElementsFactory.getExcelFolder(childFolder);
            /** @type {?} */
            const zipFolder = zip.folder(folderIntance.folderName);
            IgxExcelExporterService.populateFolder(folderIntance, zipFolder, worksheetData);
        }
        for (const childFile of folder.childFiles(worksheetData)) {
            /** @type {?} */
            const fileInstance = ExcelElementsFactory.getExcelFile(childFile);
            fileInstance.writeElement(zip, worksheetData);
        }
    }
    /**
     * @protected
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    exportDataImplementation(data, options) {
        if (this._isTreeGrid) {
            /** @type {?} */
            let maxLevel = 0;
            data.forEach((r) => {
                maxLevel = Math.max(maxLevel, r.originalRowData.level);
            });
            if (maxLevel > 7) {
                throw Error('Can create an outline of up to eight levels!');
            }
        }
        /** @type {?} */
        const worksheetData = new WorksheetData(data, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
        this._xlsx = new jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6__();
        /** @type {?} */
        const rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
        IgxExcelExporterService.populateFolder(rootFolder, this._xlsx, worksheetData);
        this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then((result) => {
            this.saveFile(result, options.fileName);
            this.onExportEnded.emit({ xlsx: this._xlsx });
        });
    }
    /**
     * @private
     * @param {?} data
     * @param {?} fileName
     * @return {?}
     */
    saveFile(data, fileName) {
        /** @type {?} */
        const blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
        });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
IgxExcelExporterService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
IgxExcelExporterService.propDecorators = {
    onExportEnded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Objects of this class are used to configure the Excel exporting process.
 */
class IgxExcelExporterOptions extends IgxExporterOptionsBase {
    /**
     * @param {?} fileName
     */
    constructor(fileName) {
        super(fileName, '.xlsx');
        /**
         * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
         * this option will always be considered as set to true.
         * ```typescript
         * let ignorePinning = this.exportOptions.ignorePinning;
         * this.exportOptions.ignorePinning = true;
         * ```
         * \@memberof IgxExcelExporterOptions
         */
        this.ignorePinning = false;
        /**
         * Specifies whether the exported data should be formatted as Excel table. (True by default)
         * ```typescript
         * let exportAsTable = this.exportOptions.exportAsTable;
         * this.exportOptions.exportAsTable = false;
         * ```
         * \@memberof IgxExcelExporterOptions
         */
        this.exportAsTable = true;
    }
    /**
     * Gets the width of the columns in the exported excel file.
     * ```typescript
     * let width = this.exportOptions.columnWidth;
     * ```
     * \@memberof IgxExcelExporterOptions
     * @return {?}
     */
    get columnWidth() {
        return this._columnWidth;
    }
    /**
     * Sets the width of the columns in the exported excel file. If left unspecified or 0,
     * the width of the largest string in the column will be used.
     * ```typescript
     * this.exportOptions.columnWidth = 55;
     * ```
     * \@memberof IgxExcelExporterOptions
     * @param {?} value
     * @return {?}
     */
    set columnWidth(value) {
        if (value < 0) {
            throw Error('Invalid value for column width!');
        }
        this._columnWidth = value;
    }
    /**
     * Gets the height of the rows in the exported excel file.
     * ```typescript
     * let height = this.exportOptions.rowHeight;
     * ```
     * \@memberof IgxExcelExporterOptions
     * @return {?}
     */
    get rowHeight() {
        return this._rowHeight;
    }
    /**
     * Sets the height of the rows in the exported excel file. If left unspecified or 0,
     * the default height of the excel rows will be used.
     * ```typescript
     * this.exportOptions.rowHeight = 25;
     * ```
     * \@memberof IgxExcelExporterOptions
     * @param {?} value
     * @return {?}
     */
    set rowHeight(value) {
        if (value < 0) {
            throw Error('Invalid value for row height!');
        }
        this._rowHeight = value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const HorizontalAlignment = {
    Left: -1,
    Center: -0.5,
    Right: 0,
};
HorizontalAlignment[HorizontalAlignment.Left] = 'Left';
HorizontalAlignment[HorizontalAlignment.Center] = 'Center';
HorizontalAlignment[HorizontalAlignment.Right] = 'Right';
/** @enum {number} */
const VerticalAlignment = {
    Top: -1,
    Middle: -0.5,
    Bottom: 0,
};
VerticalAlignment[VerticalAlignment.Top] = 'Top';
VerticalAlignment[VerticalAlignment.Middle] = 'Middle';
VerticalAlignment[VerticalAlignment.Bottom] = 'Bottom';
class Point {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
/**
 * @hidden
 */
class Util {
    /**
     * @hidden
     * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
     * if no target is provided
     * @param {?} settings Overlay settings for which to calculate target rectangle
     * @return {?}
     */
    static getTargetRect(settings) {
        /** @type {?} */
        let targetRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        if (settings.target instanceof HTMLElement) {
            targetRect = ((/** @type {?} */ (settings.target))).getBoundingClientRect();
        }
        else if (settings.target instanceof Point) {
            /** @type {?} */
            const targetPoint = (/** @type {?} */ (settings.target));
            targetRect = {
                bottom: targetPoint.y,
                height: 0,
                left: targetPoint.x,
                right: targetPoint.x,
                top: targetPoint.y,
                width: 0
            };
        }
        return targetRect;
    }
    /**
     * @hidden \@internal
     * @param {?} document
     * @return {?}
     */
    static getViewportRect(document) {
        /** @type {?} */
        const width = document.documentElement.clientWidth;
        /** @type {?} */
        const height = document.documentElement.clientHeight;
        /** @type {?} */
        const scrollPosition = Util.getViewportScrollPosition(document);
        return {
            top: scrollPosition.y,
            left: scrollPosition.x,
            right: scrollPosition.x + width,
            bottom: scrollPosition.y + height,
            width: width,
            height: height,
        };
    }
    /**
     * @hidden \@internal
     * @param {?} document
     * @return {?}
     */
    static getViewportScrollPosition(document) {
        /** @type {?} */
        const documentElement = document.documentElement;
        /** @type {?} */
        const documentRect = documentElement.getBoundingClientRect();
        /** @type {?} */
        const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
        /** @type {?} */
        const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
        return new Point(horizontalScrollPosition, verticalScrollPosition);
    }
    /**
     * @hidden \@internal
     * @param {?} object
     * @return {?}
     */
    static cloneInstance(object) {
        /** @type {?} */
        const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        clonedObj.settings = cloneValue(clonedObj.settings);
        return clonedObj;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class GlobalPositionStrategy {
    /**
     * @param {?=} settings
     */
    constructor(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            verticalDirection: VerticalAlignment.Middle,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle,
            openAnimation: fadeIn,
            closeAnimation: fadeOut,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?=} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
        this.setPosition(contentElement, this.settings);
    }
    /**
     * @protected
     * @param {?} contentElement
     * @param {?} settings
     * @return {?}
     */
    setPosition(contentElement, settings) {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                contentElement.parentElement.style.justifyContent = 'flex-start';
                break;
            case HorizontalAlignment.Center:
                contentElement.parentElement.style.justifyContent = 'center';
                break;
            case HorizontalAlignment.Right:
                contentElement.parentElement.style.justifyContent = 'flex-end';
                break;
            default:
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                contentElement.parentElement.style.alignItems = 'flex-start';
                break;
            case VerticalAlignment.Middle:
                contentElement.parentElement.style.alignItems = 'center';
                break;
            case VerticalAlignment.Bottom:
                contentElement.parentElement.style.alignItems = 'flex-end';
                break;
            default:
                break;
        }
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    clone() {
        return Util.cloneInstance(this);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ScrollStrategy {
    /**
     * @param {?=} scrollContainer
     */
    constructor(scrollContainer) { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Empty scroll strategy. Does nothing.
 */
class NoOpScrollStrategy extends ScrollStrategy {
    /**
     * @param {?=} scrollContainer
     */
    constructor(scrollContainer) {
        super(scrollContainer);
    }
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    initialize(document, overlayService, id) { }
    /**
     * \@inheritdoc
     * @return {?}
     */
    attach() { }
    /**
     * \@inheritdoc
     * @return {?}
     */
    detach() { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @param {?} message
 * @return {?}
 */
function DeprecateMethod(message) {
    /** @type {?} */
    let isMessageShown = false;
    return function (target, key, descriptor) {
        if (descriptor && descriptor.value) {
            /** @type {?} */
            const originalMethod = descriptor.value;
            descriptor.value = function () {
                /** @type {?} */
                const targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(`${targetName}.${key}: ${message}`, isMessageShown);
                return originalMethod.call(this, arguments);
            };
            return descriptor;
        }
    };
}
/**
 * @hidden
 * @param {?} message
 * @return {?}
 */
function DeprecateProperty(message) {
    return function (target, key) {
        /** @type {?} */
        let isMessageShown = false;
        /** @type {?} */
        const messageToDisplay = `${target.constructor.name}.${key}: ${message}`;
        // if the target already has the property defined
        /** @type {?} */
        const originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
        if (originalDescriptor) {
            /** @type {?} */
            let getter;
            /** @type {?} */
            let setter;
            getter = originalDescriptor.get;
            setter = originalDescriptor.set;
            if (getter) {
                originalDescriptor.get = function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return getter.call(this);
                };
            }
            if (setter) {
                originalDescriptor.set = function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    setter.call(this, value);
                };
            }
            return originalDescriptor;
        }
        // the target doesn't contain a descriptor for that property, so create one
        // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
        /** @type {?} */
        const newKey = generateUniqueKey(target, key);
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            set: function (value) {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                this[newKey] = value;
            },
            get: function () {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                return this[newKey];
            }
        });
    };
}
/**
 * @hidden
 * @param {?} target
 * @param {?} key
 * @return {?}
 */
function generateUniqueKey(target, key) {
    /** @type {?} */
    let newKey = '_' + key;
    while (target.hasOwnProperty(newKey)) {
        newKey = '_' + newKey;
    }
    return newKey;
}
/**
 * @hidden
 * @param {?} message
 * @param {?} isMessageShown
 * @return {?}
 */
function showMessage(message, isMessageShown) {
    if (!isMessageShown && Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])()) {
        console.warn(message);
    }
    return true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let warningShown = false;
/**
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay_main.html)
 * The overlay service allows users to show components on overlay div above all other elements in the page.
 */
class IgxOverlayService {
    /**
     * @param {?} _factoryResolver
     * @param {?} _appRef
     * @param {?} _injector
     * @param {?} builder
     * @param {?} document
     * @param {?} _zone
     */
    constructor(_factoryResolver, _appRef, _injector, builder, document, _zone) {
        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._defaultSettings = {
            positionStrategy: new GlobalPositionStrategy(),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: true,
            closeOnOutsideClick: true
        };
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */
        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */
        this.onAnimation = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.documentClicked = (ev) => {
            //  if we get to modal overlay just return - we should not close anything under it
            //  if we get to non-modal overlay do the next:
            //   1. Check it has close on outside click. If not go on to next overlay;
            //   2. If true check if click is on the element. If it is on the element we have closed
            //  already all previous non-modal with close on outside click elements, so we return. If
            //  not close the overlay and check next
            for (let i = this._overlayInfos.length; i--;) {
                /** @type {?} */
                const info = this._overlayInfos[i];
                if (info.settings.modal) {
                    return;
                }
                if (info.settings.closeOnOutsideClick) {
                    /** @type {?} */
                    const target = (/** @type {?} */ (ev.target));
                    //  if the click is on the element do not close this overlay
                    if (!info.elementRef.nativeElement.contains(target)) {
                        // if we should exclude position target check if the click is over it. If so do not close overlay
                        /** @type {?} */
                        const positionTarget = (/** @type {?} */ (info.settings.positionStrategy.settings.target));
                        /** @type {?} */
                        let clickOnPositionTarget = false;
                        if (positionTarget) {
                            clickOnPositionTarget = positionTarget.contains(target);
                        }
                        if (!(info.settings.excludePositionTarget && clickOnPositionTarget)) {
                            //  if the click is outside click, but close animation has started do nothing
                            if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                                this._hide(info.id, ev);
                            }
                        }
                    }
                    else {
                        //  TODO: should we return here, or continue with next overlays
                        return;
                    }
                }
            }
        };
        /**
         * @hidden
         */
        this.repositionAll = () => {
            for (let i = this._overlayInfos.length; i--;) {
                this.reposition(this._overlayInfos[i].id);
            }
        };
        this._document = (/** @type {?} */ (this.document));
    }
    /**
     * @param {?} component
     * @param {?=} settings
     * @param {?=} moduleRef
     * @return {?}
     */
    attach(component, settings, moduleRef) {
        /** @type {?} */
        let info;
        info = this.getOverlayInfo(component, moduleRef);
        //  if there is no info most probably wrong type component was provided and we just go out
        if (!info) {
            return null;
        }
        info.id = (this._componentId++).toString();
        settings = Object.assign({}, this._defaultSettings, settings);
        info.settings = settings;
        this._overlayInfos.push(info);
        return info.id;
    }
    /**
     * @param {?} compOrId
     * @param {?=} settings
     * @return {?}
     */
    show(compOrId, settings) {
        /** @type {?} */
        let info;
        /** @type {?} */
        let id;
        if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);
            if (!info) {
                console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                return null;
            }
        }
        else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return;
            }
            info.id = id;
        }
        settings = Object.assign({}, this._defaultSettings, info.settings, settings);
        info.settings = settings;
        this._show(info);
        return id;
    }
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    hide(id) {
        this._hide(id);
    }
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     * @return {?}
     */
    hideAll() {
        // since overlays are removed on animation done, que all hides
        for (let i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
        }
    }
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    reposition(id) {
        /** @type {?} */
        const overlayInfo = this.getOverlayById(id);
        if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
        }
        /** @type {?} */
        const contentElement = overlayInfo.elementRef.nativeElement.parentElement;
        /** @type {?} */
        const contentElementRect = contentElement.getBoundingClientRect();
        overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
        }, this._document, false);
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    _show(info) {
        /** @type {?} */
        const eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
        this.onOpening.emit(eventArgs);
        if (eventArgs.cancel) {
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            return;
        }
        //  if there is no close animation player, or there is one but it is not started yet we are in clear
        //  opening. Otherwise, if there is close animation player playing animation now we should not setup
        //  overlay this is already done
        if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
            /** @type {?} */
            const elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = { width: elementRect.width, height: elementRect.height };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);
            if (info.componentRef) {
                info.componentRef.changeDetectorRef.detectChanges();
            }
            this.updateSize(info);
            if (this._overlayInfos.indexOf(info) === -1) {
                this._overlayInfos.push(info);
            }
            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
        }
        this.addOutsideClickListener(info);
        this.addResizeHandler(info.id);
        if (info.settings.modal) {
            this.setupModalWrapper(info);
        }
        if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
        }
        else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
        }
    }
    /**
     * @private
     * @param {?} id
     * @param {?=} event
     * @return {?}
     */
    _hide(id, event) {
        /** @type {?} */
        const info = this.getOverlayById(id);
        if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
        }
        /** @type {?} */
        const eventArgs = { id, componentRef: info.componentRef, cancel: false, event };
        this.onClosing.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        //  TODO: synchronize where these are added/attached and where removed/detached
        info.settings.scrollStrategy.detach();
        this.removeOutsideClickListener(info);
        this.removeResizeHandler(info.id);
        /** @type {?} */
        const child = info.elementRef.nativeElement;
        if (info.settings.modal) {
            /** @type {?} */
            const parent = (/** @type {?} */ (child.parentNode.parentNode));
            this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
            parent.classList.remove('igx-overlay__wrapper--modal');
            parent.classList.add('igx-overlay__wrapper');
        }
        if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info);
        }
        else {
            this.onCloseDone(info);
        }
    }
    /**
     * @private
     * @param {?} component
     * @param {?=} moduleRef
     * @return {?}
     */
    getOverlayInfo(component, moduleRef) {
        /** @type {?} */
        const info = { ngZone: this._zone };
        if (component instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]) {
            info.elementRef = (/** @type {?} */ (component));
        }
        else {
            /** @type {?} */
            let dynamicFactory;
            /** @type {?} */
            const factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
            try {
                dynamicFactory = factoryResolver.resolveComponentFactory(component);
            }
            catch (error) {
                console.error(error);
                return null;
            }
            /** @type {?} */
            const injector = moduleRef ? moduleRef.injector : this._injector;
            /** @type {?} */
            const dynamicComponent = dynamicFactory.create(injector);
            this._appRef.attachView(dynamicComponent.hostView);
            // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
            /** @type {?} */
            const element = dynamicComponent.location.nativeElement;
            info.elementRef = (/** @type {?} */ ({ nativeElement: element }));
            info.componentRef = dynamicComponent;
        }
        return info;
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    placeElementHook(element) {
        if (!element.parentElement) {
            return null;
        }
        /** @type {?} */
        const hook = this._document.createElement('div');
        element.parentElement.insertBefore(hook, element);
        return hook;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    moveElementToOverlay(info) {
        /** @type {?} */
        const wrapperElement = this.getWrapperElement();
        /** @type {?} */
        const contentElement = this.getContentElement(wrapperElement, info.settings.modal);
        this.getOverlayElement(info).appendChild(wrapperElement);
        /** @type {?} */
        const elementScrollTop = info.elementRef.nativeElement.scrollTop;
        contentElement.appendChild(info.elementRef.nativeElement);
        if (elementScrollTop) {
            info.elementRef.nativeElement.scrollTop = elementScrollTop;
        }
    }
    /**
     * @private
     * @return {?}
     */
    getWrapperElement() {
        /** @type {?} */
        const wrapper = this._document.createElement('div');
        wrapper.classList.add('igx-overlay__wrapper');
        return wrapper;
    }
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} modal
     * @return {?}
     */
    getContentElement(wrapperElement, modal) {
        /** @type {?} */
        const content = this._document.createElement('div');
        if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', (ev) => {
                ev.stopPropagation();
            });
        }
        else {
            content.classList.add('igx-overlay__content');
        }
        content.addEventListener('scroll', (ev) => {
            ev.stopPropagation();
        });
        //  hide element to eliminate flickering. Show the element exactly before animation starts
        content.style.visibility = 'hidden';
        wrapperElement.appendChild(content);
        return content;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    getOverlayElement(info) {
        if (info.settings.outlet) {
            return info.settings.outlet.nativeElement;
        }
        if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');
            this._overlayElement.classList.add('igx-overlay');
            this._document.body.appendChild(this._overlayElement);
        }
        return this._overlayElement;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    updateSize(info) {
        if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
        }
        // set content div width only if element to show has width
        if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    setupModalWrapper(info) {
        /** @type {?} */
        const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
        Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(wrapperElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])((ev) => ev.key === 'Escape' || ev.key === 'Esc'), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => this.hide(info.id));
        wrapperElement.classList.remove('igx-overlay__wrapper');
        this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
        wrapperElement.classList.add('igx-overlay__wrapper--modal');
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    onCloseDone(info) {
        this.cleanUp(info);
        this.onClosed.emit({ id: info.id, componentRef: info.componentRef });
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    cleanUp(info) {
        /** @type {?} */
        const child = info.elementRef.nativeElement;
        /** @type {?} */
        const outlet = this.getOverlayElement(info);
        if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
        }
        outlet.removeChild(child.parentNode.parentNode);
        if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);
            info.componentRef.destroy();
        }
        if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
        }
        /** @type {?} */
        const index = this._overlayInfos.indexOf(info);
        this._overlayInfos.splice(index, 1);
        // this._overlayElement.parentElement check just for tests that manually delete the element
        if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
            this._overlayElement.parentElement.removeChild(this._overlayElement);
            this._overlayElement = null;
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    playOpenAnimation(info) {
        if (!info.openAnimationPlayer) {
            /** @type {?} */
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            /** @type {?} */
            const innerRenderer = ((/** @type {?} */ (info.openAnimationPlayer)))._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(() => {
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                if (info.openAnimationPlayer) {
                    info.openAnimationPlayer.reset();
                    info.openAnimationPlayer = null;
                }
                if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                    info.closeAnimationPlayer.reset();
                }
            });
        }
        //  if there is opening animation already started do nothing
        if (info.openAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is closing animation already started start open animation from where close one has reached
        //  and remove close animation
        if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            /** @type {?} */
            const position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
        //  to eliminate flickering show the element just before animation start
        info.elementRef.nativeElement.parentElement.style.visibility = '';
        info.openAnimationPlayer.play();
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    playCloseAnimation(info) {
        if (!info.closeAnimationPlayer) {
            /** @type {?} */
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            /** @type {?} */
            const innerRenderer = ((/** @type {?} */ (info.closeAnimationPlayer)))._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(() => {
                if (info.closeAnimationPlayer) {
                    info.closeAnimationPlayer.reset();
                    info.closeAnimationPlayer = null;
                }
                if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                    info.openAnimationPlayer.reset();
                }
                this.onCloseDone(info);
            });
        }
        //  if there is closing animation already started do nothing
        if (info.closeAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is opening animation already started start close animation from where open one has reached
        //  and remove open animation
        if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            /** @type {?} */
            const position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
        info.closeAnimationPlayer.play();
    }
    //  TODO: check if applyAnimationParams will work with complex animations
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} animationOptions
     * @return {?}
     */
    applyAnimationParams(wrapperElement, animationOptions) {
        if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
        }
        if (animationOptions.type === 10 /* AnimateRef */) {
            animationOptions = ((/** @type {?} */ (animationOptions))).animation;
        }
        if (!animationOptions.options || !animationOptions.options.params) {
            return;
        }
        /** @type {?} */
        const params = (/** @type {?} */ (animationOptions.options.params));
        if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
        }
        if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
        }
    }
    /**
     * @hidden \@internal
     * @param {?} id
     * @return {?}
     */
    getOverlayById(id) {
        if (!id) {
            return null;
        }
        /** @type {?} */
        const info = this._overlayInfos.find(e => e.id === id);
        return info;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    addOutsideClickListener(info) {
        if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$))
                    .subscribe(() => this.hide(info.id));
            }
            else if (
            //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal).length -
                this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal &&
                    x.closeAnimationPlayer &&
                    x.closeAnimationPlayer.hasStarted()).length === 1) {
                this._document.addEventListener('click', this.documentClicked, true);
            }
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    removeOutsideClickListener(info) {
        if (info.settings.modal === false) {
            /** @type {?} */
            let shouldRemoveClickEventListener = true;
            this._overlayInfos.forEach(o => {
                if (o.settings.modal === false && o.id !== info.id) {
                    shouldRemoveClickEventListener = false;
                }
            });
            if (shouldRemoveClickEventListener) {
                this._document.removeEventListener('click', this.documentClicked, true);
            }
        }
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    addResizeHandler(id) {
        /** @type {?} */
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
        }
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    removeResizeHandler(id) {
        /** @type {?} */
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxOverlayService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
IgxOverlayService.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ApplicationRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] },
    { type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
/** @nocollapse */ IgxOverlayService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ApplicationRef"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"])); }, token: IgxOverlayService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class ContainerPositionStrategy extends GlobalPositionStrategy {
    /**
     * @param {?=} settings
     */
    constructor(settings) {
        super(settings);
    }
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?=} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
        this.setPosition(contentElement, this.settings);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
class ConnectedPositioningStrategy {
    /**
     * @param {?=} settings
     */
    constructor(settings) {
        this._defaultSettings = {
            // default Point(0, 0) in getPointFromPositionsSettings
            target: null,
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: scaleInVerTop,
            closeAnimation: scaleOutVerTop,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        /** @type {?} */
        const targetRect = Util.getTargetRect(this.settings);
        /** @type {?} */
        const contentElementRect = contentElement.getBoundingClientRect();
        this.setStyle(contentElement, targetRect, contentElementRect);
    }
    /**
     * \@inheritdoc
     * Creates clone of this position strategy
     * @return {?} clone of this position strategy
     */
    clone() {
        return Util.cloneInstance(this);
    }
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @protected
     * @param {?} element Element to position
     * @param {?} targetRect Bounding rectangle of strategy target
     * @param {?} elementRect Bounding rectangle of the element
     * @return {?}
     */
    setStyle(element, targetRect, elementRect) {
        /** @type {?} */
        const startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint,
        };
        /** @type {?} */
        const wrapperRect = element.parentElement.getBoundingClientRect();
        //  clean up styles - if auto position strategy is chosen we may pass here several times
        element.style.right = '';
        element.style.left = '';
        element.style.bottom = '';
        element.style.top = '';
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                element.style.right = `${Math.round(wrapperRect.right - startPoint.x)}px`;
                break;
            case HorizontalAlignment.Center:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2)}px`;
                break;
            case HorizontalAlignment.Right:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left)}px`;
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                element.style.bottom = `${Math.round(wrapperRect.bottom - startPoint.y)}px`;
                break;
            case VerticalAlignment.Middle:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2)}px`;
                break;
            case VerticalAlignment.Bottom:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top)}px`;
                break;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class BaseFitPositionStrategy extends ConnectedPositioningStrategy {
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        /** @type {?} */
        const targetRect = Util.getTargetRect(this.settings);
        /** @type {?} */
        const contentElementRect = contentElement.getBoundingClientRect();
        if (initialCall) {
            /** @type {?} */
            const connectedFit = {};
            connectedFit.targetRect = targetRect;
            connectedFit.contentElementRect = contentElementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (!connectedFit.fitHorizontal || !connectedFit.fitVertical) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, targetRect, contentElementRect);
    }
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @protected
     * @param {?} connectedFit connectedFit to update
     * @return {?}
     */
    updateViewPortFit(connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal =
            connectedFit.viewPortRect.left < connectedFit.left && connectedFit.right < connectedFit.viewPortRect.right;
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical =
            connectedFit.viewPortRect.top < connectedFit.top && connectedFit.bottom < connectedFit.viewPortRect.bottom;
    }
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    calculateLeft(targetRect, elementRect, startPoint, direction) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction;
    }
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    calculateTop(targetRect, elementRect, startPoint, direction) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
class AutoPositionStrategy extends BaseFitPositionStrategy {
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    fitInViewport(element, connectedFit) {
        /** @type {?} */
        const transformString = [];
        if (!connectedFit.fitHorizontal) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                /** @type {?} */
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (!connectedFit.fitVertical) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                /** @type {?} */
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        /** @type {?} */
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        /** @type {?} */
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        /** @type {?} */
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return connectedFit.viewPortRect.left < leftBorder && rightBorder < connectedFit.viewPortRect.right;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        /** @type {?} */
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        /** @type {?} */
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        /** @type {?} */
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return connectedFit.viewPortRect.top < topBorder && bottomBorder < connectedFit.viewPortRect.bottom;
    }
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        /** @type {?} */
        const leftExtend = connectedFit.left;
        /** @type {?} */
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        /** @type {?} */
        const topExtend = connectedFit.top;
        /** @type {?} */
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
class ElasticPositionStrategy extends BaseFitPositionStrategy {
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    fitInViewport(element, connectedFit) {
        element.classList.add('igx-overlay__content--elastic');
        /** @type {?} */
        const transformString = [];
        if (!connectedFit.fitHorizontal) {
            /** @type {?} */
            const maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            /** @type {?} */
            const leftExtend = Math.max(0, connectedFit.viewPortRect.left - connectedFit.left);
            /** @type {?} */
            const rightExtend = Math.max(0, connectedFit.right - connectedFit.viewPortRect.right);
            /** @type {?} */
            const reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = `${connectedFit.contentElementRect.width - reduction}px`;
            //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned
            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
                //  the amount of translation depends on whether element goes off the screen to the left,
                //  to the right or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between left and right extend
                //  taken from the reduction
                /** @type {?} */
                const translation = leftExtend * reduction / (leftExtend + rightExtend);
                if (translation > 0) {
                    transformString.push(`translateX(${translation}px)`);
                }
            }
        }
        if (!connectedFit.fitVertical) {
            /** @type {?} */
            const maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            /** @type {?} */
            const topExtend = Math.max(0, connectedFit.viewPortRect.top - connectedFit.top);
            /** @type {?} */
            const bottomExtend = Math.max(0, connectedFit.bottom - connectedFit.viewPortRect.bottom);
            /** @type {?} */
            const reduction = Math.min(maxReduction, topExtend + bottomExtend);
            element.style.height = `${connectedFit.contentElementRect.height - reduction}px`;
            //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned
            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
                //  the amount of translation depends on whether element goes off the screen to the top,
                //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between top and bottom extend
                //  taken from the reduction
                /** @type {?} */
                const translation = topExtend * reduction / (topExtend + bottomExtend);
                if (translation > 0) {
                    transformString.push(`translateY(${translation}px)`);
                }
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * On scroll reposition the overlay content.
 */
class AbsoluteScrollStrategy extends ScrollStrategy {
    /**
     * @param {?=} scrollContainer
     */
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = () => {
            this._overlayService.repositionAll();
        };
        this._scrollContainer = scrollContainer;
    }
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._zone = overlayService.getOverlayById(id).ngZone;
        this._initialized = true;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    attach() {
        if (this._zone) {
            this._zone.runOutsideAngular(() => {
                this.addScrollEventListener();
            });
        }
        else {
            this.addScrollEventListener();
        }
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    detach() {
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll, true);
        }
        this._initialized = false;
    }
    /**
     * @private
     * @return {?}
     */
    addScrollEventListener() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.addEventListener('scroll', this.onScroll, true);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Prevents scrolling while the overlay content is shown.
 */
class BlockScrollStrategy extends ScrollStrategy {
    /**
     * @param {?=} scrollContainer
     */
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            ev.preventDefault();
            if (!this._sourceElement || this._sourceElement !== ev.target) {
                this._sourceElement = (/** @type {?} */ (ev.target));
                this._initialScrollTop = this._sourceElement.scrollTop;
                this._initialScrollLeft = this._sourceElement.scrollLeft;
            }
            this._sourceElement.scrollTop = this._initialScrollTop;
            this._sourceElement.scrollLeft = this._initialScrollLeft;
        };
    }
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._document = document;
        this._initialized = true;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    attach() {
        this._document.addEventListener('scroll', this.onScroll, true);
        this._document.addEventListener('wheel', this.onWheel, true);
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    detach() {
        this._document.removeEventListener('scroll', this.onScroll, true);
        this._document.removeEventListener('wheel', this.onWheel, true);
        this._sourceElement = null;
        this._initialScrollTop = 0;
        this._initialScrollLeft = 0;
        this._initialized = false;
    }
    /**
     * @private
     * @param {?} ev
     * @return {?}
     */
    onWheel(ev) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
 */
class CloseScrollStrategy extends ScrollStrategy {
    /**
     * @param {?=} scrollContainer
     */
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            if (!this._sourceElement) {
                return;
            }
            this.cumulativeScrollTop += this._sourceElement.scrollTop;
            this.cumulativeScrollLeft += this._sourceElement.scrollLeft;
            if (Math.abs(this.cumulativeScrollTop - this.initialScrollTop) > this._threshold ||
                Math.abs(this.cumulativeScrollLeft - this.initialScrollLeft) > this._threshold) {
                this._document.removeEventListener('scroll', this.onScroll, true);
                this._overlayService.hide(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
        this._threshold = 10;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
    }
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._initialized = true;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    attach() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll);
            this._sourceElement = this._scrollContainer;
        }
        else {
            this._document.addEventListener('scroll', this.onScroll);
            if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                this._sourceElement = (/** @type {?} */ (document.documentElement));
            }
            else if (document.body.scrollHeight > document.body.clientHeight) {
                this._sourceElement = (/** @type {?} */ (document.body));
            }
        }
        if (!this._sourceElement) {
            return;
        }
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = this._sourceElement.scrollTop;
        this.initialScrollLeft = this._sourceElement.scrollLeft;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    detach() {
        // TODO: check why event listener removes only on first call and remains on each next!!!
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll);
        }
        this._sourceElement = null;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = 0;
        this.initialScrollLeft = 0;
        this._initialized = false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, S
 */
class IgxBaseTransactionService {
    constructor() {
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        /**
         * \@inheritdoc
         */
        this.onStateUpdate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get canRedo() {
        return false;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get canUndo() {
        return false;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get enabled() {
        return this._isPending;
    }
    /**
     * \@inheritdoc
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    add(transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    }
    /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    getTransactionLog(id) { return []; }
    /**
     * \@inheritdoc
     * @return {?}
     */
    undo() { }
    /**
     * \@inheritdoc
     * @return {?}
     */
    redo() { }
    /**
     * \@inheritdoc
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedChanges(mergeChanges) {
        /** @type {?} */
        const result = [];
        this._pendingStates.forEach((state, key) => {
            /** @type {?} */
            const value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;
            result.push((/** @type {?} */ ({ id: key, newValue: value, type: state.type })));
        });
        return result;
    }
    /**
     * \@inheritdoc
     * @param {?} id
     * @return {?}
     */
    getState(id) {
        return this._pendingStates.get(id);
    }
    /**
     * \@inheritdoc
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedValue(id, mergeChanges) {
        /** @type {?} */
        const state = this._pendingStates.get(id);
        if (!state) {
            return null;
        }
        if (mergeChanges) {
            return this.updateValue(state);
        }
        return state.value;
    }
    /**
     * \@inheritdoc
     * @param {?} data
     * @param {?=} id
     * @return {?}
     */
    commit(data, id) { }
    /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    clear(id) {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    startPending() {
        this._isPending = true;
    }
    /**
     * \@inheritdoc
     * @param {?} commit
     * @return {?}
     */
    endPending(commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @protected
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    updateState(states, transaction, recordRef) {
        /** @type {?} */
        let state = states.get(transaction.id);
        if (state) {
            if (isObject(state.value)) {
                mergeObjects(state.value, transaction.newValue);
            }
            else {
                state.value = transaction.newValue;
            }
        }
        else {
            state = (/** @type {?} */ ({ value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type }));
            states.set(transaction.id, state);
        }
    }
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @protected
     * @param {?} state State to update value for
     * @return {?} updated value including all the changes in provided state
     */
    updateValue(state) {
        return this.mergeValues(state.recordRef, state.value);
    }
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @protected
     * @template U
     * @param {?} first Value to merge into
     * @param {?} second Value to merge
     * @return {?}
     */
    mergeValues(first, second) {
        /** @type {?} */
        let result;
        if (isObject(first) || isObject(second)) {
            result = mergeObjects(mergeObjects({}, first), second);
        }
        else {
            result = second ? second : first;
        }
        return result;
    }
}
IgxBaseTransactionService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, S
 */
class IgxTransactionService extends IgxBaseTransactionService {
    constructor() {
        super(...arguments);
        this._transactions = [];
        this._redoStack = [];
        this._undoStack = [];
        this._states = new Map();
        /**
         * \@inheritdoc
         */
        this.onStateUpdate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get canUndo() {
        return this._undoStack.length > 0;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get canRedo() {
        return this._redoStack.length > 0;
    }
    /**
     * \@inheritdoc
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    add(transaction, recordRef) {
        /** @type {?} */
        const states = this._isPending ? this._pendingStates : this._states;
        this.verifyAddedTransaction(states, transaction, recordRef);
        this.addTransaction(transaction, states, recordRef);
    }
    /**
     * @protected
     * @param {?} transaction
     * @param {?} states
     * @param {?=} recordRef
     * @return {?}
     */
    addTransaction(transaction, states, recordRef) {
        this.updateState(states, transaction, recordRef);
        /** @type {?} */
        const transactions = this._isPending ? this._pendingTransactions : this._transactions;
        transactions.push(transaction);
        if (!this._isPending) {
            this._undoStack.push([{ transaction, recordRef }]);
            this._redoStack = [];
            this.onStateUpdate.emit();
        }
    }
    /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    getTransactionLog(id) {
        if (id !== undefined) {
            return this._transactions.filter(t => t.id === id);
        }
        return [...this._transactions];
    }
    /**
     * \@inheritdoc
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedChanges(mergeChanges) {
        /** @type {?} */
        const result = [];
        this._states.forEach((state, key) => {
            /** @type {?} */
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : state.value;
            result.push((/** @type {?} */ ({ id: key, newValue: value, type: state.type })));
        });
        return result;
    }
    /**
     * \@inheritdoc
     * @param {?} id
     * @param {?=} pending
     * @return {?}
     */
    getState(id, pending = false) {
        return pending ? this._pendingStates.get(id) : this._states.get(id);
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get enabled() {
        return true;
    }
    /**
     * \@inheritdoc
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedValue(id, mergeChanges) {
        /** @type {?} */
        const state = this._states.get(id);
        /** @type {?} */
        const pendingState = super.getState(id);
        //  if there is no state and there is no pending state return null
        if (!state && !pendingState) {
            return null;
        }
        /** @type {?} */
        const pendingChange = super.getAggregatedValue(id, false);
        /** @type {?} */
        const change = state && state.value;
        /** @type {?} */
        let aggregatedValue = this.mergeValues(change, pendingChange);
        if (mergeChanges) {
            /** @type {?} */
            const originalValue = state ? state.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
        }
        return aggregatedValue;
    }
    /**
     * \@inheritdoc
     * @param {?} commit
     * @return {?}
     */
    endPending(commit) {
        this._isPending = false;
        if (commit) {
            /** @type {?} */
            const actions = [];
            // don't use addTransaction due to custom undo handling
            for (const transaction of this._pendingTransactions) {
                /** @type {?} */
                const pendingState = this._pendingStates.get(transaction.id);
                this._transactions.push(transaction);
                this.updateState(this._states, transaction, pendingState.recordRef);
                actions.push({ transaction, recordRef: pendingState.recordRef });
            }
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit();
        }
        super.endPending(commit);
    }
    /**
     * \@inheritdoc
     * @param {?} data
     * @param {?=} id
     * @return {?}
     */
    commit(data, id) {
        if (id !== undefined) {
            /** @type {?} */
            const state = this.getState(id);
            if (state) {
                this.updateRecord(data, state);
            }
        }
        else {
            this._states.forEach((s) => {
                this.updateRecord(data, s);
            });
        }
        this.clear(id);
    }
    /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    clear(id) {
        if (id !== undefined) {
            this._transactions = this._transactions.filter(t => t.id !== id);
            this._states.delete(id);
            //  Undo stack is an array of actions. Each action is array of transaction like objects
            //  We are going trough all the actions. For each action we are filtering out transactions
            //  with provided id. Finally if any action ends up as empty array we are removing it from
            //  undo stack
            this._undoStack = this._undoStack.map(a => a.filter(t => t.transaction.id !== id)).filter(a => a.length > 0);
        }
        else {
            this._transactions = [];
            this._states.clear();
            this._undoStack = [];
        }
        this._redoStack = [];
        this.onStateUpdate.emit();
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    undo() {
        if (this._undoStack.length <= 0) {
            return;
        }
        /** @type {?} */
        const lastActions = this._undoStack.pop();
        this._transactions.splice(this._transactions.length - lastActions.length);
        this._redoStack.push(lastActions);
        this._states.clear();
        for (const currentActions of this._undoStack) {
            for (const transaction of currentActions) {
                this.updateState(this._states, transaction.transaction, transaction.recordRef);
            }
        }
        this.onStateUpdate.emit();
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    redo() {
        if (this._redoStack.length > 0) {
            /** @type {?} */
            let actions;
            actions = this._redoStack.pop();
            for (const action of actions) {
                this.updateState(this._states, action.transaction, action.recordRef);
                this._transactions.push(action.transaction);
            }
            this._undoStack.push(actions);
            this.onStateUpdate.emit();
        }
    }
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @protected
     * @param {?} states
     * @param {?} transaction Transaction to be verified
     * @param {?=} recordRef
     * @return {?}
     */
    verifyAddedTransaction(states, transaction, recordRef) {
        /** @type {?} */
        const state = states.get(transaction.id);
        switch (transaction.type) {
            case TransactionType.ADD:
                if (state) {
                    //  cannot add same item twice
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already added.`);
                }
                break;
            case TransactionType.DELETE:
            case TransactionType.UPDATE:
                if (state && state.type === TransactionType.DELETE) {
                    //  cannot delete or update deleted items
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already deleted.`);
                }
                if (!state && !recordRef && !this._isPending) {
                    //  cannot initially add transaction or delete item with no recordRef
                    throw new Error(`Cannot add this transaction. This is first transaction of type ${transaction.type} ` +
                        `for id ${transaction.id}. For first transaction of this type recordRef is mandatory.`);
                }
                break;
        }
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @protected
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    updateState(states, transaction, recordRef) {
        /** @type {?} */
        let state = states.get(transaction.id);
        //  if TransactionType is ADD simply add transaction to states;
        //  if TransactionType is DELETE:
        //    - if there is state with this id of type ADD remove it from the states;
        //    - if there is state with this id of type UPDATE change its type to DELETE;
        //    - if there is no state with this id add transaction to states;
        //  if TransactionType is UPDATE:
        //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
        //    - if there is state with this id of type UPDATE merge new value into state new value
        //    - if there is state with this id and state type is DELETE change its type to UPDATE
        //    - if there is no state with this id add transaction to states;
        if (state) {
            switch (transaction.type) {
                case TransactionType.DELETE:
                    if (state.type === TransactionType.ADD) {
                        states.delete(transaction.id);
                    }
                    else if (state.type === TransactionType.UPDATE) {
                        state.value = transaction.newValue;
                        state.type = TransactionType.DELETE;
                    }
                    break;
                case TransactionType.UPDATE:
                    if (isObject(state.value)) {
                        if (state.type === TransactionType.ADD) {
                            state.value = this.mergeValues(state.value, transaction.newValue);
                        }
                        if (state.type === TransactionType.UPDATE) {
                            mergeObjects(state.value, transaction.newValue);
                        }
                    }
                    else {
                        state.value = transaction.newValue;
                    }
            }
        }
        else {
            state = (/** @type {?} */ ({ value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type }));
            states.set(transaction.id, state);
        }
        //  should not clean pending state. This will happen automatically on endPending call
        if (!this._isPending) {
            this.cleanState(transaction.id, states);
        }
    }
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @protected
     * @param {?} id
     * @param {?} states
     * @return {?}
     */
    cleanState(id, states) {
        /** @type {?} */
        const state = states.get(id);
        //  do nothing if
        //  there is no state, or
        //  there is no state value (e.g. DELETED transaction), or
        //  there is no recordRef (e.g. ADDED transaction)
        if (state && state.value && state.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state.recordRef)) {
                for (const key of Object.keys(state.value)) {
                    if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                        delete state.value[key];
                    }
                }
                //  if state's value is empty remove the state from the states, only if state is not DELETE type
                if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {
                    states.delete(id);
                }
            }
            else {
                if (state.recordRef === state.value) {
                    states.delete(id);
                }
            }
        }
    }
    /**
     * Updates state related record in the provided data
     * @protected
     * @param {?} data Data source to update
     * @param {?} state State to update data from
     * @return {?}
     */
    updateRecord(data, state) {
        /** @type {?} */
        const index = data.findIndex(i => JSON.stringify(i) === JSON.stringify(state.recordRef || {}));
        switch (state.type) {
            case TransactionType.ADD:
                data.push(state.value);
                break;
            case TransactionType.DELETE:
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
                break;
            case TransactionType.UPDATE:
                if (0 <= index && index < data.length) {
                    data[index] = this.updateValue(state);
                }
                break;
        }
    }
}
IgxTransactionService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@experimental \@hidden
 * @template T, S
 */
class IgxHierarchicalTransactionService extends IgxTransactionService {
    /**
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedChanges(mergeChanges) {
        /** @type {?} */
        const result = [];
        this._states.forEach((state, key) => {
            /** @type {?} */
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : cloneValue(state.value);
            this.clearArraysFromObject(value);
            result.push((/** @type {?} */ ({ id: key, path: state.path, newValue: value, type: state.type })));
        });
        return result;
    }
    /**
     * @protected
     * @param {?} states
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    updateState(states, transaction, recordRef) {
        super.updateState(states, transaction, recordRef);
        //  if transaction has no path, e.g. flat data source, get out
        if (!transaction.path) {
            return;
        }
        /** @type {?} */
        const currentState = states.get(transaction.id);
        if (currentState) {
            currentState.path = transaction.path;
        }
        //  if transaction has path, Hierarchical data source, and it is DELETE
        //  type transaction for all child rows remove ADD states and update
        //  transaction type and value of UPDATE states
        if (transaction.type === TransactionType.DELETE) {
            states.forEach((v, k) => {
                if (v.path && v.path.indexOf(transaction.id) !== -1) {
                    switch (v.type) {
                        case TransactionType.ADD:
                            states.delete(k);
                            break;
                        case TransactionType.UPDATE:
                            states.get(k).type = TransactionType.DELETE;
                            states.get(k).value = null;
                    }
                }
            });
        }
    }
    /**
     * Applies all transactions over the provided data
     * @param {?} data Data source to update
     * @param {?=} primaryKey Primary key of the hierarchical data
     * @param {?=} childDataKey Kye of child data collection
     * @param {?=} id Optional record id to commit transactions for
     * @return {?}
     */
    commit(data, primaryKey, childDataKey, id) {
        if (childDataKey !== undefined) {
            /** @type {?} */
            let transactions = this.getAggregatedChanges(true);
            if (id !== undefined) {
                transactions = transactions.filter(t => t.id === id);
            }
            DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, true);
        }
        else {
            super.commit(data, id);
        }
        this.clear(id);
    }
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    clearArraysFromObject(obj) {
        if (obj) {
            for (const prop of Object.keys(obj)) {
                if (Array.isArray(obj[prop])) {
                    delete obj[prop];
                }
            }
        }
    }
}
IgxHierarchicalTransactionService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxToggleDirective {
    /**
     * @hidden
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} overlayService
     * @param {?} navigationService
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._overlaySubFilter = [
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(x => x.id === this._overlayId),
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._collapsed = true;
        this.overlayClosed = () => {
            this._collapsed = true;
            this.cdr.detectChanges();
            delete this._overlayId;
            this.unsubscribe();
            this.onClosed.emit();
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     * @return {?}
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        /** @type {?} */
        const info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        /** @type {?} */
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        /** @type {?} */
        const openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.overlayService.show(this._overlayId, overlaySettings);
        this.unsubscribe();
        this._overlayOpenedSub = this.overlayService.onOpened.pipe(...this._overlaySubFilter).subscribe(() => {
            this.onOpened.emit();
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            /** @type {?} */
            const eventArgs = { cancel: false, event: e.event };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    close() {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        /** @type {?} */
        const info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get isClosing() {
        /** @type {?} */
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer : false;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @private
     * @return {?}
     */
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
    }
    /**
     * @private
     * @param {?} subscription
     * @return {?}
     */
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
}
IgxToggleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'toggle',
                selector: '[igxToggle]'
            },] }
];
/** @nocollapse */
IgxToggleDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxToggleDirective.propDecorators = {
    onOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpening: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hiddenClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-toggle--hidden',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-hidden',] }],
    defaultClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-toggle',] }]
};
class IgxToggleActionDirective {
    /**
     * @param {?} element
     * @param {?} navigationService
     */
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     * @param {?} target
     * @return {?}
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludePositionTarget: true
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        /** @type {?} */
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * Updates provided overlay settings
     * @protected
     * @param {?} settings settings to update
     * @return {?} returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            /** @type {?} */
            const positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
}
IgxToggleActionDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            },] }
];
/** @nocollapse */
IgxToggleActionDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxToggleActionDirective.propDecorators = {
    overlaySettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    outlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxToggleOutlet',] }],
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxToggleAction',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }]
};
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
class IgxOverlayOutletDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
    }
    /**
     * @hidden
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
}
IgxOverlayOutletDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            },] }
];
/** @nocollapse */
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
/**
 * @hidden
 */
class IgxToggleModule {
}
IgxToggleModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const Navigate = {
    Up: -1,
    Down: 1,
};
Navigate[Navigate.Up] = 'Up';
Navigate[Navigate.Down] = 'Down';
/** @enum {string} */
const DropDownActionKey = {
    ESCAPE: 'escape',
    ENTER: 'enter',
    SPACE: 'space',
};
/** @type {?} */
const IGX_DROPDOWN_BASE = 'IgxDropDownBaseToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxSelectionAPIService {
    constructor() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    get(componentID) {
        return this.selection.get(componentID);
    }
    /**
     * Set new component selection.
     * @param {?} componentID ID of the component.
     * @param {?} newSelection The new component selection to be set.
     * @return {?}
     */
    set(componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    }
    /**
     * Clears selection for component.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    clear(componentID) {
        this.selection.set(componentID, this.get_empty());
    }
    /**
     * Get current component selection length.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    size(componentID) {
        /** @type {?} */
        const sel = this.get(componentID);
        return sel ? sel.size : 0;
    }
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @return {?} Selection after the new item is added.
     */
    add_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemIDs Array of IDs of the items to add to component selection.
     * @param {?=} clearSelection If true it will clear previous selection.
     *
     * @return {?} Selection after the new items are added.
     */
    add_items(componentID, itemIDs, clearSelection) {
        /** @type {?} */
        let selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach((item) => selection = this.add_item(componentID, item, selection));
        return selection;
    }
    /**
     * Add item to the current component selection.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    select_item(componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    }
    /**
     * Add items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection If true it will clear previous selection.
     * @return {?}
     */
    select_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    }
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @return {?} Selection after the item is removed.
     */
    delete_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemIDs
     * @return {?} Selection after the items are removed.
     */
    delete_items(componentID, itemIDs) {
        /** @type {?} */
        let selection;
        itemIDs.forEach((deselectedItem) => selection = this.delete_item(componentID, deselectedItem, selection));
        return selection;
    }
    /**
     * Remove item from the current component selection.
     * @param {?} componentID ID of the component, which we remove item from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    deselect_item(componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    }
    /**
     * Remove items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection
     * @return {?}
     */
    deselect_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    }
    /**
     * Check if the item is selected in the component selection.
     * @param {?} componentID ID of the component.
     * @param {?} itemID ID of the item to search.
     *
     * @return {?} If item is selected.
     */
    is_item_selected(componentID, itemID) {
        /** @type {?} */
        const sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    }
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param {?} componentID ID of the component.
     *
     * @return {?} First element in the set.
     */
    first_item(componentID) {
        /** @type {?} */
        const sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    }
    /**
     * Returns whether all items are selected.
     * @param {?} componentID ID of the component.
     * @param {?} dataCount
     * @return {?} If all items are selected.
     */
    are_all_selected(componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    }
    /**
     * Returns whether any of the items is selected.
     * @param {?} componentID ID of the component.
     * @return {?} If there is any item selected.
     */
    are_none_selected(componentID) {
        return this.size(componentID) === 0;
    }
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param {?} data Entire data array.
     * @param {?=} primaryKey Data primary key.
     *
     * @return {?} Array of identifiers, either primary key values or the entire data array.
     */
    get_all_ids(data, primaryKey) {
        // If primaryKey is 0, this should still map to the property
        return primaryKey !== undefined && primaryKey !== null ? data.map((x) => x[primaryKey]) : data;
    }
    /**
     * Returns empty selection collection.
     * @return {?} empty set.
     */
    get_empty() {
        return new Set();
    }
}
IgxSelectionAPIService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ IgxSelectionAPIService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID = 0;
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
class IgxDropDownGroupComponent {
    constructor() {
        this._id = NEXT_ID++;
        /**
         * @hidden \@internal
         */
        this.role = 'group';
        /**
         * @hidden \@internal
         */
        this.groupClass = true;
        /**
         * Sets/gets if the item group is disabled
         *
         * ```typescript
         * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
         * // get
         * ...
         * const groupState: boolean = myDropDownGroup.disabled;
         * ...
         * //set
         * ...
         * myDropDownGroup,disabled = false;
         * ...
         * ```
         *
         * ```html
         * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
         *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
         *         {{ item.text }}
         *     </igx-drop-down-item>
         * </igx-drop-down-item-group>
         * ```
         *
         * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
         */
        this.disabled = false;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get labelId() {
        return `igx-item-group-label-${this._id}`;
    }
    /**
     * @return {?}
     */
    get labelledBy() {
        return this.labelId;
    }
}
IgxDropDownGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-drop-down-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-drop-down-item"></ng-content>
    `
            }] }
];
IgxDropDownGroupComponent.propDecorators = {
    labelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.aria-labelledby`,] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    groupClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__group',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.aria-disabled`,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__group--disabled',] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$1 = 0;
/** @type {?} */
let warningShown$1 = false;
/**
 * An abstract class defining a drop-down item:
 * With properties / styles for selection, highlight, height
 * Bindable property for passing data (`value: any`)
 * Parent component (has to be used under a parent with type `IDropDownBase`)
 * Method for handling click on Host()
 * @abstract
 */
class IgxDropDownItemBase {
    /**
     * @param {?} dropDown
     * @param {?} elementRef
     * @param {?} group
     * @param {?=} selection
     */
    constructor(dropDown, elementRef, group, selection) {
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.group = group;
        this.selection = selection;
        /**
         * @hidden
         */
        this._focused = false;
        this._selected = false;
        this._index = null;
        this._disabled = false;
        /**
         * Sets/gets the `id` of the item.
         * ```html
         * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
         * ```
         * ```typescript
         * let itemId =  this.item.id;
         * ```
         * \@memberof IgxSelectItemComponent
         */
        this.id = `igx-drop-down-item-${NEXT_ID$1++}`;
        /**
         * @hidden
         */
        this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/sets the `role` attribute of the item. Default is 'option'.
         *
         * ```html
         *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
         * ```
         */
        this.role = 'option';
    }
    /**
     * @protected
     * @return {?}
     */
    get hasIndex() {
        return this._index !== null && this._index !== undefined;
    }
    /**
     * @hidden \@internal
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    get itemID() {
        return (/** @type {?} */ (this));
    }
    /**
     * The data index of the dropdown item.
     *
     * ```typescript
     * // get the data index of the selected dropdown item
     * let selectedItemIndex = this.dropdown.selectedItem.index
     * ```
     * @return {?}
     */
    get index() {
        if (this._index === null) {
            warningShown$1 = showMessage('IgxDropDownItemBase: Automatic index is deprecated.' +
                'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
            return this.itemIndex;
        }
        return this._index;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set index(value) {
        this._index = value;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get itemStyle() {
        return !this.isHeader;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get itemStyleCosy() {
        return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get itemStyleCompact() {
        return this.dropDown.displayDensity === 'compact' && !this.isHeader;
    }
    /**
     * Sets/Gets if the item is the currently selected one in the dropdown
     *
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
     * ```
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get isSelected() {
        return this.selected;
    }
    /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    set isSelected(value) {
        this.selected = value;
    }
    /**
     * Sets/gets if the given item is focused
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemFocused = mySelectedItem.focused;
     * ```
     * @return {?}
     */
    get focused() {
        return (!this.isHeader && !this.disabled) && this._focused;
    }
    /**
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     * @param {?} value
     * @return {?}
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get isFocused() {
        return this.focused;
    }
    /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    set isFocused(value) {
        this.focused = value;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get headerClassCosy() {
        return this.isHeader && this.dropDown.displayDensity === 'cosy';
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get headerClassCompact() {
        return this.isHeader && this.dropDown.displayDensity === 'compact';
    }
    /**
     * Sets/gets if the given item is disabled
     *
     * ```typescript
     *  // get
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let myItemIsDisabled = mySelectedItem.disabled;
     * ```
     *
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
     * @return {?}
     */
    get disabled() {
        return this.group ? this.group.disabled || this._disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * Gets item index
     * @hidden \@internal
     * @return {?}
     */
    get itemIndex() {
        return this.dropDown.items.indexOf(this);
    }
    /**
     * Gets item element height
     * @hidden \@internal
     * @return {?}
     */
    get elementHeight() {
        return this.elementRef.nativeElement.clientHeight;
    }
    /**
     * Get item html element
     * @hidden \@internal
     * @return {?}
     */
    get element() {
        return this.elementRef;
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    clicked(event) {
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._selected) {
            /** @type {?} */
            const dropDownSelectedItem = this.dropDown.selectedItem;
            if (!dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
            else if (this.hasIndex
                ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                this !== dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
        }
    }
}
/** @nocollapse */
IgxDropDownItemBase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_DROPDOWN_BASE,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxDropDownGroupComponent, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
    { type: IgxSelectionAPIService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxSelectionAPIService,] }] }
];
IgxDropDownItemBase.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    itemStyle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__item',] }],
    itemStyleCosy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__item--cosy',] }],
    itemStyleCompact: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__item--compact',] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-selected',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__item--selected',] }],
    selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    isSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__item--focused',] }],
    isHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__header',] }],
    headerClassCosy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__header--cosy',] }],
    headerClassCompact: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__header--compact',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-disabled',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down__item--disabled',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    clicked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`IgxDropDownItemBase \`isSelected\` property is deprecated.\n` +
        `Use \`selected\` instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxDropDownItemBase.prototype, "isSelected", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`IgxDropDownItemBase \`isFocused\` property is depracated.\n` +
        `Use \`focused\` instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxDropDownItemBase.prototype, "isFocused", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
class IgxDropDownItemComponent extends IgxDropDownItemBase {
    /**
     * \@inheritdoc
     * @return {?}
     */
    get focused() {
        /** @type {?} */
        let focusedState = this._focused;
        if (this.hasIndex) {
            /** @type {?} */
            const focusedItem = this.selection.first_item(`${this.dropDown.id}-active`);
            /** @type {?} */
            const focusedIndex = focusedItem ? focusedItem.index : -1;
            focusedState = this._index === focusedIndex;
        }
        return !this.isHeader && !this.disabled && focusedState;
    }
    /**
     * \@inheritdoc
     * @param {?} value
     * @return {?}
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * \@inheritdoc
     * @return {?}
     */
    get selected() {
        if (this.hasIndex) {
            /** @type {?} */
            const item = this.selection.first_item(`${this.dropDown.id}`);
            return item ? item.index === this._index && item.value === this.value : false;
        }
        return this._selected;
    }
    /**
     * \@inheritdoc
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get setTabIndex() {
        /** @type {?} */
        const shouldSetTabIndex = this.dropDown.allowItemsFocus && !(this.disabled || this.isHeader);
        if (shouldSetTabIndex) {
            return 0;
        }
        else {
            return null;
        }
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    clicked(event) {
        if (this.disabled || this.isHeader) {
            /** @type {?} */
            const focusedItem = this.dropDown.items.find((item) => item.focused);
            if (this.dropDown.allowItemsFocus && focusedItem) {
                focusedItem.element.nativeElement.focus({ preventScroll: true });
            }
            return;
        }
        if (this.selection) {
            this.dropDown.selectItem(this, event);
        }
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    mousedownHandler(event) {
        event.preventDefault();
    }
}
IgxDropDownItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-drop-down-item',
                template: "<ng-content></ng-content>"
            }] }
];
IgxDropDownItemComponent.propDecorators = {
    setTabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    clicked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }],
    mousedownHandler: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mousedown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const DisplayDensity = {
    comfortable: 'comfortable',
    cosy: 'cosy',
    compact: 'compact',
};
/**
 * Defines the DisplayDensity DI token.
 * @type {?}
 */
const DisplayDensityToken = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
class DisplayDensityBase {
    /**
     * @param {?} displayDensityOptions
     */
    constructor(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     * @return {?}
     */
    get displayDensity() {
        return this._displayDensity ||
            ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     * @param {?} val
     * @return {?}
     */
    set displayDensity(val) {
        /** @type {?} */
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = (/** @type {?} */ (val));
        if (currentDisplayDensity !== this._displayDensity) {
            /** @type {?} */
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.initialDensity = this._displayDensity;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            /** @type {?} */
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     * @protected
     * @param {?} baseStyleClass
     * @return {?}
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
}
DisplayDensityBase.propDecorators = {
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onDensityChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$2 = 0;
/**
 * An abstract class, defining a drop-down component, with:
 * Properties for display styles and classes
 * A collection items of type `IgxDropDownItemBase`
 * Properties and methods for navigating (highlighting/focusing) items from the collection
 * Properties and methods for selecting items from the collection
 * @abstract
 */
class IgxDropDownBase extends DisplayDensityBase {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} _displayDensityOptions
     */
    constructor(elementRef, cdr, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._displayDensityOptions = _displayDensityOptions;
        this._focusedItem = null;
        this._id = `igx-drop-down-${NEXT_ID$2++}`;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
         * ```
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */
        this.maxHeight = null;
        /**
         * @hidden \@internal
         */
        this.cssClass = true;
    }
    /**
     * Get dropdown's html element of it scroll container
     * @protected
     * @return {?}
     */
    get scrollContainer() {
        return this.element;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     * @return {?}
     */
    get items() {
        /** @type {?} */
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Get all header items
     *
     * ```typescript
     * let myDropDownHeaderItems = this.dropdown.headers;
     * ```
     * @return {?}
     */
    get headers() {
        /** @type {?} */
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Get dropdown html element
     *
     * ```typescript
     * let myDropDownElement = this.dropdown.element;
     * ```
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Keydown Handler
     * @param {?} key
     * @param {?=} event
     * @return {?}
     */
    onItemActionKey(key, event) {
        switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
                this.selectItem(this.focusedItem, event);
                break;
            case DropDownActionKey.ESCAPE:
        }
    }
    /**
     * Emits onSelection with the target item & event
     * @hidden \@internal
     * @param {?=} newSelection the item selected
     * @param {?=} event the event that triggered the call
     * @return {?}
     */
    selectItem(newSelection, event) {
        this.onSelection.emit({
            newSelection,
            oldSelection: null,
            cancel: false
        });
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get focusedItem() {
        return this._focusedItem;
    }
    /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    set focusedItem(item) {
        this._focusedItem = item;
    }
    /**
     * @protected
     * @param {?} direction
     * @param {?=} currentIndex
     * @return {?}
     */
    navigate(direction, currentIndex) {
        /** @type {?} */
        let index = -1;
        if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
        }
        /** @type {?} */
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    /**
     * @protected
     * @param {?} startIndex
     * @param {?} direction
     * @return {?}
     */
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        /** @type {?} */
        let index = startIndex;
        /** @type {?} */
        const items = this.items;
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        if (index >= 0 && index < items.length) {
            return index;
        }
        else {
            return -1;
        }
    }
    /**
     * Navigates to the item on the specified index
     * @param {?} newIndex number - the index of the item in the `items` collection
     * @return {?}
     */
    navigateItem(newIndex) {
        if (newIndex !== -1) {
            /** @type {?} */
            const oldItem = this._focusedItem;
            /** @type {?} */
            const newItem = this.items[newIndex];
            if (oldItem) {
                oldItem.focused = false;
            }
            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigateFirst() {
        this.navigate(Navigate.Down, -1);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigateLast() {
        this.navigate(Navigate.Up, this.items.length);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigateNext() {
        this.navigate(Navigate.Down);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigatePrev() {
        this.navigate(Navigate.Up);
    }
    /**
     * @protected
     * @param {?} newItem
     * @return {?}
     */
    scrollToHiddenItem(newItem) {
        /** @type {?} */
        const elementRect = newItem.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const parentRect = this.scrollContainer.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
        }
    }
}
/** @nocollapse */
IgxDropDownBase.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxDropDownBase.propDecorators = {
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    height: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    maxHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.maxHeight',] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-down',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisplayContainerComponent {
    /**
     * @param {?} cdr
     * @param {?} _viewContainer
     */
    constructor(cdr, _viewContainer) {
        this.cdr = cdr;
        this._viewContainer = _viewContainer;
        this.cssClass = 'igx-display-container';
        this.notVirtual = true;
    }
}
DisplayContainerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-display-container',
                template: `
        <ng-template
            #display_container
            igxScrollInertia
            [IgxScrollInertiaScrollContainer]="scrollContainer"
            [IgxScrollInertiaDirection]="scrollDirection">
        </ng-template>
    `
            }] }
];
/** @nocollapse */
DisplayContainerComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] }
];
DisplayContainerComponent.propDecorators = {
    _vcr: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['display_container', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"], static: true },] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }],
    notVirtual: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-display-container--inactive',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualHelperBaseDirective {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     */
    constructor(elementRef, cdr) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.scrollAmount = 0;
        this._size = 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        if (this.destroyed) {
            return;
        }
        this._size = value;
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
}
VirtualHelperBaseDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxVirtualHelperBase]'
            },] }
];
/** @nocollapse */
VirtualHelperBaseDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
VirtualHelperBaseDirective.propDecorators = {
    onScroll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['scroll', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class HVirtualHelperComponent extends VirtualHelperBaseDirective {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     */
    constructor(elementRef, cdr) {
        super(elementRef, cdr);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.cssClasses = 'igx-vhelper--horizontal';
    }
}
HVirtualHelperComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-horizontal-virtual-helper',
                template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
            }] }
];
/** @nocollapse */
HVirtualHelperComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
HVirtualHelperComponent.propDecorators = {
    _vcr: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['horizontal_container', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"], static: true },] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualHelperComponent extends VirtualHelperBaseDirective {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     */
    constructor(elementRef, cdr) {
        super(elementRef, cdr);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.cssClasses = 'igx-vhelper--vertical';
    }
}
VirtualHelperComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-virtual-helper',
                template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
            }] }
];
/** @nocollapse */
VirtualHelperComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
VirtualHelperComponent.propDecorators = {
    scrollTop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['scrollTop',] }],
    _vcr: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['container', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"], static: true },] }],
    itemsLength: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxScrollInertiaDirective {
    /**
     * @param {?} element
     * @param {?} _zone
     */
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            /** @type {?} */
            const targetElem = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            targetElem.addEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.addEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.addEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.addEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.addEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.addEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.addEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.addEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     * @protected
     * @param {?} evt
     * @return {?}
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /** @type {?} */
        let scrollDeltaX;
        /** @type {?} */
        let scrollDeltaY;
        /** @type {?} */
        const scrollStep = this.wheelStep;
        /** @type {?} */
        const minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX / 120;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaX = this.calcAxisCoords(evt.deltaX, -1, 1);
        }
        /** Get delta for the Y axis*/
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY / 120;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaY = this.calcAxisCoords(evt.deltaY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            /** @type {?} */
            const curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            /** @type {?} */
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt, true);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     * @protected
     * @param {?} evt
     * @param {?} preventDefault
     * @return {?}
     */
    preventParentScroll(evt, preventDefault) {
        /** @type {?} */
        const curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        /** @type {?} */
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     * @protected
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        /** @type {?} */
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     * @protected
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /** @type {?} */
        const touch = event.touches[0];
        /** @type {?} */
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        /** @type {?} */
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        /** @type {?} */
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            /** @type {?} */
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            /** @type {?} */
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        /** @type {?} */
        let scrolledXY;
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        /** @type {?} */
        let speedX = 0;
        /** @type {?} */
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    onPointerDown(event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
        }
        this._gestureObject.addPointer(this._pointer);
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    onPointerUp(event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    }
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    onMSGestureStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    }
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    onMSGestureChange(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /** @type {?} */
        const touchPos = event;
        /** @type {?} */
        const destX = this._startX + this._touchStartX - touchPos.screenX;
        /** @type {?} */
        const destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    }
    /**
     * @private
     * @param {?} target
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    /**
     * @private
     * @param {?} destX
     * @param {?} destY
     * @return {?}
     */
    _scrollTo(destX, destY) {
        /** @type {?} */
        const curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        /** @type {?} */
        const curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // TODO Trigger scrolling event?
        /** @type {?} */
        const scrolledX = this._scrollToX(destX);
        /** @type {?} */
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    /**
     * @private
     * @param {?} dest
     * @return {?}
     */
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    /**
     * @private
     * @param {?} dest
     * @return {?}
     */
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
    /**
     * @protected
     * @param {?} speedX
     * @param {?} speedY
     * @return {?}
     */
    _inertiaInit(speedX, speedY) {
        /** @type {?} */
        const stepModifer = this.inertiaStep;
        /** @type {?} */
        const inertiaDuration = this.inertiaDuration;
        /** @type {?} */
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        /** @type {?} */
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            /** @type {?} */
            const targetElem = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            targetElem.removeEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.removeEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.removeEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.removeEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.removeEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.removeEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.removeEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.removeEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
}
IgxScrollInertiaDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[igxScrollInertia]' },] }
];
/** @nocollapse */
IgxScrollInertiaDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxScrollInertiaDirective.propDecorators = {
    IgxScrollInertiaDirection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    IgxScrollInertiaScrollContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    wheelStep: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inertiaStep: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    swipeToleranceX: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inertiaDeltaY: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inertiaDeltaX: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inertiaDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/**
 * @hidden
 */
class IgxScrollInertiaModule {
}
IgxScrollInertiaModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxScrollInertiaDirective],
                exports: [IgxScrollInertiaDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxForOfSyncService {
    constructor() {
        this._master = new Map();
    }
    /**
     * @hidden
     * @param {?} directive
     * @return {?}
     */
    isMaster(directive) {
        return this._master.get(directive.igxForScrollOrientation) === directive;
    }
    /**
     * @hidden
     * @param {?} directive
     * @param {?=} forced
     * @return {?}
     */
    setMaster(directive, forced = false) {
        /** @type {?} */
        const orientation = directive.igxForScrollOrientation;
        if (orientation && (forced || !this._master.has(orientation))) {
            this._master.set(orientation, directive);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    resetMaster() {
        this._master.clear();
    }
    /**
     * @hidden
     * @param {?} dir
     * @return {?}
     */
    sizesCache(dir) {
        return this._master.get(dir).sizesCache;
    }
    /**
     * @hidden
     * @param {?} dir
     * @return {?}
     */
    chunkSize(dir) {
        return this._master.get(dir).state.chunkSize;
    }
}
IgxForOfSyncService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ IgxForOfSyncService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
class IgxForOfScrollSyncService {
    constructor() {
        this._masterScroll = new Map();
    }
    /**
     * @param {?} dir
     * @param {?} scroll
     * @return {?}
     */
    setScrollMaster(dir, scroll) {
        this._masterScroll.set(dir, scroll);
    }
    /**
     * @param {?} dir
     * @return {?}
     */
    getScrollMaster(dir) {
        return this._masterScroll.get(dir);
    }
}
IgxForOfScrollSyncService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ IgxForOfScrollSyncService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function IgxForOfScrollSyncService_Factory() { return new IgxForOfScrollSyncService(); }, token: IgxForOfScrollSyncService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@publicApi
 * @template T
 */
class IgxForOfContext {
    /**
     * @param {?} $implicit
     * @param {?} index
     * @param {?} count
     */
    constructor($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     * @return {?}
     */
    get first() { return this.index === 0; }
    /**
     * A function that returns whether the element is the last or not
     * @return {?}
     */
    get last() { return this.index === this.count - 1; }
    /**
     * A function that returns whether the element is even or not
     * @return {?}
     */
    get even() { return this.index % 2 === 0; }
    /**
     * A function that returns whether the element is odd or not
     * @return {?}
     */
    get odd() { return !this.even; }
}
/**
 * @template T
 */
class IgxForOfDirective {
    /**
     * @param {?} _viewContainer
     * @param {?} _template
     * @param {?} _differs
     * @param {?} resolver
     * @param {?} cdr
     * @param {?} _zone
     * @param {?} syncScrollService
     */
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        /**
         * An \@Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */
        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.onContentSizeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onBeforeViewDestroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /**
         * Height that is being virtualized.
         */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /**
         * Internal track for scroll top that is being virtualized
         */
        this._virtScrollTop = 0;
        /**
         * If the next onScroll event is triggered due to internal setting of scrollTop
         */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
    }
    /**
     * @return {?}
     */
    get displayContainer() {
        return this.dc.instance._viewContainer.element.nativeElement;
    }
    /**
     * @return {?}
     */
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * @protected
     * @return {?}
     */
    get sizesCache() {
        return this._sizesCache;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    /**
     * @private
     * @return {?}
     */
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        /** @type {?} */
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    /**
     * @private
     * @return {?}
     */
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     * @return {?}
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => this.scrollComponent.nativeElement.removeEventListener('scroll', this.func));
        }
        else {
            this._zone.runOutsideAngular(() => this.scrollComponent.nativeElement.removeEventListener('scroll', this.verticalScrollHandler));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    /**
     * @return {?}
     */
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        let totalSize = 0;
        /** @type {?} */
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        /** @type {?} */
        const dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                const input = this.igxForOf[i];
                /** @type {?} */
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            /** @type {?} */
            const factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            /** @type {?} */
            const destructor = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$);
            this.contentResizeNotify.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttleTime"])(40))
                .subscribe(() => {
                this._zone.runTask(() => {
                    this.updateSizes();
                });
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => { this.onHScroll(evt); };
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                /** @type {?} */
                const hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.scrollComponent = vc.createComponent(hvFactory).instance;
                this.scrollComponent.size = totalSize;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateHScrollOffset();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const forOf = 'igxForOf';
        if (forOf in changes) {
            /** @type {?} */
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        /** @type {?} */
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        /** @type {?} */
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param {?} addTop negative value to scroll up and positive to scroll down;
     * @return {?}
     */
    addScrollTop(addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        /** @type {?} */
        const originalVirtScrollTop = this._virtScrollTop;
        /** @type {?} */
        const containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.scrollPosition += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            /** @type {?} */
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        /** @type {?} */
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param {?} index
     * @return {?}
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        /** @type {?} */
        const containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        /** @type {?} */
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
        }
        else {
            /** @type {?} */
            const maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     * @return {?}
     */
    scrollNext() {
        /** @type {?} */
        const scr = Math.ceil(this.scrollPosition);
        /** @type {?} */
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     * @return {?}
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     * @return {?}
     */
    scrollNextPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     * @return {?}
     */
    scrollPrevPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            /** @type {?} */
            const containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    }
    /**
     * @hidden
     * @param {?} colIndex
     * @return {?}
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     * @return {?}
     */
    getItemCountInView() {
        /** @type {?} */
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        /** @type {?} */
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     * @return {?}
     */
    getScroll() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     * @param {?} index
     * @return {?}
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     * @param {?} index
     * @param {?=} bottom
     * @return {?}
     */
    getScrollForIndex(index, bottom) {
        /** @type {?} */
        const containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     * @protected
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        /** @type {?} */
        const containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        const maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
        /** @type {?} */
        const realPercentScrolled = maxRealScrollTop !== 0 ? event.target.scrollTop / maxRealScrollTop : 0;
        if (!this._bScrollInternal) {
            /** @type {?} */
            const maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        }
        else {
            this._bScrollInternal = false;
        }
        /** @type {?} */
        const prevStartIndex = this.state.startIndex;
        /** @type {?} */
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    updateSizes() {
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        this.onContentSizeChange.emit();
    }
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     * @return {?}
     */
    recalcUpdateSizes() {
        /** @type {?} */
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        const diffs = [];
        /** @type {?} */
        let totalDiff = 0;
        /** @type {?} */
        const l = this._embeddedViews.length;
        /** @type {?} */
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE));
        for (let i = 0; i < l; i++) {
            /** @type {?} */
            const rNode = rNodes[i];
            if (rNode) {
                /** @type {?} */
                const h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                /** @type {?} */
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                /** @type {?} */
                const oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                /** @type {?} */
                const newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                /** @type {?} */
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                /** @type {?} */
                const totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            /** @type {?} */
            const reducer = (acc, val) => acc + val;
            if (this.igxForScrollOrientation === 'vertical') {
                /** @type {?} */
                const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                /** @type {?} */
                const hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.scrollComponent.destroyed) {
                    this.scrollComponent.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    /** @type {?} */
                    const containerSize = parseInt(this.igxForContainerSize, 10);
                    /** @type {?} */
                    const maxVirtScrollTop = this._virtHeight - containerSize;
                    this._bScrollInternal = true;
                    this._virtScrollTop = maxVirtScrollTop;
                    this.scrollPosition = maxVirtScrollTop;
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    /** @type {?} */
                    const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    /** @type {?} */
                    const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    /** @type {?} */
                    const currOffset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                    this.dc.instance._viewContainer.element.nativeElement.style.top = (currOffset - sumDiffs) + 'px';
                    this._adjustToIndex = null;
                }
            }
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} inScrollTop
     * @return {?}
     */
    fixedUpdateAllElements(inScrollTop) {
        /** @type {?} */
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        /** @type {?} */
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        /** @type {?} */
        const prevStart = this.state.startIndex;
        /** @type {?} */
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                /*recalculate and apply page size.*/
                if (diff > 0 && diff <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollNext(prevStart);
                }
                else if (diff < 0 && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    moveApplyScrollNext(prevIndex) {
        /** @type {?} */
        const start = prevIndex + this.state.chunkSize;
        for (let i = start; i < start + this.state.startIndex - prevIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            const input = this.igxForOf[i];
            /** @type {?} */
            const embView = this._embeddedViews.shift();
            /** @type {?} */
            const cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            cntx.count = this.igxForOf.length;
            /** @type {?} */
            const view = this.dc.instance._vcr.detach(0);
            this.dc.instance._vcr.insert(view);
            this._embeddedViews.push(embView);
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    moveApplyScrollPrev(prevIndex) {
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            /** @type {?} */
            const input = this.igxForOf[i];
            /** @type {?} */
            const embView = this._embeddedViews.pop();
            /** @type {?} */
            const cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            /** @type {?} */
            const view = this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
            this.dc.instance._vcr.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} input
     * @return {?}
     */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     * @protected
     * @return {?}
     */
    fixedApplyScroll() {
        /** @type {?} */
        let j = 0;
        /** @type {?} */
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            const input = this.igxForOf[i];
            /** @type {?} */
            const embView = this._embeddedViews[j++];
            /** @type {?} */
            const cntx = ((/** @type {?} */ (embView))).context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            cntx.count = this.igxForOf.length;
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     * @protected
     * @param {?} event
     * @return {?}
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        /** @type {?} */
        const prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        /** @type {?} */
        const scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     * @return {?}
     */
    get igxForTrackBy() { return this._trackByFn; }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     * @param {?} fn
     * @return {?}
     */
    set igxForTrackBy(fn) { this._trackByFn = fn; }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _applyChanges() {
        /** @type {?} */
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */
            let startIndex = this.state.startIndex;
            /** @type {?} */
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                const input = this.igxForOf[i];
                /** @type {?} */
                const embView = embeddedViewCopy.shift();
                /** @type {?} */
                const cntx = ((/** @type {?} */ (embView))).context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                cntx.count = this.igxForOf.length;
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _calcMaxBrowserHeight() {
        /** @type {?} */
        const div = document.createElement('div');
        /** @type {?} */
        const style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        document.body.appendChild(div);
        /** @type {?} */
        const size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     * @protected
     * @return {?}
     */
    _calculateChunkSize() {
        /** @type {?} */
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     * @protected
     * @param {?} viewref
     * @param {?} nodeName
     * @return {?}
     */
    getElement(viewref, nodeName) {
        /** @type {?} */
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     * @protected
     * @param {?} items
     * @return {?}
     */
    initSizesCache(items) {
        /** @type {?} */
        let totalSize = 0;
        /** @type {?} */
        let size = 0;
        /** @type {?} */
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        /** @type {?} */
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    /**
     * @protected
     * @return {?}
     */
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        /** @type {?} */
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        /** @type {?} */
        const newHeight = this.initSizesCache(this.igxForOf);
        /** @type {?} */
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            /** @type {?} */
            const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _calcMaxChunkSize() {
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let length = 0;
        /** @type {?} */
        let maxLength = 0;
        /** @type {?} */
        const arr = [];
        /** @type {?} */
        let sum = 0;
        /** @type {?} */
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        /** @type {?} */
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            /** @type {?} */
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            /** @type {?} */
            const size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    /** @type {?} */
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    /** @type {?} */
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        /** @type {?} */
                        const prevItem = this.igxForOf[prevIndex];
                        /** @type {?} */
                        const prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     * @protected
     * @param {?} left
     * @param {?} set
     * @param {?} index
     * @return {?}
     */
    getIndexAt(left, set, index) {
        /** @type {?} */
        let start = 0;
        /** @type {?} */
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            /** @type {?} */
            const midIdx = Math.floor((start + end) / 2);
            /** @type {?} */
            const midLeft = set[midIdx];
            /** @type {?} */
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    /**
     * @protected
     * @return {?}
     */
    _recalcScrollBarSize() {
        /** @type {?} */
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        if (this.igxForScrollOrientation === 'horizontal') {
            /** @type {?} */
            const totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();
            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    _calcHeight() {
        /** @type {?} */
        let height;
        if (this.heightCache) {
            height = this.heightCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    }
    /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    _recalcOnContainerChange(changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        /** @type {?} */
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            /** @type {?} */
            const scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     * @protected
     * @return {?}
     */
    removeLastElem() {
        /** @type {?} */
        const oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     * @protected
     * @return {?}
     */
    addLastElem() {
        /** @type {?} */
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        /** @type {?} */
        const input = this.igxForOf[elemIndex];
        /** @type {?} */
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => {
            this.cdr.markForCheck();
        });
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in \@addLastElem() or \@removeLastElem()
     * @protected
     * @return {?}
     */
    applyChunkSizeChange() {
        /** @type {?} */
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            /** @type {?} */
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            /** @type {?} */
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    _updateScrollOffset() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _updateVScrollOffset() {
        /** @type {?} */
        let scrollOffset = 0;
        /** @type {?} */
        const vScroll = this.scrollComponent.nativeElement;
        scrollOffset = vScroll && this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    }
    /**
     * @private
     * @return {?}
     */
    _updateHScrollOffset() {
        /** @type {?} */
        let scrollOffset = 0;
        scrollOffset = this.scrollComponent.nativeElement &&
            this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    /**
     * @private
     * @param {?} item
     * @param {?} dimension
     * @return {?}
     */
    _getItemSize(item, dimension) {
        /** @type {?} */
        const dim = item[dimension];
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
}
IgxForOfDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[igxFor][igxForOf]' },] }
];
/** @nocollapse */
IgxForOfDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: IgxForOfScrollSyncService }
];
IgxForOfDirective.propDecorators = {
    igxForOf: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    igxForSizePropName: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    igxForScrollOrientation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    igxForScrollContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    igxForContainerSize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    igxForItemSize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onChunkLoad: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onContentSizeChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDataChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onBeforeViewDestroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onChunkPreload: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    igxForTrackBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/**
 * @param {?} type
 * @return {?}
 */
function getTypeNameForDebugging(type) {
    /** @type {?} */
    const name = 'name';
    return type[name] || typeof type;
}
/**
 * @template T
 */
class IgxGridForOfDirective extends IgxForOfDirective {
    /**
     * @param {?} _viewContainer
     * @param {?} _template
     * @param {?} _differs
     * @param {?} resolver
     * @param {?} cdr
     * @param {?} _zone
     * @param {?} syncScrollService
     * @param {?} syncService
     */
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService);
        this.syncScrollService = syncScrollService;
        this.syncService = syncService;
        /**
         * @hidden \@internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.onDataChanging = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    /**
     * @return {?}
     */
    get igxGridForOf() {
        return this.igxForOf;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            /** @type {?} */
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        /** @type {?} */
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get sizesCache() {
        if (this.syncService.isMaster(this)) {
            return this._sizesCache;
        }
        return this.syncService.sizesCache(this.igxForScrollOrientation);
    }
    /**
     * @hidden
     * \@internal
     * @param {?} value
     * @return {?}
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    /**
     * @protected
     * @return {?}
     */
    get itemsDimension() {
        return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
    }
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    getItemSize(item) {
        /** @type {?} */
        let size = 0;
        /** @type {?} */
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    /**
     * @protected
     * @param {?} items
     * @return {?}
     */
    initSizesCache(items) {
        if (!this.syncService.isMaster(this)) {
            /** @type {?} */
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        /** @type {?} */
        let totalSize = 0;
        /** @type {?} */
        let size = 0;
        /** @type {?} */
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        /** @type {?} */
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    /**
     * @protected
     * @param {?=} changes
     * @return {?}
     */
    _updateSizeCache(changes = null) {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        /** @type {?} */
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        /** @type {?} */
        let newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            newHeight = this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(() => {
                this.recalcUpdateSizes();
                /** @type {?} */
                const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (this.scrollPosition !== 0) {
                    this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
                }
                else {
                    this._updateScrollOffset();
                }
            });
        }
    }
    /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    handleCacheChanges(changes) {
        /** @type {?} */
        const identityChanges = [];
        /** @type {?} */
        const newHeightCache = [];
        /** @type {?} */
        const newSizesCache = [];
        newSizesCache.push(0);
        /** @type {?} */
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        /** @type {?} */
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                /** @type {?} */
                const args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        /** @type {?} */
        const containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        const maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
        /** @type {?} */
        const realPercentScrolled = maxRealScrollTop !== 0 ? event.target.scrollTop / maxRealScrollTop : 0;
        if (!this._bScrollInternal) {
            /** @type {?} */
            const maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        }
        else {
            this._bScrollInternal = false;
        }
        /** @type {?} */
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.recalcUpdateSizes();
    }
    /**
     * @param {?} scrollAmount
     * @return {?}
     */
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        /** @type {?} */
        const scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    /**
     * @protected
     * @return {?}
     */
    addLastElem() {
        /** @type {?} */
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        /** @type {?} */
        const input = this.igxForOf[elemIndex];
        /** @type {?} */
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    /**
     * @protected
     * @param {?} prevChunkSize
     * @return {?}
     */
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */
            let startIndex;
            /** @type {?} */
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                const input = this.igxForOf[i];
                /** @type {?} */
                const embView = embeddedViewCopy.shift();
                /** @type {?} */
                const cntx = ((/** @type {?} */ (embView))).context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                cntx.count = this.igxForOf.length;
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    _applyChanges() {
        /** @type {?} */
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _calcMaxChunkSize() {
        if (this.syncService.isMaster(this)) {
            return super._calcMaxChunkSize();
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    }
}
IgxGridForOfDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxGridFor][igxGridForOf]'
            },] }
];
/** @nocollapse */
IgxGridForOfDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: IgxForOfScrollSyncService },
    { type: IgxForOfSyncService }
];
IgxGridForOfDirective.propDecorators = {
    igxGridForOf: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onDataChanging: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class IgxForOfModule {
}
IgxForOfModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                    HVirtualHelperComponent, VirtualHelperBaseDirective],
                entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                exports: [IgxForOfDirective, IgxGridForOfDirective],
                imports: [IgxScrollInertiaModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular DropDown** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop_down.html)
 *
 * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
 * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
 *
 * Example:
 * ```html
 * <igx-drop-down>
 *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
 *     {{ item.value }}
 *   </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
class IgxDropDownComponent extends IgxDropDownBase {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} selection
     * @param {?} _displayDensityOptions
     */
    constructor(elementRef, cdr, selection, _displayDensityOptions) {
        super(elementRef, cdr, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
         * ```
         */
        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
         * ```
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
         * ```
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
         * ```
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/sets whether items take focus. Disabled by default.
         * When enabled, drop down items gain tab index and are focused when active -
         * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
         *
         * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
         * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
         *
         * ```typescript
         * // get
         * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
         * ```
         */
        this.allowItemsFocus = false;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get focusedItem() {
        if (this.virtDir) {
            return this._focusedItem && this._focusedItem.index !== -1 ?
                (this.children.find(e => e.index === this._focusedItem.index) || null) :
                null;
        }
        return this._focusedItem;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set focusedItem(value) {
        if (!value) {
            this.selection.clear(`${this.id}-active`);
            this._focusedItem = null;
            return;
        }
        this._focusedItem = value;
        if (this.virtDir) {
            this._focusedItem = (/** @type {?} */ ({
                value: value.value,
                index: value.index
            }));
        }
        this.selection.set(`${this.id}-active`, new Set([this._focusedItem]));
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this.toggleDirective.id = value;
        this.selection.set(value, this.selection.get(this.id));
        this.selection.clear(this.id);
        this.selection.set(value, this.selection.get(`${this.id}-active`));
        this.selection.clear(`${this.id}-active`);
        this._id = value;
    }
    /**
     * Id of the internal listbox of the drop down
     * @return {?}
     */
    get listId() {
        return this.id + '-list';
    }
    /**
     * Get currently selected item
     *
     * ```typescript
     * let currentItem = this.dropdown.selectedItem;
     * ```
     * @return {?}
     */
    get selectedItem() {
        /** @type {?} */
        const selectedItem = this.selection.first_item(this.id);
        if (selectedItem) {
            return selectedItem;
        }
        return null;
    }
    /**
     * Gets if the dropdown is collapsed
     *
     * ```typescript
     * let isCollapsed = this.dropdown.collapsed;
     * ```
     * @return {?}
     */
    get collapsed() {
        return this.toggleDirective.collapsed;
    }
    /**
     * @protected
     * @return {?}
     */
    get scrollContainer() {
        return this.toggleDirective.element;
    }
    /**
     * @protected
     * @return {?}
     */
    get collectionLength() {
        if (this.virtDir) {
            return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
        }
    }
    /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    open(overlaySettings) {
        this.toggleDirective.open(overlaySettings);
        this.updateScrollPosition();
    }
    /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     * @return {?}
     */
    close() {
        this.toggleDirective.close();
    }
    /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    toggle(overlaySettings) {
        if (this.collapsed || this.toggleDirective.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /**
     * Select an item by index
     * @param {?} index of the item to select; If the drop down uses *igxFor, pass the index in data
     * @return {?}
     */
    setSelectedItem(index) {
        if (index < 0 || index >= this.items.length) {
            return;
        }
        /** @type {?} */
        let newSelection;
        if (this.virtDir) {
            newSelection = (/** @type {?} */ ({
                value: this.virtDir.igxForOf[index],
                index
            }));
        }
        else {
            newSelection = this.items[index];
        }
        this.selectItem(newSelection);
    }
    /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     * @param {?} index
     * @return {?}
     */
    navigateItem(index) {
        if (this.virtDir) {
            if (index === -1 || index >= this.collectionLength) {
                return;
            }
            /** @type {?} */
            const direction = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
            /** @type {?} */
            const subRequired = this.isIndexOutOfBounds(index, direction);
            this.focusedItem = (/** @type {?} */ ({
                value: this.virtDir.igxForOf[index],
                index: index
            }));
            if (subRequired) {
                this.virtDir.scrollTo(index);
            }
            if (subRequired) {
                this.virtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["take"])(1)).subscribe(() => {
                    this.skipHeader(direction);
                });
            }
            else {
                this.skipHeader(direction);
            }
        }
        else {
            super.navigateItem(index);
        }
        if (this.allowItemsFocus && this.focusedItem) {
            this.focusedItem.element.nativeElement.focus();
            this.cdr.markForCheck();
        }
    }
    /**
     * @private
     * @param {?} index
     * @param {?} direction
     * @return {?}
     */
    isIndexOutOfBounds(index, direction) {
        /** @type {?} */
        const virtState = this.virtDir.state;
        /** @type {?} */
        const currentPosition = this.virtDir.getScroll().scrollTop;
        /** @type {?} */
        const itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
        /** @type {?} */
        const indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
        /** @type {?} */
        const scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
        /** @type {?} */
        const subRequired = indexOutOfChunk || scrollNeeded;
        return subRequired;
    }
    /**
     * @protected
     * @param {?} direction
     * @return {?}
     */
    skipHeader(direction) {
        if (!this.focusedItem) {
            return;
        }
        if (this.focusedItem.isHeader || this.focusedItem.disabled) {
            if (direction === Navigate.Up) {
                this.navigatePrev();
            }
            else {
                this.navigateNext();
            }
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    updateScrollPosition() {
        if (!this.virtDir) {
            return;
        }
        if (!this.selectedItem) {
            this.virtDir.scrollTo(0);
            return;
        }
        /** @type {?} */
        let targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
        /** @type {?} */
        const itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
        targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
        this.virtDir.getScroll().scrollTop = targetScroll;
    }
    /**
     * @hidden \@internal
     * @param {?} e
     * @return {?}
     */
    onToggleOpening(e) {
        this.onOpening.emit(e);
        if (e.cancel) {
            return;
        }
        if (!this.virtDir && this.selectedItem) {
            this.scrollToItem(this.selectedItem);
        }
        if (this.virtDir) {
            this.virtDir.scrollPosition = this._scrollPosition;
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onToggleOpened() {
        if (this.selectedItem) {
            this.focusedItem = this.selectedItem;
            this._focusedItem.focused = true;
        }
        else if (this.allowItemsFocus) {
            this.navigateFirst();
        }
        this.onOpened.emit();
    }
    /**
     * @hidden \@internal
     * @param {?} e
     * @return {?}
     */
    onToggleClosing(e) {
        this.onClosing.emit(e);
        if (this.virtDir) {
            this._scrollPosition = this.virtDir.scrollPosition;
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onToggleClosed() {
        if (this._focusedItem) {
            this._focusedItem.focused = false;
        }
        this.onClosed.emit();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
        this.selection.clear(`${this.id}-active`);
    }
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    scrollToItem(item) {
        /** @type {?} */
        const itemPosition = this.calculateScrollPosition(item);
        //  in IE11 setting sctrollTop is somehow slow and forces dropdown
        //  to appear on screen before animation start. As a result dropdown
        //  flickers badly. This is why we set scrollTop just a little later
        //  allowing animation to start and prevent dropdown flickering
        if (isIE()) {
            setTimeout(() => {
                this.scrollContainer.scrollTop = (itemPosition);
            }, 1);
        }
        else {
            this.scrollContainer.scrollTop = (itemPosition);
        }
    }
    /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    calculateScrollPosition(item) {
        if (!item) {
            return 0;
        }
        /** @type {?} */
        const elementRect = item.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const parentRect = this.scrollContainer.getBoundingClientRect();
        /** @type {?} */
        const scrollDelta = parentRect.top - elementRect.top;
        /** @type {?} */
        let scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
        /** @type {?} */
        const dropDownHeight = this.scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += item.elementHeight / 2;
        return Math.floor(scrollPosition);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnInit() {
        this.toggleDirective.id = this.id;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.virtDir) {
            this.virtDir.igxForItemSize = 28;
        }
    }
    /**
     * Keydown Handler
     * @param {?} key
     * @param {?=} event
     * @return {?}
     */
    onItemActionKey(key, event) {
        super.onItemActionKey(key, event);
        this.close();
    }
    /**
     * Virtual scroll implementation
     * @hidden \@internal
     * @return {?}
     */
    navigateFirst() {
        if (this.virtDir) {
            this.navigateItem(0);
        }
        else {
            super.navigateFirst();
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigateLast() {
        if (this.virtDir) {
            this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
        }
        else {
            super.navigateLast();
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigateNext() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    navigatePrev() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     * @hidden
     * \@internal
     * @param {?=} newSelection
     * @param {?=} event
     * @return {?}
     */
    selectItem(newSelection, event) {
        /** @type {?} */
        const oldSelection = this.selectedItem;
        if (!newSelection) {
            newSelection = this.focusedItem;
        }
        if (newSelection === null) {
            return;
        }
        if (newSelection instanceof IgxDropDownItemBase && newSelection.isHeader) {
            return;
        }
        if (this.virtDir) {
            newSelection = (/** @type {?} */ ({
                value: newSelection.value,
                index: newSelection.index
            }));
        }
        /** @type {?} */
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (!args.cancel) {
            this.selection.set(this.id, new Set([newSelection]));
            if (!this.virtDir) {
                if (oldSelection) {
                    oldSelection.selected = false;
                }
                if (newSelection) {
                    newSelection.selected = true;
                }
            }
            if (event) {
                this.toggleDirective.close();
            }
        }
    }
}
IgxDropDownComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-drop-down',
                template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\" [style.height]=\"height\"\n[style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\"\n    (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n    (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <ng-container *ngIf=\"!collapsed\">\n        <ng-content></ng-content>\n    </ng-container>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent }]
            }] }
];
/** @nocollapse */
IgxDropDownComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxDropDownComponent.propDecorators = {
    virtDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxForOfDirective, { read: IgxForOfDirective, static: false },] }],
    toggleDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxToggleDirective, { static: true },] }],
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxDropDownItemComponent), { descendants: true },] }],
    onOpening: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    allowItemsFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBase component
 */
class IgxDropDownItemNavigationDirective {
    /**
     * @param {?} dropdown
     */
    constructor(dropdown) {
        this.dropdown = dropdown;
        this._target = null;
    }
    /**
     * Gets the target of the navigation directive;
     *
     * ```typescript
     * // Get
     * export class MyComponent {
     *  ...
     * \@ContentChild(IgxDropDownNavigationDirective)
     *  navDirective: IgxDropDownNavigationDirective = null
     *  ...
     *  const navTarget: IgxDropDownBase = navDirective.navTarget
     * }
     * ```
     * @return {?}
     */
    get target() {
        return this._target;
    }
    /**
     * Sets the target of the navigation directive;
     * If no valid target is passed, it falls back to the drop down context
     *
     * ```html
     * <!-- Set -->
     * <input [igxDropDownItemNavigation]="dropdown" />
     * ...
     * <igx-drop-down #dropdown>
     * ...
     * </igx-drop-down>
     * ```
     * @param {?} target
     * @return {?}
     */
    set target(target) {
        this._target = target ? target : this.dropdown;
    }
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     * @param {?} event
     * @return {?}
     */
    handleKeyDown(event) {
        if (event) {
            /** @type {?} */
            const key = event.key.toLowerCase();
            if (!this.target.collapsed) { // If dropdown is opened
                // If dropdown is opened
                /** @type {?} */
                const navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                    'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
            }
            else { // If dropdown is closed, do nothing
                return;
            }
            switch (key) {
                case 'esc':
                case 'escape':
                    this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                    break;
                case 'enter':
                    this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                    break;
                case 'space':
                case 'spacebar':
                case ' ':
                    this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                    break;
                case 'arrowup':
                case 'up':
                    this.onArrowUpKeyDown();
                    break;
                case 'arrowdown':
                case 'down':
                    this.onArrowDownKeyDown();
                    break;
                case 'home':
                    this.onHomeKeyDown();
                    break;
                case 'end':
                    this.onEndKeyDown();
                    break;
                default:
                    return;
            }
        }
    }
    /**
     * Navigates to previous item
     * @return {?}
     */
    onArrowDownKeyDown() {
        this.target.navigateNext();
    }
    /**
     * Navigates to previous item
     * @return {?}
     */
    onArrowUpKeyDown() {
        this.target.navigatePrev();
    }
    /**
     * Navigates to target's last item
     * @return {?}
     */
    onEndKeyDown() {
        this.target.navigateLast();
    }
    /**
     * Navigates to target's first item
     * @return {?}
     */
    onHomeKeyDown() {
        this.target.navigateFirst();
    }
}
IgxDropDownItemNavigationDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDropDownItemNavigation]'
            },] }
];
/** @nocollapse */
IgxDropDownItemNavigationDirective.ctorParameters = () => [
    { type: IgxDropDownBase, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_DROPDOWN_BASE,] }] }
];
IgxDropDownItemNavigationDirective.propDecorators = {
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxDropDownItemNavigation',] }],
    handleKeyDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxDropDownModule {
}
IgxDropDownModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective],
                exports: [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxToggleModule],
                providers: [IgxSelectionAPIService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const IgxHintPosition = {
    START: 0,
    END: 1,
};
IgxHintPosition[IgxHintPosition.START] = 'START';
IgxHintPosition[IgxHintPosition.END] = 'END';
class IgxHintDirective {
    /**
     * @param {?} _element
     */
    constructor(_element) {
        this._element = _element;
        this._position = IgxHintPosition.START;
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         * \@memberof IgxHintDirective
         */
        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         * \@memberof IgxHintDirective
         */
        this.isPositionEnd = false;
    }
    /**
     * Sets the position of the hint.
     * ```html
     * <igx-input-group>
     *  <input igxInput type="text"/>
     *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
     * </igx-input-group>
     * ```
     * \@memberof IgxHintDirective
     * @param {?} value
     * @return {?}
     */
    set position(value) {
        /** @type {?} */
        const position = ((/** @type {?} */ (IgxHintPosition)))[value.toUpperCase()];
        if (position !== undefined) {
            this._position = position;
            this._applyPosition(this._position);
        }
    }
    /**
     * Gets the position of the hint.
     * ```typescript
     * \@ViewChild('hint', {read: IgxHintDirective})
     * public igxHint: IgxHintDirective;
     * let hintPosition =  this.igxHint.position;
     * ```
     * \@memberof IgxHintDirective
     * @return {?}
     */
    get position() {
        return this._position.toString();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._applyPosition(this._position);
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    _applyPosition(position) {
        this.isPositionStart = this.isPositionEnd = false;
        switch (position) {
            case IgxHintPosition.START:
                this.isPositionStart = true;
                break;
            case IgxHintPosition.END:
                this.isPositionEnd = true;
                break;
            default: break;
        }
    }
}
IgxHintDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-hint,[igxHint]'
            },] }
];
/** @nocollapse */
IgxHintDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxHintDirective.propDecorators = {
    isPositionStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group__hint-item--start',] }],
    isPositionEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group__hint-item--end',] }],
    position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
class IgxInputGroupBase {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];
/** @enum {number} */
const IgxInputState = {
    INITIAL: 0,
    VALID: 1,
    INVALID: 2,
};
IgxInputState[IgxInputState.INITIAL] = 'INITIAL';
IgxInputState[IgxInputState.VALID] = 'VALID';
IgxInputState[IgxInputState.INVALID] = 'INVALID';
class IgxInputDirective {
    /**
     * @param {?} inputGroup
     * @param {?} ngModel
     * @param {?} formControl
     * @param {?} element
     * @param {?} cdr
     */
    constructor(inputGroup, ngModel, formControl, element, cdr) {
        this.inputGroup = inputGroup;
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.element = element;
        this.cdr = cdr;
        this._valid = IgxInputState.INITIAL;
        /**
         * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
         * Default value is `false`.
         * ```typescript
         * this.igxInput.isInput = true;
         * ```
         * ```typescript
         * let isCLassAdded = this.igxInput.isInput;
         * ```
         * \@memberof IgxInputDirective
         */
        this.isInput = false;
        /**
         * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
         * Default value is `false`.
         * ```typescript
         * this.igxInput.isTextArea = true;
         * ```
         * ```typescript
         * let isCLassAdded = this.igxInput.isTextArea;
         * ```
         * \@memberof IgxInputDirective
         */
        this.isTextArea = false;
    }
    /**
     * @private
     * @return {?}
     */
    get ngControl() {
        return this.ngModel ? this.ngModel : this.formControl;
    }
    /**
     * Sets the `value` property.
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [value]="'IgxInput Value'">
     * </input-group>
     * ```
     * \@memberof IgxInputDirective
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.nativeElement.value = value;
        this.checkValidity();
    }
    /**
     * Gets the `value` propery.
     * ```typescript
     * \@ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let inputValue = this.igxInput.value;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get value() {
        return this.nativeElement.value;
    }
    /**
     * Sets the `disabled` property.
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [disabled]="true">
     * </input-group>
     * ```
     * \@memberof IgxInputDirective
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this.nativeElement.disabled = value;
        this.inputGroup.disabled = value;
    }
    /**
     * Gets the `disabled` property
     * ```typescript
     * \@ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let isDisabled = this.igxInput.disabled;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get disabled() {
        return this.nativeElement.hasAttribute('disabled');
    }
    /**
     * Sets the `required` property.
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [required]="true">
     * </input-group>
     * ```
     * \@memberof IgxInputDirective
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        if (typeof value === 'boolean') {
            this.nativeElement.required = this.inputGroup.isRequired = value;
            if (value && !this.nativeElement.checkValidity()) {
                this._valid = IgxInputState.INVALID;
            }
            else {
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /**
     * Gets whether the igxInput is required.
     * ```typescript
     * let isRequired = this.igxInput.required;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get required() {
        return this.nativeElement.hasAttribute('required');
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.inputGroup.isFocused = true;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        this.inputGroup.isFocused = false;
        this._valid = IgxInputState.INITIAL;
        if (this.ngControl) {
            if (!this.ngControl.valid) {
                this._valid = IgxInputState.INVALID;
            }
        }
        else if (this._hasValidators() && !this.nativeElement.checkValidity()) {
            this._valid = IgxInputState.INVALID;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onInput() {
        this.checkValidity();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
        this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');
        this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
        // Make sure we do not invalidate the input on init
        if (!this.ngControl) {
            this._valid = IgxInputState.INITIAL;
        }
        // Also check the control's validators for required
        if (!this.inputGroup.isRequired && this.ngControl && this.ngControl.control.validator) {
            /** @type {?} */
            const validation = this.ngControl.control.validator((/** @type {?} */ ({})));
            this.inputGroup.isRequired = validation && validation.required;
        }
        /** @type {?} */
        const elTag = this.nativeElement.tagName.toLowerCase();
        if (elTag === 'textarea') {
            this.isTextArea = true;
        }
        else {
            this.isInput = true;
        }
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /**
     * Sets a focus on the igxInput.
     * ```typescript
     * this.igxInput.focus();
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    focus() {
        this.nativeElement.focus();
    }
    /**
     * Gets the `nativeElement` of the igxInput.
     * ```typescript
     * let igxInputNativeElement = this.igxInput.nativeElement;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    onStatusChanged() {
        if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
            if (this.ngControl.control.touched || this.ngControl.control.dirty) {
                //  TODO: check the logic when control is touched or dirty
                if (this.inputGroup.isFocused) {
                    // the user is still typing in the control
                    this._valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
                }
                else {
                    // the user had touched the control previously but now the value is changing due to changes in the form
                    this._valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
                }
            }
            else {
                //  if control is untouched and pristine its state is initial. This is when user did not interact
                //  with the input or when form/control is reset
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /**
     * Gets whether the igxInput has a placeholder.
     * ```typescript
     * let hasPlaceholder = this.igxInput.hasPlaceholder;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get hasPlaceholder() {
        return this.nativeElement.hasAttribute('placeholder');
    }
    /**
     * Gets the placeholder element of the igxInput.
     * ```typescript
     * let igxInputPlaceholder = this.igxInput.placeholder;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /**
     * @private
     * @return {?}
     */
    _hasValidators() {
        for (const nativeValidationAttribute of nativeValidationAttributes) {
            if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                return true;
            }
        }
        return !!this.ngControl && (!!this.ngControl.control.validator || !!this.ngControl.control.asyncValidator);
    }
    /**
     * Gets whether the igxInput is focused.
     * ```typescript
     * let isFocused = this.igxInput.focused;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get focused() {
        return this.inputGroup.isFocused;
    }
    /**
     * Gets the state of the igxInput.
     * ```typescript
     * let igxInputState = this.igxInput.valid;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get valid() {
        return this._valid;
    }
    /**
     * Gets whether the igxInput is valid.
     * ```typescript
     * let valid = this.igxInput.isValid;
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    get isValid() {
        return this.valid !== IgxInputState.INVALID;
    }
    /**
     * Sets the state of the igxInput.
     * ```typescript
     * this.igxInput.valid = IgxInputState.INVALID;
     * ```
     * \@memberof IgxInputDirective
     * @param {?} value
     * @return {?}
     */
    set valid(value) {
        this._valid = value;
    }
    /**
     * @private
     * @return {?}
     */
    checkValidity() {
        if (!this.ngControl && this._hasValidators()) {
            this._valid = this.nativeElement.checkValidity() ? IgxInputState.VALID : IgxInputState.INVALID;
        }
    }
}
IgxInputDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxInput]',
                exportAs: 'igxInput'
            },] }
];
/** @nocollapse */
IgxInputDirective.ctorParameters = () => [
    { type: IgxInputGroupBase },
    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"],] }] },
    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxInputDirective.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['value',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group__input',] }],
    isTextArea: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group__textarea',] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus', ['$event'],] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur', ['$event'],] }],
    onInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['input',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$3 = 0;
class IgxLabelDirective {
    constructor() {
        this.defaultClass = true;
        /**
         * @hidden
         */
        this.id = `igx-label-${NEXT_ID$3++}`;
    }
}
IgxLabelDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxLabel]'
            },] }
];
IgxLabelDirective.propDecorators = {
    defaultClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group__label',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxPrefixDirective {
}
IgxPrefixDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-prefix,[igxPrefix]'
            },] }
];
/**
 * @hidden
 */
class IgxPrefixModule {
}
IgxPrefixModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxPrefixDirective],
                exports: [IgxPrefixDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxSuffixDirective {
}
IgxSuffixDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-suffix,[igxSuffix]'
            },] }
];
/**
 * @hidden
 */
class IgxSuffixModule {
}
IgxSuffixModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxSuffixDirective],
                exports: [IgxSuffixDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$4 = 0;
/** @enum {number} */
const IgxInputGroupType = {
    LINE: 0,
    BOX: 1,
    BORDER: 2,
    FLUENT: 3,
    SEARCH: 4,
    FLUENT_SEARCH: 5,
};
IgxInputGroupType[IgxInputGroupType.LINE] = 'LINE';
IgxInputGroupType[IgxInputGroupType.BOX] = 'BOX';
IgxInputGroupType[IgxInputGroupType.BORDER] = 'BORDER';
IgxInputGroupType[IgxInputGroupType.FLUENT] = 'FLUENT';
IgxInputGroupType[IgxInputGroupType.SEARCH] = 'SEARCH';
IgxInputGroupType[IgxInputGroupType.FLUENT_SEARCH] = 'FLUENT_SEARCH';
class IgxInputGroupComponent extends DisplayDensityBase {
    /**
     * @param {?} _element
     * @param {?} _displayDensityOptions
     */
    constructor(_element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._element = _element;
        this._displayDensityOptions = _displayDensityOptions;
        this._type = IgxInputGroupType.LINE;
        this._filled = false;
        this._supressInputAutofocus = false;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-input-group [id]="'igx-input-group-55'"></igx-input-group>
         * ```
         */
        this.id = `igx-input-group-${NEXT_ID$4++}`;
        /**
         * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
         * By default applied the class is applied.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         * this.inputGroup.defaultClass = false;
         * ```
         * }
         */
        this.defaultClass = true;
        /**
         * @hidden
         */
        this.hasPlaceholder = false;
        /**
         * @hidden
         */
        this.isRequired = false;
        /**
         * @hidden
         */
        this.isFocused = false;
        /**
         * @hidden
         */
        this.isBox = false;
        /**
         * @hidden
         */
        this.isBorder = false;
        /**
         * @hidden
         */
        this.isSearch = false;
        /**
         * @hidden
         */
        this.isFluentSearch = false;
        /**
         * @hidden
         */
        this.isFluent = false;
        /**
         * An \@Input property that disables the `IgxInputGroupComponent`.
         * ```html
         * <igx-input-group [disabled]="'true'"></igx-input-group>
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         */
        this.hasWarning = false;
        this.element = _element;
    }
    /**
     * @hidden
     * @return {?}
     */
    get validClass() {
        return this.input.valid === IgxInputState.VALID;
    }
    /**
     * @hidden
     * @return {?}
     */
    get invalidClass() {
        return this.input.valid === IgxInputState.INVALID;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (!this._supressInputAutofocus) {
            this.input.focus();
        }
    }
    /**
     * An \@Input property that sets how the input will be styled.
     * The allowed values are `line`, `box`, `border`, `fluent`, `search` and `fluentSearch`. The default is `line`.
     * ```html
     * <igx-input-group [type]="'search'">
     * ```
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        /** @type {?} */
        const type = ((/** @type {?} */ (IgxInputGroupType)))[value.toUpperCase()];
        if (type !== undefined) {
            this.isBox = this.isFluent = this.isFluentSearch = this.isBorder = this.isSearch = false;
            switch (type) {
                case IgxInputGroupType.BOX:
                    this.isBox = true;
                    break;
                case IgxInputGroupType.BORDER:
                    this.isBorder = true;
                    break;
                case IgxInputGroupType.FLUENT:
                    this.isFluent = true;
                    break;
                case IgxInputGroupType.FLUENT_SEARCH:
                    this.isFluentSearch = true;
                    break;
                case IgxInputGroupType.SEARCH:
                    this.isSearch = true;
                    break;
                default: break;
            }
            this._type = type;
        }
    }
    /**
     * Returns whether the input element of the input group will be automatically focused on click.
     * ```typescript
     * let supressInputAutofocus = this.inputGroup.supressInputAutofocus;
     * ```
     * @return {?}
     */
    get supressInputAutofocus() {
        return this._supressInputAutofocus;
    }
    /**
     * Sets whether the input element of the input group will be automatically focused on click.
     * ```html
     * <igx-input-group [supressInputAutofocus]="true"></igx-input-group>
     * ```
     * @param {?} value
     * @return {?}
     */
    set supressInputAutofocus(value) {
        this._supressInputAutofocus = value;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isFilled() {
        return this._filled || (this.input && this.input.value);
    }
    /**
     * @hidden
     * @return {?}
     */
    get isDisplayDensityCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isDisplayDensityComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isDisplayDensityCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    /**
     * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
     * Values are `line` - 0, `box` - 1, `border` - 2,  `fluent` - 3 `fluentSearch` - 4 and `search` - 5. The default is `line`.
     * ```typescript
     * \@ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputType = this.inputGroup.type;
     * }
     * ```
     * @return {?}
     */
    get type() {
        return this._type.toString();
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has hints.
     * ```typescript
     * \@ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputHints = this.inputGroup.hasHints;
     * }
     * ```
     * @return {?}
     */
    get hasHints() {
        return this.hints.length > 0;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has border.
     * ```typescript
     * \@ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputBroder = this.inputGroup.hasBorder;
     * }
     * ```
     * @return {?}
     */
    get hasBorder() {
        return this._type === IgxInputGroupType.LINE ||
            this._type === IgxInputGroupType.BOX;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is line.
     * ```typescript
     * \@ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeLine = this.inputGroup.isTypeLine;
     * }
     * ```
     * @return {?}
     */
    get isTypeLine() {
        return this._type === IgxInputGroupType.LINE;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is box.
     * ```typescript
     * \@ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBox = this.inputGroup.isTypeBox;
     * }
     * ```
     * @return {?}
     */
    get isTypeBox() {
        return this._type === IgxInputGroupType.BOX;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is border.
     * ```typescript
     * \@ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBorder = this.inputGroup.isTypeBorder;
     * }
     * ```
     * @return {?}
     */
    get isTypeBorder() {
        return this._type === IgxInputGroupType.BORDER;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is Fluent.
     * ```typescript
     * \@ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeFluent = this.inputGroup.isTypeFluent;
     * }
     * ```
     * @return {?}
     */
    get isTypeFluent() {
        return this._type === IgxInputGroupType.FLUENT;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is search.
     * ```typescript
     * \@ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeSearch = this.inputGroup.isTypeSearch;
     * }
     * ```
     * @return {?}
     */
    get isTypeSearch() {
        return this._type === IgxInputGroupType.SEARCH;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is fluentSearch.
     * ```typescript
     * \@ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeFluentSearch = this.inputGroup.isTypeFluentSearch;
     * }
     * ```
     * @return {?}
     */
    get isTypeFluentSearch() {
        return this._type === IgxInputGroupType.FLUENT_SEARCH;
    }
    /**
     * @return {?}
     */
    get filled() {
        return this._filled;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set filled(val) {
        this._filled = val;
    }
}
IgxInputGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-input-group',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n\n<ng-template #material>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #bundle>\n\n<!--    <ng-content *ngIf=\"isTypeFluent\" select=\"[igxLabel]\"></ng-content>-->\n    <ng-container *ngIf=\"isTypeFluent\">\n        <ng-container *ngTemplateOutlet=\"material\"></ng-container>\n    </ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        <div class=\"igx-input-group__bundle-main\">\n\n                <ng-container *ngIf=\"!isTypeFluent\">\n                    <ng-container *ngTemplateOutlet=\"material\"></ng-container>\n                </ng-container>\n<!--            <ng-content *ngIf=\"!isTypeFluent\" select=\"[igxLabel]\"></ng-content>-->\n\n            <ng-content select=\"[igxInput]\"></ng-content>\n        </div>\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
                providers: [{ provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent }]
            }] }
];
/** @nocollapse */
IgxInputGroupComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxInputGroupComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    defaultClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group',] }],
    hasPlaceholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--placeholder',] }],
    isRequired: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--required',] }],
    isFocused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--focused',] }],
    isBox: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--box',] }],
    isBorder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--border',] }],
    isSearch: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--search',] }],
    isFluentSearch: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--fluent-search',] }],
    isFluent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--fluent',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--disabled',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    validClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--valid',] }],
    invalidClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--invalid',] }],
    hasWarning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--warning',] }],
    hints: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxHintDirective, { read: IgxHintDirective },] }],
    input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxInputDirective, { read: IgxInputDirective, static: true },] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['type',] }],
    supressInputAutofocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isFilled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--filled',] }],
    isDisplayDensityCosy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--cosy',] }],
    isDisplayDensityComfortable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--comfortable',] }],
    isDisplayDensityCompact: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-input-group--compact',] }]
};
/**
 * @hidden
 */
class IgxInputGroupModule {
}
IgxInputGroupModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective],
                exports: [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective, IgxPrefixDirective, IgxSuffixDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxPrefixModule, IgxSuffixModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Autocomplete** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
 *
 * The igxAutocomplete directive provides a way to enhance a text input
 * by showing a drop down of suggested options, provided by the developer.
 *
 * Example:
 * ```html
 * <input type="text" [igxAutocomplete]="townsPanel" />
 * <igx-drop-down #townsPanel>
 *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
 *         {{town}}
 *     </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
class IgxAutocompleteDirective extends IgxDropDownItemNavigationDirective {
    /**
     * @param {?} ngModel
     * @param {?} formControl
     * @param {?} group
     * @param {?} elementRef
     * @param {?} cdr
     */
    constructor(ngModel, formControl, group, elementRef, cdr) {
        super(null);
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.group = group;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.defaultSettings = {
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy({ target: this.parentElement }),
            excludePositionTarget: true
        };
        this.dropDownOpened$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * Enables/disables autocomplete component
         *
         * ```typescript
         * // get
         * let disabled = this.autocomplete.disabled;
         * ```
         * ```html
         * <!--set-->
         * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
         * ```
         * ```typescript
         * // set
         * public disabled = true;
         * ```
         */
        this.disabled = false;
        /**
         * Emitted after item from the drop down is selected
         *
         * ```html
         * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
         * ```
         */
        this.onItemSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden \@internal
         */
        this.autofill = 'off';
        /**
         * @hidden \@internal
         */
        this.role = 'combobox';
        this.select = (value) => {
            if (!value.newSelection) {
                return;
            }
            value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
            // Disable selection in the drop down, because in autocomplete we do not save selection.
            /** @type {?} */
            const newValue = value.newSelection.value;
            /** @type {?} */
            const args = { value: newValue, cancel: false };
            this.onItemSelected.emit(args);
            if (args.cancel) {
                return;
            }
            this.close();
            this.nativeElement.focus();
            // Update model after the input is re-focused, in order to have proper valid styling.
            // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
            this.model ? this.model.control.setValue(newValue) : this.nativeElement.value = newValue;
        };
        this.highlightFirstItem = () => {
            if (this.target.focusedItem) {
                this.target.focusedItem.focused = false;
                this.target.focusedItem = null;
            }
            this.target.navigateFirst();
            this.cdr.detectChanges();
        };
    }
    /**
     * @protected
     * @return {?}
     */
    get model() {
        return this.ngModel || this.formControl;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get parentElement() {
        return this.group ? this.group.element.nativeElement : this.nativeElement;
    }
    /**
     * @private
     * @return {?}
     */
    get settings() {
        /** @type {?} */
        const settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
        if (!settings.positionStrategy.settings.target) {
            /** @type {?} */
            const positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.parentElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get ariaExpanded() {
        return !this.collapsed;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get hasPopUp() {
        return 'listbox';
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get ariaOwns() {
        return this.target.listId;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get ariaActiveDescendant() {
        return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get ariaAutocomplete() {
        return 'list';
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onInput() {
        this.open();
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    onArrowDown(event) {
        event.preventDefault();
        this.open();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onTab() {
        this.close();
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    handleKeyDown(event) {
        if (!this.collapsed) {
            switch (event.key.toLowerCase()) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'home':
                case 'end':
                    return;
                default:
                    super.handleKeyDown(event);
            }
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onArrowDownKeyDown() {
        super.onArrowDownKeyDown();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onArrowUpKeyDown() {
        super.onArrowUpKeyDown();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onEndKeyDown() {
        super.onEndKeyDown();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onHomeKeyDown() {
        super.onHomeKeyDown();
    }
    /**
     * Closes autocomplete drop down
     * @return {?}
     */
    close() {
        if (this.collapsed) {
            return;
        }
        this.target.close();
        this.dropDownOpened$.next();
    }
    /**
     * Opens autocomplete drop down
     * @return {?}
     */
    open() {
        if (this.disabled || !this.collapsed) {
            return;
        }
        this.target.width = this.parentElement.clientWidth + 'px';
        this.target.open(this.settings);
        this.target.onSelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.dropDownOpened$)).subscribe(this.select);
        this.target.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(this.highlightFirstItem);
        this.target.children.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.dropDownOpened$)).subscribe(this.highlightFirstItem);
    }
    /**
     * @private
     * @return {?}
     */
    get collapsed() {
        return this.target ? this.target.collapsed : true;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.dropDownOpened$.complete();
    }
}
IgxAutocompleteDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxAutocomplete]'
            },] }
];
/** @nocollapse */
IgxAutocompleteDirective.ctorParameters = () => [
    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"],] }] },
    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"],] }] },
    { type: IgxInputGroupComponent, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxAutocompleteDirective.propDecorators = {
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxAutocomplete',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxAutocompleteDisabled',] }],
    autocompleteSettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxAutocompleteSettings',] }],
    onItemSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    autofill: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.autocomplete',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    ariaExpanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-expanded',] }],
    hasPopUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-haspopup',] }],
    ariaOwns: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-owns',] }],
    ariaActiveDescendant: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-activedescendant',] }],
    ariaAutocomplete: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-autocomplete',] }],
    onInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['input',] }],
    onArrowDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.ArrowDown', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Alt.ArrowDown', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.ArrowUp', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Alt.ArrowUp', ['$event'],] }],
    onTab: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Tab',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Shift.Tab',] }]
};
/**
 * @hidden
 */
class IgxAutocompleteModule {
}
IgxAutocompleteModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                imports: [IgxDropDownModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]],
                declarations: [IgxAutocompleteDirective],
                exports: [IgxAutocompleteDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxButtonDirective extends DisplayDensityBase {
    /**
     * @param {?} element
     * @param {?} _renderer
     * @param {?} _displayDensityOptions
     */
    constructor(element, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         */
        this._defaultType = 'flat';
        /**
         * @hidden
         */
        this._cssClassPrefix = 'igx-button';
        /**
         * Called when the button is clicked
         */
        this.buttonClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets the `role` attribute.
         * ```typescript
         * this.button.role = 'navbutton';
         * ```
         * ```typescript
         * let buttonRole =  this.button.role;
         * ```
         * \@memberof IgxButtonDirective
         */
        this.role = 'button';
        /**
         * Gets or sets whether the button is selected.
         * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
         * ```html
         * <button igxButton="flat" [selected]="button.selected"></button>
         * ```
         * \@memberof IgxButtonDirective
         */
        this.selected = false;
    }
    /**
     * Returns the underlying DOM element
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Sets the type of the button.
     * ```html
     * <button  igxButton= "icon"></button>
     * ```
     * \@memberof IgxButtonDirective
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        /** @type {?} */
        const newValue = value ? value : this._defaultType;
        if (this._type !== newValue) {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
            this._type = newValue;
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
        }
    }
    /**
     * Sets the button text color.
     * ```html
     * <button igxButton="gradient" igxButtonColor="blue"></button>
     * ```
     * \@memberof IgxButtonDirective
     * @param {?} value
     * @return {?}
     */
    set color(value) {
        this._color = value || this.nativeElement.style.color;
        this._renderer.setStyle(this.nativeElement, 'color', this._color);
    }
    /**
     * Sets the background color of the button.
     * ```html
     * <button igxButton="raised" igxButtonBackground="red"></button>
     * ```
     * \@memberof IgxButtonDirective
     * @param {?} value
     * @return {?}
     */
    set background(value) {
        this._backgroundColor = value || this._backgroundColor;
        this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
    }
    /**
     * Sets the `aria-label` attribute.
     * ```html
     * <button igxButton= "flat" igxLabel="Label"></button>
     * ```
     * \@memberof IgxButtonDirective
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        this._label = value || this._label;
        this._renderer.setAttribute(this.nativeElement, `aria-label`, this._label);
    }
    /**
     * Enables/disables the button.
     *  ```html
     * <button igxButton= "fab" [disabled]="true"></button>
     * ```
     * \@memberof IgxButtonDirective
     * @param {?} val
     * @return {?}
     */
    set disabled(val) {
        val = !!val;
        this._disabled = val;
        if (val) {
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
        else {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClassCosy() {
        return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
            this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClassCompact() {
        return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
            this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClassCosyFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClassCompactFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @return {?}
     */
    get disabledAttribute() {
        return this._disabled ? this._disabled : null;
    }
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    onClick(ev) {
        this.buttonClick.emit(ev);
    }
}
IgxButtonDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxButton]'
            },] }
];
/** @nocollapse */
IgxButtonDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxButtonDirective.propDecorators = {
    buttonClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxButton',] }],
    color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxButtonColor',] }],
    background: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxButtonBackground',] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxLabel',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClassCosy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-button--cosy',] }],
    cssClassCompact: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-button--compact',] }],
    cssClassCosyFab: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-button--fab-cosy',] }],
    cssClassCompactFab: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-button--fab-compact',] }],
    disabledAttribute: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.disabled',] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxButtonModule {
}
IgxButtonModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxButtonDirective],
                exports: [IgxButtonDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const IgxDividerType = {
    DEFAULT: 'default',
    DASHED: 'dashed',
};
/** @type {?} */
let NEXT_ID$5 = 0;
class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID$5++}`;
        /**
         * An \@Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An \@Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.DEFAULT;
        /**
         * An \@Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An \@Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    /**
     * @return {?}
     */
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     * @return {?}
     */
    get isDefault() {
        return this.type === IgxDividerType.DEFAULT;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     * @param {?} value
     * @return {?}
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     * @return {?}
     */
    get inset() {
        /** @type {?} */
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
}
IgxDividerDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            },] }
];
IgxDividerDirective.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    _inset: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['inset',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-divider',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isDashed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-divider--dashed',] }],
    middle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-divider--inset',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-divider--vertical',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inset: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.margin',] }]
};
class IgxDividerModule {
}
IgxDividerModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class IgxDefaultDropStrategy {
    /**
     * @param {?} drag
     * @param {?} drop
     * @param {?} atIndex
     * @return {?}
     */
    dropAction(drag, drop, atIndex) { }
}
// @dynamic
class IgxAppendDropStrategy {
    /**
     * @param {?} _renderer
     */
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    /**
     * @param {?} drag
     * @param {?} drop
     * @param {?} atIndex
     * @return {?}
     */
    dropAction(drag, drop, atIndex) {
        /** @type {?} */
        const dragElement = drag.element.nativeElement;
        /** @type {?} */
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        this._renderer.appendChild(dropAreaElement, dragElement);
    }
}
// @dynamic
class IgxPrependDropStrategy {
    /**
     * @param {?} _renderer
     */
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    /**
     * @param {?} drag
     * @param {?} drop
     * @param {?} atIndex
     * @return {?}
     */
    dropAction(drag, drop, atIndex) {
        /** @type {?} */
        const dragElement = drag.element.nativeElement;
        /** @type {?} */
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (dropAreaElement.children.length) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}
// @dynamic
class IgxInsertDropStrategy {
    /**
     * @param {?} _renderer
     */
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    /**
     * @param {?} drag
     * @param {?} drop
     * @param {?} atIndex
     * @return {?}
     */
    dropAction(drag, drop, atIndex) {
        if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
            return;
        }
        /** @type {?} */
        const dragElement = drag.element.nativeElement;
        /** @type {?} */
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxDragHandleDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragHandleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDragHandle]'
            },] }
];
/** @nocollapse */
IgxDragHandleDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxDragHandleDirective.propDecorators = {
    baseClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drag__handle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const RestrictDrag = {
    VERTICALLY: 0,
    HORIZONTALLY: 1,
    NONE: 2,
};
RestrictDrag[RestrictDrag.VERTICALLY] = 'VERTICALLY';
RestrictDrag[RestrictDrag.HORIZONTALLY] = 'HORIZONTALLY';
RestrictDrag[RestrictDrag.NONE] = 'NONE';
class IgxDragLocation {
    /**
     * @param {?} _pageX
     * @param {?} _pageY
     */
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
class IgxDragDirective {
    /**
     * @param {?} cdr
     * @param {?} element
     * @param {?} viewContainer
     * @param {?} zone
     * @param {?} renderer
     */
    constructor(cdr, element, viewContainer, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * An \@Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An \@Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * @deprecated Please use custom base styling instead.
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.hideBaseOnDrag = false;
        /**
         * @deprecated Please use provided transition functions in future.
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.animateOnRelease = false;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragMove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghostCreate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghostDestroy = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.transitioned = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this._baseMarginLeft = 0;
        this._baseMarginTop = 0;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._removeOnDestroy = true;
    }
    /**
     * An \@Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @param {?} value
     * @return {?}
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    /**
     * @return {?}
     */
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An \@Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @param {?} value
     * @return {?}
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    /**
     * @return {?}
     */
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    /**
     * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
     * Sets the visibility of the draggable element.
     * ```typescript
     * \@ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     this.myDrag.visible = false;
     * }
     * ```
     * @param {?} bVisible
     * @return {?}
     */
    set visible(bVisible) {
        this._visibility = bVisible ? 'visible' : 'hidden';
        this.cdr.detectChanges();
    }
    /**
     * Returns the visibility state of the draggable element.
     * ```typescript
     * \@ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     let dragVisibility = this.myDrag.visible;
     * }
     * ```
     * @return {?}
     */
    get visible() {
        return this._visibility === 'visible';
    }
    /**
     * Gets the current location of the element relative to the page.
     * @return {?}
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     * @return {?}
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     * @return {?}
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     * @return {?}
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     * @return {?}
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft;
    }
    /**
     * @hidden
     * @return {?}
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop;
    }
    /**
     * @protected
     * @return {?}
     */
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left - this.getWindowScrollLeft();
    }
    /**
     * @protected
     * @return {?}
     */
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top - this.getWindowScrollTop();
    }
    /**
     * @protected
     * @return {?}
     */
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    /**
     * @protected
     * @return {?}
     */
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    /**
     * @protected
     * @param {?} pageX
     * @return {?}
     */
    set ghostLeft(pageX) {
        // To Do: Remove requestAnimationFrame when deprecated animations inputs are removed as well.
        // We use requestAnimationFrame for the old drop animations in combination with updateDragRelativePos.
        requestAnimationFrame(() => {
            if (this.ghostElement) {
                // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
                /** @type {?} */
                const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
                // If ghost host is defined it needs to be taken into account.
                this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
            }
        });
    }
    /**
     * @protected
     * @return {?}
     */
    get ghostLeft() {
        return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
    }
    /**
     * @protected
     * @param {?} pageY
     * @return {?}
     */
    set ghostTop(pageY) {
        // To Do: Remove requestAnimationFrame when deprecated animations inputs are removed as well.
        // We use requestAnimationFrame for the old drop animations in combination with updateDragRelativePos.
        requestAnimationFrame(() => {
            if (this.ghostElement) {
                // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
                /** @type {?} */
                const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
                // If ghost host is defined it needs to be taken into account.
                this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
            }
        });
    }
    /**
     * @protected
     * @return {?}
     */
    get ghostTop() {
        return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            /** @type {?} */
            const targetElements = this.dragHandles && this.dragHandles.length ?
                this.dragHandles.map((item) => item.element.nativeElement) : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'pointerdown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'pointermove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"])), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'pointerup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'lostpointercapture').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'touchstart').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'mousedown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'touchmove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"])), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)).subscribe((res) => this.onPointerMove(res));
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'touchend').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'mousemove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"])), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)).subscribe((res) => this.onPointerMove(res));
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'mouseup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        this._baseMarginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
        this._baseMarginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
        this._baseOriginX = this.baseLeft;
        this._baseOriginY = this.baseTop;
        this._ghostStartX = this.baseLeft;
        this._ghostStartY = this.baseTop;
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param {?} newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     * @return {?}
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            /** @type {?} */
            const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            /** @type {?} */
            const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX;
            this.ghostTop = newLocation.pageY - offsetHostY;
        }
        else if (!this.ghost) {
            /** @type {?} */
            const deltaX = newLocation.pageX - this.pageX;
            /** @type {?} */
            const deltaY = newLocation.pageY - this.pageY;
            /** @type {?} */
            const transformX = this.getTransformX(this.element.nativeElement);
            /** @type {?} */
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param {?=} startLocation Start location from where the transition should start.
     * @return {?}
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param {?} target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param {?=} startLocation Start location from where the transition should start.
     * @return {?}
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
        }
        if (this.ghost && !this.ghostElement) {
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            /** @type {?} */
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                /** @type {?} */
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.getWindowScrollLeft(), targetRects.top - this.getWindowScrollTop()));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    onPointerDown(event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        /** @type {?} */
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);
        /** @type {?} */
        const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (!this._baseOriginX && !this._baseOriginY) {
            this._baseOriginX = this.baseLeft;
            this._baseOriginY = this.baseTop;
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft + this.getWindowScrollLeft() - this._startX;
        this._defaultOffsetY = this.baseTop + this.getWindowScrollTop() - this._startY;
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    onPointerMove(event) {
        if (this._clicked) {
            /** @type {?} */
            let pageX;
            /** @type {?} */
            let pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            /** @type {?} */
            const totalMovedX = pageX - this._startX;
            /** @type {?} */
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                /** @type {?} */
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX: pageX,
                    pageY: pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        /** @type {?} */
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        /** @type {?} */
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            /** @type {?} */
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            /** @type {?} */
            const setPageX = moveArgs.nextPageX;
            /** @type {?} */
            const setPageY = moveArgs.nextPageY;
            /** @type {?} */
            const updatedMovedX = setPageX - this._startX;
            /** @type {?} */
            const updatedMovedY = setPageY - this._startY;
            if (!moveArgs.cancel) {
                if (this.ghost) {
                    this.ghostLeft = this._ghostStartX + updatedMovedX;
                    this.ghostTop = this._ghostStartY + updatedMovedY;
                }
                else {
                    /** @type {?} */
                    const lastMovedX = setPageX - this._lastX;
                    /** @type {?} */
                    const lastMovedY = setPageY - this._lastY;
                    /** @type {?} */
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    /** @type {?} */
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        let pageX;
        /** @type {?} */
        let pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        /** @type {?} */
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            else if (this.animateOnRelease) {
                this.transitionToOrigin();
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param {?} event Event captured
     * @return {?}
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (this.animateOnRelease) {
                this.transitionToOrigin();
            }
            else if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} pageX Latest pointer position on the X axis relative to the page.
     * @param {?} pageY Latest pointer position on the Y axis relative to the page.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        /** @type {?} */
        let dynamicGhostRef;
        if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        /** @type {?} */
        const totalMovedX = pageX - this._startX;
        /** @type {?} */
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        /** @type {?} */
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && dynamicGhostRef) {
                dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        /** @type {?} */
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        /** @type {?} */
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        // Hide the base after the ghostElement is created, because otherwise the ghostElement will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        /** @type {?} */
        let topDropArea;
        /** @type {?} */
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        /** @type {?} */
        const elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (let i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' &&
                elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        /** @type {?} */
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    updateDragRelativePos() {
        /** @type {?} */
        let newPosX;
        /** @type {?} */
        let newPosY;
        if (this.ghost && this.ghostElement) {
            // Calculate the new ghostElement position to remain where the mouse is, so it doesn't jump
            /** @type {?} */
            const totalDraggedX = this.ghostLeft - this._ghostStartX;
            /** @type {?} */
            const totalDraggedY = this.ghostTop - this._ghostStartY;
            newPosX = this.baseLeft;
            newPosY = this.baseTop;
            /** @type {?} */
            const diffStartX = this._ghostStartX - newPosX;
            /** @type {?} */
            const diffStartY = this._ghostStartY - newPosY;
            this.ghostTop = newPosX + totalDraggedX - diffStartX;
            this.ghostLeft = newPosY + totalDraggedY - diffStartY;
        }
        else if (!this.ghost) {
            /** @type {?} */
            const totalDraggedX = this.getTransformX(this.element.nativeElement);
            /** @type {?} */
            const totalDraggedY = this.getTransformY(this.element.nativeElement);
            newPosX = this.baseLeft - totalDraggedX;
            newPosY = this.baseTop - totalDraggedY;
            /** @type {?} */
            const deltaX = this._baseOriginX - newPosX;
            /** @type {?} */
            const deltaY = this._baseOriginY - newPosY;
            this.setTransformXY(totalDraggedX + deltaX, totalDraggedY + deltaY);
        }
        this._baseOriginX = newPosX !== undefined ? newPosX : this._baseOriginX;
        this._baseOriginY = newPosY !== undefined ? newPosY : this._baseOriginY;
    }
    /**
     * @deprecated This method will be removed in future major version. Please use `transitionToOrigin` or `transitionTo`.
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usually be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    dropFinished() {
        this.updateDragRelativePos();
        if (this.animateOnRelease && this.ghostElement) {
            this.transitionToOrigin();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft;
            this._ghostStartY = this.baseTop;
            /** @type {?} */
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        /** @type {?} */
        const viewPortX = pageX - window.pageXOffset;
        /** @type {?} */
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            /** @type {?} */
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        /** @type {?} */
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    /**
     * @protected
     * @param {?} elem
     * @return {?}
     */
    getTransformX(elem) {
        /** @type {?} */
        let posX = 0;
        if (elem.style.transform) {
            /** @type {?} */
            const matrix = elem.style.transform;
            /** @type {?} */
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    /**
     * @protected
     * @param {?} elem
     * @return {?}
     */
    getTransformY(elem) {
        /** @type {?} */
        let posY = 0;
        if (elem.style.transform) {
            /** @type {?} */
            const matrix = elem.style.transform;
            /** @type {?} */
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /**
     * Method setting transformation to the base draggable element.
     * @protected
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    /**
     * @protected
     * @return {?}
     */
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    /**
     * @protected
     * @return {?}
     */
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    /**
     * @protected
     * @param {?} ghostHost
     * @return {?}
     */
    ghostHostOffsetLeft(ghostHost) {
        /** @type {?} */
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
    }
    /**
     * @protected
     * @param {?} ghostHost
     * @return {?}
     */
    ghostHostOffsetTop(ghostHost) {
        /** @type {?} */
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
        }
        return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
    }
}
IgxDragDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'drag',
                selector: '[igxDrag]'
            },] }
];
/** @nocollapse */
IgxDragDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
IgxDragDirective.propDecorators = {
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxDrag',] }],
    dragTolerance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dragChannel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ghost: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ghostClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideBaseOnDrag: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    animateOnRelease: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ghostTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ghostHost: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ghostOffsetX: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ghostOffsetY: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dragStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dragMove: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dragEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dragClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    ghostCreate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    ghostDestroy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    transitioned: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dragHandles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxDragHandleDirective,] }],
    _visibility: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.visibility',] }],
    baseClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drag',] }],
    selectDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drag--select-disabled',] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'hideBaseOnDrag' @Input property is deprecated and will be removed in future major versions.
        Alternatives to it are using the new no ghost dragging and custom base styling.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxDragDirective.prototype, "hideBaseOnDrag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'animateOnRelease' @Input property is deprecated and will be removed in future major versions.
        Please use 'transitionToOrigin' or 'transitionTo' methods instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxDragDirective.prototype, "animateOnRelease", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'visible' @Input property is deprecated and will be removed in future major versions.
        Please use native angular ways of hiding the base element using styling.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxDragDirective.prototype, "visible", null);
class IgxDropDirective {
    /**
     * @param {?} element
     * @param {?} _renderer
     * @param {?} _zone
     */
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.enter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.over = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.leave = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.dropped = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    /**
     * An \@Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * \@memberof IgxDropDirective
     * @param {?} classRef
     * @return {?}
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    /**
     * @return {?}
     */
    get dropStrategy() {
        return this._dropStrategy;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'igxDragEnter').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                .subscribe((res) => this.onDragEnter((/** @type {?} */ (res))));
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'igxDragLeave').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)).subscribe((res) => this.onDragLeave(res));
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'igxDragOver').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        /** @type {?} */
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        const offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        const offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        /** @type {?} */
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        const offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        const offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        /** @type {?} */
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        const offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        const offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        /** @type {?} */
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        const offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        const offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            /** @type {?} */
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            /** @type {?} */
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    /**
     * @protected
     * @return {?}
     */
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    /**
     * @protected
     * @param {?} drag
     * @return {?}
     */
    isDragLinked(drag) {
        /** @type {?} */
        const dragLinkArray = drag.dragChannel instanceof Array;
        /** @type {?} */
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            /** @type {?} */
            const dropLinks = (/** @type {?} */ (this.dropChannel));
            for (let i = 0; i < dropLinks.length; i++) {
                if (dropLinks[i] === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            /** @type {?} */
            const dragLinks = (/** @type {?} */ (drag.dragChannel));
            for (let i = 0; i < dragLinks.length; i++) {
                if (dragLinks[i] === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            /** @type {?} */
            const dragLinks = (/** @type {?} */ (drag.dragChannel));
            /** @type {?} */
            const dropLinks = (/** @type {?} */ (this.dropChannel));
            for (let i = 0; i < dragLinks.length; i++) {
                for (let j = 0; j < dropLinks.length; j++) {
                    if (dragLinks[i] === dropLinks[j]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * @protected
     * @param {?} draggedDir
     * @param {?} elementsAtPoint
     * @return {?}
     */
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        /** @type {?} */
        let insertIndex = -1;
        /** @type {?} */
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        /** @type {?} */
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
}
IgxDropDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'drop',
                selector: '[igxDrop]'
            },] }
];
/** @nocollapse */
IgxDropDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxDropDirective.propDecorators = {
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxDrop',] }],
    dropChannel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropStrategy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    enter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    over: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    leave: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dropped: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    droppable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.droppable',] }],
    dragover: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.dragOver',] }],
    onDragDrop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['igxDrop', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxDragDropModule {
}
IgxDragDropModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective],
                exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxFilterOptions {
    constructor() {
        // Input text value that will be used as a filtering pattern (matching condition is based on it)
        this.inputValue = '';
    }
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    /**
     * @param {?} item
     * @param {?} key
     * @return {?}
     */
    get_value(item, key) {
        /** @type {?} */
        let result = '';
        if (key && item[key]) {
            result = item[key].toString();
        }
        else if (item.element) {
            if (item.element.nativeElement) {
                result = item.element.nativeElement.textContent.trim();
                // Check if element doesn't return the DOM element directly
            }
            else if (item.element.textContent) {
                result = item.element.textContent.trim();
            }
        }
        return result;
    }
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    /**
     * @param {?} valueToTest
     * @return {?}
     */
    formatter(valueToTest) {
        return valueToTest.toLowerCase();
    }
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    /**
     * @param {?} valueToTest
     * @param {?} inputValue
     * @return {?}
     */
    matchFn(valueToTest, inputValue) {
        return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
    }
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    /**
     * @param {?} item
     * @return {?}
     */
    metConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = false;
        }
    }
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    /**
     * @param {?} item
     * @return {?}
     */
    overdueConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = true;
        }
    }
}
class IgxFilterDirective {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this.element = element;
        this.filtering = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"](false); // synchronous event emitter
        // synchronous event emitter
        this.filtered = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Detect only changes of input value
        if (changes.filterOptions &&
            changes.filterOptions.currentValue &&
            changes.filterOptions.currentValue.inputValue !== undefined &&
            changes.filterOptions.previousValue &&
            changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
            this.filter();
        }
    }
    /**
     * @private
     * @return {?}
     */
    filter() {
        if (!this.filterOptions.items) {
            return;
        }
        /** @type {?} */
        const args = { cancel: false, items: this.filterOptions.items };
        this.filtering.emit(args);
        if (args.cancel) {
            return;
        }
        /** @type {?} */
        const pipe = new IgxFilterPipe();
        /** @type {?} */
        const filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
        this.filtered.emit({ filteredItems: filtered });
    }
}
IgxFilterDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxFilter]'
            },] }
];
/** @nocollapse */
IgxFilterDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
IgxFilterDirective.propDecorators = {
    filtering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    filtered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    filterOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFilter',] }]
};
class IgxFilterPipe {
    /**
     * @param {?} items
     * @param {?} options
     * @return {?}
     */
    transform(items, 
    // options - initial settings of filter functionality
    options) {
        /** @type {?} */
        let result = [];
        if (!items || !items.length || !options) {
            return;
        }
        if (options.items) {
            items = options.items;
        }
        result = items.filter((item) => {
            /** @type {?} */
            const match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
            if (match) {
                if (options.metConditionFn) {
                    options.metConditionFn(item);
                }
            }
            else {
                if (options.overdueConditionFn) {
                    options.overdueConditionFn(item);
                }
            }
            return match;
        });
        return result;
    }
}
IgxFilterPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxFilter',
                pure: false
            },] }
];
/**
 * @hidden
 */
class IgxFilterModule {
}
IgxFilterModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxFilterDirective, IgxFilterPipe],
                exports: [IgxFilterDirective, IgxFilterPipe],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxFocusDirective {
    /**
     * @param {?} element
     * @param {?=} comp
     */
    constructor(element, comp) {
        this.element = element;
        this.comp = comp;
        this.focusState = true;
    }
    /**
     * Returns the state of the igxFocus.
     * ```typescript
     * \@ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let isFocusOn = this.igxFocus.focused;
     * ```
     * \@memberof IgxFocusDirective
     * @return {?}
     */
    get focused() {
        return this.focusState;
    }
    /**
     * Sets the state of the igxFocus.
     * ```html
     * <igx-input-group >
     *  <input #focusContainer igxInput [igxFocus]="true"/>
     * </igx-input-group>
     * ```
     * \@memberof IgxFocusDirective
     * @param {?} val
     * @return {?}
     */
    set focused(val) {
        this.focusState = val;
        this.trigger();
    }
    /**
     * Gets the native element of the igxFocus.
     * ```typescript
     * \@ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let igxFocusNativeElement = this.igxFocus.nativeElement;
     * ```
     * \@memberof IgxFocusDirective
     * @return {?}
     */
    get nativeElement() {
        if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
            return ((/** @type {?} */ (this.comp[0]))).getEditElement();
        }
        return this.element.nativeElement;
    }
    /**
     * Triggers the igxFocus state.
     * ```typescript
     * \@ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     * \@memberof IgxFocusDirective
     * @return {?}
     */
    trigger() {
        if (this.focusState) {
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
}
IgxFocusDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'igxFocus',
                selector: '[igxFocus]'
            },] }
];
/** @nocollapse */
IgxFocusDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: Array, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxFocusDirective.propDecorators = {
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFocus',] }]
};
/**
 * @hidden
 */
class IgxFocusModule {
}
IgxFocusModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxFocusDirective],
                exports: [IgxFocusDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxLayoutDirective {
    constructor() {
        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */
        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */
        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.itemAlign = 'stretch';
        /**
         * @hidden
         */
        this.display = 'flex';
    }
    /**
     * @hidden
     * @return {?}
     */
    get flexwrap() { return this.wrap; }
    /**
     * @hidden
     * @return {?}
     */
    get justifycontent() { return this.justify; }
    /**
     * @hidden
     * @return {?}
     */
    get align() { return this.itemAlign; }
    /**
     * @hidden
     * @return {?}
     */
    get direction() {
        if (this.reverse) {
            return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
        }
        return (this.dir === 'row') ? 'row' : 'column';
    }
}
IgxLayoutDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxLayout]'
            },] }
];
IgxLayoutDirective.propDecorators = {
    dir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxLayoutDir',] }],
    reverse: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxLayoutReverse',] }],
    wrap: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxLayoutWrap',] }],
    justify: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxLayoutJustify',] }],
    itemAlign: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxLayoutItemAlign',] }],
    display: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.display',] }],
    flexwrap: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flex-wrap',] }],
    justifycontent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.justify-content',] }],
    align: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.align-items',] }],
    direction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flex-direction',] }]
};
class IgxFlexDirective {
    constructor() {
        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */
        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */
        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */
        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */
        this.basis = 'auto';
    }
    /**
     * @hidden
     * @return {?}
     */
    get style() {
        if (this.flex) {
            return `${this.flex}`;
        }
        return `${this.grow} ${this.shrink} ${this.basis}`;
    }
    /**
     * @hidden
     * @return {?}
     */
    get itemorder() {
        return this.order || 0;
    }
}
IgxFlexDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxFlex]'
            },] }
];
IgxFlexDirective.propDecorators = {
    grow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFlexGrow',] }],
    shrink: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFlexShrink',] }],
    flex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFlex',] }],
    order: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFlexOrder',] }],
    basis: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxFlexBasis',] }],
    style: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flex',] }],
    itemorder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.order',] }]
};
/**
 * @hidden
 */
class IgxLayoutModule {
}
IgxLayoutModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxFlexDirective, IgxLayoutDirective],
                exports: [IgxFlexDirective, IgxLayoutDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
const MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
/**
 * @hidden
 * @type {?}
 */
const KEYS = {
    Ctrl: 17,
    Z: 90,
    Y: 89,
    X: 88,
    BACKSPACE: 8,
    DELETE: 46
};
/**
 * @hidden
 */
class MaskHelper {
    /**
     * @return {?}
     */
    get cursor() {
        return this._cursor;
    }
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @return {?}
     */
    parseValueByMask(value, maskOptions, cursor) {
        /** @type {?} */
        let inputValue = value;
        /** @type {?} */
        const mask = maskOptions.format;
        /** @type {?} */
        const literals = this.getMaskLiterals(mask);
        /** @type {?} */
        const literalKeys = Array.from(literals.keys());
        /** @type {?} */
        const nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        if (inputValue.length < mask.length) { // BACKSPACE, DELETE
            if (inputValue === '' && cursor === -1) {
                this._cursor = 0;
                return this.parseValueByMaskOnInit(value, maskOptions);
            } // workaround for IE 'x' button
            if (nonLiteralIndeces.indexOf(cursor + 1) !== -1) {
                inputValue = this.insertCharAt(inputValue, cursor + 1, maskOptions.promptChar);
                this._cursor = cursor + 1;
            }
            else {
                inputValue = this.insertCharAt(inputValue, cursor + 1, mask[cursor + 1]);
                this._cursor = cursor + 1;
                for (let i = this._cursor; i < 0; i--) {
                    if (literalKeys.indexOf(this._cursor) !== -1) {
                        this._cursor--;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        else {
            /** @type {?} */
            const char = inputValue[cursor];
            /** @type {?} */
            let isCharValid = this.validateCharOnPostion(char, cursor, mask);
            if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                inputValue = this.replaceCharAt(inputValue, cursor, '');
                if (isCharValid) {
                    inputValue = this.replaceCharAt(inputValue, cursor, char);
                    this._cursor = cursor + 1;
                }
                else {
                    this._cursor = cursor;
                }
            }
            else {
                inputValue = this.replaceCharAt(inputValue, cursor, '');
                this._cursor = ++cursor;
                for (let i = cursor; i < mask.length; i++) {
                    if (literalKeys.indexOf(this._cursor) !== -1) {
                        this._cursor = ++cursor;
                    }
                    else {
                        isCharValid = this.validateCharOnPostion(char, cursor, mask);
                        if (isCharValid) {
                            inputValue = this.replaceCharAt(inputValue, cursor, char);
                            this._cursor = ++cursor;
                            break;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        }
        return inputValue;
    }
    /**
     * @param {?} maskOptions
     * @return {?}
     */
    parseMask(maskOptions) {
        /** @type {?} */
        let outputVal = '';
        /** @type {?} */
        const mask = maskOptions.format;
        /** @type {?} */
        const literals = this.getMaskLiterals(mask);
        for (const maskSym of mask) {
            outputVal += maskOptions.promptChar;
        }
        literals.forEach((val, key) => {
            outputVal = this.replaceCharAt(outputVal, key, val);
        });
        return outputVal;
    }
    /**
     * @param {?} inputVal
     * @param {?} maskOptions
     * @return {?}
     */
    parseValueByMaskOnInit(inputVal, maskOptions) {
        /** @type {?} */
        let outputVal = '';
        /** @type {?} */
        let value = '';
        /** @type {?} */
        const mask = maskOptions.format;
        /** @type {?} */
        const literals = this.getMaskLiterals(mask);
        /** @type {?} */
        const literalKeys = Array.from(literals.keys());
        /** @type {?} */
        const nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        /** @type {?} */
        const literalValues = Array.from(literals.values());
        if (inputVal != null) {
            value = inputVal.toString();
        }
        for (const maskSym of mask) {
            outputVal += maskOptions.promptChar;
        }
        literals.forEach((val, key) => {
            outputVal = this.replaceCharAt(outputVal, key, val);
        });
        if (!value) {
            return outputVal;
        }
        /** @type {?} */
        const nonLiteralValues = this.getNonLiteralValues(value, literalValues);
        for (let i = 0; i < nonLiteralValues.length; i++) {
            /** @type {?} */
            const char = nonLiteralValues[i];
            /** @type {?} */
            const isCharValid = this.validateCharOnPostion(char, nonLiteralIndeces[i], mask);
            if (!isCharValid && char !== maskOptions.promptChar) {
                nonLiteralValues[i] = maskOptions.promptChar;
            }
        }
        if (nonLiteralValues.length > nonLiteralIndeces.length) {
            nonLiteralValues.splice(nonLiteralIndeces.length);
        }
        /** @type {?} */
        let pos = 0;
        for (const nonLiteralValue of nonLiteralValues) {
            /** @type {?} */
            const char = nonLiteralValue;
            outputVal = this.replaceCharAt(outputVal, nonLiteralIndeces[pos++], char);
        }
        return outputVal;
    }
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @return {?}
     */
    restoreValueFromMask(value, maskOptions) {
        /** @type {?} */
        let outputVal = '';
        /** @type {?} */
        const mask = maskOptions.format;
        /** @type {?} */
        const literals = this.getMaskLiterals(mask);
        /** @type {?} */
        const literalValues = Array.from(literals.values());
        for (const val of value) {
            if (literalValues.indexOf(val) === -1) {
                if (val !== maskOptions.promptChar) {
                    outputVal += val;
                }
            }
        }
        return outputVal;
    }
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @param {?} selection
     * @return {?}
     */
    parseValueByMaskUponSelection(value, maskOptions, cursor, selection) {
        /** @type {?} */
        let isCharValid;
        /** @type {?} */
        let inputValue = value;
        /** @type {?} */
        const char = inputValue[cursor];
        /** @type {?} */
        const mask = maskOptions.format;
        /** @type {?} */
        const literals = this.getMaskLiterals(mask);
        /** @type {?} */
        const literalKeys = Array.from(literals.keys());
        /** @type {?} */
        const nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        if (!this.data) {
            this._cursor = cursor < 0 ? ++cursor : cursor;
            if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                inputValue = isCharValid ? this.replaceCharAt(inputValue, this._cursor++, char) :
                    inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
                selection--;
                if (selection > 0) {
                    for (let i = 0; i < selection; i++) {
                        cursor++;
                        inputValue = nonLiteralIndeces.indexOf(cursor) !== -1 ?
                            this.insertCharAt(inputValue, cursor, maskOptions.promptChar) :
                            this.insertCharAt(inputValue, cursor, mask[cursor]);
                    }
                }
            }
            else {
                inputValue = this.replaceCharAt(inputValue, this._cursor, mask[this._cursor]);
                this._cursor++;
                selection--;
                /** @type {?} */
                let isMarked = false;
                if (selection > 0) {
                    cursor = this._cursor;
                    for (let i = 0; i < selection; i++) {
                        if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                            isCharValid = this.validateCharOnPostion(char, cursor, mask);
                            if (isCharValid && !isMarked) {
                                inputValue = this.insertCharAt(inputValue, cursor, char);
                                cursor++;
                                this._cursor++;
                                isMarked = true;
                            }
                            else {
                                inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                                cursor++;
                            }
                        }
                        else {
                            inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                            if (cursor === this._cursor) {
                                this._cursor++;
                            }
                            cursor++;
                        }
                    }
                }
            }
        }
        else {
            if (inputValue === '' && cursor === -1) {
                this._cursor = 0;
                return this.parseValueByMaskOnInit(value, maskOptions);
            } // workaround for IE 'x' button
            if (this._cursor < 0) {
                this._cursor++;
                cursor++;
            }
            cursor++;
            this._cursor = cursor;
            for (let i = 0; i < selection; i++) {
                if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                    inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                    cursor++;
                }
                else {
                    inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                    cursor++;
                }
            }
        }
        return inputValue;
    }
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @param {?} clipboardData
     * @param {?} selection
     * @return {?}
     */
    parseValueByMaskUponCopyPaste(value, maskOptions, cursor, clipboardData, selection) {
        /** @type {?} */
        let inputValue = value;
        /** @type {?} */
        const mask = maskOptions.format;
        /** @type {?} */
        const literals = this.getMaskLiterals(mask);
        /** @type {?} */
        const literalKeys = Array.from(literals.keys());
        /** @type {?} */
        const nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        /** @type {?} */
        const selectionEnd = cursor + selection;
        this._cursor = cursor;
        for (const clipboardSym of clipboardData) {
            /** @type {?} */
            const char = clipboardSym;
            if (this._cursor > mask.length) {
                return inputValue;
            }
            if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                /** @type {?} */
                const isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                if (isCharValid) {
                    inputValue = this.replaceCharAt(inputValue, this._cursor++, char);
                }
            }
            else {
                for (let i = cursor; i < mask.length; i++) {
                    if (literalKeys.indexOf(this._cursor) !== -1) {
                        this._cursor++;
                    }
                    else {
                        /** @type {?} */
                        const isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                        if (isCharValid) {
                            inputValue = this.replaceCharAt(inputValue, this._cursor++, char);
                        }
                        break;
                    }
                }
            }
            selection--;
        }
        if (selection > 0) {
            for (let i = this._cursor; i < selectionEnd; i++) {
                if (literalKeys.indexOf(this._cursor) !== -1) {
                    this._cursor++;
                }
                else {
                    inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
                }
            }
        }
        return inputValue;
    }
    /**
     * @private
     * @param {?} inputChar
     * @param {?} position
     * @param {?} mask
     * @return {?}
     */
    validateCharOnPostion(inputChar, position, mask) {
        /** @type {?} */
        let regex;
        /** @type {?} */
        let isValid;
        /** @type {?} */
        const letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        /** @type {?} */
        const letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        /** @type {?} */
        const letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        /** @type {?} */
        const letteSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        /** @type {?} */
        const digitRegEx = '[\\d]';
        /** @type {?} */
        const digitSpaceRegEx = '[\\d\\u0020]';
        /** @type {?} */
        const digitSpecialRegEx = '[\\d-\\+]';
        switch (mask.charAt(position)) {
            case 'C':
                isValid = inputChar !== '';
                break;
            case '&':
                regex = new RegExp('[\\u0020]');
                isValid = !regex.test(inputChar);
                break;
            case 'a':
                regex = new RegExp(letterDigitOrSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'A':
                regex = new RegExp(letterOrDigitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '?':
                regex = new RegExp(letteSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'L':
                regex = new RegExp(letterRegEx);
                isValid = regex.test(inputChar);
                break;
            case '0':
                regex = new RegExp(digitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '9':
                regex = new RegExp(digitSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case '#':
                regex = new RegExp(digitSpecialRegEx);
                isValid = regex.test(inputChar);
                break;
            default: {
                isValid = null;
            }
        }
        return isValid;
    }
    /**
     * @private
     * @param {?} strValue
     * @param {?} index
     * @param {?} char
     * @return {?}
     */
    replaceCharAt(strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index + 1);
        }
    }
    /**
     * @private
     * @param {?} strValue
     * @param {?} index
     * @param {?} char
     * @return {?}
     */
    insertCharAt(strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index);
        }
    }
    /**
     * @private
     * @param {?} mask
     * @return {?}
     */
    getMaskLiterals(mask) {
        /** @type {?} */
        const literals = new Map();
        for (let i = 0; i < mask.length; i++) {
            /** @type {?} */
            const char = mask.charAt(i);
            if (MASK_FLAGS.indexOf(char) === -1) {
                literals.set(i, char);
            }
        }
        return literals;
    }
    /**
     * @private
     * @param {?} mask
     * @param {?} literalKeys
     * @return {?}
     */
    getNonLiteralIndeces(mask, literalKeys) {
        /** @type {?} */
        const nonLiteralsIndeces = new Array();
        for (let i = 0; i < mask.length; i++) {
            if (literalKeys.indexOf(i) === -1) {
                nonLiteralsIndeces.push(i);
            }
        }
        return nonLiteralsIndeces;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} literalValues
     * @return {?}
     */
    getNonLiteralValues(value, literalValues) {
        /** @type {?} */
        const nonLiteralValues = new Array();
        for (const val of value) {
            if (literalValues.indexOf(val) === -1) {
                nonLiteralValues.push(val);
            }
        }
        return nonLiteralValues;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const noop = () => { };
class IgxMaskDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Emits an event each time the value changes.
         * Provides `rawValue: string` and `formattedValue: string` as event arguments.
         * ```html
         * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
         * ```
         */
        this.onValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this._maskOptions = {
            format: '',
            promptChar: ''
        };
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
        this.maskHelper = new MaskHelper();
    }
    /**
     * Specifies a placeholder.
     * ```html
     * <input placeholder = "enter text...">
     * ```
     * \@memberof IgxMaskDirective
     * @param {?} val
     * @return {?}
     */
    set placeholder(val) {
        this._placeholder = val;
        this.nativeElement.setAttribute('placeholder', this._placeholder);
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    get value() {
        return this.nativeElement.value;
    }
    /**
     * @hidden
     * @private
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        this.nativeElement.value = val;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    get selectionStart() {
        return this.nativeElement.selectionStart;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    get selectionEnd() {
        return this.nativeElement.selectionEnd;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.promptChar && this.promptChar.length > 1) {
            this._maskOptions.promptChar = this.promptChar = this.promptChar.substring(0, 1);
        }
        this._maskOptions.format = this.mask ? this.mask : 'CCCCCCCCCC';
        this._maskOptions.promptChar = this.promptChar ? this.promptChar : '_';
        this.nativeElement.setAttribute('placeholder', this.placeholder ? this.placeholder : this._maskOptions.format);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        /** @type {?} */
        const key = event.keyCode || event.charCode;
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
        }
        if (key === KEYS.Ctrl) {
            this._ctrlDown = true;
        }
        if ((this._ctrlDown && key === KEYS.Z) || (this._ctrlDown && key === KEYS.Y)) {
            event.preventDefault();
        }
        this._key = key;
        this._selection = Math.abs(this.selectionEnd - this.selectionStart);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeyup(event) {
        /** @type {?} */
        const key = event.keyCode || event.charCode;
        if (key === KEYS.Ctrl) {
            this._ctrlDown = false;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onPaste(event) {
        this._paste = true;
        this._valOnPaste = this.value;
        this._cursorOnPaste = this.getCursorPosition();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onInputChanged(event) {
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
            return;
        }
        if (this._paste) {
            this._paste = false;
            /** @type {?} */
            const clipboardData = this.value.substring(this._cursorOnPaste, this.getCursorPosition());
            this.value = this.maskHelper.parseValueByMaskUponCopyPaste(this._valOnPaste, this._maskOptions, this._cursorOnPaste, clipboardData, this._selection);
            this.setCursorPosition(this.maskHelper.cursor);
        }
        else {
            /** @type {?} */
            const currentCursorPos = this.getCursorPosition();
            this.maskHelper.data = (this._key === KEYS.BACKSPACE) || (this._key === KEYS.DELETE);
            this.value = this._selection && this._selection !== 0 ?
                this.maskHelper.parseValueByMaskUponSelection(this.value, this._maskOptions, currentCursorPos - 1, this._selection) :
                this.maskHelper.parseValueByMask(this.value, this._maskOptions, currentCursorPos - 1);
            this.setCursorPosition(this.maskHelper.cursor);
        }
        /** @type {?} */
        const rawVal = this.maskHelper.restoreValueFromMask(this.value, this._maskOptions);
        this.dataValue = this.includeLiterals ? this.value : rawVal;
        this._onChangeCallback(this.dataValue);
        this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.value });
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    onFocus(value) {
        if (this.focusedValuePipe) {
            if (isIE()) {
                this._stopPropagation = true;
            }
            this.value = this.focusedValuePipe.transform(value);
        }
        else {
            this.value = this.maskHelper.parseValueByMaskOnInit(this.value, this._maskOptions);
        }
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    onBlur(value) {
        if (this.displayValuePipe) {
            this.value = this.displayValuePipe.transform(value);
        }
        else if (value === this.maskHelper.parseMask(this._maskOptions)) {
            this.value = '';
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    getCursorPosition() {
        return this.nativeElement.selectionStart;
    }
    /**
     * @hidden
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    setCursorPosition(start, end = start) {
        this.nativeElement.setSelectionRange(start, end);
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.promptChar && this.promptChar.length > 1) {
            this._maskOptions.promptChar = this.promptChar.substring(0, 1);
        }
        this.value = value ? this.maskHelper.parseValueByMaskOnInit(value, this._maskOptions) : '';
        if (this.displayValuePipe) {
            this.value = this.displayValuePipe.transform(this.value);
        }
        this.dataValue = this.includeLiterals ? this.value : value;
        this._onChangeCallback(this.dataValue);
        this.onValueChange.emit({ rawValue: value, formattedValue: this.value });
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
}
IgxMaskDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxMaskDirective, multi: true }],
                selector: '[igxMask]'
            },] }
];
/** @nocollapse */
IgxMaskDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxMaskDirective.propDecorators = {
    mask: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxMask',] }],
    promptChar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    includeLiterals: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayValuePipe: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    focusedValuePipe: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dataValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onValueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onKeydown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }],
    onKeyup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keyup', ['$event'],] }],
    onPaste: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['paste', ['$event'],] }],
    onInputChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['input', ['$event'],] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus', ['$event.target.value'],] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur', ['$event.target.value'],] }]
};
/**
 * @hidden
 */
class IgxMaskModule {
}
IgxMaskModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxMaskDirective],
                exports: [IgxMaskDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const RadioLabelPosition = {
    BEFORE: 'before',
    AFTER: 'after',
};
/** @type {?} */
let nextId = 0;
/** @type {?} */
const noop$1 = () => { };
/**
 * **Ignite UI for Angular Radio Button** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio>
 *   Simple radio button
 * </igx-radio>
 * ```
 */
class IgxRadioComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the radio component.
         * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
         * ```html
         * <igx-radio id = "my-first-radio"></igx-radio>
         * ```
         * ```typescript
         * let radioId =  this.radio.id;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.id = `igx-radio-${nextId++}`;
        /**
         * Sets/gets the id of the `label` element in the radio component.
         * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
         * ```html
         * <igx-radio labelId = "Label1"></igx-radio>
         * ```
         * ```typescript
         * let labelId =  this.radio.labelId;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the position of the `label` in the radio component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio labelPosition = "before"></igx-radio>
         * ```
         * ```typescript
         * let labelPosition =  this.radio.labelPosition;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.labelPosition = 'after';
        /**
         * Sets the value of the `tabindex` attribute.
         * ```html
         * <igx-radio [tabindex] = "1"></igx-radio>
         * ```
         * ```typescript
         * let tabIndex =  this.radio.tabindex;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.tabindex = null;
        /**
         * Enables/disables the ripple effect on the radio button..
         * If not set, the `disableRipple` will have value `false`.
         * ```html
         * <igx-radio [disableRipple] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabledRipple =  this.radio.disableRipple;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the radio button is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio [required] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isRequired =  this.radio.required;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute of the radio component.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-radio aria-labelledby = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.radio.ariaLabelledBy;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the `aria-label` attribute of the radio component.
         * ```html
         * <igx-radio aria-label = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabel =  this.radio.ariaLabel;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the radio `value` is changed.
         * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
         * \@memberof IgxRadioComponent
         */
        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Returns the class of the radio component.
         * ```typescript
         * let radioClass = this.radio.cssClass;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.cssClass = 'igx-radio';
        /**
         * Sets/gets  the `checked` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [checked] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isChecked =  this.radio.checked;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.checked = false;
        /**
         * Sets/gets  the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [disabled] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabled =  this.radio.disabled;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the radio component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.radio.focus = true;
         * ```
         * ```typescript
         * let isFocused =  this.radio.focused;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._value = null;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$1;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$1;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onRadioChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onRadioClick(event) {
        event.stopPropagation();
        this.select();
        if (isIE()) {
            this.nativeRadio.nativeElement.blur();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    _onLabelClick() {
        this.select();
    }
    /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     * \@memberof IgxRadioComponent
     * @return {?}
     */
    select() {
        if (this.disabled) {
            return;
        }
        this.checked = true;
        this.focused = false;
        this.change.emit({ value: this.value, radio: this });
        this._onChangeCallback(this.value);
    }
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._value = value;
        this.checked = (this._value === this.value);
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.nativeRadio.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get labelClass() {
        switch (this.labelPosition) {
            case RadioLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case RadioLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.focused = true;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
}
IgxRadioComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxRadioComponent, multi: true }],
                selector: 'igx-radio',
                template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (click)=\"_onRadioClick($event)\"\n    (change)=\"_onRadioChange($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [id]=\"labelId\"\n    [class]=\"labelClass\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
            }] }
];
/** @nocollapse */
IgxRadioComponent.ctorParameters = () => [];
IgxRadioComponent.propDecorators = {
    nativeRadio: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['radio', { static: true },] }],
    nativeLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['nativeLabel', { static: true },] }],
    placeholderLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['placeholderLabel', { static: true },] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ariaLabelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-labelledby',] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-label',] }],
    change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-radio',] }],
    checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-radio--checked',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-radio--disabled',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-radio--focused',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxRippleDirective {
    /**
     * @param {?} builder
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} zone
     */
    constructor(builder, elementRef, renderer, zone) {
        this.builder = builder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        /**
         * Sets/gets the ripple target.
         * ```html
         * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleTarget = this.ripple.rippleTarget;
         * ```
         * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
         * ```html
         * <div #rippleContainer [igxRippleTarget] = "'#child"'>
         *  <button id="child">Click</button>
         * </div>
         * ```
         * \@memberof IgxRippleDirective
         */
        this.rippleTarget = '';
        /**
         * Sets/gets the ripple duration(in milliseconds).
         * Default value is `600`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleDuration = this.ripple.rippleDuration;
         * ```
         * \@memberof IgxRippleDirective
         */
        this.rippleDuration = 600;
        /**
         * Sets/gets whether the ripple is disabled.
         * Default value is `false`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let isRippleDisabled = this.ripple.rippleDisabled;
         * ```
         * \@memberof IgxRippleDirective
         */
        this.rippleDisabled = false;
        this.rippleElementClass = 'igx-ripple__inner';
        this.rippleHostClass = 'igx-ripple';
        this._centered = false;
        this.animationQueue = [];
    }
    /**
     * Enables/disables the ripple to be centered.
     * ```html
     * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
     * ```
     * \@memberof IgxRippleDirective
     * @param {?} value
     * @return {?}
     */
    set centered(value) {
        this._centered = value || this.centered;
    }
    /**
     * @protected
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        this.zone.runOutsideAngular(() => this._ripple(event));
    }
    /**
     * @private
     * @param {?} rippleElement
     * @param {?} styleParams
     * @return {?}
     */
    setStyles(rippleElement, styleParams) {
        this.renderer.addClass(rippleElement, this.rippleElementClass);
        this.renderer.setStyle(rippleElement, 'width', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'height', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'top', `${styleParams.top}px`);
        this.renderer.setStyle(rippleElement, 'left', `${styleParams.left}px`);
        if (this.rippleColor) {
            this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _ripple(event) {
        if (this.rippleDisabled) {
            return;
        }
        /** @type {?} */
        const target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
        /** @type {?} */
        const rectBounds = target.getBoundingClientRect();
        /** @type {?} */
        const radius = Math.max(rectBounds.width, rectBounds.height);
        /** @type {?} */
        let left = event.clientX - rectBounds.left - radius / 2;
        /** @type {?} */
        let top = event.clientY - rectBounds.top - radius / 2;
        if (this._centered) {
            left = top = 0;
        }
        /** @type {?} */
        const dimensions = {
            radius,
            top,
            left
        };
        /** @type {?} */
        const rippleElement = this.renderer.createElement('span');
        this.setStyles(rippleElement, dimensions);
        this.renderer.addClass(target, this.rippleHostClass);
        this.renderer.appendChild(target, rippleElement);
        /** @type {?} */
        const animation = this.builder.build([
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0.5, transform: 'scale(.3)' }),
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(this.rippleDuration, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(2)' }))
        ]).create(rippleElement);
        this.animationQueue.push(animation);
        animation.onDone(() => {
            this.animationQueue.splice(this.animationQueue.indexOf(animation), 1);
            target.removeChild(rippleElement);
            if (this.animationQueue.length < 1) {
                this.renderer.removeClass(target, this.rippleHostClass);
            }
        });
        animation.play();
    }
}
IgxRippleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRipple]'
            },] }
];
/** @nocollapse */
IgxRippleDirective.ctorParameters = () => [
    { type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxRippleDirective.propDecorators = {
    rippleTarget: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxRippleTarget',] }],
    rippleColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxRipple',] }],
    rippleDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxRippleDuration',] }],
    centered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxRippleCentered',] }],
    rippleDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxRippleDisabled',] }],
    onMouseDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mousedown', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxRippleModule {
}
IgxRippleModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxRippleDirective],
                exports: [IgxRippleDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const noop$2 = () => { };
/** @type {?} */
let nextId$1 = 0;
/**
 * **Ignite UI for Angular Radio Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio-group name="radioGroup">
 *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
 *      {{item}}
 *   </igx-radio>
 * </igx-radio-group>
 * ```
 */
class IgxRadioGroupDirective {
    constructor() {
        /**
         * An event that is emitted after the radio group `value` is changed.
         * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
         * \@memberof IgxRadioGroupDirective
         */
        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.cssClass = 'igx-radio-group';
        /**
         * @hidden
         */
        this._onChangeCallback = noop$2;
        /**
         * @hidden
         */
        this._name = `igx-radio-group-${nextId$1++}`;
        /**
         * @hidden
         */
        this._value = null;
        /**
         * @hidden
         */
        this._selected = null;
        /**
         * @hidden
         */
        this._isInitialized = false;
        /**
         * @hidden
         */
        this._labelPosition = 'after';
        /**
         * @hidden
         */
        this._disabled = false;
        /**
         * @hidden
         */
        this._required = false;
        /**
         * @hidden
         */
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
    }
    /**
     * Sets/gets the `value` attribute.
     * ```html
     * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
     * ```
     * ```typescript
     * let value =  this.radioGroup.value;
     * ```
     * \@memberof IgxRadioGroupDirective
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (this._value !== newValue) {
            this._value = newValue;
            this._selectRadioButton();
        }
    }
    /**
     * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
     * ```html
     * <igx-radio-group name = "Radio1"></igx-radio-group>
     *  ```
     * ```typescript
     * let name =  this.radioGroup.name;
     * ```
     * \@memberof IgxRadioGroupDirective
     * @return {?}
     */
    get name() { return this._name; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set name(newValue) {
        if (this._name !== newValue) {
            this._name = newValue;
            this._setRadioButtonNames();
        }
    }
    /**
     * Sets/gets whether the radio group is required.
     * If not set, `required` will have value `false`.
     * ```html
     * <igx-radio-group [required] = "true"></igx-radio-group>
     * ```
     * ```typescript
     * let isRequired =  this.radioGroup.required;
     * ```
     * \@memberof IgxRadioGroupDirective
     * @return {?}
     */
    get required() { return this._required; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set required(newValue) {
        if (this._required !== newValue) {
            this._required = newValue;
            this._setRadioButtonsRequired();
        }
    }
    /**
     * An \@Input property that allows you to disable the radio group. By default it's false.
     * ```html
     * <igx-radio-group [disabled]="true"></igx-radio-group>
     * ```
     * \@memberof IgxRadioGroupDirective
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set disabled(newValue) {
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._disableRadioButtons();
        }
    }
    /**
     * Sets/gets the position of the `label` in the child radio buttons.
     * If not set, `labelPosition` will have value `"after"`.
     * ```html
     * <igx-radio-group labelPosition = "before"></igx-radio-group>
     * ```
     * ```typescript
     * let labelPosition =  this.radioGroup.labelPosition;
     * ```
     * \@memberof IgxRadioGroupDirective
     * @return {?}
     */
    get labelPosition() { return this._labelPosition; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set labelPosition(newValue) {
        if (this._labelPosition !== newValue) {
            this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;
            this._setRadioButtonLabelPosition();
        }
    }
    /**
     * Sets/gets the selected child radio button.
     * ```typescript
     * let selectedButton = this.radioGroup.selected;
     * this.radioGroup.selected = selectedButton;
     * ```
     * \@memberof IgxRadioGroupDirective
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} selected
     * @return {?}
     */
    set selected(selected) {
        if (this._selected !== selected) {
            this._selected = selected;
            this.value = selected ? selected.value : null;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // The initial value can possibly be set by NgModel and it is possible that
        // the OnInit of the NgModel occurs after the OnInit of this class.
        this._isInitialized = true;
        setTimeout(() => { this._initRadioButtons(); });
    }
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.registerOnTouched(fn);
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _initRadioButtons() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.name = this._name;
                button.labelPosition = this._labelPosition;
                button.disabled = this._disabled;
                button.required = this._required;
                if (this._value && button.value === this._value) {
                    button.checked = true;
                    this._selected = button;
                }
                button.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((ev) => this._selectedRadioButtonChanged(ev));
            });
        }
    }
    /**
     * @hidden
     * @private
     * @param {?} args
     * @return {?}
     */
    _selectedRadioButtonChanged(args) {
        if (this._selected !== args.radio) {
            if (this._selected) {
                this._selected.checked = false;
            }
            this._selected = args.radio;
        }
        this._value = args.value;
        if (this._isInitialized) {
            this.change.emit(args);
            this._onChangeCallback(this.value);
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _setRadioButtonNames() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.name = this._name;
            });
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _selectRadioButton() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                if (!this._value) {
                    // no value - uncheck all radio buttons
                    if (button.checked) {
                        button.checked = false;
                    }
                }
                else {
                    if (this._value === button.value) {
                        // selected button
                        if (this._selected !== button) {
                            this._selected = button;
                        }
                        if (!button.checked) {
                            button.select();
                        }
                    }
                    else {
                        // non-selected button
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                }
            });
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _setRadioButtonLabelPosition() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.labelPosition = this._labelPosition;
            });
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _disableRadioButtons() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.disabled = this._disabled;
            });
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _setRadioButtonsRequired() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.required = this._required;
            });
        }
    }
}
IgxRadioGroupDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-radio-group, [igxRadioGroup]',
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxRadioGroupDirective, multi: true }]
            },] }
];
IgxRadioGroupDirective.propDecorators = {
    radioButtons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxRadioComponent,] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-radio-group',] }]
};
/**
 * @hidden
 */
class IgxRadioModule {
}
IgxRadioModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                exports: [IgxRadioGroupDirective, IgxRadioComponent],
                imports: [IgxRippleModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTextHighlightDirective {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this._div = null;
        this._observer = null;
        this._nodeWasRemoved = false;
        this._forceEvaluation = false;
        this._activeElementIndex = -1;
        this._defaultCssClass = 'igx-highlight';
        this._defaultActiveCssClass = 'igx-highlight--active';
        /**
         * Identifies the highlight within a unique group.
         * This allows it to have several different highlight groups,
         * with each of them having their own active highlight.
         *
         * ```html
         * <div
         *   igxTextHighlight
         *   [groupName]="myGroupName">
         * </div>
         * ```
         */
        this.groupName = '';
        this._value = '';
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        IgxTextHighlightDirective.onActiveElementChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((groupName) => {
            if (this.groupName === groupName) {
                if (this._activeElementIndex !== -1) {
                    this.deactivate();
                }
                this.activateIfNecessary();
            }
        });
    }
    /**
     * The underlying value of the element that will be highlighted.
     *
     * ```typescript
     * // get
     * const elementValue = this.textHighlight.value;
     * ```
     *
     * ```html
     * <!--set-->
     * <div
     *   igxTextHighlight
     *   [value]="newValue">
     * </div>
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value === undefined || value === null) {
            this._value = '';
        }
        else {
            this._value = value;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get lastSearchInfo() {
        return this._lastSearchInfo;
    }
    /**
     * Activates the highlight at a given index.
     * (if such index exists)
     * @param {?} groupName
     * @param {?} highlight
     * @return {?}
     */
    static setActiveHighlight(groupName, highlight) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    }
    /**
     * Clears any existing highlight.
     * @param {?} groupName
     * @return {?}
     */
    static clearActiveHighlight(groupName) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {
            index: -1
        });
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.clearHighlight();
        if (this._observer !== null) {
            this._observer.disconnect();
        }
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            this._valueChanged = true;
        }
        else if ((changes.row !== undefined && !changes.row.firstChange) ||
            (changes.column !== undefined && !changes.column.firstChange) ||
            (changes.page !== undefined && !changes.page.firstChange)) {
            if (this._activeElementIndex !== -1) {
                this.deactivate();
            }
            this.activateIfNecessary();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.parentElement = this.renderer.parentNode(this.element.nativeElement);
        if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {
            IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {
                index: -1
            });
        }
        this._lastSearchInfo = {
            searchedText: '',
            content: this.value,
            matchCount: 0,
            caseSensitive: false,
            exactMatch: false
        };
        this._container = this.parentElement.firstElementChild;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this._valueChanged) {
            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            this.activateIfNecessary();
            this._valueChanged = false;
        }
    }
    /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    highlight(text, caseSensitive, exactMatch) {
        /** @type {?} */
        const caseSensitiveResolved = caseSensitive ? true : false;
        /** @type {?} */
        const exactMatchResolved = exactMatch ? true : false;
        if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
            this._lastSearchInfo.content = this.value;
            if (text === '' || text === undefined || text === null) {
                this.clearHighlight();
            }
            else {
                this.clearChildElements(true);
                this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
            }
        }
        else if (this._nodeWasRemoved) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
        }
        return this._lastSearchInfo.matchCount;
    }
    /**
     * Clears any existing highlight.
     * @return {?}
     */
    clearHighlight() {
        this.clearChildElements(false);
        this._lastSearchInfo.searchedText = '';
        this._lastSearchInfo.matchCount = 0;
    }
    /**
     * Activates the highlight if it is on the currently active row, column and page.
     * @return {?}
     */
    activateIfNecessary() {
        /** @type {?} */
        const group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);
        /** @type {?} */
        const column = group.columnIndex === undefined ? group.column : group.columnIndex;
        /** @type {?} */
        const row = group.rowIndex === undefined ? group.row : group.rowIndex;
        if (column === this.column && row === this.row && group.page === this.page) {
            this.activate(group.index);
        }
    }
    /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     * @return {?}
     */
    observe() {
        if (this._observer === null) {
            /** @type {?} */
            const callback = (mutationList) => {
                mutationList.forEach((mutation) => {
                    /** @type {?} */
                    const removedNodes = Array.from(mutation.removedNodes);
                    removedNodes.forEach((n) => {
                        if (n === this._container) {
                            this._nodeWasRemoved = true;
                            this.clearChildElements(false);
                        }
                    });
                    /** @type {?} */
                    const addedNodes = Array.from(mutation.addedNodes);
                    addedNodes.forEach((n) => {
                        if (n === this.parentElement.firstElementChild && this._nodeWasRemoved) {
                            this._container = this.parentElement.firstElementChild;
                            this._nodeWasRemoved = false;
                            this._forceEvaluation = true;
                            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
                            this._forceEvaluation = false;
                            this.activateIfNecessary();
                            this._observer.disconnect();
                            this._observer = null;
                        }
                    });
                });
            };
            this._observer = new MutationObserver(callback);
            this._observer.observe(this.parentElement, { childList: true });
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    activate(index) {
        this.deactivate();
        if (this._div !== null) {
            /** @type {?} */
            const spans = this._div.querySelectorAll('span');
            this._activeElementIndex = index;
            if (spans.length <= index) {
                return;
            }
            /** @type {?} */
            const elementToActivate = spans[index];
            this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
            this.renderer.addClass(elementToActivate, this.activeCssClass);
        }
    }
    /**
     * @private
     * @return {?}
     */
    deactivate() {
        if (this._activeElementIndex === -1) {
            return;
        }
        /** @type {?} */
        const spans = this._div.querySelectorAll('span');
        if (spans.length <= this._activeElementIndex) {
            this._activeElementIndex = -1;
            return;
        }
        /** @type {?} */
        const elementToDeactivate = spans[this._activeElementIndex];
        this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
        this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
        this._activeElementIndex = -1;
    }
    /**
     * @private
     * @param {?} originalContentHidden
     * @return {?}
     */
    clearChildElements(originalContentHidden) {
        this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
        if (this._div !== null) {
            this.renderer.removeChild(this.parentElement, this._div);
            this._div = null;
            this._activeElementIndex = -1;
        }
    }
    /**
     * @private
     * @param {?} searchText
     * @param {?} caseSensitive
     * @param {?} exactMatch
     * @return {?}
     */
    getHighlightedText(searchText, caseSensitive, exactMatch) {
        this.appendDiv();
        /** @type {?} */
        const stringValue = String(this.value);
        /** @type {?} */
        const contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
        /** @type {?} */
        const searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
        /** @type {?} */
        let matchCount = 0;
        if (exactMatch) {
            if (contentStringResolved === searchTextResolved) {
                // tslint:disable-next-line:max-line-length
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue}</span>`);
                matchCount++;
            }
            else {
                this.appendText(stringValue);
            }
        }
        else {
            /** @type {?} */
            let foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
            /** @type {?} */
            let previousMatchEnd = 0;
            while (foundIndex !== -1) {
                /** @type {?} */
                const start = foundIndex;
                /** @type {?} */
                const end = foundIndex + searchTextResolved.length;
                this.appendText(stringValue.substring(previousMatchEnd, start));
                // tslint:disable-next-line:max-line-length
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue.substring(start, end)}</span>`);
                previousMatchEnd = end;
                matchCount++;
                foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
            }
            this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
        }
        return matchCount;
    }
    /**
     * @private
     * @param {?} text
     * @return {?}
     */
    appendText(text) {
        /** @type {?} */
        const textElement = this.renderer.createText(text);
        this.renderer.appendChild(this._div, textElement);
    }
    /**
     * @private
     * @param {?} outerHTML
     * @return {?}
     */
    appendSpan(outerHTML) {
        /** @type {?} */
        const span = this.renderer.createElement('span');
        this.renderer.appendChild(this._div, span);
        this.renderer.setProperty(span, 'outerHTML', outerHTML);
    }
    /**
     * @private
     * @return {?}
     */
    appendDiv() {
        this._div = this.renderer.createElement('div');
        if (this.containerClass) {
            this.renderer.addClass(this._div, this.containerClass);
        }
        this.renderer.appendChild(this.parentElement, this._div);
    }
    /**
     * @private
     * @param {?} text
     * @param {?} caseSensitive
     * @param {?} exactMatch
     * @return {?}
     */
    searchNeedsEvaluation(text, caseSensitive, exactMatch) {
        /** @type {?} */
        const searchedText = this._lastSearchInfo.searchedText;
        return !this._nodeWasRemoved &&
            (searchedText === null ||
                searchedText !== text ||
                this._lastSearchInfo.content !== this.value ||
                this._lastSearchInfo.caseSensitive !== caseSensitive ||
                this._lastSearchInfo.exactMatch !== exactMatch ||
                this._forceEvaluation);
    }
}
IgxTextHighlightDirective.onActiveElementChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
IgxTextHighlightDirective.highlightGroupsMap = new Map();
IgxTextHighlightDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxTextHighlight]'
            },] }
];
/** @nocollapse */
IgxTextHighlightDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
IgxTextHighlightDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cssClass',] }],
    activeCssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['activeCssClass',] }],
    containerClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['containerClass',] }],
    groupName: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['groupName',] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['value',] }],
    row: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['row',] }],
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['column',] }],
    page: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['page',] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`IgxTextHighlightDirective 'page' input property is deprecated.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Number)
], IgxTextHighlightDirective.prototype, "page", void 0);
/**
 * @hidden
 */
class IgxTextHighlightModule {
}
IgxTextHighlightModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxTextHighlightDirective],
                exports: [IgxTextHighlightDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTextSelectionDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.selectionState = true;
    }
    /**
     * Returns whether the input element is selectable through the directive.
     *
     * ```typescript
     * // get
     * \@ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public firstName: IgxTextSelectionDirective;
     *
     * public getFirstNameSelectionStatus() {
     *  return this.firstName.selected;
     * }
     * ```
     * @return {?}
     */
    get selected() {
        return this.selectionState;
    }
    /**
     *  Determines whether the input element could be selected through the directive.
     *
     * ```html
     * <!--set-->
     * <input
     *   type="text"
     *   id="firstName"
     *   [igxTextSelection]="true">
     * </input>
     *
     * <input
     *   type="text"
     *   id="lastName"
     *   igxTextSelection
     *   [selected]="true">
     * </input>
     * ```
     * @param {?} val
     * @return {?}
     */
    set selected(val) {
        this.selectionState = val;
    }
    /**
     * Returns the nativeElement of the element where the directive was applied.
     *
     * ```html
     * <input
     *   type="text"
     *    id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * \@ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public getNativeElement() {
     *  return this.inputElement.nativeElement;
     * }
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    onFocus() {
        this.trigger();
    }
    /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * \@ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     * @return {?}
     */
    trigger() {
        if (this.selected && this.nativeElement.value.length) {
            requestAnimationFrame(() => this.nativeElement.setSelectionRange(0, this.nativeElement.value.length));
        }
    }
}
IgxTextSelectionDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'igxTextSelection',
                selector: '[igxTextSelection]'
            },] }
];
/** @nocollapse */
IgxTextSelectionDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxTextSelectionDirective.propDecorators = {
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxTextSelection',] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus',] }]
};
/**
 * @hidden
 */
class IgxTextSelectionModule {
}
IgxTextSelectionModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxTextSelectionDirective],
                exports: [IgxTextSelectionDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Tooltip Target** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
 *
 * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
 * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
 * target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
class IgxTooltipTargetDirective extends IgxToggleActionDirective {
    /**
     * @param {?} _element
     * @param {?} _navigationService
     */
    constructor(_element, _navigationService) {
        super(_element, _navigationService);
        this._element = _element;
        this._navigationService = _navigationService;
        /**
         * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipShowDelay = this.tooltipTarget.showDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.showDelay = 500;
        /**
         * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipHideDelay = this.tooltipTarget.hideDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.hideDelay = 500;
        /**
         * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
         * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
         * the developer will still be able to show/hide the tooltip through the API.
         *
         * ```typescript
         * // get
         * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.tooltipDisabled = false;
        /**
         * Emits an event when the tooltip that is associated with this target starts showing.
         * This event is fired before the start of the countdown to showing the tooltip.
         *
         * ```typescript
         * tooltipShowing(args: ITooltipShowEventArgs) {
         *    alert("Tooltip started showing!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipShow)='tooltipShowing($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.onTooltipShow = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the tooltip that is associated with this target starts hiding.
         * This event is fired before the start of the countdown to hiding the tooltip.
         *
         * ```typescript
         * tooltipHiding(args: ITooltipHideEventArgs) {
         *    alert("Tooltip started hiding!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipHide)='tooltipHiding($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.onTooltipHide = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @hidden
     * @param {?} target
     * @return {?}
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get target() {
        if (typeof this._target === 'string') {
            return this._navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * Gets the respective native element of the directive.
     *
     * ```typescript
     * let tooltipTargetElement = this.tooltipTarget.nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Indicates if the tooltip that is is associated with this target is currently hidden.
     *
     * ```typescript
     * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
     * ```
     * @return {?}
     */
    get tooltipHidden() {
        return !this.target || this.target.collapsed;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        /** @type {?} */
        const positionSettings = {
            target: this.nativeElement,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            openAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(scaleInCenter, { params: { duration: '150ms' } }),
            closeAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeOut, { params: { duration: '75ms' } })
        };
        this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
        this._overlayDefaults.closeOnOutsideClick = false;
    }
    /**
     * @private
     * @return {?}
     */
    checkOutletAndOutsideClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
    }
    /**
     * @private
     * @return {?}
     */
    get mergedOverlaySettings() {
        return Object.assign({}, this._overlayDefaults, this.overlaySettings);
    }
    // Return true if the execution in onMouseEnter should be terminated after this method
    /**
     * @private
     * @return {?}
     */
    preMouseEnterCheck() {
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
            this.target.toBeShown = false;
        }
        // If Tooltip is opened or about to be hidden
        if (!this.target.collapsed || this.target.toBeHidden) {
            clearTimeout(this.target.timeoutId);
            /** @type {?} */
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return true;
            }
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        return false;
    }
    // Return true if the execution in onMouseLeave should be terminated after this method
    /**
     * @private
     * @return {?}
     */
    preMouseLeaveCheck() {
        clearTimeout(this.target.timeoutId);
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            this.target.toBeShown = false;
            this.target.toBeHidden = false;
            return true;
        }
        return false;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEscape(event) {
        /** @type {?} */
        const hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.close();
        this.target.toBeHidden = false;
    }
    /**
     * @hidden
     * @return {?}
     */
    onClick() {
        if (!this.target.collapsed) {
            /** @type {?} */
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            this.target.forceClose(this.mergedOverlaySettings);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onMouseEnter() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        /** @type {?} */
        const shouldReturn = this.preMouseEnterCheck();
        if (shouldReturn) {
            return;
        }
        /** @type {?} */
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * @hidden
     * @return {?}
     */
    onMouseLeave() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        /** @type {?} */
        const shouldReturn = this.preMouseLeaveCheck();
        if (shouldReturn || this.target.collapsed) {
            return;
        }
        /** @type {?} */
        const hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        this.showTooltip();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDocumentTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        if (this.nativeElement !== event.target &&
            !this.nativeElement.contains(event.target)) {
            this.hideTooltip();
        }
    }
    /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     * @return {?}
     */
    showTooltip() {
        clearTimeout(this.target.timeoutId);
        if (!this.target.collapsed) {
            /** @type {?} */
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        /** @type {?} */
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     * @return {?}
     */
    hideTooltip() {
        if (this.target.collapsed && this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
        }
        if (this.target.collapsed || this.target.toBeHidden) {
            return;
        }
        /** @type {?} */
        const hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
}
IgxTooltipTargetDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'tooltipTarget',
                selector: '[igxTooltipTarget]'
            },] }
];
/** @nocollapse */
IgxTooltipTargetDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxTooltipTargetDirective.propDecorators = {
    showDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['showDelay',] }],
    hideDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['hideDelay',] }],
    tooltipDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['tooltipDisabled',] }],
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxTooltipTarget',] }],
    onTooltipShow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onTooltipHide: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onKeydownEscape: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['document:keydown.escape', ['$event'],] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }],
    onMouseEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mouseenter',] }],
    onMouseLeave: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mouseleave',] }],
    onTouchStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['touchstart', ['$event'],] }],
    onDocumentTouchStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['document:touchstart', ['$event'],] }]
};
/** @type {?} */
let NEXT_ID$6 = 0;
/**
 * **Ignite UI for Angular Tooltip** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
 *
 * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
 * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
 * respective target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
class IgxTooltipDirective extends IgxToggleDirective {
    /**
     * @hidden
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} overlayService
     * @param {?} navigationService
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(elementRef, cdr, overlayService, navigationService);
        /**
         * @hidden
         * Returns whether close time out has started
         */
        this.toBeHidden = false;
        /**
         * @hidden
         * Returns whether open time out has started
         */
        this.toBeShown = false;
        /**
         * Identifier for the tooltip.
         * If this is property is not explicitly set, it will be automatically generated.
         *
         * ```typescript
         * let tooltipId = this.tooltip.id;
         * ```
         */
        this.id = `igx-tooltip-${NEXT_ID$6++}`;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     * @return {?}
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Get the role attribute of the tooltip.
     *
     * ```typescript
     * let tooltipRole = this.tooltip.role;
     * ```
     * @return {?}
     */
    get role() {
        return 'tooltip';
    }
    /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     * @protected
     * @param {?=} overlaySettings setting to use for opening the toggle
     * @return {?}
     */
    forceOpen(overlaySettings) {
        /** @type {?} */
        const info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        if (hasOpenAnimation) {
            info.openAnimationPlayer.finish();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
        }
        else if (this.collapsed) {
            /** @type {?} */
            const animation = overlaySettings.positionStrategy.settings.openAnimation;
            overlaySettings.positionStrategy.settings.openAnimation = null;
            this.open(overlaySettings);
            overlaySettings.positionStrategy.settings.openAnimation = animation;
        }
    }
    /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     * @protected
     * @param {?=} overlaySettings settings to use for closing the toggle
     * @return {?}
     */
    forceClose(overlaySettings) {
        /** @type {?} */
        const info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasCloseAnimation) {
            info.closeAnimationPlayer.finish();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
        }
        else if (!this.collapsed) {
            /** @type {?} */
            const animation = overlaySettings.positionStrategy.settings.closeAnimation;
            overlaySettings.positionStrategy.settings.closeAnimation = null;
            this.close();
            overlaySettings.positionStrategy.settings.closeAnimation = animation;
        }
    }
}
IgxTooltipDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                exportAs: 'tooltip',
                selector: '[igxTooltip]'
            },] }
];
/** @nocollapse */
IgxTooltipDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxTooltipDirective.propDecorators = {
    hiddenClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tooltip--hidden',] }],
    defaultClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tooltip--desktop',] }],
    context: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['context',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }]
};
/**
 * @hidden
 */
class IgxTooltipModule {
}
IgxTooltipModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]],
                providers: [IgxOverlayService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Provides base filtering operations
 * Implementations should be Singleton
 *
 * @export
 */
class IgxFilteringOperand {
    constructor() {
        this.operations = [{
                name: 'null',
                isUnary: true,
                iconName: 'is_null',
                logic: (target) => {
                    return target === null;
                }
            }, {
                name: 'notNull',
                isUnary: true,
                iconName: 'is_not_null',
                logic: (target) => {
                    return target !== null;
                }
            }, {
                name: 'in',
                isUnary: false,
                iconName: 'is_in',
                hidden: true,
                logic: (target, searchVal) => {
                    return this.findValueInSet(target, searchVal);
                }
            }];
    }
    /**
     * @return {?}
     */
    static instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} searchVal
     * @return {?}
     */
    findValueInSet(target, searchVal) {
        return searchVal.has(target);
    }
    /**
     * Returns an array of names of the conditions which are visible in the UI
     * @return {?}
     */
    conditionList() {
        return this.operations.filter(f => !f.hidden).map((element) => element.name);
    }
    /**
     * Returns an instance of the condition with the specified name.
     * @param {?} name The name of the condition.
     * @return {?}
     */
    condition(name) {
        return this.operations.find((element) => element.name === name);
    }
    /**
     * Adds a new condition to the filtering operations.
     * @param {?} operation The filtering operation.
     * @return {?}
     */
    append(operation) {
        this.operations.push(operation);
    }
}
IgxFilteringOperand._instance = null;
/**
 * Provides filtering operations for booleans
 *
 * @export
 */
class IgxBooleanFilteringOperand extends IgxFilteringOperand {
    /**
     * @protected
     */
    constructor() {
        super();
        this.operations = [{
                name: 'all',
                isUnary: true,
                iconName: 'all',
                logic: (target) => {
                    return true;
                }
            }, {
                name: 'true',
                isUnary: true,
                iconName: 'is_true',
                logic: (target) => {
                    return !!(target && target !== null && target !== undefined);
                }
            }, {
                name: 'false',
                isUnary: true,
                iconName: 'is_false',
                logic: (target) => {
                    return !target && target !== null && target !== undefined;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined;
                }
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for Dates
 *
 * @export
 */
class IgxDateFilteringOperand extends IgxFilteringOperand {
    /**
     * @protected
     */
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year === searchp.year &&
                        targetp.month === searchp.month &&
                        targetp.day === searchp.day;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: (target, searchVal) => {
                    if (!target) {
                        return true;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year !== searchp.year ||
                        targetp.month !== searchp.month ||
                        targetp.day !== searchp.day;
                }
            }, {
                name: 'before',
                isUnary: false,
                iconName: 'is_before',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target < searchVal;
                }
            }, {
                name: 'after',
                isUnary: false,
                iconName: 'is_after',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target > searchVal;
                }
            }, {
                name: 'today',
                isUnary: true,
                iconName: 'today',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                    return d.year === now.year &&
                        d.month === now.month &&
                        d.day === now.day;
                }
            }, {
                name: 'yesterday',
                isUnary: true,
                iconName: 'yesterday',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    const y = ((d) => new Date(d.setDate(d.getDate() - 1)))(new Date());
                    /** @type {?} */
                    const yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                    return td.year === yesterday.year &&
                        td.month === yesterday.month &&
                        td.day === yesterday.day;
                }
            }, {
                name: 'thisMonth',
                isUnary: true,
                iconName: 'this_month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'lastMonth',
                isUnary: true,
                iconName: 'last_month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (!now.month) {
                        now.month = 11;
                        now.year -= 1;
                    }
                    else {
                        now.month--;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'nextMonth',
                isUnary: true,
                iconName: 'next_month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (now.month === 11) {
                        now.month = 0;
                        now.year += 1;
                    }
                    else {
                        now.month++;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'thisYear',
                isUnary: true,
                iconName: 'this_year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year;
                }
            }, {
                name: 'lastYear',
                isUnary: true,
                iconName: 'last_year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year - 1;
                }
            }, {
                name: 'nextYear',
                isUnary: true,
                iconName: 'next_year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    /** @type {?} */
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    /** @type {?} */
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year + 1;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined;
                }
            }].concat(this.operations);
    }
    /**
     * Splits a Date object into parts
     *
     * \@memberof IgxDateFilteringOperand
     * @param {?} date
     * @param {?=} dateFormat
     * @return {?}
     */
    static getDateParts(date, dateFormat) {
        /** @type {?} */
        const res = {
            day: null,
            hours: null,
            milliseconds: null,
            minutes: null,
            month: null,
            seconds: null,
            year: null
        };
        if (!date || !dateFormat) {
            return res;
        }
        if (dateFormat.indexOf('y') >= 0) {
            res.year = date.getFullYear();
        }
        if (dateFormat.indexOf('M') >= 0) {
            res.month = date.getMonth();
        }
        if (dateFormat.indexOf('d') >= 0) {
            res.day = date.getDate();
        }
        if (dateFormat.indexOf('h') >= 0) {
            res.hours = date.getHours();
        }
        if (dateFormat.indexOf('m') >= 0) {
            res.minutes = date.getMinutes();
        }
        if (dateFormat.indexOf('s') >= 0) {
            res.seconds = date.getSeconds();
        }
        if (dateFormat.indexOf('f') >= 0) {
            res.milliseconds = date.getMilliseconds();
        }
        return res;
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    validateInputData(target) {
        if (!(target instanceof Date)) {
            throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
        }
    }
    /**
     * @protected
     * @param {?} target
     * @param {?} searchVal
     * @return {?}
     */
    findValueInSet(target, searchVal) {
        if (!target) {
            return false;
        }
        return searchVal.has(new Date(target.getFullYear(), target.getMonth(), target.getDate()).toISOString());
    }
}
/**
 * Provides filtering operations for numbers
 *
 * @export
 */
class IgxNumberFilteringOperand extends IgxFilteringOperand {
    /**
     * @protected
     */
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    return target === searchVal;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: (target, searchVal) => {
                    return target !== searchVal;
                }
            }, {
                name: 'greaterThan',
                isUnary: false,
                iconName: 'greater_than',
                logic: (target, searchVal) => {
                    return target > searchVal;
                }
            }, {
                name: 'lessThan',
                isUnary: false,
                iconName: 'less_than',
                logic: (target, searchVal) => {
                    return target < searchVal;
                }
            }, {
                name: 'greaterThanOrEqualTo',
                isUnary: false,
                iconName: 'greater_than_or_equal',
                logic: (target, searchVal) => {
                    return target >= searchVal;
                }
            }, {
                name: 'lessThanOrEqualTo',
                isUnary: false,
                iconName: 'less_than_or_equal',
                logic: (target, searchVal) => {
                    return target <= searchVal;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined || isNaN(target);
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined && !isNaN(target);
                }
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for strings
 *
 * @export
 */
class IgxStringFilteringOperand extends IgxFilteringOperand {
    /**
     * @protected
     */
    constructor() {
        super();
        this.operations = [{
                name: 'contains',
                isUnary: false,
                iconName: 'contains',
                logic: (target, searchVal, ignoreCase) => {
                    /** @type {?} */
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) !== -1;
                }
            }, {
                name: 'doesNotContain',
                isUnary: false,
                iconName: 'does_not_contain',
                logic: (target, searchVal, ignoreCase) => {
                    /** @type {?} */
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) === -1;
                }
            }, {
                name: 'startsWith',
                isUnary: false,
                iconName: 'starts_with',
                logic: (target, searchVal, ignoreCase) => {
                    /** @type {?} */
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.startsWith(search);
                }
            }, {
                name: 'endsWith',
                isUnary: false,
                iconName: 'ends_with',
                logic: (target, searchVal, ignoreCase) => {
                    /** @type {?} */
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.endsWith(search);
                }
            }, {
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal, ignoreCase) => {
                    /** @type {?} */
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target === search;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: (target, searchVal, ignoreCase) => {
                    /** @type {?} */
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target !== search;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined || target.length === 0;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined && target.length > 0;
                }
            }].concat(this.operations);
    }
    /**
     * Applies case sensitivity on strings if provided
     *
     * \@memberof IgxStringFilteringOperand
     * @param {?} a
     * @param {?} ignoreCase
     * @return {?}
     */
    static applyIgnoreCase(a, ignoreCase) {
        a = a || '';
        // bulletproof
        return ignoreCase ? ('' + a).toLowerCase() : a;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const filteringStateDefaults = {
    strategy: new FilteringStrategy()
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class GroupedRecords extends Array {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Icon Service** -
 *
 * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
 * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given fontSet.
 *
 * Example:
 * ```typescript
 * this.iconService.registerFontSetAlias('material', 'material-icons');
 * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
 * ```
 */
class IgxIconService {
    /**
     * @param {?} _sanitizer
     * @param {?} _document
     */
    constructor(_sanitizer, _document) {
        this._sanitizer = _sanitizer;
        this._document = _document;
        this._fontSet = 'material-icons';
        this._fontSetAliases = new Map();
        this._cachedSvgIcons = new Set();
    }
    /**
     *  Returns the default font set.
     * ```typescript
     *   const defaultFontSet = this.iconService.defaultFontSet;
     * ```
     * @return {?}
     */
    get defaultFontSet() {
        return this._fontSet;
    }
    /**
     *  Sets the default font set.
     * ```typescript
     *   this.iconService.defaultFontSet = 'svg-flags';
     * ```
     * @param {?} className
     * @return {?}
     */
    set defaultFontSet(className) {
        this._fontSet = className;
    }
    /**
     *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
     * ```typescript
     *   this.iconService.registerFontSetAlias('material', 'material-icons');
     * ```
     * @template THIS
     * @this {THIS}
     * @param {?} alias
     * @param {?=} className
     * @return {THIS}
     */
    registerFontSetAlias(alias, className = alias) {
        (/** @type {?} */ (this))._fontSetAliases.set(alias, className);
        return (/** @type {?} */ (this));
    }
    /**
     *  Returns the custom class, if any, associated to a given fontSet.
     * ```typescript
     *   const fontSetClass = this.iconService.fontSetClassName('material');
     * ```
     * @param {?} alias
     * @return {?}
     */
    fontSetClassName(alias) {
        return this._fontSetAliases.get(alias) || alias;
    }
    /**
     *  Adds an SVG image to the cache. SVG source is an url.
     * ```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?} url
     * @param {?=} fontSet
     * @return {?}
     */
    addSvgIcon(iconName, url, fontSet = '') {
        if (iconName && url) {
            /** @type {?} */
            const safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
            if (!safeUrl) {
                throw new Error(`The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: "${url}".`);
            }
            /** @type {?} */
            const sanitizedUrl = this._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_1__["SecurityContext"].RESOURCE_URL, safeUrl);
            if (!sanitizedUrl) {
                throw new Error(`The URL provided was not trusted as a resource URL: "${url}".`);
            }
            this.fetchSvg(iconName, url, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `url` to register an svg icon.');
        }
    }
    /**
     *  Adds an SVG image to the cache. SVG source is its text.
     * ```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?} iconText
     * @param {?=} fontSet
     * @return {?}
     */
    addSvgIconFromText(iconName, iconText, fontSet = '') {
        if (iconName && iconText) {
            this.cacheSvgIcon(iconName, iconText, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `iconText` to register an svg icon.');
        }
    }
    /**
     *  Returns whether a given SVG image is present in the cache.
     * ```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?=} fontSet
     * @return {?}
     */
    isSvgIconCached(iconName, fontSet = '') {
        /** @type {?} */
        const iconKey = this.getSvgIconKey(iconName, fontSet);
        return this._cachedSvgIcons.has(iconKey);
    }
    /**
     *  Returns the key of a cached SVG image.
     * ```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?=} fontSet
     * @return {?}
     */
    getSvgIconKey(iconName, fontSet = '') {
        return fontSet + '_' + iconName;
    }
    /**
     * @hidden
     * @private
     * @param {?} iconName
     * @param {?} url
     * @param {?=} fontSet
     * @return {?}
     */
    fetchSvg(iconName, url, fontSet = '') {
        /** @type {?} */
        const instance = this;
        /** @type {?} */
        const httpRequest = new XMLHttpRequest();
        httpRequest.open('GET', url, true);
        httpRequest.responseType = 'text';
        // load – when the result is ready, that includes HTTP errors like 404.
        httpRequest.onload = function (event) {
            if (event) {
                /** @type {?} */
                const request = (/** @type {?} */ (event.target));
                if (request.status === 200) {
                    instance.cacheSvgIcon(iconName, request.responseText, fontSet);
                }
                else {
                    throw new Error(`Could not fetch SVG from url: ${url}; error: ${request.status} (${request.statusText})`);
                }
            }
            else {
                throw new Error(`Could not fetch SVG from url: ${url};`);
            }
        };
        // error – when the request couldn’t be made, e.g.network down or invalid URL.
        httpRequest.onerror = function (event) {
            if (event) {
                /** @type {?} */
                const request = (/** @type {?} */ (event.target));
                throw new Error(`Could not fetch SVG from url: ${url}; error status code: ${request.status} (${request.statusText})`);
            }
            throw new Error(`Could not fetch SVG from url: ${url};`);
        };
        httpRequest.send();
    }
    /**
     * @hidden
     * @private
     * @param {?} iconName
     * @param {?} value
     * @param {?=} fontSet
     * @return {?}
     */
    cacheSvgIcon(iconName, value, fontSet = '') {
        if (iconName && value) {
            this.ensureSvgContainerCreated();
            /** @type {?} */
            const div = this._document.createElement('DIV');
            div.innerHTML = value;
            /** @type {?} */
            const svg = (/** @type {?} */ (div.querySelector('svg')));
            if (svg) {
                /** @type {?} */
                const iconKey = this.getSvgIconKey(iconName, fontSet);
                svg.setAttribute('id', iconKey);
                svg.setAttribute('fit', '');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                if (this._cachedSvgIcons.has(iconKey)) {
                    /** @type {?} */
                    const oldChild = this._svgContainer.querySelector(`svg[id='${iconKey}']`);
                    this._svgContainer.removeChild(oldChild);
                }
                this._svgContainer.appendChild(svg);
                this._cachedSvgIcons.add(iconKey);
            }
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    ensureSvgContainerCreated() {
        if (!this._svgContainer) {
            this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
            if (!this._svgContainer) {
                this._svgContainer = this._document.createElement('DIV');
                this._svgContainer.classList.add('igx-svg-container');
                this._document.documentElement.appendChild(this._svgContainer);
            }
        }
    }
}
IgxIconService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
IgxIconService.ctorParameters = () => [
    { type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["DomSanitizer"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] }
];
/** @nocollapse */ IgxIconService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function IgxIconService_Factory() { return new IgxIconService(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["DomSanitizer"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"])); }, token: IgxIconService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Icon** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/icon.html)
 *
 * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
 * support custom colors and can be marked as active or disabled using the `isActive` property. This will change the appearance
 * of the icon.
 *
 * Example:
 * ```html
 * <igx-icon color="#00ff00" isActive="true">home</igx-icon>
 * ```
 * @type {?}
 */
let NEXT_ID$7 = 0;
class IgxIconComponent {
    /**
     * @param {?} _el
     * @param {?} iconService
     */
    constructor(_el, iconService) {
        this._el = _el;
        this.iconService = iconService;
        /**
         *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
         * ```typescript
         * \@ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *    this.icon.cssClass = "";
         *    this.cdRef.detectChanges();
         * }
         * ```
         */
        this.cssClass = 'igx-icon';
        /**
         *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
         * ```typescript
         * \@ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *    this.icon.ariaHidden = false;
         *    this.cdRef.detectChanges();
         * }
         * ```
         */
        this.ariaHidden = true;
        /**
         *  An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-icon id="igx-icon-1" fontSet="material" color="blue" [isActive]="false">settings</igx-icon>
         * ```
         */
        this.id = `igx-icon-${NEXT_ID$7++}`;
        /**
         *  An \@Input property that allows you to disable the `active` property. By default it's applied.
         * ```html
         * <igx-icon [isActive]="false" fontSet="material" color="blue">settings</igx-icon>
         * ```
         */
        this.active = true;
        this.el = _el;
        this.font = this.iconService.defaultFontSet;
        this.iconService.registerFontSetAlias('material', 'material-icons');
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.updateIconClass();
    }
    /**
     *  An accessor that returns the value of the font property.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconFont = this.icon.getFontSet;
     * }
     * ```
     * @return {?}
     */
    get getFontSet() {
        return this.font;
    }
    /**
     *  An accessor that returns the value of the active property.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getActive;
     * }
     * ```
     * @return {?}
     */
    get getActive() {
        return this.active;
    }
    /**
     *  An accessor that returns inactive property.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getInactive;
     * }
     * ```
     * @return {?}
     */
    get getInactive() {
        return !this.active;
    }
    /**
     *  An accessor that returns the opposite value of the `iconColor` property.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconColor = this.icon.getIconColor;
     * }
     * ```
     * @return {?}
     */
    get getIconColor() {
        return this.iconColor;
    }
    /**
     *  An accessor that returns the value of the iconName property.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconName = this.icon.getIconName;
     * }
     * ```
     * @return {?}
     */
    get getIconName() {
        return this.iconName;
    }
    /**
     *  An accessor that returns the key of the SVG image.
     *  The key consists of the fontSet and the iconName separated by underscore.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let svgKey = this.icon.getSvgKey;
     * }
     * ```
     * @return {?}
     */
    get getSvgKey() {
        if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
            return '#' + this.iconService.getSvgIconKey(this.iconName, this.font);
        }
        return null;
    }
    /**
     *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
     * ```typescript
     * \@ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconTemplate = this.icon.template;
     * }
     * ```
     * @return {?}
     */
    get template() {
        if (this.iconName) {
            if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                return this.svgImage;
            }
            return this.noLigature;
        }
        return this.explicitLigature;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    updateIconClass() {
        /** @type {?} */
        const className = this.iconService.fontSetClassName(this.font);
        this.el.nativeElement.classList.add(className);
        if (this.iconName && !this.iconService.isSvgIconCached(this.iconName, this.font)) {
            this.el.nativeElement.classList.add(this.iconName);
        }
    }
}
IgxIconComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-icon',
                template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            }] }
];
/** @nocollapse */
IgxIconComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxIconService }
];
IgxIconComponent.propDecorators = {
    noLigature: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['noLigature', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    explicitLigature: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['explicitLigature', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    svgImage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['svgImage', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-icon',] }],
    ariaHidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-hidden',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    font: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['fontSet',] }],
    active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['isActive',] }],
    iconColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['color',] }],
    iconName: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['name',] }],
    getInactive: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-icon--inactive',] }],
    getIconColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxIconModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: IgxIconModule
        };
    }
}
IgxIconModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxIconComponent],
                exports: [IgxIconComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateMethod('IgxIconModule.forRoot method is deprecated. Use IgxIconModule instead.'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", []),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:returntype", void 0)
], IgxIconModule, "forRoot", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$8 = 0;
/** @enum {string} */
const Size = {
    SMALL: 'small',
    MEDIUM: 'medium',
    LARGE: 'large',
};
/** @enum {string} */
const AvatarType = {
    DEFAULT: 'default',
    INITIALS: 'initials',
    IMAGE: 'image',
    ICON: 'icon',
};
/**
 * **Ignite UI for Angular Avatar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/avatar.html)
 *
 * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
 * image, someone's initials or a material icon from the google material icon set.
 *
 * Example:
 * ```html
 * <igx-avatar initials="MS" roundShape="true" size="large">
 * </igx-avatar>
 * ```
 */
class IgxAvatarComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Returns the `aria-label` of the avatar.
         *
         * ```typescript
         * let ariaLabel = this.avatar.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'avatar';
        /**
         * Returns the `role` attribute of the avatar.
         *
         * ```typescript
         * let avatarRole = this.avatar.role;
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.role = 'img';
        /**
         * Returns the class of the avatar.
         *
         * ```typescript
         * let avatarCLass =  this.avatar.cssClass;
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.cssClass = 'igx-avatar';
        /**
         * @hidden
         */
        this._size = 'small';
        /**
         * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
         *
         * ```html
         * <igx-avatar id="my-first-avatar"></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.id = `igx-avatar-${NEXT_ID$8++}`;
        /**
         * Sets a round shape to the avatar if `roundShape` is `"true"`.
         * By default the shape of the avatar is a square.
         *
         * ```html
         * <igx-avatar roundShape = "true" ></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.roundShape = false;
    }
    /**
     * Returns the `size` of the avatar.
     *
     * ```typescript
     * let avatarSize =  this.avatar.size;
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * Sets the `size`  of the avatar.
     * By default the `size` is `"small"`. It can be set to `"medium"` or `"large"`.
     *
     * ```
     * <igx-avatar size="large"></igx-avatar>
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        switch (value) {
            case 'small':
            case 'medium':
            case 'large':
                this._size = value;
                break;
            default:
                this._size = 'small';
        }
    }
    /**
     * Returns the type of the avatar.
     *
     * ```typescript
     * let avatarType = this.avatar.type;
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @return {?}
     */
    get type() {
        if (this.src) {
            return AvatarType.IMAGE;
        }
        if (this.icon) {
            return AvatarType.ICON;
        }
        if (this.initials) {
            return AvatarType.INITIALS;
        }
        return AvatarType.DEFAULT;
    }
    /**
     * Returns the template of the avatar.
     *
     * ```typescript
     * let template = this.avatar.template;
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @return {?}
     */
    get template() {
        switch (this.type) {
            case AvatarType.IMAGE:
                return this.imageTemplate;
            case AvatarType.INITIALS:
                return this.initialsTemplate;
            case AvatarType.ICON:
                return this.iconTemplate;
            default:
                return this.defaultTemplate;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.roleDescription = this.getRole();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.elementRef.nativeElement.classList
            .add(`igx-avatar--${this._size}`, `igx-avatar--${this.type}`);
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    getRole() {
        switch (this.type) {
            case AvatarType.IMAGE:
                return 'image avatar';
            case AvatarType.ICON:
                return 'icon avatar';
            case AvatarType.INITIALS:
                return 'initials avatar';
            default:
                return 'custom avatar';
        }
    }
    /**
     * Returns the url of the `image`.
     *
     * ```typescript
     * let imageSourceUrl = this.avatar.getSrcUrl();
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @return {?}
     */
    getSrcUrl() {
        return `url(${this.src})`;
    }
}
IgxAvatarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-avatar',
                template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            }] }
];
/** @nocollapse */
IgxAvatarComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxAvatarComponent.propDecorators = {
    image: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['image', { static: false },] }],
    defaultTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    imageTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['imageTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    initialsTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['initialsTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    iconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['iconTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-label',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-avatar',] }],
    roleDescription: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-roledescription',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    roundShape: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-avatar--rounded',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.color',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    bgColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.background',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    initials: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    src: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    size: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/**
 * @hidden
 */
class IgxAvatarModule {
}
IgxAvatarModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxAvatarComponent],
                exports: [IgxAvatarComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$9 = 0;
/** @enum {string} */
const Type = {
    DEFAULT: 'default',
    INFO: 'info',
    SUCCESS: 'success',
    WARNING: 'warning',
    ERROR: 'error',
};
/**
 * **Ignite UI for Angular Badge** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/badge.html)
 *
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * Example:
 * ```html
 * <igx-avatar icon="person" roundShape="true" size="small">
 *   <igx-badge icon="check" type="success" class="badge-style">
 *   </igx-badge>
 * </igx-avatar>
 * ```
 * The `badge-style` class is used to position the badge:
 * ```css
 * .badge-style {
 *   position: absolute;
 *   bottom: -6px;
 *   right:-50px;
 * }
 * ```
 */
class IgxBadgeComponent {
    constructor() {
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-badge id="igx-badge-2" icon="check" type="success" class="badge-style"></igx-badge>
         * ```
         */
        this.id = `igx-badge-${NEXT_ID$9++}`;
        /**
         * An \@Input property controlling the type of the badge.
         * Allowed values are `default`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         * ```html
         * <igx-badge type="success" icon="check" class="badge-style"></igx-badge>
         * ```
         */
        this.type = 'default';
        /**
         * An \@Input property that sets the value to be displayed inside the badge.
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the contentent of the badge will be empty.
         * ```html
         * <igx-badge value="11" type="success" class="badge-style"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * This allows you to set value to role attribute.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.label = "badge-status";
         * ```
         */
        this.role = 'status';
        /**
         * This allows you to disable igx-badge class. The default it's applied.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.cssClass = false;
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * This allows you to set value to aria-label attribute.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.label = "icon-badge";
         * ```
         */
        this.label = 'badge';
    }
    /**
     * @hidden
     * Defines a human-readable, accessor, author-localized description for the `type` and the `icon` or `value` of the element.
     * @return {?}
     */
    get roleDescription() {
        /** @type {?} */
        let message;
        // tslint:disable-next-line:prefer-conditional-expression
        if (this.icon) {
            message = this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value) {
            message = this.type + ' badge type with value ' + this.value;
        }
        else {
            message = this.type + ' badge type without value';
        }
        return message;
    }
    /**
     * @hidden
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @return {?}
     */
    setClasses() {
        /** @type {?} */
        let classes = {};
        switch (Type[this.type.toUpperCase()]) {
            case Type.DEFAULT:
                classes = {
                    [`${this.cssClass}__circle--default`]: true
                };
                break;
            case Type.INFO:
                classes = {
                    [`${this.cssClass}__circle--info`]: true
                };
                break;
            case Type.SUCCESS:
                classes = {
                    [`${this.cssClass}__circle--success`]: true
                };
                break;
            case Type.WARNING:
                classes = {
                    [`${this.cssClass}__circle--warning`]: true
                };
                break;
            case Type.ERROR:
                classes = {
                    [`${this.cssClass}__circle--error`]: true
                };
                break;
        }
        return classes;
    }
}
IgxBadgeComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-badge',
                template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
            }] }
];
IgxBadgeComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-badge',] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-label',] }]
};
/**
 * @hidden
 */
class IgxBadgeModule {
}
IgxBadgeModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxBadgeComponent],
                exports: [IgxBadgeComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
const IGX_EXPANSION_PANEL_COMPONENT = 'IgxExpansionPanelToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxExpansionPanelBodyComponent {
    /**
     * @param {?} panel
     * @param {?} element
     * @param {?} cdr
     */
    constructor(panel, element, cdr) {
        this.panel = panel;
        this.element = element;
        this.cdr = cdr;
        this._labelledBy = '';
        this._label = '';
        /**
         * @hidden
         */
        this.cssClass = `igx-expansion-panel__body`;
        /**
         * Gets/sets the `role` attribute of the panel body
         * Default is 'region';
         * Get
         * ```typescript
         *  const currentRole = this.panel.body.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.body.role = 'content';
         * ```
         * ```html
         *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
         * ```
         */
        this.role = 'region';
    }
    /**
     * Gets the `aria-label` attribute of the panel body
     * Defaults to the panel id with '-region' in the end;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.label;
     * ```
     * @return {?}
     */
    get label() {
        return this._label || this.panel.id + '-region';
    }
    /**
     * Sets the `aria-label` attribute of the panel body
     * ```typescript
     *  this.panel.body.label = 'my-custom-label';
     * ```
     * ```html
     *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
     * ```
     * @param {?} val
     * @return {?}
     */
    set label(val) {
        this._label = val;
    }
    /**
     * Gets the `aria-labelledby` attribute of the panel body
     * Defaults to the panel header id;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.labelledBy;
     * ```
     * @return {?}
     */
    get labelledBy() {
        return this._labelledBy;
    }
    /**
     * Sets the `aria-labelledby` attribute of the panel body
     * ```typescript
     *  this.panel.body.labelledBy = 'my-custom-id';
     * ```
     * ```html
     *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
     * ```
     * @param {?} val
     * @return {?}
     */
    set labelledBy(val) {
        this._labelledBy = val;
    }
}
IgxExpansionPanelBodyComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-body',
                template: `<ng-content></ng-content>`
            }] }
];
/** @nocollapse */
IgxExpansionPanelBodyComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxExpansionPanelBodyComponent.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel__body',] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-label',] }],
    labelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-labelledby',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExpansionPanelTitleDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-title`;
    }
}
IgxExpansionPanelTitleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-title'
            },] }
];
IgxExpansionPanelTitleDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel__header-title',] }]
};
/**
 * @hidden
 */
class IgxExpansionPanelDescriptionDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-description`;
    }
}
IgxExpansionPanelDescriptionDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-description'
            },] }
];
IgxExpansionPanelDescriptionDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel__header-description',] }]
};
/**
 * @hidden
 */
class IgxExpansionPanelIconDirective {
}
IgxExpansionPanelIconDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-icon'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ICON_POSITION = {
    LEFT: 'left',
    NONE: 'none',
    RIGHT: 'right',
};
class IgxExpansionPanelHeaderComponent {
    /**
     * @param {?} panel
     * @param {?} cdr
     * @param {?} elementRef
     */
    constructor(panel, cdr, elementRef) {
        this.panel = panel;
        this.cdr = cdr;
        this.elementRef = elementRef;
        // properties section
        this._iconTemplate = false;
        /**
         * Sets/gets the `id` of the expansion panel header.
         * ```typescript
         * let panelHeaderId =  this.panel.header.id;
         * ```
         * \@memberof IgxExpansionPanelComponent
         */
        this.id = '';
        /**
         * Gets/sets the `aria-level` attribute of the header
         * Get
         * ```typescript
         *  const currentAriaLevel = this.panel.header.lv;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.lv = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
         * ```
         */
        this.lv = '3';
        /**
         * Gets/sets the `role` attribute of the header
         * Get
         * ```typescript
         *  const currentRole = this.panel.header.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.role = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
         * ```
         */
        this.role = 'heading';
        /**
         * Gets/sets the position of the expansion-panel-header expand/collapse icon
         * Accepts `left`, `right` or `none`
         * ```typescript
         *  const currentIconPosition = this.panel.header.iconPosition;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.iconPosition = 'left';
         * ```
         * ```html
         *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
         * ```
         */
        this.iconPosition = ICON_POSITION.LEFT;
        /**
         * Emitted whenever a user interacts with the header host
         * ```typescript
         *  handleInteraction(event: IExpansionPanelEventArgs) {
         *  ...
         * }
         * ```
         * ```html
         *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
         *      ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.onInteraction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel__header';
        /**
         * Gets/sets the whether the header is disabled
         * When disabled, the header will not handle user events and will stop their propagation
         *
         * ```typescript
         *  const isDisabled = this.panel.header.disabled;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.disabled = true;
         * ```
         * ```html
         *  <igx-expansion-panel-header [disabled]="true">
         *     ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.disabled = false;
        this.id = `${this.panel.id}-header`;
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    set iconTemplate(val) {
        this._iconTemplate = (/** @type {?} */ (val));
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconTemplate() {
        return this._iconTemplate;
    }
    /**
     * @hidden
     * @return {?}
     */
    get controls() {
        return this.panel.id;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isExpanded() {
        return !this.panel.collapsed;
    }
    /**
     * @hidden
     * @param {?=} evt
     * @return {?}
     */
    onAction(evt) {
        if (this.disabled) {
            evt.stopPropagation();
            return;
        }
        this.onInteraction.emit({ event: evt, panel: this.panel });
        this.panel.toggle(evt);
        evt.preventDefault();
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    openPanel(event) {
        if (event.altKey) {
            this.panel.expand(event);
            this.onInteraction.emit({ event: event, panel: this.panel });
        }
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    closePanel(event) {
        if (event.altKey) {
            this.panel.collapse(event);
            this.onInteraction.emit({ event: event, panel: this.panel });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconPositionClass() {
        switch (this.iconPosition) {
            case (ICON_POSITION.LEFT):
                return `igx-expansion-panel__header-icon--start`;
            case (ICON_POSITION.RIGHT):
                return `igx-expansion-panel__header-icon--end`;
            case (ICON_POSITION.NONE):
                return `igx-expansion-panel__header-icon--none`;
            default:
                return '';
        }
    }
}
IgxExpansionPanelHeaderComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-expansion-panel-header',
                template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\" fontSet=\"material\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxExpansionPanelHeaderComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Host"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxExpansionPanelHeaderComponent.propDecorators = {
    iconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxExpansionPanelIconDirective, { static: false },] }],
    lv: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-level',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    iconPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onInteraction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel__header',] }],
    isExpanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel__header--expanded',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel--disabled',] }],
    onAction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Enter', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Space', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Spacebar', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }],
    openPanel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Alt.ArrowDown', ['$event'],] }],
    closePanel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Alt.ArrowUp', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$a = 0;
class IgxExpansionPanelComponent {
    /**
     * @param {?} cdr
     * @param {?} builder
     */
    constructor(cdr, builder) {
        this.cdr = cdr;
        this.builder = builder;
        this._collapsed = true;
        /**
         * Sets/gets the animation settings of the expansion panel component
         * Open and Close animation should be passed
         *
         * Get
         * ```typescript
         *  const currentAnimations = this.panel.animationSettings;
         * ```
         * Set
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  this.panel.animationsSettings = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```
         * or via template
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  myCustomAnimationObject = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```html
         *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
         *  ...
         *  </igx-expansion-panel>
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /**
         * Sets/gets the `id` of the expansion panel component.
         * If not set, `id` will have value `"igx-expansion-panel-0"`;
         * ```html
         * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
         * ```
         * ```typescript
         * let panelId =  this.panel.id;
         * ```
         * \@memberof IgxExpansionPanelComponent
         */
        this.id = `igx-expansion-panel-${NEXT_ID$a++}`;
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel';
        /**
         * @hidden
         */
        this.collapsedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the expansion panel finishes collapsing
         * ```typescript
         *  handleCollapsed(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onCollapsed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the expansion panel finishes expanding
         * ```typescript
         *  handleExpanded(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onExpanded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Gets/sets whether the component is collapsed (its content is hidden)
     * Get
     * ```typescript
     *  const myPanelState: boolean = this.panel.collapsed;
     * ```
     * Set
     * ```html
     *  this.panel.collapsed = true;
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
     * ```
     * @return {?}
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsed(value) {
        this._collapsed = value;
        this.collapsedChange.emit(this._collapsed);
    }
    /**
     * @hidden
     * @return {?}
     */
    get headerId() {
        return this.header ? `${this.id}-header` : '';
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.body && this.header) {
            // schedule at end of turn:
            Promise.resolve().then(() => {
                this.body.labelledBy = this.body.labelledBy || this.headerId;
                this.body.label = this.body.label || this.id + '-region';
            });
        }
    }
    /**
     * @private
     * @param {?} cb
     * @return {?}
     */
    playOpenAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        /** @type {?} */
        const animation = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(this.animationSettings.openAnimation);
        /** @type {?} */
        const animationBuilder = this.builder.build(animation);
        /** @type {?} */
        const openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        openAnimationPlayer.onDone(() => {
            cb();
            openAnimationPlayer.reset();
        });
        openAnimationPlayer.play();
    }
    /**
     * @private
     * @param {?} cb
     * @return {?}
     */
    playCloseAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        /** @type {?} */
        const animation = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(this.animationSettings.closeAnimation);
        /** @type {?} */
        const animationBuilder = this.builder.build(animation);
        /** @type {?} */
        const closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        closeAnimationPlayer.onDone(() => {
            cb();
            closeAnimationPlayer.reset();
        });
        closeAnimationPlayer.play();
    }
    /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    collapse(evt) {
        if (this.collapsed) { // If expansion panel is already collapsed, do nothing
            return;
        }
        this.playCloseAnimation(() => {
            this.onCollapsed.emit({ event: evt, panel: this });
            this.collapsed = true;
        });
    }
    /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    expand(evt) {
        if (!this.collapsed) { // If the panel is already opened, do nothing
            return;
        }
        this.collapsed = false;
        this.cdr.detectChanges();
        this.playOpenAnimation(() => {
            this.onExpanded.emit({ event: evt, panel: this });
        });
    }
    /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    toggle(evt) {
        if (this.collapsed) {
            this.open(evt);
        }
        else {
            this.close(evt);
        }
    }
    /**
     * @param {?=} evt
     * @return {?}
     */
    open(evt) {
        this.expand(evt);
    }
    /**
     * @param {?=} evt
     * @return {?}
     */
    close(evt) {
        this.collapse(evt);
    }
}
IgxExpansionPanelComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-expansion-panel',
                template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent }]
            }] }
];
/** @nocollapse */
IgxExpansionPanelComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"] }
];
IgxExpansionPanelComponent.propDecorators = {
    animationSettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-expansion-panel',] }],
    collapsed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    collapsedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCollapsed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onExpanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    body: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxExpansionPanelBodyComponent),
                { read: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxExpansionPanelBodyComponent), static: false },] }],
    header: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxExpansionPanelHeaderComponent),
                { read: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxExpansionPanelHeaderComponent), static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExpansionPanelModule {
}
IgxExpansionPanelModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                entryComponents: [],
                exports: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:directive-selector
class IgxBannerActionsDirective {
}
IgxBannerActionsDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-banner-actions'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Banner** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
 *
 * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
 *
 * Usage:
 *
 * ```html
 * <igx-banner #banner>
 *   Our privacy settings have changed.
 *  <igx-banner-actions>
 *      <button igxButton="raised">Read More</button>
 *      <button igxButton="raised">Accept and Continue</button>
 *  </igx-banner-actions>
 * </igx-banner>
 * ```
 */
class IgxBannerComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Fires after the banner shows up
         * ```typescript
         * public handleOpened(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
         * ```
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Fires before the banner shows up
         * ```typescript
         * public handleOpening(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
         * ```
         */
        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Fires after the banner hides
         * ```typescript
         * public handleClosed(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
         * ```
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Fires before the banner hides
         * ```typescript
         * public handleClosing(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
         * ```
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @hidden
     * @return {?}
     */
    get useDefaultTemplate() {
        return !this._bannerActionTemplate;
    }
    /**
     * Get the animation settings used by the banner open/close methods
     * ```typescript
     * let currentAnimations: AnimationSettings = banner.animationSettings
     * ```
     * @return {?}
     */
    get animationSettings() {
        return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
    }
    /**
     * Set the animation settings used by the banner open/close methods
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
     * ```
     * @param {?} settings
     * @return {?}
     */
    set animationSettings(settings) {
        this._animationSettings = settings;
    }
    /**
     * Gets whether banner is collapsed
     *
     * ```typescript
     * const isCollapsed: boolean = banner.collapsed;
     * ```
     * @return {?}
     */
    get collapsed() {
        return this._expansionPanel.collapsed;
    }
    /**
     * Returns the native element of the banner component
     * ```typescript
     *  const myBannerElement: HTMLElement = banner.element;
     * ```
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get displayStyle() {
        return this.collapsed ? '' : 'block';
    }
    /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    open(event) {
        this._bannerEvent = { banner: this, event };
        /** @type {?} */
        const openingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onOpening.emit(openingArgs);
        if (openingArgs.cancel) {
            return;
        }
        this._expansionPanel.open(event);
    }
    /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    close(event) {
        this._bannerEvent = { banner: this, event };
        /** @type {?} */
        const closingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onClosing.emit(closingArgs);
        if (closingArgs.cancel) {
            return;
        }
        this._expansionPanel.close(event);
    }
    /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    toggle(event) {
        if (this.collapsed) {
            this.open(event);
        }
        else {
            this.close(event);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onExpansionPanelOpen() {
        this.onOpened.emit(this._bannerEvent);
    }
    /**
     * @hidden
     * @return {?}
     */
    onExpansionPanelClose() {
        this.onClosed.emit(this._bannerEvent);
    }
}
IgxBannerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-banner',
                template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
            }] }
];
/** @nocollapse */
IgxBannerComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxBannerComponent.propDecorators = {
    _expansionPanel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['expansionPanel', { static: true },] }],
    _bannerActionTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxBannerActionsDirective, { static: false },] }],
    bannerIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxIconComponent, { static: false },] }],
    onOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpening: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    animationSettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayStyle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.display',] }]
};
/**
 * @hidden
 */
class IgxBannerModule {
}
IgxBannerModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                exports: [IgxBannerComponent, IgxBannerActionsDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ButtonGroupAlignment = {
    horizontal: 0, vertical: 1,
};
ButtonGroupAlignment[ButtonGroupAlignment.horizontal] = 'horizontal';
ButtonGroupAlignment[ButtonGroupAlignment.vertical] = 'vertical';
/** @type {?} */
let NEXT_ID$b = 0;
/**
 * **Ignite UI for Angular Button Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
 *
 * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
 * single, multiple and toggle selection.
 *
 * Example:
 * ```html
 * <igx-buttongroup multiSelection="true" [values]="fontOptions">
 * </igx-buttongroup>
 * ```
 * The `fontOptions` value shown above is defined as:
 * ```typescript
 * this.fontOptions = [
 *   { icon: 'format_bold', selected: false },
 *   { icon: 'format_italic', selected: false },
 *   { icon: 'format_underlined', selected: false }];
 * ```
 */
class IgxButtonGroupComponent extends DisplayDensityBase {
    /**
     * @param {?} _cdr
     * @param {?} _renderer
     * @param {?} _displayDensityOptions
     */
    constructor(_cdr, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._cdr = _cdr;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        this._disabled = false;
        this.buttonClickNotifier$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.queryListNotifier$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * An \@Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
         * ```html
         *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         */
        this.id = `igx-buttongroup-${NEXT_ID$b++}`;
        /**
         * @hidden
         */
        this.zIndex = 0;
        /**
         * An \@Input property that enables selecting multiple buttons. By default, multi-selection is false.
         * ```html
         * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
         * ```
         */
        this.multiSelection = false;
        /**
         * @hidden
         */
        this.selectedIndexes = [];
        /**
         * An \@Ouput property that emits an event when a button is selected.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onSelect(buttongroup){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * <igx-buttongroup #MyChild [multiSelection]="!multi" (onSelect)="onSelect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have made a selection!"></igx-toast>
         * ```
         */
        this.onSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Ouput property that emits an event when a button is deselected.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onUnselect(buttongroup){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * igx-buttongroup #MyChild [multiSelection]="multi" (onUnselect)="onUnselect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have deselected a button!"></igx-toast>
         * ```
         */
        this.onUnselect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * A collection containing all buttons inside the button group.
     * @return {?}
     */
    get buttons() {
        return [...this.viewButtons.toArray(), ...this.templateButtons.toArray()];
    }
    /**
     * Allows you to set a style using the `itemContentCssClass` input.
     * The value should be the CSS class name that will be applied to the button group.
     * ```typescript
     * public style1 = "styleClass";
     * //..
     * ```
     * ```html
     * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
     * ```
     * @param {?} value
     * @return {?}
     */
    set itemContentCssClass(value) {
        this._itemContentCssClass = value || this._itemContentCssClass;
    }
    /**
     * Returns the CSS class of the item content of the `IgxButtonGroup`.
     * ```typescript
     * \@ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *   let buttonSelect = this.buttonG.itemContentCssClass;
     * }
     * ```
     * @return {?}
     */
    get itemContentCssClass() {
        return this._itemContentCssClass;
    }
    /**
     * An \@Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
     * ```html
     * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
     * ```
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
            if (this.viewButtons && this.templateButtons) {
                this.buttons.forEach((b) => b.disabled = this._disabled);
            }
        }
    }
    /**
     * Allows you to set the button group alignment.
     * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
     * ```typescript
     * public alignment = ButtonGroupAlignment.vertical;
     * //..
     * ```
     * ```html
     * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
     * ```
     * @param {?} value
     * @return {?}
     */
    set alignment(value) {
        this._isVertical = value === ButtonGroupAlignment.vertical;
    }
    /**
     * Returns the alignment of the `igx-buttongroup`.
     * ```typescript
     * \@ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonAlignment = this.buttonG.alignment;
     * }
     * ```
     * @return {?}
     */
    get alignment() {
        return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
    }
    /**
     * Returns true if the `igx-buttongroup` alignment is vertical.
     * Note that in order for the accessor to work correctly the property should be set explicitly.
     * ```html
     * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
     * ```
     * ```typescript
     * //...
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let orientation = this.buttonG.isVertical;
     * }
     * ```
     * @return {?}
     */
    get isVertical() {
        return this._isVertical;
    }
    /**
     * Gets the selected button/buttons.
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let selectedButton = this.buttonG.selectedButtons;
     * }
     * ```
     * @return {?}
     */
    get selectedButtons() {
        return this.buttons.filter((b, i) => {
            return this.selectedIndexes.indexOf(i) !== -1;
        });
    }
    /**
     * Selects a button by its index.
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * \@memberOf {\@link IgxButtonGroupComponent}
     * @param {?} index
     * @return {?}
     */
    selectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        /** @type {?} */
        const button = this.buttons[index];
        /** @type {?} */
        const buttonElement = button.nativeElement;
        this.selectedIndexes.push(index);
        button.selected = true;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
        this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
        this.onSelect.emit({ button: button, index: index });
        /** @type {?} */
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = true;
        }
        // deselect other buttons if multiSelection is not enabled
        if (!this.multiSelection && this.selectedIndexes.length > 1) {
            this.buttons.forEach((b, i) => {
                if (i !== index && this.selectedIndexes.indexOf(i) !== -1) {
                    this.deselectButton(i);
                }
            });
        }
    }
    /**
     * Deselects a button by its index.
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * \@memberOf {\@link IgxButtonGroupComponent}
     * @param {?} index
     * @return {?}
     */
    deselectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        /** @type {?} */
        const button = this.buttons[index];
        /** @type {?} */
        const buttonElement = button.nativeElement;
        this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
        button.selected = false;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
        this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
        this.onUnselect.emit({ button: button, index: index });
        /** @type {?} */
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = false;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        this.templateButtons.forEach((button) => {
            if (!button.initialDensity) {
                button.displayDensity = this.displayDensity;
            }
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const initButtons = () => {
            // Cancel any existing buttonClick subscriptions
            this.buttonClickNotifier$.next();
            this.selectedIndexes.splice(0, this.selectedIndexes.length);
            // initial configuration
            this.buttons.forEach((button, index) => {
                /** @type {?} */
                const buttonElement = button.nativeElement;
                if (this.disabled) {
                    button.disabled = true;
                }
                if (button.selected) {
                    this.selectButton(index);
                }
                button.buttonClick.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.buttonClickNotifier$)).subscribe((ev) => this._clickHandler(ev, index));
                this._renderer.addClass(buttonElement, 'igx-button-group__item');
            });
        };
        this.viewButtons.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.queryListNotifier$)).subscribe(() => initButtons());
        this.templateButtons.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.queryListNotifier$)).subscribe(() => initButtons());
        initButtons();
        this._cdr.detectChanges();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.buttonClickNotifier$.next();
        this.buttonClickNotifier$.complete();
        this.queryListNotifier$.next();
        this.queryListNotifier$.complete();
    }
    /**
     * @hidden
     * @param {?} event
     * @param {?} i
     * @return {?}
     */
    _clickHandler(event, i) {
        if (this.selectedIndexes.indexOf(i) !== -1) {
            this.deselectButton(i);
        }
        else {
            this.selectButton(i);
        }
    }
}
IgxButtonGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-buttongroup',
                template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <div class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\" fontSet=\"material\">{{button.icon}}</igx-icon>\n            <span *ngIf=\"button.label\">{{button.label}}</span>\n        </div>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxButtonGroupComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxButtonGroupComponent.propDecorators = {
    viewButtons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxButtonDirective,] }],
    templateButtons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxButtonDirective,] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    zIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.zIndex',] }],
    itemContentCssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    multiSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    values: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    alignment: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onUnselect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class IgxButtonGroupModule {
}
IgxButtonGroupModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxButtonGroupComponent],
                exports: [IgxButtonGroupComponent],
                imports: [IgxButtonModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxRippleModule, IgxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const DateRangeType = {
    After: 0,
    Before: 1,
    Between: 2,
    Specific: 3,
    Weekdays: 4,
    Weekends: 5,
};
DateRangeType[DateRangeType.After] = 'After';
DateRangeType[DateRangeType.Before] = 'Before';
DateRangeType[DateRangeType.Between] = 'Between';
DateRangeType[DateRangeType.Specific] = 'Specific';
DateRangeType[DateRangeType.Weekdays] = 'Weekdays';
DateRangeType[DateRangeType.Weekends] = 'Weekends';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/** @type {?} */
const FEBRUARY = 1;
/**
 * @param {?=} start
 * @param {?=} stop
 * @param {?=} step
 * @return {?}
 */
function range(start = 0, stop, step = 1) {
    /** @type {?} */
    const res = [];
    /** @type {?} */
    const cur = (stop === undefined) ? 0 : start;
    /** @type {?} */
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {?} year
 * @return {?}
 */
function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}
/**
 * @param {?} year
 * @param {?} month
 * @param {?} day
 * @return {?}
 */
function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {?} year
 * @param {?} month
 * @return {?}
 */
function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    /** @type {?} */
    const day = weekDay(year, month, 1);
    /** @type {?} */
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}
/**
 * @param {?} date
 * @param {?} ranges
 * @return {?}
 */
function isDateInRanges(date, ranges) {
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    /** @type {?} */
    const dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        /** @type {?} */
        const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;
        switch (descriptor.type) {
            case (DateRangeType.After):
                if (dateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Before):
                if (dateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Between):
                /** @type {?} */
                const dRange = dRanges.map(d => d.getTime());
                /** @type {?} */
                const min = Math.min(dRange[0], dRange[1]);
                /** @type {?} */
                const max = Math.max(dRange[0], dRange[1]);
                if (dateInMs >= min && dateInMs <= max) {
                    return true;
                }
                break;
            case (DateRangeType.Specific):
                /** @type {?} */
                const datesInMs = dRanges.map(d => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (dateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            case (DateRangeType.Weekdays):
                /** @type {?} */
                const day = date.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            case (DateRangeType.Weekends):
                /** @type {?} */
                const weekday = date.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            default:
                return false;
        }
    }
    return false;
}
/** @enum {number} */
const WEEKDAYS = {
    SUNDAY: 0,
    MONDAY: 1,
    TUESDAY: 2,
    WEDNESDAY: 3,
    THURSDAY: 4,
    FRIDAY: 5,
    SATURDAY: 6,
};
WEEKDAYS[WEEKDAYS.SUNDAY] = 'SUNDAY';
WEEKDAYS[WEEKDAYS.MONDAY] = 'MONDAY';
WEEKDAYS[WEEKDAYS.TUESDAY] = 'TUESDAY';
WEEKDAYS[WEEKDAYS.WEDNESDAY] = 'WEDNESDAY';
WEEKDAYS[WEEKDAYS.THURSDAY] = 'THURSDAY';
WEEKDAYS[WEEKDAYS.FRIDAY] = 'FRIDAY';
WEEKDAYS[WEEKDAYS.SATURDAY] = 'SATURDAY';
class Calendar {
    /**
     * @param {?=} firstWeekDay
     */
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    /**
     * @return {?}
     */
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * \@memberof Calendar
     * @return {?}
     *
     */
    weekdays() {
        /** @type {?} */
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    monthdates(year, month, extraWeek = false) {
        /** @type {?} */
        let date = new Date(year, month, 1);
        /** @type {?} */
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        /** @type {?} */
        const res = [];
        /** @type {?} */
        let value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, 'day', 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    monthdatescalendar(year, month, extraWeek = false) {
        /** @type {?} */
        const dates = this.monthdates(year, month, extraWeek);
        /** @type {?} */
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    /**
     * @param {?} date
     * @param {?} interval
     * @param {?} units
     * @return {?}
     */
    timedelta(date, interval, units) {
        /** @type {?} */
        const ret = new Date(date);
        /** @type {?} */
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    /**
     * @param {?} date
     * @param {?} locale
     * @param {?} options
     * @param {?} parts
     * @return {?}
     */
    formatToParts(date, locale, options, parts) {
        /** @type {?} */
        const formatter = new Intl.DateTimeFormat(locale, options);
        /** @type {?} */
        const result = {
            date,
            full: formatter.format(date)
        };
        if (((/** @type {?} */ (formatter))).formatToParts) {
            /** @type {?} */
            const formattedParts = ((/** @type {?} */ (formatter))).formatToParts(date);
            /** @type {?} */
            const toType = (partType) => {
                /** @type {?} */
                const index = formattedParts.findIndex(({ type }) => type === partType);
                /** @type {?} */
                const o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts[index].value;
                o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            for (const each of parts) {
                result[each] = toType(each);
            }
        }
        else {
            for (const each of parts) {
                result[each] = { value: '', literal: '', combined: '' };
            }
        }
        return result;
    }
    /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    }
    /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxCalendarYearDirective {
    constructor() {
        this.onYearSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return !this.isCurrentYear;
    }
    /**
     * @return {?}
     */
    get currentCSS() {
        return this.isCurrentYear;
    }
    /**
     * @return {?}
     */
    get isCurrentYear() {
        return this.date.getFullYear() === this.value.getFullYear();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.onYearSelection.emit(this.value);
    }
}
IgxCalendarYearDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCalendarYear]'
            },] }
];
IgxCalendarYearDirective.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxCalendarYear',] }],
    date: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onYearSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__year',] }],
    currentCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__year--current',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }]
};
class IgxCalendarMonthDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onMonthSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.tabindex = 0;
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return !this.isCurrentMonth;
    }
    /**
     * @return {?}
     */
    get currentCSS() {
        return this.isCurrentMonth;
    }
    /**
     * @return {?}
     */
    get isCurrentMonth() {
        return this.date.getMonth() === this.value.getMonth();
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    onClick() {
        /** @type {?} */
        const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.onMonthSelection.emit(date);
    }
}
IgxCalendarMonthDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCalendarMonth]'
            },] }
];
/** @nocollapse */
IgxCalendarMonthDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxCalendarMonthDirective.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxCalendarMonth',] }],
    date: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onMonthSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__month',] }],
    currentCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__month--current',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }]
};
/**
 * @hidden
 */
class IgxCalendarHeaderTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarHeaderTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCalendarHeader]'
            },] }
];
/** @nocollapse */
IgxCalendarHeaderTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxCalendarSubheaderTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarSubheaderTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCalendarSubheader]'
            },] }
];
/** @nocollapse */
IgxCalendarSubheaderTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxCalendarScrollMonthDirective {
    /**
     * @param {?} element
     * @param {?} zone
     */
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'keyup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((event) => {
            this.stopScroll(event);
        });
        this.zone.runOutsideAngular(() => {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["tap"])((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    this.zone.run(() => this.startScroll(true));
                }
            });
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @return {?}
     */
    onMouseDown() {
        this.startScroll();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        this.stopScroll(event);
    }
}
IgxCalendarScrollMonthDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCalendarScrollMonth]'
            },] }
];
/** @nocollapse */
IgxCalendarScrollMonthDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxCalendarScrollMonthDirective.propDecorators = {
    startScroll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    stopScroll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onMouseDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mousedown',] }],
    onMouseUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mouseup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const CalendarSelection = {
    SINGLE: 'single',
    MULTI: 'multi',
    RANGE: 'range',
};
/** @enum {string} */
const ScrollMonth = {
    PREV: 'prev',
    NEXT: 'next',
    NONE: 'none',
};
class IgxCalendarBase {
    /**
     * @hidden
     */
    constructor() {
        /**
         * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
         * Default value is `false`.
         * ```html
         * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let hideOutsideDays = this.calendar.hideOutsideDays;
         * ```
         */
        this.hideOutsideDays = false;
        /**
         * Emits an event when a date is selected.
         * Provides reference the `selectedDates` property.
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this._selection = CalendarSelection.SINGLE;
        /**
         * @hidden
         */
        this.rangeStarted = false;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._disabledDates = null;
        /**
         * @hidden
         */
        this._specialDates = null;
        /**
         * @hidden
         */
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        /**
         * @hidden
         */
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        /**
         * @hidden
         */
        this.monthScrollDirection = ScrollMonth.NONE;
        /**
         * @hidden
         */
        this.scrollMonth$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this.stopMonthScroll$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this.startMonthScroll$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.calendarModel = new Calendar();
        this.viewDate = this.viewDate ? this.viewDate : new Date();
        this.calendarModel.firstWeekDay = this.weekStart;
        this.initFormatters();
    }
    /**
     * Gets the start day of the week.
     * Can return a numeric or an enum representation of the week day.
     * Defaults to `Sunday` / `0`.
     * @return {?}
     */
    get weekStart() {
        return this.calendarModel.firstWeekDay;
    }
    /**
     * Sets the start day of the week.
     * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
     * @param {?} value
     * @return {?}
     */
    set weekStart(value) {
        this.calendarModel.firstWeekDay = value;
    }
    /**
     * Gets the `locale` of the calendar.
     * Default value is `"en"`.
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the calendar.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
        this.initFormatters();
    }
    /**
     * Gets the date format options of the days view.
     * @return {?}
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the date format options of the days view.
     * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
     * @param {?} formatOptions
     * @return {?}
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
        this.initFormatters();
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     * @return {?}
     */
    get formatViews() {
        return this._formatViews;
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     * @param {?} formatViews
     * @return {?}
     */
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     *
     * Gets the selection type.
     * Default value is `"single"`.
     * Changing the type of selection resets the currently
     * selected values if any.
     * @return {?}
     */
    get selection() {
        return this._selection;
    }
    /**
     * Sets the selection.
     * @param {?} value
     * @return {?}
     */
    set selection(value) {
        switch (value) {
            case CalendarSelection.SINGLE:
                this.selectedDates = null;
                break;
            case CalendarSelection.MULTI:
            case CalendarSelection.RANGE:
                this.selectedDates = [];
                break;
            default:
                throw new Error('Invalid selection value');
        }
        this._onChangeCallback(this.selectedDates);
        this.rangeStarted = false;
        this._selection = value;
    }
    /**
     * Gets the selected date(s).
     *
     * When selection is set to `single`, it returns
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     * @return {?}
     */
    get value() {
        return this.selectedDates;
    }
    /**
     * Sets the selected date(s).
     *
     * When selection is set to `single`, it accepts
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!value || !!value && ((/** @type {?} */ (value))).length === 0) {
            return;
        }
        this.selectDate(value);
    }
    /**
     * Gets the date that is presented.
     * By default it is the current date.
     * @return {?}
     */
    get viewDate() {
        return this._viewDate;
    }
    /**
     * Sets the date that will be presented in the default view when the component renders.
     * @param {?} value
     * @return {?}
     */
    set viewDate(value) {
        this._viewDate = this.getDateOnly(value);
    }
    /**
     * Gets the disabled dates descriptors.
     * @return {?}
     */
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Sets the disabled dates' descriptors.
     * ```typescript
     * \@ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.disabledDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set disabledDates(value) {
        this._disabledDates = value;
    }
    /**
     * Gets the special dates descriptors.
     * @return {?}
     */
    get specialDates() {
        return this._specialDates;
    }
    /**
     * Sets the special dates' descriptors.
     * ```typescript
     * \@ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.specialDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * @hidden
     * @private
     * @param {?} date
     * @return {?}
     */
    getDateOnlyInMs(date) {
        return this.getDateOnly(date).getTime();
    }
    /**
     * @hidden
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    generateDateRange(start, end) {
        /** @type {?} */
        const result = [];
        start = this.getDateOnly(start);
        end = this.getDateOnly(end);
        while (start.getTime() !== end.getTime()) {
            start = this.calendarModel.timedelta(start, 'day', 1);
            result.push(start);
        }
        return result;
    }
    /**
     * Performs a single selection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    selectSingle(value) {
        this.selectedDates = this.getDateOnly(value);
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a multiple selection
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    selectMultiple(value) {
        if (Array.isArray(value)) {
            /** @type {?} */
            const newDates = value.map(v => this.getDateOnly(v).getTime());
            /** @type {?} */
            const selDates = this.selectedDates.map(v => this.getDateOnly(v).getTime());
            if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
                return;
            }
            this.selectedDates = Array.from(new Set([...newDates, ...selDates])).map(v => new Date(v));
        }
        else {
            /** @type {?} */
            const valueDateOnly = this.getDateOnly(value);
            /** @type {?} */
            const newSelection = [];
            if (this.selectedDates.every((date) => date.getTime() !== valueDateOnly.getTime())) {
                newSelection.push(valueDateOnly);
            }
            else {
                this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
            }
            if (newSelection.length > 0) {
                this.selectedDates = this.selectedDates.concat(newSelection);
            }
        }
        this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * @hidden
     * @private
     * @param {?} value
     * @param {?=} excludeDisabledDates
     * @return {?}
     */
    selectRange(value, excludeDisabledDates = false) {
        /** @type {?} */
        let start;
        /** @type {?} */
        let end;
        if (Array.isArray(value)) {
            // this.rangeStarted = false;
            value.sort((a, b) => a.valueOf() - b.valueOf());
            start = this.getDateOnly(value[0]);
            end = this.getDateOnly(value[value.length - 1]);
            this.selectedDates = [start, ...this.generateDateRange(start, end)];
        }
        else {
            if (!this.rangeStarted) {
                this.rangeStarted = true;
                this.selectedDates = [value];
            }
            else {
                this.rangeStarted = false;
                if (this.selectedDates[0].getTime() === value.getTime()) {
                    this.selectedDates = [];
                    this._onChangeCallback(this.selectedDates);
                    return;
                }
                this.selectedDates.push(value);
                this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
                start = this.selectedDates.shift();
                end = this.selectedDates.pop();
                this.selectedDates = [start, ...this.generateDateRange(start, end)];
            }
        }
        if (excludeDisabledDates) {
            this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        }
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a single deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    deselectSingle(value) {
        if (this.selectedDates !== null &&
            this.getDateOnlyInMs((/** @type {?} */ (value))) === this.getDateOnlyInMs(this.selectedDates)) {
            this.selectedDates = null;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs a multiple deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    deselectMultiple(value) {
        value = value.filter(v => v !== null);
        /** @type {?} */
        const selectedDatesCount = this.selectedDates.length;
        /** @type {?} */
        const datesInMsToDeselect = new Set(value.map(v => this.getDateOnlyInMs(v)));
        for (let i = this.selectedDates.length - 1; i >= 0; i--) {
            if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                this.selectedDates.splice(i, 1);
            }
        }
        if (this.selectedDates.length !== selectedDatesCount) {
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs deselection of a single value, when selection is multi
     * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
     * @hidden
     * @param {?} value
     * @return {?}
     */
    deselectMultipleInMonth(value) {
        /** @type {?} */
        const valueDateOnly = this.getDateOnly(value);
        this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
    }
    /**
     * Performs a range deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    deselectRange(value) {
        value = value.filter(v => v !== null);
        if (value.length < 1) {
            return;
        }
        value.sort((a, b) => a.valueOf() - b.valueOf());
        /** @type {?} */
        const valueStart = this.getDateOnlyInMs(value[0]);
        /** @type {?} */
        const valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        /** @type {?} */
        const selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
        /** @type {?} */
        const selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
        if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
            this.selectedDates = [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    initFormatters() {
        this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
        this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
        this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
        this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
        this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
    }
    /**
     * @hidden
     * @protected
     * @param {?} date
     * @return {?}
     */
    getDateOnly(date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.selectDate((/** @type {?} */ (value)));
    }
    /**
     * Checks whether a date is disabled.
     * @hidden
     * @param {?} date
     * @return {?}
     */
    isDateDisabled(date) {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(date, this.disabledDates);
    }
    /**
     * Selects date(s) (based on the selection type).
     * @param {?} value
     * @return {?}
     */
    selectDate(value) {
        if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                if (isDate(value) && !this.isDateDisabled((/** @type {?} */ (value)))) {
                    this.selectSingle((/** @type {?} */ (value)));
                }
                break;
            case CalendarSelection.MULTI:
                this.selectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     * @param {?=} value
     * @return {?}
     */
    deselectDate(value) {
        if (this.selectedDates === null || this.selectedDates.length === 0) {
            return;
        }
        if (value === null || value === undefined) {
            this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                this.deselectSingle((/** @type {?} */ (value)));
                break;
            case CalendarSelection.MULTI:
                this.deselectMultiple((/** @type {?} */ (value)));
                break;
            case CalendarSelection.RANGE:
                this.deselectRange((/** @type {?} */ (value)));
                break;
        }
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    selectDateFromClient(value) {
        switch (this.selection) {
            case CalendarSelection.SINGLE:
            case CalendarSelection.MULTI:
                this.selectDate(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
}
IgxCalendarBase.propDecorators = {
    weekStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    locale: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatViews: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    viewDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabledDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    specialDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideOutsideDays: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const CalendarView = {
    DEFAULT: 0,
    YEAR: 1,
    DECADE: 2,
};
CalendarView[CalendarView.DEFAULT] = 'DEFAULT';
CalendarView[CalendarView.YEAR] = 'YEAR';
CalendarView[CalendarView.DECADE] = 'DECADE';
class IgxMonthPickerBase extends IgxCalendarBase {
    constructor() {
        super(...arguments);
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._activeView = CalendarView.DEFAULT;
    }
    /**
     * Gets the current active view.
     * @return {?}
     */
    get activeView() {
        return this._activeView;
    }
    /**
     * Sets the current active view.
     * @param {?} val
     * @return {?}
     */
    set activeView(val) {
        this._activeView = val;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isDefaultView() {
        return this._activeView === CalendarView.DEFAULT;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isDecadeView() {
        return this._activeView === CalendarView.DECADE;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    changeYear(event) {
        this.viewDate = new Date(event.getFullYear(), this.viewDate.getMonth());
        this._activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            if (this.yearsBtn) {
                this.yearsBtn.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @param {?=} args
     * @return {?}
     */
    activeViewDecade(args) {
        this._activeView = CalendarView.DECADE;
    }
    /**
     * @hidden
     * @param {?} event
     * @param {?=} args
     * @return {?}
     */
    activeViewDecadeKB(event, args) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewDecade(args);
        }
    }
    /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    formattedYear(value) {
        if (this.formatViews.year) {
            return this.formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
}
IgxMonthPickerBase.propDecorators = {
    yearsBtn: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['yearsBtn', { static: false },] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$c = 0;
class IgxMonthsViewComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         * \@memberof IgxMonthsViewComponent
         */
        this.id = `igx-months-view-${NEXT_ID$c++}`;
        /**
         * Gets/sets the selected date of the months view.
         * By default it is the current date.
         * ```html
         * <igx-months-view [date]="myDate"></igx-months-view>
         * ```
         * ```typescript
         * let date =  this.monthsView.date;
         * ```
         * \@memberof IgxMonthsViewComponent
         */
        this.date = new Date();
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and monthFormat, if any.
         */
        this.formatView = true;
        /**
         * Emits an event when a selection is made in the months view.
         * Provides reference the `date` property in the `IgxMonthsViewComponent`.
         * ```html
         * <igx-months-view (onSelection)="onSelection($event)"></igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._monthFormat = 'short';
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.initMonthFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets the month format option of the months view.
     * ```typescript
     * let monthFormat = this.monthsView.monthFormat.
     * ```
     * @return {?}
     */
    get monthFormat() {
        return this._monthFormat;
    }
    /**
     * Sets the month format option of the months view.
     * ```html
     * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
     * ```
     * \@memberof IgxMonthsViewComponent
     * @param {?} value
     * @return {?}
     */
    set monthFormat(value) {
        this._monthFormat = value;
        this.initMonthFormatter();
    }
    /**
     * Gets the `locale` of the months view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.monthsView.locale;
     * ```
     * \@memberof IgxMonthsViewComponent
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the months view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-months-view [locale]="de"></igx-months-view>
     * ```
     * \@memberof IgxMonthsViewComponent
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
        this.initMonthFormatter();
    }
    /**
     * Returns an array of date objects which are then used to
     * properly render the month names.
     *
     * Used in the template of the component
     *
     * @hidden
     * @return {?}
     */
    get months() {
        /** @type {?} */
        let start = new Date(this.date.getFullYear(), 0, 1);
        /** @type {?} */
        const result = [];
        for (let i = 0; i < 12; i++) {
            result.push(start);
            start = this._calendarModel.timedelta(start, 'month', 1);
        }
        return result;
    }
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    formattedMonth(value) {
        if (this.formatView) {
            return this._formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    selectMonth(event) {
        this.onSelection.emit(event);
        this.date = event;
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    monthTracker(index, item) {
        return `${item.getMonth()}}`;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    initMonthFormatter() {
        this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const node = this.dates.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        /** @type {?} */
        const months = this.dates.toArray();
        /** @type {?} */
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) - 1; index >= 0; index--) {
            /** @type {?} */
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            /** @type {?} */
            const tolerance = 6;
            if (nodeRect.top !== nextNodeRect.top && (nextNodeRect.left - nodeRect.left) < tolerance) {
                months[index].nativeElement.focus();
                break;
            }
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const node = this.dates.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        /** @type {?} */
        const months = this.dates.toArray();
        /** @type {?} */
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) + 1; index < months.length; index++) {
            /** @type {?} */
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            /** @type {?} */
            const tolerance = 6;
            if (nextNodeRect.top !== nodeRect.top && (nodeRect.left - nextNodeRect.left) < tolerance) {
                months[index].nativeElement.focus();
                break;
            }
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const node = this.dates.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        /** @type {?} */
        const months = this.dates.toArray();
        if (months.indexOf(node) + 1 < months.length) {
            /** @type {?} */
            const month = months[months.indexOf(node) + 1];
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const node = this.dates.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        /** @type {?} */
        const months = this.dates.toArray();
        if (months.indexOf(node) - 1 >= 0) {
            /** @type {?} */
            const month = months[months.indexOf(node) - 1];
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const month = this.dates.toArray()[0];
        month.nativeElement.focus();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const months = this.dates.toArray();
        /** @type {?} */
        const month = months[months.length - 1];
        month.nativeElement.focus();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnter(event) {
        /** @type {?} */
        const value = this.dates.find((date) => date.nativeElement === event.target).value;
        this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
}
IgxMonthsViewComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxMonthsViewComponent, multi: true }],
                selector: 'igx-months-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-row--wrap\">\n        <div [igxCalendarMonth]=\"month\" [date]=\"date\" (onMonthSelection)=\"selectMonth($event)\" [index]=\"i\" *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </div>\n    </div>\n</div>\n\n"
            }] }
];
/** @nocollapse */
IgxMonthsViewComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxMonthsViewComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    date: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    monthFormat: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    locale: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar',] }],
    dates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective },] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    onKeydownArrowUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowup', ['$event'],] }],
    onKeydownArrowDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowRight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownHome: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.end', ['$event'],] }],
    onKeydownEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.enter', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$d = 0;
class CalendarHammerConfig extends _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HammerGestureConfig"] {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
}
CalendarHammerConfig.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
class IgxYearsViewComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the years view.
         * If not set, the `id` will have value `"igx-years-view-0"`.
         * ```html
         * <igx-years-view id = "my-years-view"></igx-years-view>
         * ```
         * ```typescript
         * let yearsViewId =  this.yearsView.id;
         * ```
         * \@memberof IgxCalendarComponent
         */
        this.id = `igx-years-view-${NEXT_ID$d++}`;
        /**
         * Gets/sets the selected date of the years view.
         * By default it is the current date.
         * ```html
         * <igx-years-view [date]="myDate"></igx-years-view>
         * ```
         * ```typescript
         * let date =  this.yearsView.date;
         * ```
         * \@memberof IgxYearsViewComponent
         */
        this.date = new Date();
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (onSelection)="onSelection($event)"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._yearFormat = 'numeric';
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.initYearFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets the year format option of the years view.
     * ```typescript
     * let yearFormat = this.yearsView.yearFormat.
     * ```
     * @return {?}
     */
    get yearFormat() {
        return this._yearFormat;
    }
    /**
     * Sets the year format option of the years view.
     * ```html
     * <igx-years-view [yearFormat]="numeric"></igx-years-view>
     * ```
     * \@memberof IgxYearsViewComponent
     * @param {?} value
     * @return {?}
     */
    set yearFormat(value) {
        this._yearFormat = value;
        this.initYearFormatter();
    }
    /**
     * Gets the `locale` of the years view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.yearsView.locale;
     * ```
     * \@memberof IgxYearsViewComponent
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the years view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-years-view [locale]="de"></igx-years-view>
     * ```
     * \@memberof IgxYearsViewComponent
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
        this.initYearFormatter();
    }
    /**
     * Returns an array of date objects which are then used to properly
     * render the years.
     *
     * Used in the template of the component.
     *
     * @hidden
     * @return {?}
     */
    get decade() {
        /** @type {?} */
        const result = [];
        /** @type {?} */
        const start = this.date.getFullYear() - 3;
        /** @type {?} */
        const end = this.date.getFullYear() + 4;
        for (const year of range(start, end)) {
            result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
        }
        return result;
    }
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    formattedYear(value) {
        if (this.formatView) {
            return this._formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    selectYear(event) {
        this.date = event;
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scroll(event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        const delta = event.deltaY < 0 ? -1 : 1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    pan(event) {
        /** @type {?} */
        const delta = event.deltaY < 0 ? 1 : -1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    yearTracker(index, item) {
        return `${item.getFullYear()}}`;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(1);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(-1);
    }
    /**
     * @hidden
     * @return {?}
     */
    onKeydownEnter() {
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    initYearFormatter() {
        this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
    }
    /**
     * @hidden
     * @private
     * @param {?} delta
     * @return {?}
     */
    generateYearRange(delta) {
        /** @type {?} */
        const currentYear = new Date().getFullYear();
        if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
            (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
            return;
        }
        this.date = this._calendarModel.timedelta(this.date, 'year', delta);
    }
}
IgxYearsViewComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [
                    {
                        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
                        useExisting: IgxYearsViewComponent,
                        multi: true
                    },
                    {
                        provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_GESTURE_CONFIG"],
                        useClass: CalendarHammerConfig
                    }
                ],
                selector: 'igx-years-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span [igxCalendarYear]=\"year\" [date]=\"date\" (onYearSelection)=\"selectYear($event)\" *ngFor=\"let year of decade; trackBy: yearTracker\">\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxYearsViewComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxYearsViewComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    date: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    yearFormat: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    locale: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    onKeydownArrowDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowup', ['$event'],] }],
    onKeydownEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.enter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxDayItemComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.hideOutsideDays = false;
        this.isLastInRange = false;
        this.isFirstInRange = false;
        this.isWithinRange = false;
        this.onDateSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._selected = false;
    }
    /**
     * Returns boolean indicating if the day is selected
     *
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Selects the day
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this._selected = value;
    }
    /**
     * @return {?}
     */
    get isCurrentMonth() {
        return this.date.isCurrentMonth;
    }
    /**
     * @return {?}
     */
    get isPreviousMonth() {
        return this.date.isPrevMonth;
    }
    /**
     * @return {?}
     */
    get isNextMonth() {
        return this.date.isNextMonth;
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get isSelectedCSS() {
        return (!this.isDisabled && this.selected);
    }
    /**
     * @return {?}
     */
    get isInactive() {
        return this.date.isNextMonth || this.date.isPrevMonth;
    }
    /**
     * @return {?}
     */
    get isHidden() {
        return this.hideOutsideDays && this.isInactive;
    }
    /**
     * @return {?}
     */
    get isToday() {
        /** @type {?} */
        const today = new Date(Date.now());
        /** @type {?} */
        const date = this.date.date;
        return (date.getFullYear() === today.getFullYear() &&
            date.getMonth() === today.getMonth() &&
            date.getDate() === today.getDate());
    }
    /**
     * @return {?}
     */
    get isWeekend() {
        /** @type {?} */
        const day = this.date.date.getDay();
        return day === 0 || day === 6;
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.disabledDates);
    }
    /**
     * @return {?}
     */
    get isOutOfRange() {
        if (!this.outOfRangeDates) {
            return false;
        }
        return isDateInRanges(this.date.date, this.outOfRangeDates);
    }
    /**
     * @return {?}
     */
    get isFocusable() {
        return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
    }
    /**
     * @return {?}
     */
    get isWithinRangeCSS() {
        return !this.isSingleSelection && this.isWithinRange;
    }
    /**
     * @return {?}
     */
    get isSpecial() {
        if (this.specialDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.specialDates);
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
    }
    /**
     * @return {?}
     */
    get isDisabledCSS() {
        return this.isHidden || this.isDisabled || this.isOutOfRange;
    }
    /**
     * @return {?}
     */
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this.isDisabled || this.isHidden ? -1 : 0;
    }
    /**
     * @return {?}
     */
    onSelect() {
        this.onDateSelection.emit(this.date);
    }
}
IgxDayItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-day-item',
                template: "<span class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
            }] }
];
/** @nocollapse */
IgxDayItemComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxDayItemComponent.propDecorators = {
    date: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabledDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    outOfRangeDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    specialDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideOutsideDays: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isLastInRange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--last',] }],
    isFirstInRange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--first',] }],
    isWithinRange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onDateSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    isSelectedCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--selected',] }],
    isInactive: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--inactive',] }],
    isHidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--hidden',] }],
    isToday: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--current',] }],
    isWeekend: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--weekend',] }],
    isWithinRangeCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--range',] }],
    isSpecial: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--special',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date',] }],
    isDisabledCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--disabled',] }],
    isSingleSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar__date--single',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    onSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.enter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const Direction = {
    Up: 'ArrowUp',
    Down: 'ArrowDown',
    Left: 'ArrowLeft',
    Right: 'ArrowRight',
};
/** @type {?} */
const ARROW = 'Arrow';
/**
 * @hidden
 */
class IgxDaysViewNavigationService {
    /**
     * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
     * @hidden
     * @param {?} target
     * @param {?} key
     * @param {?=} nextView
     * @return {?}
     */
    focusNextDate(target, key, nextView = false) {
        if (target.childElementCount === 0) {
            target = target.parentElement;
        }
        if (key.indexOf('Arrow') === -1) {
            key = ARROW.concat(key);
        }
        /** @type {?} */
        const monthView = this.monthView;
        /** @type {?} */
        const node = monthView.dates.find((date) => date.nativeElement === target);
        /** @type {?} */
        let dates = monthView.dates.toArray();
        /** @type {?} */
        let day;
        /** @type {?} */
        let step;
        /** @type {?} */
        let i;
        /** @type {?} */
        let nextDate;
        /** @type {?} */
        const index = dates.indexOf(node);
        if (!node) {
            return;
        }
        // focus item in current month
        switch (key) {
            case Direction.Left: {
                step = -1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i > 0; i--) {
                    day = nextView ? dates[i] : dates[i - 1];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Right: {
                step = 1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i < dates.length - 1; i++) {
                    day = nextView ? dates[i] : dates[i + 1];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Up: {
                step = -7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i - 7 > -1; i -= 7) {
                    day = nextView ? dates[i] : dates[i - 7];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Down: {
                step = 7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i + 7 < 42; i += 7) {
                    day = nextView ? dates[i] : dates[i + 7];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
        }
        // focus item in prev/next visible month
        /** @type {?} */
        const nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;
        if (nextMonthView) {
            dates = nextMonthView.dates.toArray();
            day = dates.find((item) => item.date.date.getTime() === nextDate.getTime());
            if (day && day.isFocusable) {
                day.nativeElement.focus();
                return;
            }
            nextMonthView.navService.focusNextDate(day.nativeElement, key);
        }
        // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
        // then it is needed to recalculate the next day, which is going to be part of the prev/next months
        if (day && !day.isFocusable) {
            day = dates[i + step];
            if (!day) {
                nextDate = this.timedelta(node.date.date, step + i - index);
            }
        }
        // focus item in prev/next month, which is currently out of view
        /** @type {?} */
        let dayIsNextMonth;
        if (day) {
            dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
        }
        if (monthView.changeDaysView && !nextMonthView && ((day && dayIsNextMonth) || !day)) {
            /** @type {?} */
            const monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;
            monthView.onViewChanging.emit({ monthAction: monthAction, key: key, nextDate: nextDate });
        }
    }
    /**
     * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
     * @hidden
     * @return {?}
     */
    focusHomeDate() {
        /** @type {?} */
        let monthView = this.monthView;
        while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
    }
    /**
     * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
     * @hidden
     * @return {?}
     */
    focusEndDate() {
        /** @type {?} */
        let monthView = this.monthView;
        while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
    }
    /**
     * @private
     * @param {?} date
     * @param {?} units
     * @return {?}
     */
    timedelta(date, units) {
        /** @type {?} */
        const ret = new Date(date);
        ret.setDate(ret.getDate() + units);
        return ret;
    }
    /**
     * @private
     * @param {?} monthView
     * @return {?}
     */
    focusFirstDay(monthView) {
        /** @type {?} */
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = 0; i < dates.length; i++) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     * @param {?} monthView
     * @return {?}
     */
    focusLastDay(monthView) {
        /** @type {?} */
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = dates.length - 1; i >= 0; i--) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
}
IgxDaysViewNavigationService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$e = 0;
class IgxDaysViewComponent extends IgxCalendarBase {
    /**
     * @hidden
     * @param {?} navService
     */
    constructor(navService) {
        super();
        this.navService = navService;
        /**
         * Sets/gets the `id` of the days view.
         * If not set, the `id` will have value `"igx-days-view-0"`.
         * ```html
         * <igx-days-view id="my-days-view"></igx-days-view>
         * ```
         * ```typescript
         * let daysViewId =  this.daysView.id;
         * ```
         */
        this.id = `igx-days-view-${NEXT_ID$e++}`;
        /**
         * @hidden
         */
        this.changeDaysView = false;
        /**
         * @hidden
         */
        this.onDateSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.onViewChanging = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * @hidden
     * @return {?}
     */
    get getCalendarMonth() {
        return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.navService.monthView = this;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
        if (!this.changeDaysView && this.dates) {
            this.disableOutOfRangeDates();
        }
    }
    /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    formattedDate(value) {
        if (this.formatViews.day) {
            return this.formatterDay.format(value);
        }
        return `${value.getDate()}`;
    }
    /**
     * @hidden
     * @return {?}
     */
    generateWeekHeader() {
        /** @type {?} */
        const dayNames = [];
        /** @type {?} */
        const rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
        for (const day of rv) {
            dayNames.push(this.formatterWeekday.format(day.date));
        }
        return dayNames;
    }
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    rowTracker(index, item) {
        return `${item[index].date.getMonth()}${item[index].date.getDate()}`;
    }
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    dateTracker(index, item) {
        return `${item.date.getMonth()}--${item.date.getDate()}`;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    isCurrentMonth(value) {
        return this.viewDate.getMonth() === value.getMonth();
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    isCurrentYear(value) {
        return this.viewDate.getFullYear() === value.getFullYear();
    }
    /**
     * @hidden
     * @param {?} date
     * @return {?}
     */
    isSelected(date) {
        /** @type {?} */
        let selectedDates;
        if (this.isDateDisabled(date.date) || !this.value ||
            (Array.isArray(this.value) && this.value.length === 0)) {
            return false;
        }
        if (this.selection === CalendarSelection.SINGLE) {
            selectedDates = ((/** @type {?} */ (this.value)));
            return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
        }
        selectedDates = ((/** @type {?} */ (this.value)));
        if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
            return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
        }
        if (this.selection === CalendarSelection.MULTI) {
            /** @type {?} */
            const start = this.getDateOnly(selectedDates[0]);
            /** @type {?} */
            const end = this.getDateOnly(selectedDates[selectedDates.length - 1]);
            if (this.isWithinRange(date.date, false, start, end)) {
                /** @type {?} */
                const currentDate = selectedDates.find(element => element.getTime() === date.date.getTime());
                return !!currentDate;
            }
            else {
                return false;
            }
        }
        else {
            return this.isWithinRange(date.date, true);
        }
    }
    /**
     * @hidden
     * @param {?} date
     * @return {?}
     */
    isLastInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        /** @type {?} */
        const dates = (/** @type {?} */ (this.value));
        /** @type {?} */
        const lastDate = dates[dates.length - 1];
        return isEqual(lastDate, date.date);
    }
    /**
     * @hidden
     * @param {?} date
     * @return {?}
     */
    isFirstInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        return isEqual(((/** @type {?} */ (this.value)))[0], date.date);
    }
    /**
     * @hidden
     * @param {?} date
     * @param {?} checkForRange
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    isWithinRange(date, checkForRange, min, max) {
        if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
            return false;
        }
        min = min ? min : this.value[0];
        max = max ? max : this.value[((/** @type {?} */ (this.value))).length - 1];
        return isDateInRanges(date, [
            {
                type: DateRangeType.Between,
                dateRange: [min, max]
            }
        ]);
    }
    /**
     * @hidden
     * @return {?}
     */
    focusActiveDate() {
        /** @type {?} */
        let date = this.dates.find((d) => d.selected);
        if (!date) {
            date = this.dates.find((d) => d.isToday);
        }
        if (date.isFocusable) {
            date.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    selectDay(event) {
        this.selectDateFromClient(event.date);
        this.onDateSelection.emit(event);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    disableOutOfRangeDates() {
        /** @type {?} */
        const dateRange = [];
        this.dates.toArray().forEach((date) => {
            if (!date.isCurrentMonth) {
                dateRange.push(date.date.date);
            }
        });
        this.outOfRangeDates = [{
                type: DateRangeType.Specific,
                dateRange: dateRange
            }];
    }
    /**
     * @hidden
     * @return {?}
     */
    getFirstMonthView() {
        /** @type {?} */
        let monthView = (/** @type {?} */ (this));
        while (monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    getLastMonthView() {
        /** @type {?} */
        let monthView = (/** @type {?} */ (this));
        while (monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.navService.focusNextDate((/** @type {?} */ (event.target)), event.key);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        this.getFirstMonthView().navService.focusHomeDate();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        this.getLastMonthView().navService.focusEndDate();
    }
}
IgxDaysViewComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [
                    {
                        multi: true,
                        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
                        useExisting: IgxDaysViewComponent
                    },
                    { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
                ],
                selector: 'igx-days-view',
                template: "<div class=\"igx-calendar__body-row\">\n    <span *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n    class=\"igx-calendar__body-row\">\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        (onDateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxDaysViewComponent.ctorParameters = () => [
    { type: IgxDaysViewNavigationService }
];
IgxDaysViewComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    changeDaysView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onDateSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onViewChanging: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxDayItemComponent, { read: IgxDayItemComponent },] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar',] }],
    onKeydownArrow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowleft', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowright', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowup', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownHome: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.end', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$f = 0;
/**
 * **Ignite UI for Angular Calendar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/calendar.html)
 *
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * Example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
class IgxCalendarComponent extends IgxMonthPickerBase {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the calendar.
         * If not set, the `id` will have value `"igx-calendar-0"`.
         * ```html
         * <igx-calendar id = "my-first-calendar"></igx-calendar>
         * ```
         * ```typescript
         * let calendarId =  this.calendar.id;
         * ```
         * \@memberof IgxCalendarComponent
         */
        this.id = `igx-calendar-${NEXT_ID$f++}`;
        this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let isVertical = this.calendar.vertical;
         * ```
         */
        this.vertical = false;
        /**
         * @hidden
         */
        this.animationAction = '';
        /**
         * @hidden
         */
        this.isKeydownTrigger = false;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * The default aria role attribute for the component.
         *
         * @hidden
         */
        this.role = 'grid';
        /**
         * The default aria lebelled by attribute for the component.
         *
         * @hidden
         */
        this.ariaLabelledBy = 'calendar';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this._monthsViewNumber = 1;
        /**
         * @hidden
         */
        this.defaultDayView = {
            value: this.value,
            viewDate: this.viewDate
        };
        /**
         * @hidden
         */
        this.dayViews = [this.defaultDayView];
        /**
         * @hidden
         */
        this.startPrevMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.PREV;
            this.previousMonth(isKeydownTrigger);
        };
        /**
         * @hidden
         */
        this.startNextMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.NEXT;
            this.nextMonth(isKeydownTrigger);
        };
        /**
         * @hidden
         */
        this.stopMonthScroll = (event) => {
            event.stopPropagation();
            // generally the scrolling is built on the calendar component
            // and all start/stop scrolling methods are called on the calendar
            // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
            // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
            this.daysView.stopMonthScroll$.next(true);
            this.daysView.stopMonthScroll$.complete();
            if (this.monthScrollDirection === ScrollMonth.PREV) {
                this.prevMonthBtn.nativeElement.focus();
            }
            else if (this.monthScrollDirection === ScrollMonth.NEXT) {
                this.nextMonthBtn.nativeElement.focus();
            }
            this.monthScrollDirection = ScrollMonth.NONE;
        };
    }
    /**
     * Sets/gets the number of month views displayed.
     * Default value is `1`.
     * ```html
     * <igx-calendar [vertical] = "true" [monthsViewNumber]="2"></igx-calendar>
     * ```
     * ```typescript
     * let monthViewsDisplayed = this.calendar.monthsViewNumber;
     * ```
     * @return {?}
     */
    get monthsViewNumber() {
        return this._monthsViewNumber;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set monthsViewNumber(val) {
        if (this._monthsViewNumber === val || val <= 0) {
            return;
        }
        else if (this._monthsViewNumber < val) {
            for (let i = this._monthsViewNumber; i < val; i++) {
                /** @type {?} */
                const nextMonthDate = new Date(this.viewDate);
                nextMonthDate.setMonth(nextMonthDate.getMonth() + i);
                /** @type {?} */
                const monthView = {
                    value: null,
                    viewDate: nextMonthDate
                };
                this.dayViews.push(monthView);
            }
            this._monthsViewNumber = val;
        }
        else {
            this.dayViews.splice(val, this.dayViews.length - val);
            this._monthsViewNumber = val;
        }
    }
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * @return {?}
     */
    get styleVerticalClass() {
        return this.vertical;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isYearView() {
        return this.activeView === CalendarView.YEAR;
    }
    /**
     * Gets the header template.
     * ```typescript
     * let headerTemplate =  this.calendar.headerTeamplate;
     * ```
     * \@memberof IgxCalendarComponent
     * @return {?}
     */
    get headerTemplate() {
        if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the header template.
     * ```html
     * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
     * ```
     * \@memberof IgxCalendarComponent
     * @param {?} directive
     * @return {?}
     */
    set headerTemplate(directive) {
        this.headerTemplateDirective = directive;
    }
    /**
     * Gets the subheader template.
     * ```typescript
     * let subheaderTemplate = this.calendar.subheaderTemplate;
     * ```
     * @return {?}
     */
    get subheaderTemplate() {
        if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the subheader template.
     * ```html
     * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
     * ```
     * \@memberof IgxCalendarComponent
     * @param {?} directive
     * @return {?}
     */
    set subheaderTemplate(directive) {
        this.subheaderTemplateDirective = directive;
    }
    /**
     * Gets the context for the template marked with the `igxCalendarHeader` directive.
     * ```typescript
     * let headerContext =  this.calendar.headerContext;
     * ```
     * @return {?}
     */
    get headerContext() {
        /** @type {?} */
        const date = this.headerDate;
        return this.generateContext(date);
    }
    /**
     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
     * or `igxCalendarSubHeaderYear` directive.
     * ```typescript
     * let context =  this.calendar.context;
     * ```
     * @return {?}
     */
    get context() {
        /** @type {?} */
        const date = this.viewDate;
        return this.generateContext(date);
    }
    /**
     * @hidden
     * @return {?}
     */
    get headerDate() {
        return this.selectedDates ? this.selectedDates : new Date();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setSiblingMonths(this.monthViews);
        this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {
            this.setSiblingMonths(c);
        });
        this.startMonthScroll$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.stopMonthScroll$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["switchMap"])(() => this.scrollMonth$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["skipLast"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(300)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.stopMonthScroll$)))).subscribe(() => {
            switch (this.monthScrollDirection) {
                case ScrollMonth.PREV:
                    this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    }
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    formattedMonth(value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * @hidden
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    previousMonth(isKeydownTrigger = false) {
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'month', -1);
        this.animationAction = ScrollMonth.PREV;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    /**
     * @hidden
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    nextMonth(isKeydownTrigger = false) {
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'month', 1);
        this.animationAction = ScrollMonth.NEXT;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    activeViewDecade(args) {
        super.activeViewDecade();
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @param {?} args
     * @return {?}
     */
    activeViewDecadeKB(event, args) {
        super.activeViewDecadeKB(event, args);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    getFormattedDate() {
        /** @type {?} */
        const date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    }
    /**
     * @hidden
     * @param {?} instance
     * @return {?}
     */
    childClicked(instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        this.selectDateFromClient(instance.date);
        if (this.selection === 'multi') {
            this.deselectDateInMonthViews(instance.date);
        }
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    viewChanging(args) {
        this.animationAction = args.monthAction;
        this.isKeydownTrigger = true;
        this.nextDate = args.nextDate;
        this.callback = (next) => {
            /** @type {?} */
            const day = this.daysView.dates.find((item) => item.date.date.getTime() === next.getTime());
            if (day) {
                this.daysView.navService.focusNextDate(day.nativeElement, args.key, true);
            }
        };
        this.viewDate = this.calendarModel.timedelta(this.nextDate, 'month', 0);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    changeMonth(event) {
        this.viewDate = new Date(this.viewDate.getFullYear(), event.getMonth());
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            if (this.monthsBtn) {
                this.monthsBtn.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @param {?} args
     * @param {?} event
     * @return {?}
     */
    activeViewYear(args, event) {
        this.activeView = CalendarView.YEAR;
        requestAnimationFrame(() => {
            this.monthsView.date = args;
            this.focusMonth(event.target);
        });
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    focusMonth(target) {
        /** @type {?} */
        const month = this.monthsView.dates.find((date) => date.index === parseInt(target.parentElement.attributes['data-month'].value, 10));
        if (month) {
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} args
     * @param {?} event
     * @return {?}
     */
    activeViewYearKB(args, event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewYear(args, event);
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     * ```typescript
     * this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     * @param {?=} value
     * @return {?}
     */
    deselectDate(value) {
        super.deselectDate(value);
        this.monthViews.forEach((view) => {
            view.selectedDates = this.selectedDates;
            view.rangeStarted = false;
        });
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Helper method that does deselection for all month views when selection is "multi"
     * If not called, selection in other month views stays
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    deselectDateInMonthViews(value) {
        this.monthViews.forEach(m => {
            m.deselectMultipleInMonth(value);
        });
    }
    /**
     * @hidden
     * @param {?} i
     * @return {?}
     */
    getViewDate(i) {
        /** @type {?} */
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date;
    }
    /**
     * @hidden
     * @param {?} i
     * @return {?}
     */
    getMonth(i) {
        /** @type {?} */
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date.getMonth();
    }
    /**
     * @hidden
     * @param {?} i
     * @return {?}
     */
    getContext(i) {
        /** @type {?} */
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return this.generateContext(date, i);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    animationDone(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
        }
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        /** @type {?} */
        let monthView = (/** @type {?} */ (this.daysView));
        /** @type {?} */
        let date = monthView.dates.find((d) => d.selected);
        while (!date && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find((d) => d.selected);
        }
        if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(() => {
                date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
        }
        else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
        }
        this.animationAction = ScrollMonth.NONE;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        /** @type {?} */
        const isPageDown = event.key === 'PageDown';
        /** @type {?} */
        const step = isPageDown ? 1 : -1;
        /** @type {?} */
        let monthView = (/** @type {?} */ (this.daysView));
        /** @type {?} */
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            let year = this.nextDate.getFullYear();
            /** @type {?} */
            let month = this.nextDate.getMonth() + step;
            if (isPageDown) {
                if (month > 11) {
                    month = 0;
                    year += step;
                }
            }
            else {
                if (month < 0) {
                    month = 11;
                    year += step;
                }
            }
            /** @type {?} */
            const range = monthRange(this.nextDate.getFullYear(), month);
            /** @type {?} */
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = (/** @type {?} */ (this.daysView));
                /** @type {?} */
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        if (isPageDown) {
            this.nextMonth(true);
        }
        else {
            this.previousMonth(true);
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownShiftPageUp(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        /** @type {?} */
        const isPageDown = event.key === 'PageDown';
        /** @type {?} */
        const step = isPageDown ? 1 : -1;
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
        this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
        this.isKeydownTrigger = true;
        /** @type {?} */
        let monthView = (/** @type {?} */ (this.daysView));
        /** @type {?} */
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            const year = this.nextDate.getFullYear() + step;
            /** @type {?} */
            const range = monthRange(year, this.nextDate.getMonth());
            /** @type {?} */
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = (/** @type {?} */ (this.daysView));
                /** @type {?} */
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownHome(event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnd(event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
        }
    }
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     * @private
     * @param {?} value
     * @param {?=} i
     * @return {?}
     */
    generateContext(value, i) {
        /** @type {?} */
        const formatObject = Object.assign({ index: i, monthView: () => this.activeViewYear(value, event), yearView: () => this.activeViewDecade(value) }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
        return { $implicit: formatObject };
    }
    /**
     * Helper method that sets references for prev/next months for each month in the view
     * @hidden
     * @private
     * @param {?} monthViews
     * @return {?}
     */
    setSiblingMonths(monthViews) {
        monthViews.forEach((item, index) => {
            /** @type {?} */
            const prevMonthView = this.getMonthView(index - 1);
            /** @type {?} */
            const nextMonthView = this.getMonthView(index + 1);
            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
        });
    }
    /**
     * Helper method returning previous/next day views
     * @hidden
     * @private
     * @param {?} index
     * @return {?}
     */
    getMonthView(index) {
        if (index === -1 || index === this.monthViews.length) {
            return null;
        }
        else {
            return this.monthViews.toArray()[index];
        }
    }
}
IgxCalendarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [
                    {
                        multi: true,
                        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
                        useExisting: IgxCalendarComponent
                    }
                ],
                animations: [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateView', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => 0', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn)),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateChange', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => prev', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-calendar',
                template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"activeViewYearKB(getViewDate(obj.index), $event)\" (click)=\"activeViewYear(getViewDate(obj.index), $event)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(getViewDate(obj.index)) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event, getViewDate(obj.index))\" (click)=\"activeViewDecade(getViewDate(obj.index))\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(getViewDate(obj.index)) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\"  [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\" *ngFor=\"let view of dayViews; index as i;\" [style.width.%]=\"100/monthsViewNumber\" [attr.data-month]=\"getMonth(i)\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\" [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <div style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view *ngFor=\"let view of dayViews; index as i;\" [changeDaysView]=\"true\" #days\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [viewDate]=\"getViewDate(i)\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [selection]=\"selection\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                (onViewChanging)=\"viewChanging($event)\"\n                (onDateSelection)=\"childClicked($event)\">\n        </igx-days-view>\n    </div>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>\n"
            }] }
];
IgxCalendarComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hasHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    monthsViewNumber: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    animationAction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    ariaLabelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-labelledby',] }],
    styleVerticalClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar--vertical',] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar',] }],
    monthsView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['months', { read: IgxMonthsViewComponent, static: false },] }],
    monthsBtn: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['monthsBtn', { static: false },] }],
    dacadeView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['decade', { read: IgxYearsViewComponent, static: false },] }],
    daysView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['days', { read: IgxDaysViewComponent, static: false },] }],
    monthViews: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: ['days', { read: IgxDaysViewComponent },] }],
    prevMonthBtn: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['prevMonthBtn', { static: false },] }],
    nextMonthBtn: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['nextMonthBtn', { static: false },] }],
    headerTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true },] }],
    subheaderTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true },] }],
    onKeydownPageDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.pagedown', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.pageup', ['$event'],] }],
    onKeydownShiftPageUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.shift.pageup', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.shift.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.end', ['$event'],] }],
    onMouseUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['document:mouseup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$g = 0;
class IgxMonthPickerComponent extends IgxMonthPickerBase {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the month picker.
         * If not set, the `id` will have value `"igx-month-picker-0"`.
         */
        this.id = `igx-month-picker-${NEXT_ID$g++}`;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this.yearAction = '';
    }
    /**
     * @hidden
     * @return {?}
     */
    animationDone() {
        this.yearAction = '';
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    activeViewDecadeKB(event) {
        super.activeViewDecadeKB(event);
        if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
            event.preventDefault();
            this.nextYear();
        }
        if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
            event.preventDefault();
            this.previousYear();
        }
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    activeViewDecade() {
        super.activeViewDecade();
        requestAnimationFrame(() => {
            this.dacadeView.el.nativeElement.focus();
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    nextYear() {
        this.yearAction = 'next';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', 1);
        this.selectDate(this.viewDate);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    nextYearKB(event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            event.stopPropagation();
            this.nextYear();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    previousYear() {
        this.yearAction = 'prev';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', -1);
        this.selectDate(this.viewDate);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    previousYearKB(event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            event.stopPropagation();
            this.previousYear();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    selectYear(event) {
        this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
        this.activeView = CalendarView.DEFAULT;
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
        requestAnimationFrame(() => {
            if (this.yearsBtn) {
                this.yearsBtn.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    selectMonth(event) {
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * Selects a date.
     * ```typescript
     * this.monPicker.selectDate(new Date(`2018-06-12`));
     * ```
     * @param {?} value
     * @return {?}
     */
    selectDate(value) {
        if (!value) {
            return new Date();
        }
        // TO DO: to be refactored after discussion on the desired behavior
        super.selectDate(value);
        this.viewDate = value;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        // TO DO: to be refactored after discussion on the desired behavior
        if (value) {
            this.viewDate = this.selectedDates = value;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownPageUp(event) {
        event.preventDefault();
        this.yearAction = 'prev';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', -1);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        this.yearAction = 'next';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', 1);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownHome(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownHome(event);
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnd(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownEnd(event);
        }
    }
}
IgxMonthPickerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [
                    {
                        multi: true,
                        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
                        useExisting: IgxMonthPickerComponent
                    }
                ],
                animations: [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateView', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => 0', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn)),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateChange', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => prev', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-month-picker',
                template: "<div *ngIf=\"isDefaultView\" [@animateView]=\"activeView\" class=\"igx-calendar__body\" (swiperight)=\"previousYear()\" (swipeleft)=\"nextYear()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" (click)=\"previousYear()\" (keydown)=\"previousYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'left': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\" class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" (click)=\"nextYear()\" (keydown)=\"nextYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'right': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone()\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (onSelection)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"selectYear($event)\">\n</igx-years-view>\n"
            }] }
];
IgxMonthPickerComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-calendar',] }],
    monthsView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['months', { read: IgxMonthsViewComponent, static: false },] }],
    dacadeView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['decade', { read: IgxYearsViewComponent, static: false },] }],
    daysView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['days', { read: IgxDaysViewComponent, static: false },] }],
    onKeydownPageUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.pageup', ['$event'],] }],
    onKeydownPageDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.end', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxCalendarModule {
}
IgxCalendarModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxDayItemComponent,
                    IgxDaysViewComponent,
                    IgxCalendarComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective,
                    IgxCalendarScrollMonthDirective,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent
                ],
                exports: [
                    IgxCalendarComponent,
                    IgxDaysViewComponent,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective
                ],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$h = 0;
/**
 * IgxCardMedia is container for the card media section.
 * Use it to wrap images and videos.
 */
class IgxCardMediaDirective {
    constructor() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card__media';
        /**
         * An \@Input property that sets the `width` and `min-width` style property
         * of the media container. If not provided it will be set to `auto`.
         * ```html
         * <igx-card-media width="300px"></igx-card-media>
         * ```
         */
        this.width = 'auto';
        /**
         * An \@Input property that sets the `height` style property of the media container.
         * If not provided it will be set to `auto`.
         * ```html
         * <igx-card-media height="50%"></igx-card-media>
         * ```
         */
        this.height = 'auto';
        /**
         * An \@Input property that sets the `role` attribute of the media container.
         */
        this.role = 'img';
    }
}
IgxCardMediaDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-media'
            },] }
];
IgxCardMediaDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card__media',] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.min-width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    height: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.height',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/**
 * IgxCardHeader is container for the card header
 */
class IgxCardHeaderComponent {
    constructor() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card-header';
        /**
         * An \@Input property that sets the layout style of the header.
         * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
         * ```html
         * <igx-card-header [vertical]="true"></igx-card-header>
         * ```
         */
        this.vertical = false;
        /**
         * An \@Input property that sets the value of the `role` attribute of the card header.
         * By default the value is set to `header`.
         * ```html
         * <igx-card-header role="header"></igx-card-header>
         * ```
         */
        this.role = 'header';
    }
}
IgxCardHeaderComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-card-header',
                template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
            }] }
];
IgxCardHeaderComponent.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-header',] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-header--vertical',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }]
};
/**
 * IgxCardThumbnail is container for the card thumbnail section.
 * Use it to wrap anything you want to be used as a thumbnail.
 */
class IgxCardThumbnailDirective {
}
IgxCardThumbnailDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCardThumbnail]'
            },] }
];
/**
 * igxCardHeaderTitle is used to denote the header title in a card.
 * Use it to tag text nodes.
 */
class IgxCardHeaderTitleDirective {
    constructor() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card__header__title';
    }
}
IgxCardHeaderTitleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCardHeaderTitle]'
            },] }
];
IgxCardHeaderTitleDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-header__title',] }]
};
/**
 * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
 * Use it to tag text nodes.
 */
class IgxCardHeaderSubtitleDirective {
    constructor() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card-header__subtitle';
    }
}
IgxCardHeaderSubtitleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCardHeaderSubtitle]'
            },] }
];
IgxCardHeaderSubtitleDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-header__subtitle',] }]
};
/**
 * IgxCardContent is container for the card content.
 */
class IgxCardContentDirective {
    constructor() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card-content';
    }
}
IgxCardContentDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-content'
            },] }
];
IgxCardContentDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-content',] }]
};
/**
 * IgxCardFooter is container for the card footer
 */
class IgxCardFooterDirective {
    constructor() {
        /**
         * An \@Input property that sets the value of the `role` attribute of the card footer.
         * By default the value is set to `footer`.
         * ```html
         * <igx-card-footer role="footer"></igx-card-footer>
         * ```
         */
        this.role = 'footer';
    }
}
IgxCardFooterDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-footer'
            },] }
];
IgxCardFooterDirective.propDecorators = {
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/** @enum {string} */
const IgxCardType = {
    DEFAULT: 'default',
    OUTLINED: 'outlined',
};
class IgxCardComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the card.
         * If not set, `id` will have value `"igx-card-0"`;
         * ```html
         * <igx-card id = "my-first-card"></igx-card>
         * ```
         * ```typescript
         * let cardId =  this.card.id;
         * ```
         * \@memberof IgxCardComponent
         */
        this.id = `igx-card-${NEXT_ID$h++}`;
        /**
         * An \@Input property that sets the value of the `role` attribute of the card.
         * By default the value is set to `group`.
         * ```html
         * <igx-card role="group"></igx-card>
         * ```
         */
        this.role = 'group';
        /**
         * An \@Input property that sets the value of the `type` attribute of the card.
         * By default the value is set to `default`. You can make the card use the
         * outlined style by setting the value to `outlined`.
         * ```html
         * <igx-card type="outlined"></igx-card>
         * ```
         */
        this.type = IgxCardType.DEFAULT;
        /**
         * An \@Input property that sets the value of the `horizontal` attribute of the card.
         * Setting this to `true` will make the different card sections align horizontally,
         * essentially flipping the card to the side.
         * ```html
         * <igx-card [horizontal]="true"></igx-card>
         * ```
         */
        this.horizontal = false;
    }
    /**
     * A getter which will return true if the card type is `outlined`.
     * @return {?}
     */
    get isOutlinedCard() {
        return this.type === IgxCardType.OUTLINED;
    }
}
IgxCardComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-card',
                template: "<ng-container select='igx-card-media'></ng-container>\n\n<ng-container select='igx-card-header'></ng-container>\n<ng-container select='igx-card-content'>\n    <ng-content></ng-content>\n</ng-container>\n\n<ng-container select='igx-card-actions'></ng-container>\n"
            }] }
];
IgxCardComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isOutlinedCard: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card--outlined',] }],
    horizontal: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card--horizontal',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/** @enum {string} */
const IgxCardActionsLayout = {
    DEFAULT: 'default',
    JUSTIFY: 'justify',
};
/**
 * IgxCardActions is container for the card actions.
 */
class IgxCardActionsComponent {
    /**
     * @param {?} card
     */
    constructor(card) {
        this.card = card;
        this.isVerticalSet = false;
        /**
         * An \@Input property that sets the layout style of the actions.
         * By default icons and icon buttons, as well as regular buttons
         * are split into two containers, which are then positioned on both ends
         * of the card-actions area.
         * You can justify the elements in those groups so they are positioned equally
         * from one another taking up all the space available along the card actions axis.
         * ```html
         * <igx-card-actions layout="justify"></igx-card-actions>
         * ```
         */
        this.layout = 'default';
        /**
         * An \@Input property that sets order of the buttons the actions area.
         * By default all icons/icon buttons are placed at the end of the action
         * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
         * placed in the actions area.
         * If you want to reverse their positions so that icons appear first, use the `reverse`
         * attribute.
         * ```html
         * <igx-card-actions [reverse]="true"></igx-card-actions>
         * ```
         */
        this.reverse = false;
    }
    /**
     * A getter that returns `true` when the layout has been
     * set to `justify`.
     * @return {?}
     */
    get isJustifyLayout() {
        return this.layout === IgxCardActionsLayout.JUSTIFY;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const prop in changes) {
            if (prop === 'vertical') {
                this.isVerticalSet = true;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.vertical = !this.isVerticalSet && this.card.horizontal;
    }
}
IgxCardActionsComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-actions',
                template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
IgxCardActionsComponent.ctorParameters = () => [
    { type: IgxCardComponent, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxCardComponent,] }] }
];
IgxCardActionsComponent.propDecorators = {
    layout: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-actions',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-actions--vertical',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isJustifyLayout: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-actions--justify',] }],
    reverse: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-card-actions--reverse',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/**
 * @hidden
 */
class IgxCardModule {
}
IgxCardModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                exports: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxButtonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$i = 0;
/** @enum {number} */
const Direction$1 = {
    NONE: 0, NEXT: 1, PREV: 2,
};
Direction$1[Direction$1.NONE] = 'NONE';
Direction$1[Direction$1.NEXT] = 'NEXT';
Direction$1[Direction$1.PREV] = 'PREV';
/**
 * **Ignite UI for Angular Carousel** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
 *
 * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
 * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
 * It can be used as a separate fullscreen element or inside another component.
 *
 * Example:
 * ```html
 * <igx-carousel>
 *   <igx-slide>
 *     <h3>First Slide Header</h3>
 *     <p>First slide Content</p>
 *   <igx-slide>
 *   <igx-slide>
 *     <h3>Second Slide Header</h3>
 *     <p>Second Slide Content</p>
 * </igx-carousel>
 * ```
 */
class IgxCarouselComponent {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        /**
         * Returns the `role` attribute of the carousel.
         * ```typescript
         * let carouselRole =  this.carousel.role;
         * ```
         * \@memberof IgxCarouselComponent
         */
        this.role = 'region';
        /**
         * Sets the `id` of the carousel.
         * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
         * ```html
         * <igx-carousel id="my-first-carousel"></igx-carousel>
         * ```
         * \@memberof IgxCarouselComponent
         */
        this.id = `igx-carousel-${NEXT_ID$i++}`;
        /**
         * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
         * Default value is `true`.
         * ```html
         * <igx-carousel [loop]="false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.loop = true;
        /**
         * Sets whether the carousel will `pause` the slide transitions on user interactions.
         * Default value is `true`.
         * ```html
         *  <igx-carousel [pause]="false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.pause = true;
        /**
         * Controls whether the carousel should render the left/right `navigation` buttons.
         * Default value is `true`.
         * ```html
         * <igx-carousel [navigation] = "false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.navigation = true;
        /**
         * An event that is emitted after a slide transition has happened.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onSlideChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after a slide has been added to the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onSlideAdded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after a slide has been removed from the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onSlideRemoved = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the carousel has been paused.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onCarouselPaused = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the carousel has resumed transitioning between `slides`.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onCarouselPlaying = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The collection of `slides` currently in the carousel.
         * ```typescript
         * let slides: IgxSlideComponent[] = this.carousel.slides;
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.slides = [];
        this._total = 0;
    }
    /**
     * Returns the time `interval` in milliseconds before the slide changes.
     * ```typescript
     * let timeInterval = this.carousel.interval;
     * ```
     * \@memberof IgxCarouselComponent
     * @return {?}
     */
    get interval() {
        return this._interval;
    }
    /**
     * Sets the time `interval` in milliseconds before the slide changes.
     * If not set, the carousel will not change `slides` automatically.
     * ```html
     * <igx-carousel [interval] = "1000"></igx-carousel>
     * ```
     * \@memberof IgxCarouselComponent
     * @param {?} value
     * @return {?}
     */
    set interval(value) {
        this._interval = +value;
        this._restartInterval();
    }
    /**
     * Returns the `tabIndex` of the carousel component.
     * ```typescript
     * let tabIndex =  this.carousel.tabIndex;
     * ```
     * \@memberof IgxCarouselComponent
     * @return {?}
     */
    get tabIndex() {
        return 0;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed = true;
        if (this._lastInterval) {
            clearInterval(this._lastInterval);
        }
    }
    /**
     * @hidden
     * \@memberof IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    setAriaLabel(slide) {
        return `Item ${slide.index + 1} of ${this.total}`;
    }
    /**
     * Returns the total number of `slides` in the carousel.
     * ```typescript
     * let slideCount =  this.carousel.total;
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    get total() {
        return this._total;
    }
    /**
     * The index of the slide being currently shown.
     * ```typescript
     * let currentSlideNumber =  this.carousel.current;
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    get current() {
        return !this._currentSlide ? 0 : this._currentSlide.index;
    }
    /**
     * Returns a boolean indicating if the carousel is playing.
     * ```typescript
     * let isPlaying =  this.carousel.isPlaying;
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    get isPlaying() {
        return this._playing;
    }
    /**
     * Returns а boolean indicating if the carousel is destroyed.
     * ```typescript
     * let isDestroyed =  this.carousel.isDestroyed;
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    get isDestroyed() {
        return this._destroyed;
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.carousel.nativeElement;
     * ```
     * \@memberof IgxCarouselComponent
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} index
     * @return {?}
     */
    get(index) {
        for (const each of this.slides) {
            if (each.index === index) {
                return each;
            }
        }
    }
    /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    add(slide) {
        slide.index = this.total;
        this.slides.push(slide);
        this._total += 1;
        if (this.total === 1 || slide.active) {
            this.select(slide);
            if (this.total === 1) {
                this.play();
            }
        }
        else {
            slide.active = false;
        }
        this.onSlideAdded.emit({ carousel: this, slide });
    }
    /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    remove(slide) {
        if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
            if (slide.index === this.current) {
                slide.active = false;
                this.next();
            }
            this.slides.splice(slide.index, 1);
            this._total -= 1;
            if (!this.total) {
                this._currentSlide = null;
                return;
            }
            for (let i = 0; i < this.total; i++) {
                this.slides[i].index = i;
            }
            this.onSlideRemoved.emit({ carousel: this, slide });
        }
    }
    /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @param {?=} direction
     * @return {?}
     */
    select(slide, direction = Direction$1.NONE) {
        /** @type {?} */
        const newIndex = slide.index;
        if (direction === Direction$1.NONE) {
            direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
        }
        if (slide && slide !== this._currentSlide) {
            this._moveTo(slide, direction);
        }
    }
    /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    next() {
        /** @type {?} */
        const index = (this.current + 1) % this.total;
        if (index === 0 && !this.loop) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.NEXT);
    }
    /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    prev() {
        /** @type {?} */
        const index = this.current - 1 < 0 ?
            this.total - 1 : this.current - 1;
        if (!this.loop && index === this.total - 1) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.PREV);
    }
    /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    play() {
        if (!this._playing) {
            this._playing = true;
            this.onCarouselPlaying.emit(this);
            this._restartInterval();
        }
    }
    /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    stop() {
        if (this.pause) {
            this._playing = false;
            this.onCarouselPaused.emit(this);
            this._resetInterval();
        }
    }
    /**
     * @hidden
     * @private
     * @param {?} slide
     * @param {?} direction
     * @return {?}
     */
    _moveTo(slide, direction) {
        if (this._destroyed) {
            return;
        }
        slide.direction = direction;
        slide.active = true;
        if (this._currentSlide) {
            this._currentSlide.direction = direction;
            this._currentSlide.active = false;
        }
        this._currentSlide = slide;
        this.onSlideChanged.emit({ carousel: this, slide });
        this._restartInterval();
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _resetInterval() {
        if (this._lastInterval) {
            clearInterval(this._lastInterval);
            this._lastInterval = null;
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    _restartInterval() {
        this._resetInterval();
        if (!isNaN(this.interval) && this.interval > 0) {
            this._lastInterval = setInterval(() => {
                /** @type {?} */
                const tick = +this.interval;
                if (this._playing && this.total && !isNaN(tick) && tick > 0) {
                    this.next();
                }
                else {
                    this.stop();
                }
            }, this.interval);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onKeydownArrowRight() {
        this.next();
        requestAnimationFrame(() => this.nativeElement.focus());
    }
    /**
     * @hidden
     * @return {?}
     */
    onKeydownArrowLeft() {
        this.prev();
        requestAnimationFrame(() => this.nativeElement.focus());
    }
}
IgxCarouselComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-carousel',
                template: "<div tabindex=\"0\" aria-label=\"carousel\" class=\"igx-carousel\"\n        (mouseenter)=\"stop()\"\n        (mouseleave)=\"play()\"\n        (swipeleft)=\"next()\"\n        (swiperight)=\"prev()\"\n        (tap)=\"isPlaying ? stop() : play()\">\n    <ul class=\"igx-carousel__indicators\" [hidden]=\"slides.length <= 1\">\n        <li *ngFor=\"let slide of slides\" [attr.aria-label]=\"setAriaLabel(slide)\" [attr.aria-selected]=\"slide.active\" [class.active]=\"slide.active === true\"\n            (click)=\"select(slide)\"></li>\n    </ul>\n    <div class=\"igx-carousel__inner\" role=\"list\">\n        <ng-content></ng-content>\n    </div>\n    <div *ngIf=\"navigation\">\n        <a role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" (click)=\"prev()\" [hidden]=\"!slides.length\">\n            <igx-icon fontSet=\"material\">arrow_back</igx-icon>\n        </a>\n        <a role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" (click)=\"next()\" [hidden]=\"!slides.length\">\n            <igx-icon fontSet=\"material\">arrow_forward</igx-icon>\n        </a>\n    </div>\n</div>\n",
                styles: [`
    :host {
        display: block;
        outline-style: none;
    }`]
            }] }
];
/** @nocollapse */
IgxCarouselComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxCarouselComponent.propDecorators = {
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    loop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pause: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    interval: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    navigation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onSlideChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSlideAdded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSlideRemoved: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCarouselPaused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCarouselPlaying: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onKeydownArrowRight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowright',] }],
    onKeydownArrowLeft: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowleft',] }]
};
/**
 * A slide component that usually holds an image and/or a caption text.
 * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
 *
 * ```
 * <igx-slide [input bindings] >
 *    <ng-content></ng-content>
 * </igx-slide>
 * ```
 *
 * @export
 */
class IgxSlideComponent {
    /**
     * @param {?} carousel
     */
    constructor(carousel) {
        this.carousel = carousel;
        /**
         * @hidden
         */
        this.activeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Gets/sets the `active` state of the slide.
     * ```html
     * <igx-carousel>
     *  <igx-slide [active] ="false"></igx-slide>
     * <igx-carousel>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-carousel>
     *  <igx-slide [(active)] ="model.isActive"></igx-slide>
     * <igx-carousel>
     * ```
     * \@memberof IgxSlideComponent
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        this._active = value;
        this.activeChange.emit(this._active);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.carousel.add(this);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.carousel.remove(this);
    }
}
IgxSlideComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-slide',
                template: "<div\n    role=\"listitem\"\n    [class.active]=\"active\"\n    class=\"igx-slide\"\n    [attr.aria-selected]=\"active\"\n    [attr.aria-live]=\"active ? 'polite' : null\"\n    [attr.tabIndex]=\"active ? 0 : null\"\n>\n    <ng-content></ng-content>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxSlideComponent.ctorParameters = () => [
    { type: IgxCarouselComponent }
];
IgxSlideComponent.propDecorators = {
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    direction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.active',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    activeChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class IgxCarouselModule {
}
IgxCarouselModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxCarouselComponent, IgxSlideComponent],
                exports: [IgxCarouselComponent, IgxSlideComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const LabelPosition = {
    BEFORE: 'before',
    AFTER: 'after',
};
/** @type {?} */
const noop$3 = () => { };
/** @type {?} */
let nextId$2 = 0;
/**
 * **Ignite UI for Angular Checkbox** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/checkbox.html)
 *
 * The Ignite UI Checkbox is a selection control that allows users to make a binary choice. It behaves similarly
 * to the native browser checkbox.
 *
 * Example:
 * ```html
 * <igx-checkbox checked="true">
 *   simple checkbox
 * </igx-checkbox>
 * ```
 */
class IgxCheckboxComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the checkbox component.
         * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
         * ```html
         * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
         * ```
         * ```typescript
         * let checkboxId =  this.checkbox.id;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.id = `igx-checkbox-${nextId$2++}`;
        /**
         * Sets/gets the id of the `label` element.
         * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
         * ```html
         * <igx-checkbox labelId = "Label1"></igx-checkbox>
         * ```
         * ```typescript
         * let labelId =  this.checkbox.labelId;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         * ```html
         * <igx-checkbox [tabindex] = "1"></igx-checkbox>
         * ```
         * ```typescript
         * let tabIndex =  this.checkbox.tabindex;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.tabindex = null;
        /**
         *  Sets/gets the position of the `label`.
         *  If not set, the `labelPosition` will have value `"after"`.
         * ```html
         * <igx-checkbox labelPosition = "before"></igx-checkbox>
         * ```
         * ```typescript
         * let labelPosition =  this.checkbox.labelPosition;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.labelPosition = LabelPosition.AFTER;
        /**
         * Enables/Disables the ripple effect.
         * If not set, `disableRipple` will have value `false`.
         * ```html
         * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRippleDisabled = this.checkbox.desableRipple;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the checkbox is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-checkbox [required] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRequired =  this.checkbox.required;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         * ```html
         * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabel = this.checkbox.aruaLabel;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the checkbox state is changed.
         * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
         * \@memberof IgxCheckboxComponent
         */
        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Returns the class of the checkbox component.
         * ```typescript
         * let class =  this.checkbox.cssClass;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.cssClass = 'igx-checkbox';
        /**
         * Sets/gets whether the checkbox component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.checkbox.focused =  true;
         * ```
         * ```typescript
         * let isFocused =  this.checkbox.focused;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.focused = false;
        /**
         * Sets/gets the checkbox indeterminate visual state.
         * Default value is `false`;
         * ```html
         * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isIndeterminate = this.checkbox.indeterminate;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.indeterminate = false;
        /**
         * Sets/gets whether the checkbox is checked.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [checked] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isChecked =  this.checkbox.checked;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.checked = false;
        /**
         * Sets/gets whether the checkbox is disabled.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [disabled] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isDisabled = this.checkbox.disabled;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the checkbox is readonly.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [readonly]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let readonly = this.checkbox.readonly;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.readonly = false;
        /**
         * Sets/gets whether the checkbox should disable all css transitions.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let disableTransitions = this.checkbox.disableTransitions;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.disableTransitions = false;
        /**
         * @hidden
         */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$3;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$3;
    }
    /**
     * If `disabled` is `false`, switches the `checked` state.
     * ```typescript
     * this.checkbox.toggle();
     * ```
     * \@memberof IgxCheckboxComponent
     * @return {?}
     */
    toggle() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.indeterminate = false;
        this.focused = false;
        this.checked = !this.checked;
        this.change.emit({ checked: this.checked, checkbox: this });
        this._onChangeCallback(this.checked);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onCheckboxChange(event) {
        // We have to stop the original checkbox change event
        // from bubbling up since we emit our own change event
        event.stopPropagation();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onCheckboxClick(event) {
        // Since the original checkbox is hidden and the label
        // is used for styling and to change the checked state of the checkbox,
        // we need to prevent the checkbox click event from bubbling up
        // as it gets triggered on label click
        event.stopPropagation();
        if (this.readonly) {
            // readonly prevents the component from changing state (see toggle() method).
            // However, the native checkbox can still be activated through user interaction (focus + space, label click)
            // Prevent the native change so the input remains in sync
            event.preventDefault();
        }
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
        this.toggle();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onLabelClick(event) {
        // We use a span element as a placeholder label
        // in place of the native label, we need to emit
        // the change event separately here alongside
        // the click event emitted on click
        this.toggle();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.focused = true;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /**
     * @hidden
     * @return {?}
     */
    get labelClass() {
        switch (this.labelPosition) {
            case LabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case LabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
}
IgxCheckboxComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxCheckboxComponent, multi: true }],
                selector: 'igx-checkbox',
                preserveWhitespaces: false,
                template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            }] }
];
IgxCheckboxComponent.propDecorators = {
    nativeCheckbox: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['checkbox', { static: true },] }],
    nativeLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['label', { static: true },] }],
    placeholderLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['placeholderLabel', { static: true },] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ariaLabelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-labelledby',] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-label',] }],
    change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-checkbox',] }],
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-checkbox--focused',] }],
    indeterminate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-checkbox--indeterminate',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-checkbox--checked',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-checkbox--disabled',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    readonly: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disableTransitions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-checkbox--plain',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/** @type {?} */
const IGX_CHECKBOX_REQUIRED_VALIDATOR = {
    provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALIDATORS"],
    useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxCheckboxRequiredDirective),
    multi: true
};
/* tslint:disable directive-selector */
class IgxCheckboxRequiredDirective extends _angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxRequiredValidator"] {
}
IgxCheckboxRequiredDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: `igx-checkbox[required][formControlName],
    igx-checkbox[required][formControl],
    igx-checkbox[required][ngModel]`,
                providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
            },] }
];
/**
 * @hidden
 */
class IgxCheckboxModule {
}
IgxCheckboxModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                imports: [IgxRippleModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let CHIP_ID = 0;
class IgxChipComponent extends DisplayDensityBase {
    /**
     * @param {?} cdr
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} _displayDensityOptions
     */
    constructor(cdr, elementRef, renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-chip [id]="'igx-chip-1'"></igx-chip>
         * ```
         */
        this.id = `igx-chip-${CHIP_ID++}`;
        /**
         * An \@Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
         * ```
         */
        this.draggable = false;
        /**
         * An \@Input property that enables/disables the draggable element animation when the element is released.
         * By default it's set to true.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
         * ```
         */
        this.animateOnRelease = true;
        /**
         * An \@Input property that enables/disables the hiding of the base element that has been dragged.
         * By default it's set to true.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
         * ```
         */
        this.hideBaseOnDrag = true;
        /**
         * An \@Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
         * ```
         */
        this.removable = false;
        /**
         * An \@Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
         * ```
         */
        this.selectable = false;
        /**
         * @hidden
         */
        this.class = '';
        /**
         * An \@Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
         * like focusing on click or tab, selection on click or Space, dragging.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         */
        this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` moving starts.
         * Returns the moving `IgxChipComponent`.
         * ```typescript
         * moveStarted(event: IBaseChipEventArgs){
         *     let movingChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveStart)="moveStarted($event)">
         * ```
         */
        this.onMoveStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` moving ends.
         * Returns the moved `IgxChipComponent`.
         * ```typescript
         * moveEnded(event: IBaseChipEventArgs){
         *     let movedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveEnd)="moveEnded($event)">
         * ```
         */
        this.onMoveEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` is removed.
         * Returns the removed `IgxChipComponent`.
         * ```typescript
         * remove(event: IBaseChipEventArgs){
         *     let removedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onRemove)="remove($event)">
         * ```
         */
        this.onRemove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` is clicked.
         * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
         * ```typescript
         * chipClick(event: IChipClickEventArgs){
         *     let clickedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onClick)="chipClick($event)">
         * ```
         */
        this.onClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected.
         * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
         * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
         * ```typescript
         * chipSelect(event: IChipSelectEventArgs){
         *     let selectedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelection)="chipSelect($event)">
         * ```
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
         * ```typescript
         * chipSelectEnd(event: IBaseChipEventArgs){
         *     let selectedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelectionDone)="chipSelectEnd($event)">
         * ```
         */
        this.onSelectionDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
         * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
         * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
         * ```typescript
         * chipKeyDown(event: IChipKeyDownEventArgs){
         *     let keyDown = event.key;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onKeyDown)="chipKeyDown($event)">
         * ```
         */
        this.onKeyDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
         * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
         * the original drop event arguments.
         * ```typescript
         * chipEnter(event: IChipEnterDragAreaEventArgs){
         *     let targetChip = event.targetChip;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
         * ```
         */
        this.onDragEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._selected = false;
        this._selectedItemClass = 'igx-chip__item--selected';
        this._movedWhileRemoving = false;
    }
    /**
     * Sets the `IgxChipComponent` selected state.
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
     * ```
     * @param {?} newValue
     * @return {?}
     */
    set selected(newValue) {
        this.changeSelection(newValue);
    }
    /**
     * Returns if the `IgxChipComponent` is selected.
     * ```typescript
     * \@ViewChild('myChip')
     * public chip: IgxChipComponent;
     * selectedChip(){
     *     let selectedChip = this.chip.selected;
     * }
     * ```
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * An \@Input property that sets the `IgxChipComponent` background color.
     * The `color` property supports string, rgb, hex.
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
     * ```
     * @param {?} newColor
     * @return {?}
     */
    set color(newColor) {
        this.chipArea.nativeElement.style.backgroundColor = newColor;
    }
    /**
     * Returns the background color of the `IgxChipComponent`.
     * ```typescript
     * \@ViewChild('myChip')
     * public chip: IgxChipComponent;
     * ngAfterViewInit(){
     *     let chipColor = this.chip.color;
     * }
     * ```
     * @return {?}
     */
    get color() {
        return this.chipArea.nativeElement.style.backgroundColor;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hostClass() {
        /** @type {?} */
        const classes = [this.getComponentDensityClass('igx-chip')];
        classes.push(this.disabled ? 'igx-chip--disabled' : '');
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @return {?}
     */
    get removeButtonTemplate() {
        return this.removeIcon || this.defaultRemoveIcon;
    }
    /**
     * @hidden
     * @return {?}
     */
    get selectIconTemplate() {
        return this.selectIcon || this.defaultSelectIcon;
    }
    /**
     * @hidden
     * @return {?}
     */
    get ghostClass() {
        return this.getComponentDensityClass('igx-chip__ghost');
    }
    /**
     * @return {?}
     */
    get chipTabindex() {
        return !this.disabled ? 0 : '';
    }
    /**
     * @hidden
     * @param {?} condition
     * @return {?}
     */
    selectClass(condition) {
        /** @type {?} */
        const SELECT_CLASS = 'igx-chip__select';
        return {
            [SELECT_CLASS]: condition,
            [`${SELECT_CLASS}--hidden`]: !condition
        };
    }
    /**
     * @protected
     * @param {?} newValue
     * @param {?=} srcEvent
     * @return {?}
     */
    changeSelection(newValue, srcEvent = null) {
        /** @type {?} */
        const onSelectArgs = {
            originalEvent: srcEvent,
            owner: this,
            selected: false,
            cancel: false
        };
        if (newValue && !this._selected) {
            onSelectArgs.selected = true;
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
        else if (!newValue && this._selected) {
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSelectTransitionDone(event) {
        if (event.propertyName === 'width' && !!event.target.tagName) {
            // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
            this.onSelectionDone.emit({
                owner: this,
                originalEvent: event
            });
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipKeyDown(event) {
        /** @type {?} */
        const keyDownArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onKeyDown.emit(keyDownArgs);
        if (keyDownArgs.cancel) {
            return;
        }
        if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
        }
        if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
        if (event.key !== 'Tab') {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onRemoveBtnKeyDown(event) {
        if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRemoveMouseDown(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onRemoveClick(event) {
        this.onRemove.emit({
            originalEvent: event,
            owner: this
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    onRemoveTouchMove() {
        // We don't remove chip if user starting touch interacting on the remove button moves the chip
        this._movedWhileRemoving = true;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onRemoveTouchEnd(event) {
        if (!this._movedWhileRemoving) {
            this.onRemoveClick(event);
        }
        this._movedWhileRemoving = false;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // -----------------------------
    // Start chip igxDrag behavior
    onChipDragStart(event) {
        this.onMoveStart.emit({
            originalEvent: event,
            owner: this
        });
        event.cancel = !this.draggable || this.disabled;
    }
    /**
     * @hidden
     * @return {?}
     */
    onChipDragEnd() {
        if (this.animateOnRelease) {
            this.dragDirective.transitionToOrigin();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipMoveEnd(event) {
        // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
        this.onMoveEnd.emit({
            originalEvent: event,
            owner: this
        });
        if (this.selected) {
            this.chipArea.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipDragClicked(event) {
        /** @type {?} */
        const clickEventArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onClick.emit(clickEventArgs);
        if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
    }
    // End chip igxDrag behavior
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // -----------------------------
    // Start chip igxDrop behavior
    onChipDragEnterHandler(event) {
        if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
            return;
        }
        /** @type {?} */
        const eventArgs = {
            owner: this,
            dragChip: event.drag.data.chip,
            originalEvent: event
        };
        this.onDragEnter.emit(eventArgs);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipDrop(event) {
        // Cancel the default drop logic
        event.cancel = true;
    }
}
IgxChipComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-chip',
                template: "<div #chipArea class=\"igx-chip__item\"\n    [attr.tabindex]=\"chipTabindex\"\n    (keydown)=\"onChipKeyDown($event)\"\n    [igxDrag]=\"{chip: this}\"\n    [hideBaseOnDrag]=\"hideBaseOnDrag\"\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div [ngClass]=\"selectClass(selected)\" (transitionend)=\"onSelectTransitionDone($event)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        tabindex=\"0\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
IgxChipComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxChipComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    draggable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    animateOnRelease: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideBaseOnDrag: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    removable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    removeIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    class: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onMoveStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onMoveEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRemove: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSelectionDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onKeyDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDragEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    hostClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.class',] }],
    dragDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['chipArea', { read: IgxDragDirective, static: true },] }],
    chipArea: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['chipArea', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: true },] }],
    defaultRemoveIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultRemoveIcon', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultSelectIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultSelectIcon', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxChipsAreaComponent {
    /**
     * @param {?} cdr
     * @param {?} element
     * @param {?} _iterableDiffers
     */
    constructor(cdr, element, _iterableDiffers) {
        this.cdr = cdr;
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
         * Returns an array of `IgxChipComponent`s.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
         * ```
         * ```typescript
         * public changedOrder(event: IChipsAreaReorderEventArgs){
         *      let chips: IgxChipComponent[] = event.chipsArray;
         * }
         * ```
         */
        this.onReorder = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
         * Fired after the chips area is initialized if there are initially selected chips as well.
         * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onSelection)="selection($event)"></igx-chips-area>
         * ```
         * ```typescript
         * public selection(event: IChipsAreaSelectEventArgs){
         *      let selectedChips: IgxChipComponent[] = event.newSelection;
         * }
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveStart)="moveStart($event)"></igx-chips-area>
         * ```
         * ```typescript
         * moveStart(event: IBaseChipsAreaEventArgs){
         *      let chipArea = event.owner;
         * }
         * ```
         */
        this.onMoveStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveEnd)="moveEnd($event)"></igx-chips-area>
         * ```
         * ```typescript
         * moveEnd(event: IBaseChipsAreaEventArgs){
         *      let chipArea = event.owner;
         * }
         * ```
         */
        this.onMoveEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._differ = null;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._differ = this._iterableDiffers.find([]).create(null);
    }
    /**
     * @hidden
     * @return {?}
     */
    get hostClass() {
        /** @type {?} */
        const classes = ['igx-chip-area'];
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
        if (this.chipsList.length) {
            /** @type {?} */
            const selectedChips = this.chipsList.filter((item) => item.selected);
            if (selectedChips.length) {
                this.onSelection.emit({
                    originalEvent: null,
                    newSelection: selectedChips,
                    owner: this
                });
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
        if (this.chipsList) {
            /** @type {?} */
            const changes = this._differ.diff(this.chipsList.toArray());
            if (changes) {
                changes.forEachAddedItem((addedChip) => {
                    addedChip.item.onMoveStart.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
                        this.onChipMoveStart(args);
                    });
                    addedChip.item.onMoveEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
                        this.onChipMoveEnd(args);
                    });
                    addedChip.item.onDragEnter.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
                        this.onChipDragEnter(args);
                    });
                    addedChip.item.onKeyDown.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
                        this.onChipKeyDown(args);
                    });
                    if (addedChip.item.selectable) {
                        addedChip.item.onSelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
                            this.onChipSelectionChange(args);
                        });
                    }
                });
                this.modifiedChipsArray = this.chipsList.toArray();
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    onChipKeyDown(event) {
        /** @type {?} */
        let orderChanged = false;
        /** @type {?} */
        const chipsArray = this.chipsList.toArray();
        /** @type {?} */
        const dragChipIndex = chipsArray.findIndex((el) => el === event.owner);
        if (event.originalEvent.shiftKey === true) {
            if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                if (orderChanged) {
                    setTimeout(() => {
                        this.chipsList.toArray()[dragChipIndex - 1].chipArea.nativeElement.focus();
                    });
                }
            }
            else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
            }
        }
        else {
            if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                chipsArray[dragChipIndex - 1].chipArea.nativeElement.focus();
            }
            else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                dragChipIndex < chipsArray.length - 1) {
                chipsArray[dragChipIndex + 1].chipArea.nativeElement.focus();
            }
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    onChipMoveStart(event) {
        this.onMoveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    onChipMoveEnd(event) {
        this.onMoveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    onChipDragEnter(event) {
        /** @type {?} */
        const dropChipIndex = this.chipsList.toArray().findIndex((el) => el === event.owner);
        /** @type {?} */
        const dragChipIndex = this.chipsList.toArray().findIndex((el) => el === event.dragChip);
        if (dragChipIndex < dropChipIndex) {
            // from the left to right
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
        }
        else {
            // from the right to left
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} chipIndex
     * @param {?} targetIndex
     * @param {?} shiftRestLeft
     * @param {?} originalEvent
     * @return {?}
     */
    positionChipAtIndex(chipIndex, targetIndex, shiftRestLeft, originalEvent) {
        if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
            targetIndex < 0 || this.chipsList.length <= targetIndex) {
            return false;
        }
        /** @type {?} */
        const chipsArray = this.chipsList.toArray();
        /** @type {?} */
        const result = [];
        for (let i = 0; i < chipsArray.length; i++) {
            if (shiftRestLeft) {
                if (chipIndex <= i && i < targetIndex) {
                    result.push(chipsArray[i + 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
            else {
                if (targetIndex < i && i <= chipIndex) {
                    result.push(chipsArray[i - 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
        }
        this.modifiedChipsArray = result;
        /** @type {?} */
        const eventData = {
            chipsArray: this.modifiedChipsArray,
            originalEvent: originalEvent,
            owner: this
        };
        this.onReorder.emit(eventData);
        return true;
    }
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    onChipSelectionChange(event) {
        /** @type {?} */
        let selectedChips = this.chipsList.filter((chip) => chip.selected);
        if (event.selected && !selectedChips.includes(event.owner)) {
            selectedChips.push(event.owner);
        }
        else if (!event.selected && selectedChips.includes(event.owner)) {
            selectedChips = selectedChips.filter((chip) => {
                return chip.id !== event.owner.id;
            });
        }
        this.onSelection.emit({
            originalEvent: event.originalEvent,
            newSelection: selectedChips,
            owner: this
        });
    }
}
IgxChipsAreaComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-chips-area',
                template: "<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
IgxChipsAreaComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
];
IgxChipsAreaComponent.propDecorators = {
    class: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hostClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.class',] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.width.px',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    height: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.height.px',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onReorder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onMoveStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onMoveEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    chipsList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxChipComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxChipsModule {
}
IgxChipsModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxChipsAreaComponent,
                    IgxChipComponent
                ],
                exports: [
                    IgxChipsAreaComponent,
                    IgxChipComponent,
                    IgxPrefixDirective,
                    IgxSuffixDirective
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule,
                    IgxDragDropModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxComboHeaderDirective {
}
IgxComboHeaderDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboHeader]'
            },] }
];
/**
 * @hidden
 */
class IgxComboFooterDirective {
}
IgxComboFooterDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboFooter]'
            },] }
];
/**
 * @hidden
 */
class IgxComboItemDirective {
}
IgxComboItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboItem]'
            },] }
];
/**
 * @hidden
 */
class IgxComboEmptyDirective {
}
IgxComboEmptyDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboEmpty]'
            },] }
];
/**
 * @hidden
 */
class IgxComboHeaderItemDirective {
}
IgxComboHeaderItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboHeaderItem]'
            },] }
];
/**
 * @hidden
 */
class IgxComboAddItemDirective {
}
IgxComboAddItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboAddItem]'
            },] }
];
/**
 * @hidden
 */
class IgxComboToggleIconDirective {
}
IgxComboToggleIconDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboToggleIcon]'
            },] }
];
/**
 * @hidden
 */
class IgxComboClearIconDirective {
}
IgxComboClearIconDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxComboClearIcon]'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxComboAPIService {
    constructor() {
        this.disableTransitions = false;
    }
    /**
     * @param {?} combo
     * @return {?}
     */
    register(combo) {
        this.combo = combo;
    }
    /**
     * @return {?}
     */
    clear() {
        this.combo = null;
    }
    /**
     * @return {?}
     */
    get valueKey() {
        return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
    }
    /**
     * @return {?}
     */
    get item_focusable() {
        return false;
    }
    /**
     * @return {?}
     */
    get isRemote() {
        return this.combo.isRemote;
    }
    /**
     * @return {?}
     */
    add_custom_item() {
        if (!this.combo) {
            return;
        }
        this.combo.addItemToCollection();
    }
    /**
     * @return {?}
     */
    get comboID() {
        return this.combo.id;
    }
    /**
     * @param {?} itemID
     * @param {?=} event
     * @return {?}
     */
    set_selected_item(itemID, event) {
        /** @type {?} */
        const selected = this.combo.isItemSelected(itemID);
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (!selected) {
            this.combo.selectItems([itemID], false, event);
        }
        else {
            this.combo.deselectItems([itemID], event);
        }
    }
    /**
     * @param {?} itemID
     * @return {?}
     */
    is_item_selected(itemID) {
        return this.combo.isItemSelected(itemID);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxComboItemComponent extends IgxDropDownItemComponent {
    /**
     * @param {?} comboAPI
     * @param {?} dropDown
     * @param {?} elementRef
     * @param {?} selection
     */
    constructor(comboAPI, dropDown, elementRef, selection) {
        super(dropDown, elementRef, null, selection);
        this.comboAPI = comboAPI;
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.selection = selection;
        /**
         * Gets the height of a list item
         * @hidden
         */
        this.itemHeight = '';
    }
    /**
     * @hidden
     * @return {?}
     */
    get itemID() {
        /** @type {?} */
        const valueKey = this.comboAPI.valueKey;
        return valueKey !== null ? this.value[valueKey] : this.value;
    }
    /**
     * @hidden
     * @return {?}
     */
    get comboID() {
        return this.comboAPI.comboID;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get disableTransitions() {
        return this.comboAPI.disableTransitions;
    }
    /**
     * @hidden
     * @return {?}
     */
    get selected() {
        return this.comboAPI.is_item_selected(this.itemID);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
    }
    /**
     * @hidden
     * @param {?} direction
     * @return {?}
     */
    isVisible(direction) {
        /** @type {?} */
        const rect = this.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
        if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
        }
        return rect.y >= parentDiv.y;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        if (this.disabled || this.isHeader) {
            /** @type {?} */
            const focusedItem = this.dropDown.items.find((item) => item.focused);
            if (this.dropDown.allowItemsFocus && focusedItem) {
                focusedItem.element.nativeElement.focus({ preventScroll: true });
            }
            return;
        }
        this.dropDown.navigateItem(this.index);
        this.comboAPI.set_selected_item(this.itemID, event);
    }
    /**
     * @hidden
     * \@internal
     * The event that is prevented is the click on the checkbox label element.
     * That is the only visible element that a user can interact with.
     * The click propagates to the host and the preventDefault is to stop it from
     * switching focus to the input it's base on.
     * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
     * @param {?} event
     * @return {?}
     */
    disableCheck(event) {
        event.preventDefault();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
    }
}
IgxComboItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-combo-item',
                template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
IgxComboItemComponent.ctorParameters = () => [
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_DROPDOWN_BASE,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxSelectionAPIService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxSelectionAPIService,] }] }
];
IgxComboItemComponent.propDecorators = {
    itemHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.height.px',] }],
    clicked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const IGX_COMBO_COMPONENT = 'IgxComboComponentToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxComboAddItemComponent extends IgxComboItemComponent {
    /**
     * @return {?}
     */
    get selected() {
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        this.comboAPI.add_custom_item();
    }
}
IgxComboAddItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-combo-add-item',
                template: '<ng-content></ng-content>',
                providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent }]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxComboDropDownComponent extends IgxDropDownComponent {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} selection
     * @param {?} combo
     * @param {?} comboAPI
     * @param {?} _displayDensityOptions
     */
    constructor(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.combo = combo;
        this.comboAPI = comboAPI;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * \@internal
         */
        this.children = null;
        this.scrollHandler = () => {
            this.comboAPI.disableTransitions = true;
        };
    }
    /**
     * @protected
     * @return {?}
     */
    get scrollContainer() {
        return this.virtDir.dc.location.nativeElement;
    }
    /**
     * @protected
     * @return {?}
     */
    get isScrolledToLast() {
        /** @type {?} */
        const scrollTop = this.virtDir.scrollPosition;
        /** @type {?} */
        const scrollHeight = this.virtDir.getScroll().scrollHeight;
        return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
    }
    /**
     * @protected
     * @return {?}
     */
    get lastVisibleIndex() {
        return this.combo.totalItemCount ?
            Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
            this.items.length - 1;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onFocus() {
        this.focusedItem = this._focusedItem || this.items[0];
    }
    /**
     * @hidden \@internal
     * @param {?=} evt
     * @return {?}
     */
    onBlur(evt) {
        this.focusedItem = null;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onToggleOpened() {
        this.onOpened.emit();
    }
    /**
     * @hidden
     * @return {?}
     */
    navigateFirst() {
        this.navigateItem(this.virtDir.igxForOf.findIndex(e => !e.isHeader));
    }
    /**
     * @hidden
     * @return {?}
     */
    navigatePrev() {
        if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
            this.combo.focusSearchInput(false);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    navigateNext() {
        /** @type {?} */
        const lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
        if (this._focusedItem && this._focusedItem.index === lastIndex) {
            this.focusAddItemButton();
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        if (item === null || item === undefined) {
            return;
        }
        this.comboAPI.set_selected_item(item.itemID);
        this._focusedItem = item;
    }
    /**
     * @private
     * @return {?}
     */
    focusAddItemButton() {
        if (this.combo.isAddButtonVisible()) {
            this.focusedItem = this.items[this.items.length - 1];
        }
    }
    /**
     * @protected
     * @param {?} newItem
     * @return {?}
     */
    scrollToHiddenItem(newItem) { }
    /**
     * @protected
     * @return {?}
     */
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => {
                return a.index - b.index;
            });
        }
        return null;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     * @return {?}
     */
    get items() {
        /** @type {?} */
        const items = [];
        if (this.children !== undefined) {
            /** @type {?} */
            const sortedChildren = (/** @type {?} */ (this.sortedChildren));
            for (const child of sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    updateScrollPosition() {
        this.virtDir.getScroll().scrollTop = this._scrollPosition;
    }
    /**
     * @hidden \@internal
     * @param {?} key
     * @return {?}
     */
    onItemActionKey(key) {
        switch (key) {
            case DropDownActionKey.ENTER:
                this.handleEnter();
                break;
            case DropDownActionKey.SPACE:
                this.handleSpace();
                break;
            case DropDownActionKey.ESCAPE:
                this.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    handleEnter() {
        if (this.isAddItemFocused()) {
            this.combo.addItemToCollection();
        }
        else {
            this.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    handleSpace() {
        if (this.isAddItemFocused()) {
            return;
        }
        else {
            this.selectItem(this.focusedItem);
        }
    }
    /**
     * @private
     * @return {?}
     */
    isAddItemFocused() {
        return this.focusedItem instanceof IgxComboAddItemComponent;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxComboDropDownComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-combo-drop-down',
                template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\" [style.height]=\"height\"\n[style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\"\n    (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n    (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <ng-container *ngIf=\"!collapsed\">\n        <ng-content></ng-content>\n    </ng-container>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent }]
            }] }
];
/** @nocollapse */
IgxComboDropDownComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_COMBO_COMPONENT,] }] },
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxComboDropDownComponent.propDecorators = {
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxComboItemComponent, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxComboFilteringPipe {
    /**
     * @param {?} combo
     */
    constructor(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} logic
     * @return {?}
     */
    transform(collection, expressions, logic) {
        /** @type {?} */
        const filteringExpressionsTree = new FilteringExpressionsTree(logic);
        filteringExpressionsTree.filteringOperands = expressions;
        /** @type {?} */
        const state = { expressionsTree: filteringExpressionsTree, strategy: new SimpleFilteringStrategy() };
        state.expressionsTree.filteringOperands = this.combo.filteringExpressions;
        if (!state.expressionsTree.filteringOperands.length) {
            return collection;
        }
        /** @type {?} */
        const result = DataUtil.filter(cloneArray(collection), state);
        return result;
    }
}
IgxComboFilteringPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'comboFiltering'
            },] }
];
/** @nocollapse */
IgxComboFilteringPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_COMBO_COMPONENT,] }] }
];
/**
 * @hidden
 */
class SimpleFilteringStrategy extends FilteringStrategy {
    /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    findMatchByExpression(rec, expr) {
        /** @type {?} */
        const cond = expr.condition;
        /** @type {?} */
        const val = expr.fieldName === undefined ? rec : rec[expr.fieldName];
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    }
}
/**
 * @hidden
 */
class IgxComboSortingPipe {
    constructor() { }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @return {?}
     */
    transform(collection, expressions) {
        if (!expressions.length) {
            return collection;
        }
        /** @type {?} */
        const result = DataUtil.sort(cloneArray(collection), expressions);
        return result;
    }
}
IgxComboSortingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'comboSorting',
                pure: true
            },] }
];
/** @nocollapse */
IgxComboSortingPipe.ctorParameters = () => [];
/**
 * @hidden
 */
class IgxComboGroupingPipe {
    /**
     * @param {?} combo
     */
    constructor(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} groupKey
     * @return {?}
     */
    transform(collection, groupKey) {
        this.combo.filteredData = collection;
        if ((!groupKey && groupKey !== 0) || !collection.length) {
            return collection;
        }
        /** @type {?} */
        const data = cloneArray(collection);
        /** @type {?} */
        let inserts = 0;
        /** @type {?} */
        let currentHeader = null;
        for (let i = 0; i < collection.length; i++) {
            /** @type {?} */
            let insertFlag = 0;
            if (currentHeader !== collection[i][groupKey]) {
                currentHeader = collection[i][groupKey];
                insertFlag = 1;
            }
            if (insertFlag) {
                data.splice(i + inserts, 0, {
                    [this.combo.valueKey]: currentHeader,
                    [this.combo.groupKey]: currentHeader,
                    isHeader: true
                });
                inserts++;
            }
        }
        return data;
    }
}
IgxComboGroupingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'comboGrouping'
            },] }
];
/** @nocollapse */
IgxComboGroupingPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_COMBO_COMPONENT,] }] }
];
/**
 * @hidden
 */
class IgxComboFilterConditionPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return value.split(/(?=[A-Z])/).join(' ');
    }
}
IgxComboFilterConditionPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'filterCondition',
                pure: true
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const DataTypes = {
    EMPTY: 'empty',
    PRIMITIVE: 'primitive',
    COMPLEX: 'complex',
    PRIMARYKEY: 'valueKey',
};
/**
 * @hidden
 * @type {?}
 */
const ItemHeights = {
    'comfortable': 40,
    'cosy': 32,
    'compact': 28,
};
/**
 * @hidden
 * The default number of items that should be in the combo's
 * drop-down list if no `[itemsMaxHeight]` is specified
 * @type {?}
 */
const itemsInContainer = 10;
/** @enum {number} */
const IgxComboState = {
    /**
     * Combo with initial state.
     */
    INITIAL: 0,
    /**
     * Combo with valid state.
     */
    VALID: 1,
    /**
     * Combo with invalid state.
     */
    INVALID: 2,
};
IgxComboState[IgxComboState.INITIAL] = 'INITIAL';
IgxComboState[IgxComboState.VALID] = 'VALID';
IgxComboState[IgxComboState.INVALID] = 'INVALID';
/**
 * When called with sets A & B, returns A - B (as array);
 * @hidden
 * @param {?} set1
 * @param {?} set2
 * @return {?}
 */
function diffInSets(set1, set2) {
    /** @type {?} */
    const results = [];
    set1.forEach(entry => {
        if (!set2.has(entry)) {
            results.push(entry);
        }
    });
    return results;
}
/** @type {?} */
let NEXT_ID$j = 0;
/** @type {?} */
const noop$4 = () => { };
class IgxComboComponent extends DisplayDensityBase {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} selection
     * @param {?} comboAPI
     * @param {?} _displayDensityOptions
     * @param {?} _injector
     */
    constructor(elementRef, cdr, selection, comboAPI, _displayDensityOptions, _injector) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.comboAPI = comboAPI;
        this._displayDensityOptions = _displayDensityOptions;
        this._injector = _injector;
        /**
         * @hidden \@internal
         */
        this.customValueFlag = true;
        /**
         * @hidden \@internal
         */
        this.defaultFallbackGroup = 'Other';
        this.stringFilters = IgxStringFilteringOperand;
        this.booleanFilters = IgxBooleanFilteringOperand;
        this._filteringLogic = FilteringLogic.Or;
        this._filteringExpressions = [];
        this._sortingExpressions = [];
        this._groupKey = '';
        this._prevInputValue = '';
        this._dataType = '';
        this.ngControl = null;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._data = [];
        this._filteredData = [];
        this._itemHeight = null;
        this._itemsMaxHeight = null;
        this._remoteSelection = {};
        this._onChangeCallback = noop$4;
        this._overlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludePositionTarget: true
        };
        this._value = '';
        this._valid = IgxComboState.INITIAL;
        /**
         * Set custom overlay settings that control how the combo's list of items is displayed.
         * Set:
         * ```html
         * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
         * ```
         *
         * ```typescript
         *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
         *  combo.overlaySettings = customSettings;
         * ```
         * Get any custom overlay settings used by the combo:
         * ```typescript
         *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
         * ```
         */
        this.overlaySettings = null;
        /**
         * @hidden \@internal
         */
        this.searchInput = null;
        /**
         * The custom template, if any, that should be used when rendering ITEMS in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.itemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboItem>
         *          <div class="custom-item" let-item let-key="valueKey">
         *              <div class="custom-item__name">{{ item[key] }}</div>
         *              <div class="custom-item__cost">{{ item.cost }}</div>
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.itemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeader>
         *          <div class="combo__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboFooter>
         *          <div class="combo__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.footerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
         *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.addItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboAddItem>
         *          <button class="combo__add-button">
         *              Click to add item
         *          </button>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.addItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.emptyTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboEmpty>
         *          <div class="combo--empty">
         *              There are no items to display
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.emptyTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo CLEAR button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.clearIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboClearIcon>
         *          <igx-icon>clear</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.clearIconTemplate = null;
        this.dropdownContainer = null;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
         * ```
         */
        this.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-combo onOpening='handleOpening($event)'></igx-combo>
         * ```
         */
        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-combo (onOpened)='handleOpened()'></igx-combo>
         * ```
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
         * ```
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosed)='handleClosed()'></igx-combo>
         * ```
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when an item is being added to the data collection
         *
         * ```html
         * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
         * ```
         */
        this.onAddition = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
         *
         * ```html
         * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
         * ```
         */
        this.onSearchInput = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when new chunk of data is loaded from the virtualization
         *
         * ```html
         * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
         * ```
         */
        this.onDataPreLoad = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/gets combo id.
         *
         * ```typescript
         * // get
         * let id = this.combo.id;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [id]='combo1'></igx-combo>
         * ```
         */
        this.id = `igx-combo-${NEXT_ID$j++}`;
        /**
         * @hidden \@internal
         */
        this.cssClass = 'igx-combo'; // Independent of display density, at the time being
        // Independent of display density, at the time being
        /**
         * @hidden \@internal
         */
        this.role = 'combobox';
        /**
         * Controls whether custom values can be added to the collection
         *
         * ```typescript
         * // get
         * let comboAllowsCustomValues = this.combo.allowCustomValues;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [allowCustomValues]='true'></igx-combo>
         * ```
         */
        this.allowCustomValues = false;
        /**
         * @hidden \@internal
         */
        this.filteringLogic = FilteringLogic.Or;
        /**
         * Defines the placeholder value for the combo dropdown search field
         *
         * ```typescript
         * // get
         * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
         * ```
         */
        this.searchPlaceholder = 'Enter a Search Term';
        /**
         * Combo value data source property.
         *
         * ```typescript
         * // get
         * let myComboValueKey = this.combo.valueKey;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [valueKey]='myKey'></igx-combo>
         * ```
         */
        this.valueKey = null;
        /**
         * An \@Input property that enabled/disables filtering in the list. The default is `true`.
         * ```html
         * <igx-combo [filterable]="'false'">
         * ```
         */
        this.filterable = true;
        /**
         * An \@Input property that enabled/disables combo. The default is `false`.
         * ```html
         * <igx-combo [disabled]="'true'">
         * ```
         */
        this.disabled = false;
        /**
         * An \@Input property that sets how the combo will be styled.
         * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
         * ```html
         * <igx-combo [type]="'line'">
         * ```
         */
        this.type = 'box';
        /**
         * @hidden \@internal
         */
        this.searchValue = '';
        this.onStatusChanged = () => {
            if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
                (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
                this.valid = this.ngControl.valid ? IgxComboState.VALID : IgxComboState.INVALID;
            }
            this.manageRequiredAsterisk();
        };
        this.comboAPI.register(this);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get displaySearchInput() {
        return this.filterable || this.allowCustomValues;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get ariaExpanded() {
        return !this.dropdown.collapsed;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get hasPopUp() {
        return 'listbox';
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get ariaOwns() {
        return this.dropdown.id;
    }
    /**
     * Configures the drop down list height
     *
     * ```typescript
     * // get
     * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemsMaxHeight]='320'></igx-combo>
     * ```
     * @return {?}
     */
    get itemsMaxHeight() {
        if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
            return this.itemHeight * itemsInContainer;
        }
        return this._itemsMaxHeight;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set itemsMaxHeight(val) {
        this._itemsMaxHeight = val;
    }
    /**
     * Configures the drop down list item height
     *
     * ```typescript
     * // get
     * let myComboItemHeight = this.combo.itemHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemHeight]='32'></igx-combo>
     * ```
     * @return {?}
     */
    get itemHeight() {
        if (this._itemHeight === null || this._itemHeight === undefined) {
            return ItemHeights[this.displayDensity];
        }
        return this._itemHeight;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set itemHeight(val) {
        this._itemHeight = val;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get inputEmpty() {
        return !this.value && !this.placeholder;
    }
    /**
     * Combo data source.
     *
     * ```html
     * <!--set-->
     * <igx-combo [data]='items'></igx-combo>
     * ```
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        this._data = (val) ? val : [];
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set displayKey(val) {
        this._displayKey = val;
    }
    /**
     * Combo text data source property.
     *
     * ```typescript
     * // get
     * let myComboDisplayKey = this.combo.displayKey;
     *
     * // set
     * this.combo.displayKey = 'val';
     *
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
     * ```
     * @return {?}
     */
    get displayKey() {
        return this._displayKey ? this._displayKey : this.valueKey;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```html
     * <!--set-->
     * <igx-combo [groupKey]='newGroupKey'></igx-combo>
     * ```
     * @param {?} val
     * @return {?}
     */
    set groupKey(val) {
        this.clearSorting(this._groupKey);
        this._groupKey = val;
        this.sort(this._groupKey);
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```typescript
     * // get
     * let currentGroupKey = this.combo.groupKey;
     * ```
     * @return {?}
     */
    get groupKey() {
        return this._groupKey;
    }
    /**
     * Gets if control is valid, when used in a form
     *
     * ```typescript
     * // get
     * let valid = this.combo.valid;
     * ```
     *
     * @return {?}
     */
    get valid() {
        return this._valid;
    }
    /**
     * Sets if control is valid, when used in a form
     *
     * ```typescript
     * // set
     * this.combo.valid = IgxComboState.INVALID;
     * ```
     * @param {?} valid
     * @return {?}
     */
    set valid(valid) {
        this._valid = valid;
        this.comboInput.valid = IgxInputState[IgxComboState[valid]];
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.open();
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    onInputClick(event) {
        event.stopPropagation();
        event.preventDefault();
        this.toggle();
    }
    /**
     * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
     *
     * ```typescript
     * // get
     * let state = this.combo.virtualizationState;
     * ```
     * @return {?}
     */
    get virtualizationState() {
        return this.virtDir.state;
    }
    /**
     * Sets the current state of the virtualized data.
     *
     * ```typescript
     * // set
     * this.combo.virtualizationState(state);
     * ```
     * @param {?} state
     * @return {?}
     */
    set virtualizationState(state) {
        this.virtDir.state = state;
    }
    /**
     * Gets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // get
     * let count = this.combo.totalItemCount;
     * ```
     * @return {?}
     */
    get totalItemCount() {
        return this.virtDir.totalItemCount;
    }
    /**
     * Sets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // set
     * this.combo.totalItemCount(remoteService.count);
     * ```
     * @param {?} count
     * @return {?}
     */
    set totalItemCount(count) {
        this.virtDir.totalItemCount = count;
        this.cdr.detectChanges();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get filteringExpressions() {
        return this.filterable ? this._filteringExpressions : [];
    }
    /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    set filteringExpressions(value) {
        this._filteringExpressions = value;
        this.cdr.markForCheck();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get sortingExpressions() {
        return this._sortingExpressions;
    }
    /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    set sortingExpressions(value) {
        this._sortingExpressions = value;
        this.cdr.markForCheck();
    }
    /**
     * @protected
     * @param {?=} field
     * @return {?}
     */
    clearSorting(field) {
        if (field === undefined || field === null) {
            this.sortingExpressions = [];
            return;
        }
        /** @type {?} */
        const currentState = cloneArray(this.sortingExpressions);
        /** @type {?} */
        const index = currentState.findIndex((expr) => expr.fieldName === field);
        if (index > -1) {
            currentState.splice(index, 1);
            this.sortingExpressions = currentState;
        }
    }
    /**
     * The text displayed in the combo input
     *
     * ```typescript
     * // get
     * let comboValue = this.combo.value;
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get filteredData() {
        return this.filterable ? this._filteredData : this.data;
    }
    /**
     * @hidden \@internal
     * @param {?} val
     * @return {?}
     */
    set filteredData(val) {
        this._filteredData = this.groupKey ? (val || []).filter((e) => e.isHeader !== true) : val;
        this.checkMatch();
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    handleKeyUp(event) {
        if (event.key === 'ArrowDown' || event.key === 'Down') {
            this.dropdown.focusedItem = this.dropdown.items[0];
            this.dropdownContainer.nativeElement.focus();
        }
        else if (event.key === 'Escape' || event.key === 'Esc') {
            this.toggle();
        }
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    handleKeyDown(event) {
        if (event.key === 'ArrowUp' || event.key === 'Up') {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkMatch() {
        /** @type {?} */
        const displayKey = this.displayKey;
        /** @type {?} */
        const matchFn = (e) => {
            /** @type {?} */
            const value = displayKey ? e[displayKey] : e;
            return value.toString().toLowerCase() === this.searchValue.trim().toLowerCase();
        };
        /** @type {?} */
        const itemMatch = this.filteredData.some(matchFn);
        this.customValueFlag = this.allowCustomValues && !itemMatch;
    }
    /**
     * @hidden \@internal
     * @param {?=} event
     * @return {?}
     */
    handleInputChange(event) {
        /** @type {?} */
        let cdrFlag = false;
        /** @type {?} */
        const vContainer = this.virtDir;
        if (event !== undefined && this._prevInputValue === event) {
            // Nothing has changed
            return;
        }
        else {
            this._prevInputValue = event !== undefined ? event : '';
        }
        if (event !== undefined) {
            // Do not scroll if not scrollable
            if (vContainer.isScrollable()) {
                vContainer.scrollTo(0);
            }
            else {
                cdrFlag = true;
            }
            this.onSearchInput.emit(event);
        }
        else {
            cdrFlag = true;
        }
        if (this.filterable) {
            this.filter();
            // If there was no scroll before filtering, check if there is after and detect changes
            if (cdrFlag) {
                vContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["take"])(1)).subscribe(() => {
                    if (vContainer.isScrollable()) {
                        this.cdr.detectChanges();
                    }
                });
            }
        }
        else {
            this.checkMatch();
        }
    }
    /**
     * @hidden \@internal
     * @param {?} fieldName
     * @param {?=} dir
     * @param {?=} ignoreCase
     * @param {?=} strategy
     * @return {?}
     */
    sort(fieldName, dir = SortingDirection.Asc, ignoreCase = true, strategy = DefaultSortingStrategy.instance()) {
        if (!fieldName) {
            return;
        }
        /** @type {?} */
        const sortingState = cloneArray(this.sortingExpressions, true);
        this.prepare_sorting_expression(sortingState, fieldName, dir, ignoreCase, strategy);
        this.sortingExpressions = sortingState;
    }
    /**
     * @protected
     * @param {?} state
     * @param {?} fieldName
     * @param {?} dir
     * @param {?} ignoreCase
     * @param {?} strategy
     * @return {?}
     */
    prepare_sorting_expression(state, fieldName, dir, ignoreCase, strategy) {
        if (dir === SortingDirection.None) {
            state.splice(state.findIndex((expr) => expr.fieldName === fieldName), 1);
            return;
        }
        /** @type {?} */
        const expression = state.find((expr) => expr.fieldName === fieldName);
        if (!expression) {
            state.push({ fieldName, dir, ignoreCase, strategy });
        }
        else {
            Object.assign(expression, { fieldName, dir, ignoreCase });
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get dataType() {
        if (this.displayKey) {
            return DataTypes.COMPLEX;
        }
        return DataTypes.PRIMITIVE;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get isRemote() {
        return this.totalItemCount > 0 &&
            this.valueKey &&
            this.dataType === DataTypes.COMPLEX;
    }
    /**
     * Contains key-value pairs of the selected valueKeys and their resp. displayKeys
     * @private
     * @param {?} ids
     * @param {?=} add
     * @return {?}
     */
    registerRemoteEntries(ids, add = true) {
        if (add) {
            /** @type {?} */
            const selection = this.getValueDisplayPairs(ids);
            for (const entry of selection) {
                this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
            }
        }
        else {
            for (const entry of ids) {
                delete this._remoteSelection[entry];
            }
        }
    }
    /**
     * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`
     * @private
     * @param {?} ids
     * @return {?}
     */
    getValueDisplayPairs(ids) {
        return this.data.filter(entry => ids.indexOf(entry[this.valueKey]) > -1).map(e => {
            return {
                [this.valueKey]: e[this.valueKey],
                [this.displayKey]: e[this.displayKey]
            };
        });
    }
    /**
     * Returns if the specified itemID is selected
     * @hidden
     * \@internal
     * @param {?} item
     * @return {?}
     */
    isItemSelected(item) {
        return this.selection.is_item_selected(this.id, item);
    }
    /**
     * Triggers change detection on the combo view
     * @return {?}
     */
    triggerCheck() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    isAddButtonVisible() {
        // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
        return this.searchValue !== '' && this.customValueFlag;
    }
    /**
     * @hidden \@internal
     * @param {?} evt
     * @return {?}
     */
    handleSelectAll(evt) {
        if (evt.checked) {
            this.selectAllItems();
        }
        else {
            this.deselectAllItems();
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    addItemToCollection() {
        if (!this.searchValue) {
            return;
        }
        /** @type {?} */
        const newValue = this.searchValue.trim();
        /** @type {?} */
        const addedItem = this.displayKey ? {
            [this.valueKey]: newValue,
            [this.displayKey]: newValue
        } : newValue;
        if (this.groupKey) {
            Object.assign(addedItem, { [this.groupKey]: this.defaultFallbackGroup });
        }
        /** @type {?} */
        const oldCollection = this.data;
        /** @type {?} */
        const newCollection = [...this.data];
        newCollection.push(addedItem);
        /** @type {?} */
        const args = {
            oldCollection, addedItem, newCollection
        };
        this.onAddition.emit(args);
        this.data.push(addedItem);
        // If you mutate the array, no pipe is invoked and the display isn't updated;
        // if you replace the array, the pipe executes and the display is updated.
        this.data = cloneArray(this.data);
        this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
        this.customValueFlag = false;
        this.searchInput.nativeElement.focus();
        this.dropdown.focusedItem = null;
        this.handleInputChange();
    }
    /**
     * @hidden \@internal
     * @param {?=} opening
     * @return {?}
     */
    focusSearchInput(opening) {
        if (this.displaySearchInput && this.searchInput) {
            this.searchInput.nativeElement.focus();
        }
        else {
            if (opening) {
                this.dropdownContainer.nativeElement.focus();
            }
            else {
                this.comboInput.nativeElement.focus();
                this.toggle();
            }
        }
    }
    /**
     * @protected
     * @param {?} searchVal
     * @param {?} condition
     * @param {?} ignoreCase
     * @param {?=} fieldName
     * @return {?}
     */
    prepare_filtering_expression(searchVal, condition, ignoreCase, fieldName) {
        /** @type {?} */
        const newArray = [...this.filteringExpressions];
        /** @type {?} */
        const expression = newArray.find((expr) => expr.fieldName === fieldName);
        /** @type {?} */
        const newExpression = { fieldName, searchVal, condition, ignoreCase };
        if (!expression) {
            newArray.push(newExpression);
        }
        else {
            Object.assign(expression, newExpression);
        }
        if (this.groupKey) {
            /** @type {?} */
            const expression2 = newArray.find((expr) => expr.fieldName === 'isHeader');
            /** @type {?} */
            const headerExpression = {
                fieldName: 'isHeader', searchVale: '',
                condition: IgxBooleanFilteringOperand.instance().condition('true'), ignoreCase: true
            };
            if (!expression2) {
                newArray.push(headerExpression);
            }
            else {
                Object.assign(expression2, headerExpression);
            }
        }
        this.filteringExpressions = newArray;
    }
    /**
     * @protected
     * @return {?}
     */
    manageRequiredAsterisk() {
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            /** @type {?} */
            const error = this.ngControl.control.validator((/** @type {?} */ ({})));
            this.inputGroup.isRequired = error && error.required;
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onBlur() {
        if (this.collapsed) {
            if (this.ngControl && !this.ngControl.valid) {
                this.valid = IgxComboState.INVALID;
            }
            else {
                this.valid = IgxComboState.INITIAL;
            }
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    filter() {
        this.prepare_filtering_expression(this.searchValue.trim(), IgxStringFilteringOperand.instance().condition('contains'), true, this.dataType === DataTypes.PRIMITIVE ? undefined : this.displayKey);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this._injector.get((/** @type {?} */ (_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"])), null);
        this._overlaySettings.positionStrategy.settings.target = this.elementRef.nativeElement;
        this.selection.set(this.id, new Set());
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngAfterViewInit() {
        this.filteredData = [...this.data];
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(this.onStatusChanged);
            this.manageRequiredAsterisk();
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.comboAPI.clear();
        this.selection.clear(this.id);
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.selectItems(value, true);
        this.cdr.markForCheck();
    }
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @hidden \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.comboInput.nativeElement;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get template() {
        this._dataType = this.dataType;
        if (this.itemTemplate) {
            return this.itemTemplate;
        }
        if (this._dataType === DataTypes.COMPLEX) {
            return this.complexTemplate;
        }
        return this.primitiveTemplate;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    handleClearItems(event) {
        this.deselectAllItems(true, event);
        event.stopPropagation();
    }
    /**
     * A method that opens/closes the combo.
     *
     * ```html
     * <button (click)="combo.toggle()">Toggle Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    toggle() {
        /** @type {?} */
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.toggle(overlaySettings);
    }
    /**
     * A method that opens the combo.
     *
     * ```html
     * <button (click)="combo.open()">Open Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    open() {
        /** @type {?} */
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.open(overlaySettings);
    }
    /**
     * A method that closes the combo.
     *
     * ```html
     * <button (click)="combo.close()">Close Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    close() {
        this.dropdown.close();
    }
    /**
     * Gets drop down state.
     *
     * ```typescript
     * let state = this.combo.collapsed;
     * ```
     * @return {?}
     */
    get collapsed() {
        return this.dropdown.collapsed;
    }
    /**
     * Get current selection state
     * @return {?} Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    selectedItems() {
        /** @type {?} */
        const items = Array.from(this.selection.get(this.id));
        return items;
    }
    /**
     * Select defined items
     * @param {?} newItems new items to be selected
     * @param {?=} clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     * @param {?=} event
     * @return {?}
     */
    selectItems(newItems, clearCurrentSelection, event) {
        if (newItems) {
            /** @type {?} */
            const newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Deselect defined items
     * @param {?} items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     * @param {?=} event
     * @return {?}
     */
    deselectItems(items, event) {
        if (items) {
            /** @type {?} */
            const newSelection = this.selection.delete_items(this.id, items);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Select all (filtered) items
     * @param {?=} ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     * @param {?=} event
     * @return {?}
     */
    selectAllItems(ignoreFilter, event) {
        /** @type {?} */
        const allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
        /** @type {?} */
        const newSelection = this.selection.add_items(this.id, allVisible);
        this.setSelection(newSelection, event);
    }
    /**
     * Deselect all (filtered) items
     * @param {?=} ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     * @param {?=} event
     * @return {?}
     */
    deselectAllItems(ignoreFilter, event) {
        /** @type {?} */
        let newSelection = this.selection.get_empty();
        if (this.filteredData.length !== this.data.length && !ignoreFilter) {
            newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
        }
        this.setSelection(newSelection, event);
    }
    /**
     * Selects/Deselects a single item
     * @param {?} itemID the itemID of the specific item
     * @param {?=} select If the item should be selected (true) or deselected (false)
     *
     * Without specified valueKey;
     * ```typescript
     * this.combo.valueKey = null;
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem(items[0], true);
     * ```
     * With specified valueKey;
     * ```typescript
     * this.combo.valueKey = 'field';
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * ```
     * @param {?=} event
     * @return {?}
     */
    setSelectedItem(itemID, select = true, event) {
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (select) {
            this.selectItems([itemID], false, event);
        }
        else {
            this.deselectItems([itemID], event);
        }
    }
    /**
     * @protected
     * @param {?} newSelection
     * @param {?=} event
     * @return {?}
     */
    setSelection(newSelection, event) {
        /** @type {?} */
        const removed = diffInSets(this.selection.get(this.id), newSelection);
        /** @type {?} */
        const added = diffInSets(newSelection, this.selection.get(this.id));
        /** @type {?} */
        const args = {
            newSelection: Array.from(newSelection),
            oldSelection: Array.from(this.selection.get(this.id) || []),
            added,
            removed,
            event,
            cancel: false
        };
        this.onSelectionChange.emit(args);
        if (!args.cancel) {
            this.selection.select_items(this.id, args.newSelection, true);
            /** @type {?} */
            let value = '';
            if (this.isRemote) {
                if (args.newSelection.length) {
                    /** @type {?} */
                    const removedItems = args.oldSelection.filter(e => args.newSelection.indexOf(e) < 0);
                    /** @type {?} */
                    const addedItems = args.newSelection.filter(e => args.oldSelection.indexOf(e) < 0);
                    this.registerRemoteEntries(addedItems);
                    this.registerRemoteEntries(removedItems, false);
                    value = Object.keys(this._remoteSelection).map(e => this._remoteSelection[e]).join(', ');
                }
                else {
                    // If new selection is empty, clear all items
                    this.registerRemoteEntries(args.oldSelection, false);
                }
            }
            else {
                value = this.displayKey !== null && this.displayKey !== undefined ?
                    this.convertKeysToItems(args.newSelection).map(entry => entry[this.displayKey]).join(', ') :
                    args.newSelection.join(', ');
            }
            this._value = value;
            this._onChangeCallback(args.newSelection);
        }
    }
    /**
     * if there is a valueKey - map the keys to data items, else - just return the keys
     * @private
     * @param {?} keys
     * @return {?}
     */
    convertKeysToItems(keys) {
        if (this.comboAPI.valueKey === null) {
            return keys;
        }
        // map keys vs. filter data to retain the order of the selected items
        return keys.map(key => this.data.find(entry => entry[this.valueKey] === key)).filter(e => e !== undefined);
    }
    /**
     * Event handlers
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    handleOpening(event) {
        this.onOpening.emit(event);
        if (event.cancel) {
            return;
        }
        this.handleInputChange();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    handleOpened() {
        this.triggerCheck();
        this.focusSearchInput(true);
        this.onOpened.emit();
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    handleClosing(event) {
        this.onClosing.emit(event);
        if (event.cancel) {
            return;
        }
        this.searchValue = '';
        this.comboInput.nativeElement.focus();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    handleClosed() {
        this.onClosed.emit();
    }
}
IgxComboComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-combo',
                template: "<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>\n\n<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n            <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n        </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" />\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\" igxRipple (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\" fontSet=\"material\">clear</igx-icon>\n    </igx-suffix>\n    <igx-suffix igxButton=\"icon\" class=\"igx-combo__toggle-button\" igxRipple>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\" [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\"\n    (onClosing)=\"handleClosing($event)\" (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\" [style.maxHeight.px]=\"itemsMaxHeight\"\n        [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\" [tabindex]=\"dropdown.collapsed ? -1 : 0\"\n        role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <ng-template igxFor let-item let-index=\"index\" [igxForOf]=\"data | comboFiltering:filteringExpressions:filteringLogic | comboSorting:sortingExpressions | comboGrouping:groupKey\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForContainerSize]=\"itemsMaxHeight\" [igxForItemSize]=\"itemHeight\"\n            (onChunkPreload)=\"dataLoading($event)\">\n            <igx-combo-item  [itemHeight]='itemHeight' [value]=\"item\" [isHeader]=\"item.isHeader\" role=\"option\" [index]=\"index\">\n                <ng-container *ngIf=\"item.isHeader\">\n                    <ng-container *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase; context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\"></ng-container>\n                </ng-container>\n                <ng-container *ngIf=\"!item.isHeader\">\n                    <ng-container #listItem *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\"></ng-container>\n                </ng-container>\n            </igx-combo-item>\n        </ng-template>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\" [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\"\n            class=\"igx-combo__add-item\" role=\"button\" aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n",
                providers: [
                    IgxComboAPIService,
                    { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent },
                    { provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxComboComponent), multi: true }
                ]
            }] }
];
/** @nocollapse */
IgxComboComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxSelectionAPIService },
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxComboComponent.propDecorators = {
    virtDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxForOfDirective, { read: IgxForOfDirective, static: true },] }],
    overlaySettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inputGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
    comboInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['comboInput', { read: IgxInputDirective, static: true },] }],
    dropdown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true },] }],
    searchInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['searchInput', { static: false },] }],
    itemTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboItemDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    headerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboHeaderDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    footerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboFooterDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    headerItemTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboHeaderItemDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    addItemTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboAddItemDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    emptyTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboEmptyDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    toggleIconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboToggleIconDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    clearIconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxComboClearIconDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    primitiveTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['primitive', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    complexTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['complex', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    virtualScrollContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxForOfDirective, { static: true },] }],
    dropdownContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dropdownItemContainer', { static: true },] }],
    onSelectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpening: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onAddition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSearchInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDataPreLoad: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-combo',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.role`,] }],
    ariaExpanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-expanded',] }],
    hasPopUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-haspopup',] }],
    ariaOwns: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-owns',] }],
    allowCustomValues: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    itemsMaxHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    itemsWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    itemHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    searchPlaceholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    valueKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ariaLabelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-labelledby',] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onArrowDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.ArrowDown', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Alt.ArrowDown', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxComboModule {
}
IgxComboModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboFilterConditionPipe, IgxComboGroupingPipe,
                    IgxComboFilteringPipe, IgxComboSortingPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                imports: [IgxRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxInputGroupModule, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"],
                    IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
                providers: [IgxSelectionAPIService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
class DatePickerUtil {
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param {?} maskValue
     * @param {?=} locale
     * @return {?} array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        /** @type {?} */
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            /** @type {?} */
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            /** @type {?} */
            const maskArray = Array.from(mask);
            /** @type {?} */
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            /** @type {?} */
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            /** @type {?} */
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     * @param {?} dateStruct array
     * @return {?} input mask
     */
    static getInputMask(dateStruct) {
        /** @type {?} */
        const inputMask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     * @param {?} dateStruct
     * @return {?} editor mask
     */
    static getMask(dateStruct) {
        /** @type {?} */
        const mask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param {?} dateFormatParts
     * @param {?} prevDateValue
     * @param {?} inputValue
     * @return {?} object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        /** @type {?} */
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        /** @type {?} */
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        /** @type {?} */
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        /** @type {?} */
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        /** @type {?} */
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        /** @type {?} */
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        /** @type {?} */
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        /** @type {?} */
        let yearPrefix;
        if (prevDateValue) {
            /** @type {?} */
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        /** @type {?} */
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month + 1)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    /**
     * @param {?} mask
     * @return {?}
     */
    static maskToPromptChars(mask) {
        /** @type {?} */
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     * @param {?} value
     * @return {?}
     */
    static trimUnderlines(value) {
        /** @type {?} */
        const result = value.replace(/_/g, '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?} position
     * @param {?} delta
     * @param {?} isSpinLoop
     * @return {?} modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        /** @type {?} */
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        /** @type {?} */
        const datePartType = datePart.type;
        /** @type {?} */
        const datePartFormatType = datePart.formatType;
        /** @type {?} */
        let newValue;
        /** @type {?} */
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        /** @type {?} */
        let maxValue;
        /** @type {?} */
        let minValue;
        /** @type {?} */
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        /** @type {?} */
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        /** @type {?} */
        const startIdx = datePart.position[0];
        /** @type {?} */
        const endIdx = datePart.position[1];
        /** @type {?} */
        const start = inputValue.slice(0, startIdx);
        /** @type {?} */
        const end = inputValue.slice(endIdx, inputValue.length);
        /** @type {?} */
        let changedPart;
        /** @type {?} */
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     * @param {?} dateFormatParts
     * @param {?} date
     * @param {?} inputValue
     * @return {?} date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        /** @type {?} */
        const dateArray = Array.from(inputValue);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     * @param {?} dateFormatParts
     * @param {?} input
     * @return {?} input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        /** @type {?} */
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        /** @type {?} */
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        /** @type {?} */
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        /** @type {?} */
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        /** @type {?} */
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    /**
     * @private
     * @param {?} format
     * @return {?}
     */
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    /**
     * @private
     * @param {?} format
     * @return {?}
     */
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    /**
     * @private
     * @param {?} format
     * @return {?}
     */
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    /**
     * @private
     * @param {?} locale
     * @return {?}
     */
    static getDefaultLocaleMask(locale) {
        /** @type {?} */
        const dateStruct = [];
        /** @type {?} */
        const formatter = new Intl.DateTimeFormat(locale);
        /** @type {?} */
        const formatToParts = formatter.formatToParts(new Date());
        for (let i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type,
                });
            }
        }
        /** @type {?} */
        const formatterOptions = formatter.resolvedOptions();
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    /**
     * @private
     * @param {?} char
     * @return {?}
     */
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    /**
     * @private
     * @param {?} formatType
     * @return {?}
     */
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} datePart
     * @param {?} inputValue
     * @return {?}
     */
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        /** @type {?} */
        let maxValue;
        /** @type {?} */
        let minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    /**
     * @private
     * @param {?} fullYear
     * @param {?} month
     * @return {?}
     */
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month, 0).getDate();
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} type
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        /** @type {?} */
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        /** @type {?} */
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimUnderlines(result) : result;
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} type
     * @return {?}
     */
    static getDateFormatPart(dateFormatParts, type) {
        /** @type {?} */
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} input
     * @return {?}
     */
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} value
     * @return {?}
     */
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} position
     * @return {?}
     */
    static getDatePartOnPosition(dateFormatParts, position) {
        /** @type {?} */
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    /**
     * @private
     * @param {?} yearPart
     * @param {?} inputValue
     * @return {?}
     */
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    /**
     * @private
     * @param {?} dateArray
     * @return {?}
     */
    static fillDatePartsPositions(dateArray) {
        /** @type {?} */
        let currentPos = 0;
        for (let i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
const IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class DatePickerDisplayValuePipe {
    /**
     * @param {?} _datePicker
     */
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    transform(value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimUnderlines(value);
        }
        return '';
    }
}
DatePickerDisplayValuePipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'displayValue'
            },] }
];
/** @nocollapse */
DatePickerDisplayValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
/**
 * @hidden
 */
class DatePickerInputValuePipe {
    /**
     * @param {?} _datePicker
     */
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    transform(value, args) {
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    }
}
DatePickerInputValuePipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'inputValue'
            },] }
];
/** @nocollapse */
DatePickerInputValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_DATE_PICKER_COMPONENT,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
 *
 * @hidden
 */
class IgxDatePickerTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxDatePickerTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDatePickerTemplate]'
            },] }
];
/** @nocollapse */
IgxDatePickerTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
 */
class IgxDatePickerActionsDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxDatePickerActionsDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDatePickerActions]'
            },] }
];
/** @nocollapse */
IgxDatePickerActionsDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const InteractionMode = {
    DropDown: 'dropdown',
    Dialog: 'dialog',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxCalendarContainerComponent {
    constructor() {
        this.mode = InteractionMode.Dialog;
        this.vertical = false;
        this.onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onTodaySelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.styleClass = 'igx-date-picker';
    }
    /**
     * @return {?}
     */
    get dropdownCSS() {
        return this.mode === InteractionMode.DropDown;
    }
    /**
     * @return {?}
     */
    get verticalCSS() {
        return this.vertical && this.mode === InteractionMode.Dialog;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEscape(event) {
        event.preventDefault();
        this.onClose.emit();
    }
    /**
     * Returns whether the date-picker is in readonly dialog mode.
     *
     * @hidden
     * @return {?}
     */
    get isReadonly() {
        return this.mode === InteractionMode.Dialog;
    }
    /**
     * Emits close event for the calendar.
     * @return {?}
     */
    closeCalendar() {
        this.onClose.emit();
    }
    /**
     * Emits today selection event for the calendar.
     * @return {?}
     */
    triggerTodaySelection() {
        this.onTodaySelection.emit();
    }
}
IgxCalendarContainerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-calendar-container',
                template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
                styles: [':host {display: block;}']
            }] }
];
IgxCalendarContainerComponent.propDecorators = {
    calendar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['calendar', { static: true },] }],
    mode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cancelButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    todayButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    datePickerActions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onTodaySelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-date-picker',] }],
    dropdownCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-date-picker--dropdown',] }],
    verticalCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-date-picker--vertical',] }],
    onEscape: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.esc', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.alt.arrowup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$k = 0;
/** @enum {string} */
const PredefinedFormatOptions = {
    ShortDate: 'shortDate',
    MediumDate: 'mediumDate',
    LongDate: 'longDate',
    FullDate: 'fullDate',
};
/**
 * **Ignite UI for Angular Date Picker** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/date_picker.html)
 *
 * The Ignite UI Date Picker displays a popup calendar that lets users select a single date.
 *
 * Example:
 * ```html
 * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
 * ```
 */
class IgxDatePickerComponent {
    /**
     * @param {?} _overlayService
     * @param {?} element
     * @param {?} _cdr
     * @param {?} _moduleRef
     */
    constructor(_overlayService, element, _cdr, _moduleRef) {
        this._overlayService = _overlayService;
        this.element = element;
        this._cdr = _cdr;
        this._moduleRef = _moduleRef;
        /**
         * An \@Input property that sets the `IgxDatePickerComponent` label.
         * The default label is 'Date'.
         * ```html
         * <igx-date-picker [label]="Calendar"></igx-date-picker>
         * ```
         */
        this.label = 'Date';
        /**
         * An \@Input property that sets the `IgxDatePickerComponent` label visibility.
         * By default the visibility is set to true.
         * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
         */
        this.labelVisibility = true;
        /**
         * An \@Input property that sets on which day the week starts.
         * ```html
         * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * Sets/gets the number of month views displayed.
         * Default value is `1`.
         * ```html
         * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
         * ```
         * ```typescript
         * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
         * ```
         */
        this.monthsViewNumber = 1;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.id = `igx-date-picker-${NEXT_ID$k++}`;
        /**
         * An \@Input property that sets the orientation of the `IgxDatePickerComponent` header.
         * ```html
         * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.vertical = false;
        /**
         * An \@Input property that sets whether `IgxDatePickerComponent` is in dialog or drop down mode.
         * ```html
         * <igx-date-picker mode="dropdown"></igx-date-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * An \@Input property that sets whether the `IgxDatePickerComponent` date parts would spin continuously or stop when min/max is reached.
         * ```html
         * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An event that is emitted when the `IgxDatePickerComponent` calendar is opened.
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the `IgxDatePickerComponent` is closed.
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the `IgxDatePickerComponent` is being closed.
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that is fired when selection is made in the calendar.
         * ```typescript
         * public selection(event){
         *    alert("A date has been selected!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onSelection)="selection($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that is fired when date picker value is changed.
         * ```typescript
         * public valueChanged(event){
         *    alert("Date picker value is changed");
         * }
         * ```
         * ```html
         * <igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
         * ```
         */
        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that fires when the user types/spins to a disabled date in the date-picker editor.
         * ```typescript
         * public onDisabledDate(event){
         *    alert("This date is disabled!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
         * ```
         */
        this.onDisabledDate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that fires when the user types/spins invalid date in the date-picker editor.
         * ```typescript
         * public onValidationFailed(event){
         *    alert("This date is not valid!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
         * ```
         */
        this.onValidationFailed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.hasHeader = true;
        this.collapsed = true;
        this.displayValuePipe = new DatePickerDisplayValuePipe(this);
        this.inputValuePipe = new DatePickerInputValuePipe(this);
        this.dateFormatParts = [];
        this.isEmpty = true;
        this.invalidDate = '';
        this.spinDelta = 1;
        this.defaultLocale = 'en';
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._disabledDates = null;
        this._specialDates = null;
        this._onOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._onTouchedCallback = () => { };
        this._onChangeCallback = () => { };
    }
    /**
     * Returns the format options of the `IgxDatePickerComponent`.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    let formatOptions = this.datePicker.formatOptions;
     * }
     * ```
     * @return {?}
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the format options of the `IgxDatePickerComponent`.
     * ```typescript
     * public Options;
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.Options = {
     *        day: "numeric",
     *        month: "long",
     *        weekday: "long",
     *        year: "numeric"
     *    }
     * this.datePicker.formatOptions = this.Options;
     * }
     * ```
     * @param {?} formatOptions
     * @return {?}
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
    }
    /**
     * Returns the date display format of the `IgxDatePickerComponent` in dropdown mode.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    let format = this.datePicker.format;
     * }
     * ```
     * @return {?}
     */
    get format() {
        return (this._format === undefined) ? PredefinedFormatOptions.ShortDate : this._format;
    }
    /**
     * Sets the date format of the `IgxDatePickerComponent` when in editable dropdown mode.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * this.datePicker.format = 'yyyy-M-d';
     * }
     * ```
     * @param {?} format
     * @return {?}
     */
    set format(format) {
        this._format = format;
    }
    /**
     * Returns the format views of the `IgxDatePickerComponent`.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    let formatViews = this.datePicker.formatViews;
     * }
     * ```
     * @return {?}
     */
    get formatViews() {
        return this._formatViews;
    }
    /**
     * Sets the format views of the `IgxDatePickerComponent`.
     * ```typescript
     * public Views;
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.Views = {day:false, month: false, year:false};
     *    this.datePicker.formatViews = this.Views;
     * }
     * ```
     * @param {?} formatViews
     * @return {?}
     */
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     * Gets the disabled dates descriptors.
     * ```typescript
     * let disabledDates = this.datepicker.disabledDates;
     * ```
     * @return {?}
     */
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Sets the disabled dates' descriptors.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.datePicker.disabledDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set disabledDates(value) {
        this._disabledDates = value;
    }
    /**
     * Gets the special dates descriptors.
     * ```typescript
     * let specialDates = this.datepicker.specialDates;
     * ```
     * @return {?}
     */
    get specialDates() {
        return this._specialDates;
    }
    /**
     * Sets the special dates' descriptors.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.datePicker.specialDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * @return {?}
     */
    get modalOverlaySettings() {
        return this._modalOverlay;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set modalOverlaySettings(value) {
        this._modalOverlay = value;
    }
    /**
     * @return {?}
     */
    get dropDownOverlaySettings() {
        return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dropDownOverlaySettings(value) {
        this._dropDownOverlaySettings = value;
    }
    /**
     * Returns the formatted date when `IgxDatePickerComponent` is in dialog mode.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * public selection(event){
     *    let selectedDate = this.datePicker.displayData;
     *    alert(selectedDate);
     * }
     * ```
     * ```html
     * <igx-date-picker #MyDatePicker (onSelection)="selection()" todayButtonLabel="today"></igx-date-picker>
     * ```
     * @return {?}
     */
    get displayData() {
        if (this.value) {
            return this._customFormatChecker(this.formatter, this.value);
        }
        return '';
    }
    /**
     * hidden
     * @return {?}
     */
    get transformedDate() {
        if (this._value) {
            this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
            this.isEmpty = false;
        }
        else {
            this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
        }
        return this._transformedDate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set transformedDate(value) {
        this._transformedDate = value;
    }
    /**
     * Gets the input group template.
     * ```typescript
     * let template = this.template();
     * ```
     * \@memberof IgxDatePickerComponent
     * @return {?}
     */
    get template() {
        if (this.datePickerTemplateDirective) {
            return this.datePickerTemplateDirective.template;
        }
        return (this.mode === InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     * \@memberof IgxDatePickerComponent
     * @return {?}
     */
    get context() {
        return {
            disabled: this.disabled,
            disabledDates: this.disabledDates,
            displayData: this.displayData,
            format: this.format,
            isSpinLoop: this.isSpinLoop,
            label: this.label,
            labelVisibility: this.labelVisibility,
            locale: this.locale,
            mask: this.mask,
            mode: this.mode,
            specialDates: this.specialDates,
            value: this.value,
            openDialog: (target) => this.openDialog(target)
        };
    }
    /**
     * An \@Input property that gets/sets the selected date.
     * ```typescript
     * public date: Date = new Date();
     * ```
     * ```html
     * <igx-date-picker [value]="date"></igx-date-picker>
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set value(date) {
        this._value = date;
        this._onChangeCallback(date);
    }
    /**
     * @deprecated Use 'onOpened' instead.
     * An event that is emitted when the `IgxDatePickerComponent` calendar is opened.
     * ```typescript
     * public open(event){
     *    alert("The date-picker calendar has been opened!");
     * }
     * ```
     * ```html
     * <igx-date-picker (onOpen)="open($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
     * ```
     * @return {?}
     */
    get onOpen() {
        return this._onOpen;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set onOpen(val) {
        this._onOpen = val;
    }
    /**
     * @deprecated Use 'onClosed' instead.
     * "An event that is emitted when the `IgxDatePickerComponent` is closed.
     * ```typescript
     * public close(event){
     *    alert("The date-picker has been closed!");
     * }
     * ```
     * ```html
     * <igx-date-picker (onClose)="close($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
     * ```
     * @return {?}
     */
    get onClose() {
        return this._onClose;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set onClose(val) {
        this._onClose = val;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onSpaceClick(event) {
        this.openDialog(this.getInputGroupElement());
        event.preventDefault();
    }
    /**
     * Method that sets the selected date.
     * ```typescript
     * public date = new Date();
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.datePicker.writeValue(this.date);
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @param {?} value The date you want to select.
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        this._cdr.markForCheck();
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        /** @type {?} */
        const inputElement = this.editableInput || this.readonlyInput || this.input;
        return (inputElement) ? inputElement.nativeElement : null;
    }
    /**
     * @hidden
     * @return {?}
     */
    getInputGroupElement() {
        return this.inputGroup ? this.inputGroup.element.nativeElement : null;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this._defaultDropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(this._positionSettings),
            outlet: this.outlet
        };
        this._modalOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true,
            outlet: this.outlet
        };
        this._overlayService.onOpening.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])((overlay) => overlay.id === this._componentID), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((eventArgs) => {
            this._onOpening(eventArgs);
        });
        this._overlayService.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])((overlay) => overlay.id === this._componentID), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => {
            this._onOpened();
        });
        this._overlayService.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(overlay => overlay.id === this._componentID), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => {
            this._onClosed();
        });
        this._overlayService.onClosing.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(overlay => overlay.id === this._componentID), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((event) => {
            this.onClosing.emit(event);
        });
        if (this.mode === InteractionMode.DropDown) {
            this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
            if (this.mask === undefined) {
                this.mask = DatePickerUtil.getMask(this.dateFormatParts);
            }
            this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this.editableInput) {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.editableInput.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"])), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((res) => this.onKeyDown(res));
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this._componentID) {
            this._overlayService.hide(this._componentID);
        }
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * Selects today's date from calendar and change the input field value, \@calendar.viewDate and \@calendar.value.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.triggerTodaySelection();
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @return {?}
     */
    triggerTodaySelection() {
        /** @type {?} */
        const today = new Date(Date.now());
        this.handleSelection(today);
    }
    /**
     * Change the calendar selection and calling this method will emit the \@calendar.onSelection event,
     * which will fire \@handleSelection method.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.selectDate(this.date);
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @param {?} date passed date that has to be set to the calendar.
     * @return {?}
     */
    selectDate(date) {
        /** @type {?} */
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.onSelection.emit(date);
        this._onChangeCallback(date);
    }
    /**
     * Deselects the calendar date.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.deselectDate();
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @return {?}
     */
    deselectDate() {
        /** @type {?} */
        const oldValue = this.value;
        this.value = null;
        this.emitValueChangeEvent(oldValue, this.value);
        if (this.calendar) {
            this.calendar.deselectDate();
        }
        this._onChangeCallback(null);
    }
    /**
     * Opens the date picker drop down or dialog.
     * @param {?=} target HTMLElement - the target element to use for positioning the drop down container according to
     * ```html
     * <igx-date-picker [value]="date" mode="dropdown" #retemplated>
     *   <ng-template igxDatePickerTemplate let-openDialog="openDialog"
     *                let-displayData="displayData">
     *     <igx-input-group>
     *       <input #dropDownTarget igxInput [value]="displayData" />
     *       <igx-suffix (click)="openDialog(dropDownTarget)">
     *         <igx-icon>alarm</igx-icon>
     *       </igx-suffix>
     *     </igx-input-group>
     *   </ng-template>
     * </igx-date-picker>
     * ```
     * @return {?}
     */
    openDialog(target) {
        if (!this.collapsed) {
            return;
        }
        switch (this.mode) {
            case InteractionMode.Dialog: {
                this.hasHeader = true;
                /** @type {?} */
                const modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
            case InteractionMode.DropDown: {
                this.hasHeader = false;
                if (target) {
                    this.dropDownOverlaySettings.positionStrategy.settings.target = target;
                }
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
        }
    }
    /**
     * Close the calendar.
     *
     * @hidden
     * @return {?}
     */
    closeCalendar() {
        this._overlayService.hide(this._componentID);
    }
    /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden
     * @return {?}
     */
    clear() {
        this.isEmpty = true;
        this.invalidDate = '';
        this.deselectDate();
        this._setCursorPosition(0);
    }
    /**
     * Evaluates when \@calendar.onSelection event was fired
     * and update the input value.
     *
     * @hidden
     * @param {?} date
     * @return {?}
     */
    handleSelection(date) {
        if (this.value) {
            date.setHours(this.value.getHours());
            date.setMinutes(this.value.getMinutes());
            date.setSeconds(this.value.getSeconds());
            date.setMilliseconds(this.value.getMilliseconds());
        }
        /** @type {?} */
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.calendar.viewDate = date;
        this._onChangeCallback(date);
        this.closeCalendar();
        this.onSelection.emit(date);
    }
    /**
     * Evaluates when the input blur event was fired
     * and re-calculate the date picker value.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    onBlur(event) {
        this._isInEditMode = false;
        this.calculateDate(event.target.value, event.type);
    }
    /**
     * Evaluates when the input focus event was fired
     * and re-calculate the editor text.
     *
     * @hidden
     * @return {?}
     */
    onFocus() {
        this._isInEditMode = true;
        if (this.value && this.invalidDate === '') {
            this._transformedDate = this._getEditorDate(this.value);
        }
    }
    /**
     * Evaluates when the keydown event was fired for up/down keys
     * to provide spinning of date parts.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                event.preventDefault();
                event.stopPropagation();
                this.spinValue(event.target.value, 1, event.type);
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.openDialog(this.getInputGroupElement());
                }
                else {
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, -1, event.type);
                }
                break;
            default:
                break;
        }
    }
    /**
     * Evaluates when the mouse wheel event was fired
     * to provide spinning of date parts.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    onWheel(event) {
        if (this._isInEditMode) {
            event.preventDefault();
            event.stopPropagation();
            /** @type {?} */
            const sign = (event.deltaY > 0) ? -1 : 1;
            this.spinValue(event.target.value, sign, event.type);
        }
    }
    /**
     * Evaluates when input event was fired in editor.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    onInput(event) {
        /** @type {?} */
        const targetValue = event.target.value;
        /** @type {?} */
        const cursorPosition = this._getCursorPosition();
        /** @type {?} */
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
        this._isInEditMode = true;
        if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
            this.isEmpty = false;
        }
        // If all date parts are completed, change the date-picker value, stay in edit mode
        if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
            this._transformedDate = targetValue;
            this.calculateDate(targetValue, event.type);
            this._setCursorPosition(cursorPosition);
        }
        else if (checkInput === 'partial') {
            // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
            this.deselectDate();
            requestAnimationFrame(() => {
                this.getEditElement().value = targetValue;
                this._setCursorPosition(cursorPosition);
            });
        }
        else if (checkInput === 'empty') {
            // Total clean-up as input is deleted.
            this.isEmpty = true;
            this.deselectDate();
        }
    }
    /**
     * @private
     * @param {?} oldValue
     * @param {?} newValue
     * @return {?}
     */
    emitValueChangeEvent(oldValue, newValue) {
        if (!isEqual(oldValue, newValue)) {
            this.valueChange.emit(newValue);
        }
    }
    /**
     * @private
     * @param {?} dateString
     * @param {?} invokedByEvent
     * @return {?}
     */
    calculateDate(dateString, invokedByEvent) {
        if (dateString !== '') {
            /** @type {?} */
            const prevDateValue = this.value;
            /** @type {?} */
            const inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
            /** @type {?} */
            const newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
            if (newDateArray.state === "valid" /* Valid */) {
                /** @type {?} */
                const newValue = newDateArray.date;
                // Restore the time part if any
                if (prevDateValue) {
                    newValue.setHours(prevDateValue.getHours());
                    newValue.setMinutes(prevDateValue.getMinutes());
                    newValue.setSeconds(prevDateValue.getSeconds());
                    newValue.setMilliseconds(prevDateValue.getMilliseconds());
                }
                if (this.disabledDates === null
                    || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                    /** @type {?} */
                    const oldValue = this.value;
                    this.value = newValue;
                    this.emitValueChangeEvent(oldValue, this.value);
                    this.invalidDate = '';
                    this._onChangeCallback(newValue);
                }
                else {
                    /** @type {?} */
                    const args = {
                        datePicker: this,
                        currentValue: newValue,
                    };
                    this.onDisabledDate.emit(args);
                }
            }
            else {
                /** @type {?} */
                const args = {
                    datePicker: this,
                    prevValue: prevDateValue
                };
                this.invalidDate = dateString;
                this.onValidationFailed.emit(args);
            }
        }
    }
    /**
     * @private
     * @param {?} inputValue
     * @param {?} sign
     * @param {?} eventType
     * @return {?}
     */
    spinValue(inputValue, sign, eventType) {
        this._isInEditMode = true;
        this.isEmpty = false;
        /** @type {?} */
        const cursorPosition = this._getCursorPosition();
        /** @type {?} */
        const modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
        this.getEditElement().value = modifiedInputValue;
        this._setCursorPosition(cursorPosition);
        /** @type {?} */
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
        if (checkInput === 'complete') {
            this._isInEditMode = true;
            this.calculateDate(modifiedInputValue, eventType);
            this._setCursorPosition(cursorPosition);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _onOpening(event) {
        this._initializeCalendarContainer((/** @type {?} */ (event.componentRef.instance)));
        this.collapsed = false;
    }
    /**
     * @private
     * @return {?}
     */
    _onOpened() {
        this._onTouchedCallback();
        this.onOpened.emit(this);
        // TODO: remove this line after deprecating 'onOpen'
        this._onOpen.emit(this);
        if (this.calendar) {
            this._focusCalendarDate();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _onClosed() {
        this.collapsed = true;
        this._componentID = null;
        this.onClosed.emit(this);
        // TODO: remove this line after deprecating 'onClose'
        this.onClose.emit(this);
        if (this.getEditElement()) {
            this.getEditElement().focus();
        }
    }
    /**
     * @private
     * @param {?} componentInstance
     * @return {?}
     */
    _initializeCalendarContainer(componentInstance) {
        this.calendar = componentInstance.calendar;
        /** @type {?} */
        const isVertical = (this.vertical && this.mode === InteractionMode.Dialog);
        this.calendar.hasHeader = this.hasHeader;
        this.calendar.formatOptions = this.formatOptions;
        this.calendar.formatViews = this.formatViews;
        this.calendar.locale = this.locale;
        this.calendar.vertical = isVertical;
        this.calendar.weekStart = this.weekStart;
        this.calendar.specialDates = this.specialDates;
        this.calendar.disabledDates = this.disabledDates;
        this.calendar.headerTemplate = this.headerTemplate;
        this.calendar.subheaderTemplate = this.subheaderTemplate;
        this.calendar.hideOutsideDays = this.hideOutsideDays;
        this.calendar.monthsViewNumber = this.monthsViewNumber;
        this.calendar.onSelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((ev) => this.handleSelection(ev));
        if (this.value) {
            this.calendar.value = this.value;
            this.calendar.viewDate = this.value;
        }
        componentInstance.mode = this.mode;
        componentInstance.vertical = isVertical;
        componentInstance.cancelButtonLabel = this.cancelButtonLabel;
        componentInstance.todayButtonLabel = this.todayButtonLabel;
        componentInstance.datePickerActions = this.datePickerActionsDirective;
        componentInstance.onClose.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => this.closeCalendar());
        componentInstance.onTodaySelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => this.triggerTodaySelection());
    }
    // Focus a date, after the calendar appearance into DOM.
    /**
     * @private
     * @return {?}
     */
    _focusCalendarDate() {
        requestAnimationFrame(() => {
            this.calendar.daysView.focusActiveDate();
        });
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setLocaleToDate(value) {
        if (isIE()) {
            // this is a workaround fixing the following IE11 issue:
            // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
            // precedes each portion that comprises the total date... For more information read this article:
            // tslint:disable-next-line: max-line-length
            // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/
            /** @type {?} */
            const localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
            return localeDateStrIE.toLocaleDateString(this.locale);
        }
        return value.toLocaleDateString(this.locale);
    }
    /**
     * @private
     * @return {?}
     */
    _getCursorPosition() {
        return this.getEditElement().selectionStart;
    }
    /**
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    _setCursorPosition(start, end = start) {
        requestAnimationFrame(() => {
            this.getEditElement().setSelectionRange(start, end);
        });
    }
    /**
     * Apply custom user formatter upon date.
     * @private
     * @param {?} formatter custom formatter function.
     * @param {?} date passed date
     * @return {?}
     */
    _customFormatChecker(formatter, date) {
        return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
    }
    /*
        * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
        * using @angular/common formatDate method: https://angular.io/api/common/formatDate
        * @param  value: string | number | Date
        * @returns formatted string
        */
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _getDisplayDate(value) {
        if (this.format && !this.formatter) {
            /** @type {?} */
            const locale = this.locale || this.defaultLocale;
            return Object(_angular_common__WEBPACK_IMPORTED_MODULE_3__["formatDate"])(value, this.format, locale);
        }
        else {
            return this._customFormatChecker(this.formatter, value);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _getEditorDate(value) {
        /** @type {?} */
        const locale = this.locale || this.defaultLocale;
        /** @type {?} */
        const changedValue = (value) ? Object(_angular_common__WEBPACK_IMPORTED_MODULE_3__["formatDate"])(value, this.mask, locale) : '';
        return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
    }
}
IgxDatePickerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [{
                        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
                        useExisting: IgxDatePickerComponent,
                        multi: true
                    }],
                // tslint:disable-next-line:component-selector
                selector: 'igx-date-picker',
                template: "<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input #readonlyInput class=\"igx-date-picker__input-date\" igxInput [value]=\"displayData || ''\"\n            [disabled]=\"disabled\" readonly />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup [supressInputAutofocus]=\"true\">\n        <igx-prefix (click)=\"openDialog(editableInputGroup.element.nativeElement)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input #editableInput class=\"igx-date-picker__input-date\" igxInput [igxTextSelection]=\"true\"\n            type=\"text\" [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\" [placeholder]=\"mask\" [disabled]=\"disabled\" [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\" (blur)=\"onBlur($event)\" (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\" (focus)=\"onFocus()\" />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxDatePickerComponent.ctorParameters = () => [
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"] }
];
IgxDatePickerComponent.propDecorators = {
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelVisibility: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    locale: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    weekStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideOutsideDays: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    monthsViewNumber: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    format: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    mask: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatViews: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabledDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    specialDates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    modalOverlaySettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropDownOverlaySettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    todayButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cancelButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    mode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isSpinLoop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    outlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDisabledDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onValidationFailed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    readOnlyDatePickerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['readOnlyDatePickerTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    editableDatePickerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['editableDatePickerTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    inputGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxInputGroupComponent, { static: false },] }],
    editableInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['editableInput', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    readonlyInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['readonlyInput', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxInputDirective, { static: false },] }],
    datePickerTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective, static: false },] }],
    headerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective, static: false },] }],
    subheaderTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective, static: false },] }],
    datePickerActionsDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective, static: false },] }],
    onSpaceClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.spacebar', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.space', ['$event'],] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'onOpen' @Output property is deprecated. Use 'onOpened' instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])
], IgxDatePickerComponent.prototype, "onOpen", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'onClose' @Output property is deprecated. Use 'onClosed' instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])
], IgxDatePickerComponent.prototype, "onClose", null);
/**
 * @hidden
 */
class IgxDatePickerModule {
}
IgxDatePickerModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxDatePickerComponent, IgxCalendarContainerComponent, IgxDatePickerActionsDirective,
                    IgxDatePickerTemplateDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe],
                exports: [IgxDatePickerComponent, IgxDatePickerTemplateDirective, IgxDatePickerActionsDirective,
                    DatePickerDisplayValuePipe, DatePickerInputValuePipe],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule, IgxInputGroupModule, IgxCalendarModule, IgxButtonModule,
                    IgxRippleModule, IgxMaskModule, IgxTextSelectionModule],
                entryComponents: [IgxCalendarContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxDialogTitleDirective {
    constructor() {
        this.defaultStyle = true;
    }
}
IgxDialogTitleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-dialog-title,[igxDialogTitle]'
            },] }
];
IgxDialogTitleDirective.propDecorators = {
    defaultStyle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-dialog__window-title',] }]
};
/**
 * @hidden
 */
class IgxDialogActionsDirective {
    constructor() {
        this.defaultClass = true;
    }
}
IgxDialogActionsDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: 'igx-dialog-actions,[igxDialogActions]'
            },] }
];
IgxDialogActionsDirective.propDecorators = {
    defaultClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-dialog__window-actions',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let DIALOG_ID = 0;
/**
 * **Ignite UI for Angular Dialog Window** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
 *
 * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
 * more complicated visuals such as a user sign-in form.  It also provides a right and left button
 * which can be used for custom actions.
 *
 * Example:
 * ```html
 * <button (click)="form.open()">Show Dialog</button>
 * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
 *   <div>
 *     <input type="text" igxInput/>
 *     <label igxLabel>Username</label>
 *   </div>
 *   <div>
 *     <input type="password" igxInput/>
 *     <label igxLabel>Password</label>
 *   </div>
 * </igx-dialog>
 * ```
 */
class IgxDialogComponent {
    /**
     * @param {?} elementRef
     * @param {?} navService
     */
    constructor(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification" leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.id = `igx-dialog-${DIALOG_ID++}`;
        /**
         * An \@Input property controlling the `title` of the dialog.
         * ```html
         * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.title = '';
        /**
         *  An \@Input property controlling the `message` of the dialog.
         * ```html
         * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.message = '';
        /**
         * An \@Input property to set the `label` of the left button of the dialog.
         * ```html
         * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonLabel = '';
        /**
         * An \@Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonType = 'flat';
        /**
         * An \@Input property to set the left button color. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonColor = '';
        /**
         * An \@Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonBackgroundColor = '';
        /**
         * An \@Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
         * The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonRipple = '';
        /**
         * An \@Input property to set the `label` of the right button of the dialog.
         * ```html
         * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonLabel = '';
        /**
         * An \@Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonType = 'flat';
        /**
         * An \@Input property to set the right button `color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonColor = '';
        /**
         * An \@Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonBackgroundColor = '';
        /**
         * An \@Input property to set the right button `ripple`.
         * ```html
         * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonRipple = '';
        /**
         * An event that is emitted when the dialog is opened.
         * ```html
         * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the dialog is closed.
         * ```html
         * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the left button is clicked.
         * ```html
         * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
         * </igx-dialog>
         * ```
         */
        this.onLeftButtonSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the right button is clicked.
         * ```html
         * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
         * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
         * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
         * </igx-dialog>
         * ```
         */
        this.onRightButtonSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._positionSettings = {
            openAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
            closeAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
        };
        this._closeOnOutsideSelect = false;
        this._isModal = true;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * The default `tabindex` attribute for the component
         *
         * @hidden
         */
        this.tabindex = -1;
        this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';
        this._overlayDefaultSettings = {
            positionStrategy: new GlobalPositionStrategy(this._positionSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: this.isModal,
            closeOnOutsideClick: this.closeOnOutsideSelect
        };
    }
    /**
     * @return {?}
     */
    get isModal() {
        return this._isModal;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set isModal(val) {
        this._overlayDefaultSettings.modal = val;
        this._isModal = val;
    }
    /**
     * An \@Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
     * ```html
     * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
     * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
     * </igx-dialog>
     * ```
     * @return {?}
     */
    get closeOnOutsideSelect() {
        return this._closeOnOutsideSelect;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set closeOnOutsideSelect(val) {
        this._overlayDefaultSettings.closeOnOutsideClick = val;
        this._closeOnOutsideSelect = val;
    }
    /**
     * Get the position and animation settings used by the dialog.
     * ```typescript
     * \@ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     * let currentPosition: PositionSettings = this.alert.positionSettings
     * ```
     * @return {?}
     */
    get positionSettings() {
        return this._positionSettings;
    }
    /**
     * Set the position and animation settings used by the dialog.
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * \@ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     *  public newPositionSettings: PositionSettings = {
     *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
     *      horizontalDirection: HorizontalAlignment.Left,
     *      verticalDirection: VerticalAlignment.Middle,
     *      horizontalStartPoint: HorizontalAlignment.Left,
     *      verticalStartPoint: VerticalAlignment.Middle,
     *      minSize: { height: 100, width: 100 }
     *  };
     * this.alert.positionSettings = this.newPositionSettings;
     * ```
     * @param {?} settings
     * @return {?}
     */
    set positionSettings(settings) {
        this._positionSettings = settings;
        this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
    }
    /**
     * @hidden
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns the value of state. Possible state values are "open" or "close".
     * ```typescript
     * \@ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *    let dialogState = this.dialog.state;
     * }
     * ```
     * @return {?}
     */
    get state() {
        return this.isOpen ? 'open' : 'close';
    }
    /**
     * Returns whether the dialog is visible to the end user.
     * ```typescript
     * \@ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *    let dialogOpen = this.dialog.isOpen;
     * }
     * ```
     * @return {?}
     */
    get isOpen() {
        return !this.toggleRef.collapsed;
    }
    /**
     * @return {?}
     */
    get isCollapsed() {
        return this.toggleRef.collapsed;
    }
    /**
     * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
     * ```typescript
     * \@ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *    let dialogRole = this.dialog.role;
     * }
     * ```
     * @return {?}
     */
    get role() {
        if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
            return 'dialog';
        }
        else if (this.leftButtonLabel !== '' ||
            this.rightButtonLabel !== '') {
            return 'alertdialog';
        }
        else {
            return 'alert';
        }
    }
    /**
     * Returns the value of the title id.
     * ```typescript
     * \@ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *    let dialogTitle = this.dialog.titleId;
     * }
     * ```
     * @return {?}
     */
    get titleId() {
        return this._titleId;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.toggleRef.onClosing.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => this.emitCloseFromDialog());
    }
    /**
     * @private
     * @return {?}
     */
    emitCloseFromDialog() {
        this.onClose.emit({ dialog: this, event: null });
    }
    /**
     * A method that opens the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    open(overlaySettings = this._overlayDefaultSettings) {
        this.toggleRef.open(overlaySettings);
        this.onOpen.emit({ dialog: this, event: null });
        if (!this.leftButtonLabel && !this.rightButtonLabel) {
            this.toggleRef.element.focus();
        }
    }
    /**
     * A method that that closes the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @return {?}
     */
    close() {
        // `onClose` will emit from `toggleRef.onClosing` subscription
        this.toggleRef.close();
    }
    /**
     * A method that opens/closes the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @return {?}
     */
    toggle() {
        this.isOpen ? this.close() : this.open();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDialogSelected(event) {
        event.stopPropagation();
        if (this.isOpen &&
            this.closeOnOutsideSelect &&
            event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {
            this.close();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onInternalLeftButtonSelect(event) {
        this.onLeftButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onInternalRightButtonSelect(event) {
        this.onRightButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    }
}
IgxDialogComponent.NEXT_ID = 1;
IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
IgxDialogComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-dialog',
                template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\" *ngIf=\"message\">{{ message }}</div>\n        <ng-content *ngIf=\"!message\"></ng-content>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxDialogComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxDialogComponent.propDecorators = {
    toggleRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxToggleDirective, { static: true },] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isModal: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    title: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    message: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    leftButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    leftButtonType: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    leftButtonColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    leftButtonBackgroundColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    leftButtonRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rightButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rightButtonType: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rightButtonColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rightButtonBackgroundColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rightButtonRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    closeOnOutsideSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    positionSettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onLeftButtonSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRightButtonSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    isOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isCollapsed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-dialog--hidden',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    titleId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/**
 * @hidden
 */
class IgxDialogModule {
}
IgxDialogModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Refactor - export in a separate file
class IgxRow {
    /**
     * @param {?} id
     * @param {?} index
     * @param {?} data
     */
    constructor(id, index, data) {
        this.id = id;
        this.index = index;
        this.data = data;
    }
    /**
     * @return {?}
     */
    createEditEventArgs() {
        return {
            rowID: this.id,
            oldValue: Object.assign({}, this.data),
            newValue: this.newData,
            cancel: false
        };
    }
}
class IgxCell {
    /**
     * @param {?} id
     * @param {?} rowIndex
     * @param {?} column
     * @param {?} value
     * @param {?} editValue
     * @param {?} rowData
     */
    constructor(id, rowIndex, column, value, editValue, rowData) {
        this.id = id;
        this.rowIndex = rowIndex;
        this.column = column;
        this.value = value;
        this.editValue = editValue;
        this.rowData = rowData;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    castToNumber(value) {
        if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
            /** @type {?} */
            const v = parseFloat(value);
            return !isNaN(v) && isFinite(v) ? v : 0;
        }
        return value;
    }
    /**
     * @return {?}
     */
    createEditEventArgs() {
        return {
            rowID: this.id.rowID,
            cellID: this.id,
            oldValue: this.value,
            newValue: this.editValue,
            cancel: false
        };
    }
}
class IgxGridCRUDService {
    constructor() {
        this.cell = null;
        this.row = null;
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    createCell(cell) {
        return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData);
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    createRow(cell) {
        return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData);
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    sameRow(rowID) {
        return this.row && this.row.id === rowID;
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    sameCell(cell) {
        return (this.cell.id.rowID === cell.id.rowID &&
            this.cell.id.columnID === cell.id.columnID);
    }
    /**
     * @return {?}
     */
    get inEditMode() {
        return !!this.cell;
    }
    /**
     * @return {?}
     */
    get rowEditing() {
        return this.grid.rowEditable;
    }
    /**
     * @return {?}
     */
    get primaryKey() {
        return this.grid.primaryKey;
    }
    /**
     * @return {?}
     */
    beginRowEdit() {
        if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
            console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
        }
        this.row = this.createRow(this.cell);
        /** @type {?} */
        const args = {
            rowID: this.row.id,
            oldValue: this.row.data,
            cancel: false
        };
        this.grid.onRowEditEnter.emit(args);
        if (args.cancel) {
            this.endRowEdit();
            return;
        }
        this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
        this.grid.transactions.startPending();
        this.grid.openRowOverlay(this.row.id);
    }
    /**
     * @return {?}
     */
    endRowEdit() {
        this.row = null;
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    begin(cell) {
        /** @type {?} */
        const newCell = this.createCell(cell);
        newCell.primaryKey = this.primaryKey;
        /** @type {?} */
        const args = {
            cellID: newCell.id,
            rowID: newCell.id.rowID,
            oldValue: newCell.value,
            cancel: false
        };
        this.grid.onCellEditEnter.emit(args);
        if (args.cancel) {
            this.end();
            return;
        }
        if (this.rowEditing) {
            if (this.row && !this.sameRow(newCell.id.rowID)) {
                this.grid.endEdit(true);
                this.cell = newCell;
                this.beginRowEdit();
                return;
            }
            this.cell = newCell;
            if (!this.row) {
                this.beginRowEdit();
                return;
            }
        }
        else {
            this.cell = newCell;
            this.endRowEdit();
        }
    }
    /**
     * @return {?}
     */
    end() {
        this.cell = null;
    }
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    isInEditMode(rowIndex, columnIndex) {
        if (!this.cell) {
            return false;
        }
        return this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
    }
}
IgxGridCRUDService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
class IgxGridSelectionService {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.dragMode = false;
        this.keyboardState = (/** @type {?} */ ({}));
        this.pointerState = (/** @type {?} */ ({}));
        this.selection = new Map();
        this.temp = new Map();
        this._ranges = new Set();
        this.rowSelection = new Set();
        this.initPointerState();
        this.initKeyboardState();
    }
    /**
     * Returns the current selected ranges in the grid from both
     * keyboard and pointer interactions
     * @return {?}
     */
    get ranges() {
        // The last action was keyboard + shift selection -> add it
        this.addKeyboardRange();
        /** @type {?} */
        const ranges = Array.from(this._ranges).map(range => JSON.parse(range));
        // No ranges but we have a focused cell -> add it
        if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
            ranges.push(this.generateRange(this.activeElement));
        }
        return ranges;
    }
    /**
     * @return {?}
     */
    get primaryButton() {
        return this.pointerState.primaryButton;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set primaryButton(value) {
        this.pointerState.primaryButton = value;
    }
    /**
     * Resets the keyboard state
     * @return {?}
     */
    initKeyboardState() {
        this.keyboardState.node = null;
        this.keyboardState.shift = false;
        this.keyboardState.range = null;
        this.keyboardState.active = false;
    }
    /**
     * Resets the pointer state
     * @return {?}
     */
    initPointerState() {
        this.pointerState.node = null;
        this.pointerState.ctrl = false;
        this.pointerState.shift = false;
        this.pointerState.range = null;
        this.pointerState.primaryButton = true;
    }
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     * @param {?} node
     * @param {?=} addToRange
     * @return {?}
     */
    add(node, addToRange = true) {
        this.selection.has(node.row) ? this.selection.get(node.row).add(node.column) :
            this.selection.set(node.row, new Set()).get(node.row).add(node.column);
        if (addToRange) {
            this._ranges.add(JSON.stringify(this.generateRange(node)));
        }
    }
    /**
     * Adds the active keyboard range selection (if any) to the `ranges` meta.
     * @return {?}
     */
    addKeyboardRange() {
        if (this.keyboardState.range) {
            this._ranges.add(JSON.stringify(this.keyboardState.range));
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    remove(node) {
        if (this.selection.has(node.row)) {
            this.selection.get(node.row).delete(node.column);
        }
        if (this.isActiveNode(node)) {
            this.activeElement = null;
        }
        this._ranges.delete(JSON.stringify(this.generateRange(node)));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isInMap(node) {
        return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
            (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    selected(node) {
        return (this.isActiveNode(node) && this.grid.isCellSelectable) || this.isInMap(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isActiveNode(node) {
        if (this.activeElement) {
            /** @type {?} */
            const isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;
            if (this.grid.hasColumnLayouts) {
                /** @type {?} */
                const layout = this.activeElement.layout;
                return isActive && this.isActiveLayout(layout, node.layout);
            }
            return isActive;
        }
        return false;
    }
    /**
     * @param {?} current
     * @param {?} target
     * @return {?}
     */
    isActiveLayout(current, target) {
        return current.columnVisibleIndex === target.columnVisibleIndex;
    }
    /**
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    addRangeMeta(node, state) {
        this._ranges.add(JSON.stringify(this.generateRange(node, state)));
    }
    /**
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    removeRangeMeta(node, state) {
        this._ranges.delete(JSON.stringify(this.generateRange(node, state)));
    }
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    generateRange(node, state) {
        if (!state) {
            return {
                rowStart: node.row,
                rowEnd: node.row,
                columnStart: node.column,
                columnEnd: node.column
            };
        }
        const { row, column } = state.node;
        /** @type {?} */
        const rowStart = Math.min(node.row, row);
        /** @type {?} */
        const rowEnd = Math.max(node.row, row);
        /** @type {?} */
        const columnStart = Math.min(node.column, column);
        /** @type {?} */
        const columnEnd = Math.max(node.column, column);
        return { rowStart, rowEnd, columnStart, columnEnd };
    }
    /**
     *
     * @param {?} node
     * @param {?} shift
     * @param {?} shiftTab
     * @return {?}
     */
    keyboardStateOnKeydown(node, shift, shiftTab) {
        this.keyboardState.active = true;
        this.initPointerState();
        this.keyboardState.shift = shift && !shiftTab;
        // Kb navigation with shift and no previous node.
        // Clear the current selection init the start node.
        if (this.keyboardState.shift && !this.keyboardState.node) {
            this.clear();
            this.keyboardState.node = node;
        }
    }
    /**
     * @param {?} node
     * @param {?} emitter
     * @param {?} dom
     * @return {?}
     */
    keyboardStateOnFocus(node, emitter, dom) {
        /** @type {?} */
        const kbState = this.keyboardState;
        // Focus triggered by keyboard navigation
        if (kbState.active) {
            if (isChromium()) {
                this._moveSelectionChrome(dom);
            }
            // Start generating a range if shift is hold
            if (kbState.shift) {
                this.dragSelect(node, kbState);
                kbState.range = this.generateRange(node, kbState);
                emitter.emit(this.generateRange(node, kbState));
                return;
            }
            this.initKeyboardState();
            this.clear();
            this.add(node);
        }
    }
    /**
     * @param {?} node
     * @param {?} shift
     * @param {?} ctrl
     * @return {?}
     */
    pointerDown(node, shift, ctrl) {
        this.addKeyboardRange();
        this.initKeyboardState();
        this.pointerState.ctrl = ctrl;
        this.pointerState.shift = shift;
        // No ctrl key pressed - no multiple selection
        if (!ctrl) {
            this.clear();
        }
        if (shift) {
            // No previously 'clicked' node. Use the last active node.
            if (!this.pointerState.node) {
                this.pointerState.node = this.activeElement || node;
            }
            this.pointerDownShiftKey(node);
            this.clearTextSelection();
            return;
        }
        this.removeRangeMeta(node);
        this.pointerState.node = node;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    pointerDownShiftKey(node) {
        this.clear();
        this.selectRange(node, this.pointerState);
    }
    /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    mergeMap(target, source) {
        /** @type {?} */
        const iterator = source.entries();
        /** @type {?} */
        let pair = iterator.next();
        /** @type {?} */
        let key;
        /** @type {?} */
        let value;
        while (!pair.done) {
            [key, value] = pair.value;
            if (target.has(key)) {
                /** @type {?} */
                const newValue = target.get(key);
                value.forEach(record => newValue.add(record));
                target.set(key, newValue);
            }
            else {
                target.set(key, value);
            }
            pair = iterator.next();
        }
    }
    /**
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    pointerEnter(node, event) {
        // https://www.w3.org/TR/pointerevents/#the-button-property
        this.dragMode = event.buttons === 1 && event.button === -1;
        if (!this.dragMode) {
            return false;
        }
        this.clearTextSelection();
        // If the users triggers a drag-like event by first clicking outside the grid cells
        // and then enters in the grid body we may not have a initial pointer starting node.
        // Assume the first pointerenter node is where we start.
        if (!this.pointerState.node) {
            this.pointerState.node = node;
        }
        this.pointerState.ctrl ? this.selectRange(node, this.pointerState, this.temp) :
            this.dragSelect(node, this.pointerState);
        return true;
    }
    /**
     * @param {?} node
     * @param {?} emitter
     * @return {?}
     */
    pointerUp(node, emitter) {
        if (this.dragMode) {
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            this.mergeMap(this.selection, this.temp);
            this.zone.runTask(() => emitter.emit(this.generateRange(node, this.pointerState)));
            this.temp.clear();
            this.dragMode = false;
            return true;
        }
        if (this.pointerState.shift) {
            this.clearTextSelection();
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            emitter.emit(this.generateRange(node, this.pointerState));
            return true;
        }
        this.add(node);
        return false;
    }
    /**
     * @param {?} node
     * @param {?} state
     * @param {?=} collection
     * @return {?}
     */
    selectRange(node, state, collection = this.selection) {
        if (collection === this.temp) {
            collection.clear();
        }
        const { rowStart, rowEnd, columnStart, columnEnd } = this.generateRange(node, state);
        for (let i = rowStart; i <= rowEnd; i++) {
            for (let j = (/** @type {?} */ (columnStart)); j <= columnEnd; j++) {
                collection.has(i) ? collection.get(i).add(j) :
                    collection.set(i, new Set()).get(i).add(j);
            }
        }
    }
    /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    dragSelect(node, state) {
        if (!this.pointerState.ctrl) {
            this.selection.clear();
        }
        this.selectRange(node, state);
    }
    /**
     * @param {?=} clearAcriveEl
     * @return {?}
     */
    clear(clearAcriveEl = false) {
        if (clearAcriveEl) {
            this.activeElement = null;
        }
        this.selection.clear();
        this.temp.clear();
        this._ranges.clear();
    }
    /**
     * @return {?}
     */
    clearTextSelection() {
        /** @type {?} */
        const selection = window.getSelection();
        if (selection.rangeCount) {
            this._selectionRange = selection.getRangeAt(0);
            this._selectionRange.collapse(true);
            selection.removeAllRanges();
        }
    }
    /**
     * @return {?}
     */
    restoreTextSelection() {
        /** @type {?} */
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            selection.addRange(this._selectionRange || document.createRange());
        }
    }
    /**
     * (╯°□°）╯︵ ┻━┻
     * Chrome and Chromium don't care about the active
     * range after keyboard navigation, thus this.
     * @param {?} node
     * @return {?}
     */
    _moveSelectionChrome(node) {
        /** @type {?} */
        const selection = window.getSelection();
        selection.removeAllRanges();
        /** @type {?} */
        const range = new Range();
        range.selectNode(node);
        range.collapse(true);
        selection.addRange(range);
    }
    /**
     * Returns array of the selected row id's.
     * @return {?}
     */
    getSelectedRows() {
        return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
    }
    /**
     * Clears row selection, if filtering is applied clears only selected rows from filtered data.
     * @param {?=} event
     * @return {?}
     */
    clearRowSelection(event) {
        /** @type {?} */
        const removedRec = this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rID => this.isRowSelected(rID)) : this.getSelectedRows();
        /** @type {?} */
        const newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(x => !removedRec.includes(x)) : [];
        this.emitRowSelectionEvent(newSelection, [], removedRec, event);
    }
    /**
     * Select all rows, if filtering is applied select only from filtered data.
     * @param {?=} event
     * @return {?}
     */
    selectAllRows(event) {
        /** @type {?} */
        const allRowIDs = this.getRowIDs(this.allData);
        /** @type {?} */
        const addedRows = allRowIDs.filter((rID) => !this.isRowSelected(rID));
        /** @type {?} */
        const newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
        this.emitRowSelectionEvent(newSelection, addedRows, [], event);
    }
    /**
     * Select the specified row and emit event.
     * @param {?} rowID
     * @param {?=} clearPrevSelection
     * @param {?=} event
     * @return {?}
     */
    selectRowById(rowID, clearPrevSelection, event) {
        if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
            return;
        }
        clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
        /** @type {?} */
        const newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ?
            this.getSelectedRows() : [...this.getSelectedRows(), rowID];
        /** @type {?} */
        const removed = clearPrevSelection ? this.getSelectedRows() : [];
        this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
    }
    /**
     * Deselect the specified row and emit event.
     * @param {?} rowID
     * @param {?=} event
     * @return {?}
     */
    deselectRow(rowID, event) {
        if (!this.isRowSelected(rowID)) {
            return;
        }
        /** @type {?} */
        const newSelection = this.getSelectedRows().filter(r => r !== rowID);
        if (this.rowSelection.size && this.rowSelection.has(rowID)) {
            this.emitRowSelectionEvent(newSelection, [], [rowID], event);
        }
    }
    /**
     * Select specified rows. No event is emitted.
     * @param {?} rowIDs
     * @param {?=} clearPrevSelection
     * @return {?}
     */
    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {
        if (clearPrevSelection) {
            this.rowSelection.clear();
        }
        rowIDs.forEach(rowID => { this.rowSelection.add(rowID); });
        this.allRowsSelected = undefined;
    }
    /**
     * Deselect specified rows. No event is emitted.
     * @param {?} rowIDs
     * @return {?}
     */
    deselectRowsWithNoEvent(rowIDs) {
        rowIDs.forEach(rowID => this.rowSelection.delete(rowID));
        this.allRowsSelected = undefined;
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    isRowSelected(rowID) {
        return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
    }
    /**
     * Select range from last selected row to the current specified row.
     * @param {?} rowID
     * @param {?} rowData
     * @param {?=} event
     * @return {?}
     */
    selectMultipleRows(rowID, rowData, event) {
        this.allRowsSelected = undefined;
        if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
            this.selectRowById(rowID);
            return;
        }
        /** @type {?} */
        const gridData = this.allData;
        /** @type {?} */
        const lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
        /** @type {?} */
        const currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
        /** @type {?} */
        const newIndex = gridData.indexOf(rowData);
        /** @type {?} */
        const rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
        /** @type {?} */
        const added = this.getRowIDs(rows).filter(rID => !this.isRowSelected(rID));
        /** @type {?} */
        const newSelection = this.getSelectedRows().concat(added);
        this.emitRowSelectionEvent(newSelection, added, [], event);
    }
    /**
     * @return {?}
     */
    areAllRowSelected() {
        if (!this.grid.data) {
            return false;
        }
        if (this.allRowsSelected !== undefined) {
            return this.allRowsSelected;
        }
        /** @type {?} */
        const dataItemsID = this.getRowIDs(this.allData);
        return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 &&
            new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
    }
    /**
     * @return {?}
     */
    hasSomeRowSelected() {
        /** @type {?} */
        const filteredData = this.isFilteringApplied() ?
            this.getRowIDs(this.grid.filteredData).some(rID => this.isRowSelected(rID)) : true;
        return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
    }
    /**
     * @return {?}
     */
    get filteredSelectedRowIds() {
        return this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rowID => this.isRowSelected(rowID)) :
            this.getSelectedRows().filter(rowID => !this.isRowDeleted(rowID));
    }
    /**
     * @param {?} newSelection
     * @param {?} added
     * @param {?} removed
     * @param {?=} event
     * @return {?}
     */
    emitRowSelectionEvent(newSelection, added, removed, event) {
        /** @type {?} */
        const currSelection = this.getSelectedRows();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        /** @type {?} */
        const args = {
            oldSelection: currSelection, newSelection: newSelection,
            added: added, removed: removed, event: event, cancel: false
        };
        this.grid.onRowSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectRowsWithNoEvent(args.newSelection, true);
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    getRowDataById(rowID) {
        if (!this.grid.primaryKey) {
            return rowID;
        }
        /** @type {?} */
        const rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
        return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getRowIDs(data) {
        return this.grid.primaryKey && data.length ? data.map(rec => rec[this.grid.primaryKey]) : data;
    }
    /**
     * @return {?}
     */
    clearHeaderCBState() {
        this.allRowsSelected = undefined;
    }
    /**
     * Clear rowSelection and update checkbox state
     * @return {?}
     */
    clearAllSelectedRows() {
        this.rowSelection.clear();
        this.clearHeaderCBState();
    }
    /**
     * Returns all data in the grid, with applied filtering and sorting and without deleted rows.
     * @return {?}
     */
    get allData() {
        /** @type {?} */
        const allData = this.isFilteringApplied() || this.grid.sortingExpressions.length ?
            this.grid.filteredSortedData : this.grid.gridAPI.get_all_data(true);
        return allData.filter(rData => !this.isRowDeleted(this.grid.gridAPI.get_row_id(rData)));
    }
    /**
     * @private
     * @param {?} first
     * @param {?} second
     * @return {?}
     */
    areEqualCollections(first, second) {
        return first.length === second.length && new Set(first.concat(second)).size === first.length;
    }
    /**
     * @private
     * @return {?}
     */
    isFilteringApplied() {
        return this.grid.filteringExpressionsTree.filteringOperands.length > 0;
    }
    /**
     * @private
     * @param {?} rowID
     * @return {?}
     */
    isRowDeleted(rowID) {
        return this.grid.gridAPI.row_deleted_transaction(rowID);
    }
}
IgxGridSelectionService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
/** @nocollapse */
IgxGridSelectionService.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
/**
 * @return {?}
 */
function isChromium() {
    return (/Chrom|e?ium/g.test(navigator.userAgent) || /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 * @hidden
 */
class HammerGesturesManager {
    /**
     * @param {?} _zone
     * @param {?} doc
     * @param {?} platformUtil
     */
    constructor(_zone, doc, platformUtil) {
        this._zone = _zone;
        this.doc = doc;
        this.platformUtil = platformUtil;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {};
        this._hammerManagers = [];
        this.platformBrowser = this.platformUtil.isBrowser;
        if (this.platformBrowser) {
            this.hammerOptions = {
                // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                inputClass: Hammer.TouchInput,
                recognizers: [
                    [Hammer.Pan, { threshold: 0 }],
                    [Hammer.Swipe, {
                            direction: Hammer.DIRECTION_HORIZONTAL
                        }],
                    [Hammer.Tap],
                    [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                ]
            };
        }
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    supports(eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventHandler
     * @param {?=} options
     * @return {?}
     */
    addEventListener(element, eventName, eventHandler, options = null) {
        if (!this.platformBrowser) {
            return;
        }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(() => {
            /** @type {?} */
            let mc = this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, Object.assign(this.hammerOptions, options));
                this.addManagerForElement(element, mc);
            }
            /** @type {?} */
            const handler = (eventObj) => { this._zone.run(() => { eventHandler(eventObj); }); };
            mc.on(eventName, handler);
            return () => { mc.off(eventName, handler); };
        });
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param {?} target Can be one of either window, body or document(fallback default).
     * @param {?} eventName
     * @param {?} eventHandler
     * @return {?}
     */
    addGlobalEventListener(target, eventName, eventHandler) {
        if (!this.platformBrowser) {
            return;
        }
        /** @type {?} */
        const element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener((/** @type {?} */ (element)), eventName, eventHandler);
    }
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param {?} target Target name
     * @return {?}
     */
    getGlobalEventTarget(target) {
        return Object(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["ɵgetDOM"])().getGlobalEventTarget(this.doc, target);
    }
    /**
     * Set HammerManager options.
     *
     * @param {?} element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     * @param {?} event
     * @param {?} options
     * @return {?}
     */
    setManagerOption(element, event, options) {
        /** @type {?} */
        const manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    }
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @param {?} manager
     * @return {?}
     */
    addManagerForElement(element, manager) {
        this._hammerManagers.push({ element, manager });
    }
    /**
     * Get HammerManager for the element or null
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    getManagerForElement(element) {
        /** @type {?} */
        const result = this._hammerManagers.filter((value, index, array) => {
            return value.element === element;
        });
        return result.length ? result[0].manager : null;
    }
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    removeManagerForElement(element) {
        /** @type {?} */
        let index = null;
        for (let i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            /** @type {?} */
            const item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    }
    /**
     * Destroys all internally tracked HammerManagers, removing event listeners in the process.
     * @return {?}
     */
    destroy() {
        for (const item of this._hammerManagers) {
            item.manager.destroy();
        }
        this._hammerManagers = [];
    }
}
HammerGesturesManager.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
/** @nocollapse */
HammerGesturesManager.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: PlatformUtil }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const FilterMode = {
    quickFilter: 'quickFilter',
    excelStyleFilter: 'excelStyleFilter',
};
/** @enum {string} */
const GridSummaryPosition = {
    top: 'top',
    bottom: 'bottom',
};
/** @enum {string} */
const GridSummaryCalculationMode = {
    rootLevelOnly: 'rootLevelOnly',
    childLevelsOnly: 'childLevelsOnly',
    rootAndChildLevels: 'rootAndChildLevels',
};
/** @enum {string} */
const GridKeydownTargetType = {
    dataCell: 'dataCell',
    summaryCell: 'summaryCell',
    groupRow: 'groupRow',
    hierarchicalRow: 'hierarchicalRow',
};
/** @enum {string} */
const GridSelectionMode = {
    none: 'none',
    single: 'single',
    multiple: 'multiple',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Providing reference to `IgxGridCellComponent`:
 * ```typescript
 * \@ViewChild('grid', { read: IgxGridComponent })
 *  public grid: IgxGridComponent;
 * ```
 * ```typescript
 *  let column = this.grid.columnList.first;
 * ```
 * ```typescript
 *  let cell = column.cells[0];
 * ```
 */
class IgxGridCellComponent {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} gridAPI
     * @param {?} cdr
     * @param {?} element
     * @param {?} zone
     * @param {?} touchManager
     * @param {?} platformUtil
     */
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.touchManager = touchManager;
        this.platformUtil = platformUtil;
        this._vIndex = -1;
        /**
         * Sets/gets the highlight class of the cell.
         * Default value is `"igx-highlight"`.
         * ```typescript
         * let highlightClass = this.cell.highlightClass;
         * ```
         * ```typescript
         * this.cell.highlightClass = 'igx-cell-highlight';
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.highlightClass = 'igx-highlight';
        /**
         * Sets/gets the active highlight class class of the cell.
         * Default value is `"igx-highlight__active"`.
         * ```typescript
         * let activeHighlightClass = this.cell.activeHighlightClass;
         * ```
         * ```typescript
         * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.activeHighlightClass = 'igx-highlight__active';
        /**
         * @hidden
         * \@internal
         */
        this.lastPinned = false;
        /**
         * Returns whether the cell is in edit mode.
         */
        this.editMode = false;
        /**
         * Sets/get the `tabindex` property of the cell.
         * Default value is `0`.
         * ```typescript
         * this.cell.tabindex = 1;
         * ```
         * ```typescript
         * let cellTabIndex = this.cell.tabindex;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.tabindex = 0;
        /**
         * Sets/get the `role` property of the cell.
         * Default value is `"gridcell"`.
         * ```typescript
         * this.cell.role = 'grid-cell';
         * ```
         * ```typescript
         * let cellRole = this.cell.role;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.role = 'gridcell';
        /**
         * Gets the width of the cell.
         * ```typescript
         * let cellWidth = this.cell.width;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.width = '';
        /**
         * @hidden
         * \@internal
         */
        this.focused = false;
        this.isInCompositionMode = false;
        this._cellSelection = GridSelectionMode.multiple;
        /**
         *
         * @hidden
         * \@internal
         */
        this.pointerdown = (event) => {
            if (!isLeftClick(event)) {
                this.selectionService.addKeyboardRange();
                this.selectionService.initKeyboardState();
                this.selectionService.primaryButton = false;
                return;
            }
            this.selectionService.pointerDown(this.selectionNode, event.shiftKey, event.ctrlKey);
        };
        /**
         *
         * @hidden
         * \@internal
         */
        this.pointerenter = (event) => {
            /** @type {?} */
            const dragMode = this.selectionService.pointerEnter(this.selectionNode, event);
            if (dragMode) {
                this.grid.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         * \@internal
         */
        this.pointerup = (event) => {
            if (this.grid.hasColumnLayouts) {
                this.grid.navigation.setStartNavigationCell(this.colStart, this.rowStart, null);
            }
            if (!isLeftClick(event)) {
                return;
            }
            if (this.selectionService.pointerUp(this.selectionNode, this.grid.onRangeSelection)) {
                this.grid.cdr.detectChanges();
            }
            this._updateCRUDStatus();
        };
        /**
         * @hidden
         * \@internal
         */
        this.onDoubleClick = (event) => {
            if (event.type === 'doubletap') {
                // prevent double-tap to zoom on iOS
                ((/** @type {?} */ (event))).preventDefault();
            }
            if (this.editable && !this.editMode && !this.row.deleted) {
                this.crudService.begin(this);
            }
            this.grid.onDoubleClick.emit({
                cell: this,
                event
            });
        };
    }
    /**
     * Gets the cell template context object.
     * ```typescript
     *  let context = this.cell.context();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get context() {
        return {
            $implicit: this.value,
            cell: this
        };
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get template() {
        if (this.editMode) {
            /** @type {?} */
            const inlineEditorTemplate = this.column.inlineEditorTemplate;
            return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
        }
        if (this.cellTemplate) {
            return this.cellTemplate;
        }
        return this.defaultCellTemplate;
    }
    /**
     * Gets the `id` of the grid in which the cell is stored.
     * ```typescript
     * let gridId = this.cell.gridID;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get gridID() {
        return this.row.gridID;
    }
    /**
     * Gets the grid of the cell.
     * ```typescript
     * let grid = this.cell.grid;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the `index` of the row where the cell is stored.
     * ```typescript
     * let rowIndex = this.cell.rowIndex;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get rowIndex() {
        return this.row.index;
    }
    /**
     * Gets the `index` of the cell column.
     * ```typescript
     * let columnIndex = this.cell.columnIndex;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get columnIndex() {
        return this.column.index;
    }
    /**
     * Gets the visible `index` of the in which the cell is stored.
     * ```typescript
     * let visibleColumnIndex = this.cell.visibleColumnIndex;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get visibleColumnIndex() {
        return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set visibleColumnIndex(val) {
        this._vIndex = val;
    }
    /**
     * Gets the ID of the cell.
     * ```typescript
     * let cellID = this.cell.cellID;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get cellID() {
        /** @type {?} */
        const primaryKey = this.grid.primaryKey;
        /** @type {?} */
        const rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
        return { rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
    }
    /**
     * Returns a reference to the nativeElement of the cell.
     * ```typescript
     * let cellNativeElement = this.cell.nativeElement;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @deprecated
     * Use `cell.editMode` as a getter and
     * `cell.setEditMode(true | false)` to start/exit edit mode.
     *
     * Gets/sets whether the cell is in edit mode.
     * ```typescript
     * let isCellInEditMode = this.cell.inEditMode;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get inEditMode() {
        return this.editMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inEditMode(value) {
        this.setEditMode(value);
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get cellSelectionMode() {
        return this._cellSelection;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set cellSelectionMode(value) {
        if (this._cellSelection === value) {
            return;
        }
        this.zone.runOutsideAngular(() => {
            value === GridSelectionMode.multiple ?
                this.addPointerListeners(value) : this.removePointerListeners(this._cellSelection);
        });
        this._cellSelection = value;
    }
    /**
     * Gets whether the cell is editable.
     * ```typescript
     * let isCellReadonly = this.cell.readonly;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get readonly() {
        return !this.column.editable;
    }
    /**
     * @return {?}
     */
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    /**
     * @return {?}
     */
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    /**
     * @return {?}
     */
    get rowEnd() {
        return this.column.rowEnd;
    }
    /**
     * @return {?}
     */
    get colEnd() {
        return this.column.colEnd;
    }
    /**
     * @return {?}
     */
    get rowStart() {
        return this.column.rowStart;
    }
    /**
     * @return {?}
     */
    get colStart() {
        return this.column.colStart;
    }
    /**
     * Returns a string containing the grid `id` and the column `field` concatenated by "_".
     * ```typescript
     * let describedBy = this.cell.describedBy;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get describedby() {
        return `${this.row.gridID}_${this.column.field}`;
    }
    /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isSelected = this.cell.selected;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get selected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * Selects/deselects the cell.
     * ```typescript
     * this.cell.selected = true.
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} val
     * @return {?}
     */
    set selected(val) {
        /** @type {?} */
        const node = this.selectionNode;
        val ? this.selectionService.add(node) : this.selectionService.remove(node);
        this.grid.notifyChanges();
    }
    /**
     * @return {?}
     */
    get dirty() {
        if (this.grid.rowEditable) {
            /** @type {?} */
            const rowCurrentState = this.grid.transactions.getAggregatedValue(this.row.rowID, false);
            if (rowCurrentState) {
                return rowCurrentState[this.column.field] !== undefined && rowCurrentState[this.column.field] !== null;
            }
        }
        else {
            /** @type {?} */
            const rowTransaction = this.grid.transactions.getState(this.row.rowID);
            return rowTransaction && rowTransaction.value &&
                (rowTransaction.value[this.column.field] ||
                    rowTransaction.value[this.column.field] === 0 ||
                    rowTransaction.value[this.column.field] === false);
        }
        return false;
    }
    /**
     * Sets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * this.cell.editValue = value;
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} value
     * @return {?}
     */
    set editValue(value) {
        if (this.crudService.inEditMode) {
            this.crudService.cell.editValue = value;
        }
    }
    /**
     * Gets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * let editValue = this.cell.editValue;
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    get editValue() {
        if (this.crudService.inEditMode) {
            return this.crudService.cell.editValue;
        }
    }
    /**
     * Returns whether the cell is editable.
     * @return {?}
     */
    get editable() {
        return this.column.editable;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    set highlight(value) {
        this._highlight = value;
        if (this._highlight && this.grid.lastSearchInfo.searchText) {
            this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
            this._highlight.activateIfNecessary();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    get highlight() {
        return this._highlight;
    }
    /**
     * @protected
     * @return {?}
     */
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.visibleColumnIndex
            } : null
        };
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    addPointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.addEventListener('pointerdown', this.pointerdown);
        this.nativeElement.addEventListener('pointerenter', this.pointerenter);
        this.nativeElement.addEventListener('pointerup', this.pointerup);
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    removePointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.removeEventListener('pointerdown', this.pointerdown);
        this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
        this.nativeElement.removeEventListener('pointerup', this.pointerup);
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.addPointerListeners(this.cellSelectionMode);
            // IE 11 workarounds
            if (isIE()) {
                this.compositionStartHandler = () => this.isInCompositionMode = true;
                this.compositionEndHandler = () => this.isInCompositionMode = false;
                // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                this.nativeElement.addEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.addEventListener('compositionend', this.compositionEndHandler);
            }
        });
        if (this.platformUtil.isIOS) {
            this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, (/** @type {?} */ ({
                cssProps: {} /* don't disable user-select, etc */
            })));
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.removePointerListeners(this.cellSelectionMode);
            if (isIE()) {
                this.nativeElement.removeEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.removeEventListener('compositionend', this.compositionEndHandler);
            }
        });
        this.touchManager.destroy();
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    _updateCRUDStatus() {
        if (this.editMode) {
            return;
        }
        /** @type {?} */
        const crud = this.crudService;
        /** @type {?} */
        const editableCell = this.crudService.cell;
        /** @type {?} */
        const editMode = !!(crud.row || crud.cell);
        if (this.editable && editMode && !this.row.deleted) {
            if (editableCell) {
                this.gridAPI.update_cell(editableCell, editableCell.editValue);
            }
            crud.end();
            this.grid.notifyChanges();
            crud.begin(this);
            return;
        }
        if (editableCell && crud.sameRow(this.cellID.rowID)) {
            this.gridAPI.submit_value();
        }
        else if (editMode && !crud.sameRow(this.cellID.rowID)) {
            this.grid.endEdit(true);
        }
    }
    /**
     * @deprecated
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    isCellSelected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * @hidden
     * \@internal
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            if (this.highlight) {
                this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
            }
        }
    }
    /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     * @param {?} value
     * @return {?}
     */
    setEditMode(value) {
        if (this.row.deleted) {
            return;
        }
        if (this.editable && value) {
            this.gridAPI.submit_value();
            this.crudService.begin(this);
        }
        else {
            this.gridAPI.escape_editMode();
        }
        this.grid.notifyChanges();
    }
    /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} val
     * @return {?}
     */
    // TODO: Refactor
    update(val) {
        if (this.row.deleted) {
            return;
        }
        /** @type {?} */
        const cell = this.crudService.createCell(this);
        /** @type {?} */
        const args = this.gridAPI.update_cell(cell, val);
        if (this.crudService.cell && this.crudService.sameCell(cell)) {
            if (args.cancel) {
                return;
            }
            this.gridAPI.escape_editMode();
        }
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        this.grid.onCellClick.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onContextMenu(event) {
        this.grid.onContextMenu.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        if (this.focused) {
            return;
        }
        this.focused = true;
        this.row.focused = true;
        /** @type {?} */
        const node = this.selectionNode;
        /** @type {?} */
        const shouldEmitSelection = !this.selectionService.isActiveNode(node);
        if (this.selectionService.primaryButton) {
            this._updateCRUDStatus();
            this.selectionService.activeElement = node;
        }
        else {
            this.selectionService.activeElement = null;
            if (this.crudService.inEditMode && !this.editMode) {
                this.gridAPI.submit_value();
            }
        }
        this.selectionService.primaryButton = true;
        if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {
            this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation
            this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
        }
        if (this.grid.isCellSelectable && shouldEmitSelection) {
            this.grid.onSelection.emit({ cell: this, event });
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    onBlur() {
        this.focused = false;
        this.row.focused = false;
    }
    /**
     * @protected
     * @param {?} key
     * @param {?} event
     * @return {?}
     */
    handleAlt(key, event) {
        if (this.row.nativeElement.tagName.toLowerCase() === 'igx-tree-grid-row' && this.isToggleKey(key)) {
            /** @type {?} */
            const collapse = ((/** @type {?} */ (this.row))).expanded && ROW_COLLAPSE_KEYS.has(key);
            /** @type {?} */
            const expand = !((/** @type {?} */ (this.row))).expanded && ROW_EXPAND_KEYS.has(key);
            if (collapse) {
                ((/** @type {?} */ (this.gridAPI))).trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
            }
            else if (expand) {
                ((/** @type {?} */ (this.gridAPI))).trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
            }
        }
    }
    /**
     * @protected
     * @param {?} shift
     * @return {?}
     */
    handleTab(shift) {
        if (shift) {
            this.grid.navigation.performShiftTabKey(this.row.nativeElement, this.selectionNode);
        }
        else {
            this.grid.navigation.performTab(this.row.nativeElement, this.selectionNode);
        }
    }
    /**
     * @protected
     * @param {?} ctrl
     * @return {?}
     */
    handleEnd(ctrl) {
        if (ctrl) {
            this.grid.navigation.goToLastCell();
        }
        else {
            this.grid.navigation.onKeydownEnd(this.rowIndex, false, this.rowStart);
        }
    }
    /**
     * @protected
     * @param {?} ctrl
     * @return {?}
     */
    handleHome(ctrl) {
        if (ctrl) {
            this.grid.navigation.goToFirstCell();
        }
        else {
            this.grid.navigation.onKeydownHome(this.rowIndex, false, this.rowStart);
        }
    }
    // TODO: Refactor
    /**
     *
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    dispatchEvent(event) {
        /** @type {?} */
        const key = event.key.toLowerCase();
        /** @type {?} */
        const shift = event.shiftKey;
        /** @type {?} */
        const ctrl = event.ctrlKey;
        /** @type {?} */
        const node = this.selectionNode;
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        const keydownArgs = { targetType: 'dataCell', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel) {
            this.selectionService.clear();
            this.selectionService.keyboardState.active = true;
            return;
        }
        if (event.altKey) {
            event.preventDefault();
            this.handleAlt(key, event);
            return;
        }
        this.selectionService.keyboardStateOnKeydown(node, shift, shift && key === 'tab');
        if (key === 'tab') {
            event.preventDefault();
        }
        if (this.editMode) {
            if (NAVIGATION_KEYS.has(key)) {
                if (this.column.inlineEditorTemplate) {
                    return;
                }
                if (['date', 'boolean'].indexOf(this.column.dataType) > -1) {
                    return;
                }
                return;
            }
        }
        if (NAVIGATION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'tab':
                this.handleTab(shift);
                break;
            case 'end':
                this.handleEnd(ctrl);
                break;
            case 'home':
                this.handleHome(ctrl);
                break;
            case 'arrowleft':
            case 'left':
                if (ctrl) {
                    this.grid.navigation.onKeydownHome(node.row, false, this.rowStart);
                    break;
                }
                this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.selectionNode);
                break;
            case 'arrowright':
            case 'right':
                if (ctrl) {
                    this.grid.navigation.onKeydownEnd(node.row, false, this.rowStart);
                    break;
                }
                this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.selectionNode);
                break;
            case 'arrowup':
            case 'up':
                if (ctrl) {
                    this.grid.navigation.navigateTop(this.visibleColumnIndex);
                    break;
                }
                this.grid.navigation.navigateUp(this.row.nativeElement, this.selectionNode);
                break;
            case 'arrowdown':
            case 'down':
                if (ctrl) {
                    this.grid.navigation.navigateBottom(this.visibleColumnIndex);
                    break;
                }
                this.grid.navigation.navigateDown(this.row.nativeElement, this.selectionNode);
                break;
            case 'enter':
            case 'f2':
                this.onKeydownEnterEditMode();
                break;
            case 'escape':
            case 'esc':
                this.onKeydownExitEditMode();
                break;
            case ' ':
            case 'spacebar':
            case 'space':
                if (this.grid.isRowSelectable) {
                    this.row.selected ? this.selectionService.deselectRow(this.row.rowID, event) :
                        this.selectionService.selectRowById(this.row.rowID, false, event);
                }
                break;
            default:
                return;
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    onKeydownEnterEditMode() {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.column.editable && !this.row.deleted) {
            if (this.editMode) {
                this.grid.endEdit(true);
                this.nativeElement.focus();
            }
            else {
                this.crudService.begin(this);
            }
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    onKeydownExitEditMode() {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.editMode) {
            /** @type {?} */
            const args = this.crudService.cell.createEditEventArgs();
            this.grid.onCellEditCancel.emit(args);
            if (args.cancel) {
                return;
            }
            this.grid.endEdit(false);
            this.nativeElement.focus();
        }
    }
    /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    highlightText(text, caseSensitive, exactMatch) {
        return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
    }
    /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    clearHighlight() {
        if (this.highlight && this.column.searchable) {
            this.highlight.clearHighlight();
        }
    }
    /**
     * @hidden
     * \@internal
     * @param {?} range
     * @return {?}
     */
    calculateSizeToFit(range) {
        return Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    isToggleKey(key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    }
}
IgxGridCellComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                selector: 'igx-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
                providers: [HammerGesturesManager]
            }] }
];
/** @nocollapse */
IgxGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxGridCellComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    row: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowData: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cellTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-rowIndex',] }],
    visibleColumnIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-visibleIndex',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cellSelectionMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    lastPinned: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__td--pinned-last',] }],
    editMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__td--editing',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    readonly: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-readonly',] }],
    gridRowSpan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-row-span',] }],
    gridColumnSpan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-column-span',] }],
    rowEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-row-end',] }],
    colEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-column-end',] }],
    rowStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-row',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-row-start',] }],
    colStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-column',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-column-start',] }],
    describedby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-describedby',] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.min-width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.max-width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flex-basis',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-selected',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__td--selected',] }],
    dirty: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__td--edited',] }],
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__td--active',] }],
    defaultCellTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultCell', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    inlineEditorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inlineEditor', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    highlight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective, static: false },] }],
    onDoubleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['dblclick', ['$event'],] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }],
    onContextMenu: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['contextmenu', ['$event'],] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus', ['$event'],] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur',] }],
    dispatchEvent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'inEditMode' is deprecated\nUse 'editMode' to get the current state and 'setEditMode(boolean)' as a setter`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridCellComponent.prototype, "inEditMode", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateMethod(`'isCellSelected' is deprecated. Use 'selected' property instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", []),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:returntype", void 0)
], IgxGridCellComponent.prototype, "isCellSelected", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class IgxRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} crudService
     * @param {?} selectionService
     * @param {?} element
     * @param {?} cdr
     */
    constructor(gridAPI, crudService, selectionService, element, cdr) {
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.role = 'row';
        /**
         * @hidden
         */
        this.dragging = false;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         * \@internal
         */
        this.defaultCssClass = 'igx-grid__tr';
    }
    /**
     *  The data passed to the row component.
     *
     * ```typescript
     * // get the row data for the first selected row
     * let selectedRowData = this.grid.selectedRows[0].rowData;
     * ```
     * @return {?}
     */
    get rowData() {
        if (this.inEditMode) {
            return Object.assign({}, this._rowData, this.grid.transactions.getAggregatedValue(this.rowID, false));
        }
        return this._rowData;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set rowData(v) {
        this._rowData = v;
    }
    /**
     * @return {?}
     */
    get dataRowIndex() {
        return this.index;
    }
    /**
     * @hidden
     * @return {?}
     */
    get styleClasses() {
        return this.resolveClasses();
    }
    /**
     * @hidden
     * @return {?}
     */
    get selected() {
        return this.selectionService.isRowSelected(this.rowID);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        value ? this.selectionService.selectRowsWithNoEvent([this.rowID]) :
            this.selectionService.deselectRowsWithNoEvent([this.rowID]);
        this.grid.cdr.markForCheck();
    }
    /**
     * @hidden
     * @return {?}
     */
    get columns() {
        return this.grid.visibleColumns;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get viewIndex() {
        if (((/** @type {?} */ (this.grid))).groupingExpressions.length) {
            return this.grid.filteredSortedData.indexOf(this.rowData);
        }
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     * @return {?}
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get showRowSelectors() {
        return this.grid.showRowSelectors;
    }
    /**
     * @hidden
     * @return {?}
     */
    get dirty() {
        /** @type {?} */
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this.selectionService.isRowSelected(this.rowID);
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowDraggable() {
        return this.grid.rowDraggable;
    }
    /**
     * @hidden
     * @return {?}
     */
    get added() {
        /** @type {?} */
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD;
        }
        return false;
    }
    /**
     * @hidden
     * @return {?}
     */
    get deleted() {
        return this.gridAPI.row_deleted_transaction(this.rowID);
    }
    // TODO: Refactor
    /**
     * @return {?}
     */
    get inEditMode() {
        if (this.grid.rowEditable) {
            /** @type {?} */
            const editRowState = this.crudService.row;
            return (editRowState && editRowState.id === this.rowID) || false;
        }
        else {
            return false;
        }
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the ID of the row.
     * A row in the grid is identified either by:
     * - primaryKey data value,
     * - the whole rowData, if the primaryKey is omitted.
     *
     * ```typescript
     * let rowID = this.grid.selectedRows[2].rowID;
     * ```
     * @return {?}
     */
    get rowID() {
        /** @type {?} */
        const primaryKey = this.grid.primaryKey;
        return primaryKey ? this._rowData[primaryKey] : this._rowData;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.grid.rowSelection === 'none' || this.deleted) {
            return;
        }
        if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onRowSelectorClick(event) {
        event.stopPropagation();
        if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selected ? this.selectionService.deselectRow(this.rowID, event) :
            this.selectionService.selectRowById(this.rowID, false, event);
    }
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     * @param {?} value
     * @return {?}
     */
    update(value) {
        /** @type {?} */
        const crudService = this.crudService;
        if (crudService.inEditMode && crudService.cell.id.rowID === this.rowID) {
            this.grid.endEdit(false);
        }
        /** @type {?} */
        const row = new IgxRow(this.rowID, this.index, this.rowData);
        this.gridAPI.update_row(row, value);
        this.cdr.markForCheck();
    }
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     * @return {?}
     */
    delete() {
        this.grid.deleteRowById(this.rowID);
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowCheckboxAriaLabel() {
        return this.grid.primaryKey ?
            this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
            this.selected ? 'Deselect row' : 'Select row';
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    resolveClasses() {
        /** @type {?} */
        const indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
        /** @type {?} */
        const selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
        /** @type {?} */
        const editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
        /** @type {?} */
        const dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
        /** @type {?} */
        const deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
        /** @type {?} */
        const mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
        /** @type {?} */
        const dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
        return `${this.defaultCssClass} ${indexClass} ${selectedClass} ${editClass} ${dirtyClass}
         ${deletedClass} ${mrlClass} ${dragClass}`.trim();
    }
    /**
     * @hidden
     * @return {?}
     */
    get resolveDragIndicatorClasses() {
        /** @type {?} */
        const defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
        /** @type {?} */
        const dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
        return `${defaultDragIndicatorCssClass} ${dragIndicatorOff}`;
    }
}
IgxRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
/** @nocollapse */
IgxRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridCRUDService },
    { type: IgxGridSelectionService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxRowComponent.propDecorators = {
    rowData: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    gridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    virtDirRow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['igxDirRef', { read: IgxGridForOfDirective, static: false },] }],
    checkboxElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxCheckboxComponent), { read: IgxCheckboxComponent, static: false },] }],
    cells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxGridCellComponent),] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    dataRowIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-rowIndex',] }],
    styleClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }],
    selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-selected',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty('isSelected property is deprecated. Use selected property instead.'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [])
], IgxRowComponent.prototype, "isSelected", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const clear = (el) => el === 0 || Boolean(el);
/** @type {?} */
const first = (arr) => arr[0];
/** @type {?} */
const last = (arr) => arr[arr.length - 1];
class IgxSummaryOperand {
    /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     * \@memberof IgxSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static count(data) {
        return data.length;
    }
    /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     * \@memberof IgxSummaryOperand
     * @param {?=} data
     * @param {?=} allData
     * @param {?=} fieldName
     * @return {?}
     */
    operate(data = [], allData = [], fieldName) {
        return [{
                key: 'count',
                label: 'Count',
                summaryResult: IgxSummaryOperand.count(data)
            }];
    }
}
// @dynamic
class IgxNumberSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static min(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.min(a, b)) : 0;
    }
    /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static max(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.max(a, b)) : 0;
    }
    /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static sum(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => +a + +b) : 0;
    }
    /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static average(data) {
        return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: "max",
     *       label: "Max",
     *       summaryResult: IgxNumberSummaryOperand.max(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?=} data
     * @param {?=} allData
     * @param {?=} fieldName
     * @return {?}
     */
    operate(data = [], allData = [], fieldName) {
        /** @type {?} */
        const result = super.operate(data, allData, fieldName);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: IgxNumberSummaryOperand.min(data)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: IgxNumberSummaryOperand.max(data)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: IgxNumberSummaryOperand.sum(data)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: IgxNumberSummaryOperand.average(data)
        });
        return result;
    }
}
// @dynamic
class IgxDateSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static latest(data) {
        return data.length && data.filter(clear).length ?
            first(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?} data
     * @return {?}
     */
    static earliest(data) {
        return data.length && data.filter(clear).length ?
            last(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "latest",
     *       label: "Latest Date",
     *       summaryResult: IgxDateSummaryOperand.latest(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?=} data
     * @param {?=} allData
     * @param {?=} fieldName
     * @return {?}
     */
    operate(data = [], allData = [], fieldName) {
        /** @type {?} */
        const result = super.operate(data, allData, fieldName);
        result.push({
            key: 'earliest',
            label: 'Earliest',
            summaryResult: IgxDateSummaryOperand.earliest(data)
        });
        result.push({
            key: 'latest',
            label: 'Latest',
            summaryResult: IgxDateSummaryOperand.latest(data)
        });
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @return {?}
 */
function WatchChanges() {
    return (target, key, propDesc) => {
        /** @type {?} */
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        /** @type {?} */
        const originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
        propDesc.set = function (val) {
            /** @type {?} */
            const init = this._init;
            /** @type {?} */
            const oldValue = this[key];
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                originalSetter.call(this, val);
                if (this.ngOnChanges && !init) {
                    // in case wacthed prop changes trigger ngOnChanges manually
                    /** @type {?} */
                    const changes = {
                        [key]: new _angular_core__WEBPACK_IMPORTED_MODULE_1__["SimpleChange"](oldValue, val, false)
                    };
                    this.ngOnChanges(changes);
                }
            }
        };
        return propDesc;
    };
}
/**
 * @param {?=} repaint
 * @return {?}
 */
function notifyChanges(repaint = false) {
    return (_, key, propDesc) => {
        /** @type {?} */
        const privateKey = `__${key}`;
        propDesc = propDesc || {
            enumerable: true,
            configurable: true
        };
        /** @type {?} */
        const originalSetter = propDesc ? propDesc.set : null;
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        propDesc.set = function (newValue) {
            if (originalSetter) {
                originalSetter.call(this, newValue);
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
            else {
                if (newValue === this[key]) {
                    return;
                }
                this[privateKey] = newValue;
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
        };
        return (/** @type {?} */ (propDesc));
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxFilterCellTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxFilterCellTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxFilterCellTemplate]'
            },] }
];
/** @nocollapse */
IgxFilterCellTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxCellTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCellTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCell]'
            },] }
];
/** @nocollapse */
IgxCellTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxCellHeaderTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCellHeaderTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxHeader]'
            },] }
];
/** @nocollapse */
IgxCellHeaderTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxCellFooterTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCellFooterTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxFooter]'
            },] }
];
/** @nocollapse */
IgxCellFooterTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxCellEditorTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCellEditorTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxCellEditor]'
            },] }
];
/** @nocollapse */
IgxCellEditorTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
class IgxColumnComponent {
    /**
     * @param {?} gridAPI
     * @param {?} cdr
     */
    constructor(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * @hidden
         */
        this.widthChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._calcWidth = null;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.pinnedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        this._vIndex = NaN;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        /** @type {?} */
        const rowEditable = this.grid && this.grid.rowEditable;
        /** @type {?} */
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} editable
     * @return {?}
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.notifyChanges();
                // this.grid.refreshSearch(true);
            }
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'15%'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set minWidth(value) {
        /** @type {?} */
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    /**
     * @return {?}
     */
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                value ? this.pin() : this.unpin();
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} classRef
     * @return {?}
     */
    set summaries(classRef) {
        this._summaries = new classRef();
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            ((/** @type {?} */ (this.grid)))._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} instance
     * @return {?}
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} classRef
     * @return {?}
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} funcRef
     * @return {?}
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowComponent)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        /** @type {?} */
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        /** @type {?} */
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        /** @type {?} */
        let col = this;
        /** @type {?} */
        let vIndex = -1;
        if (this.columnGroup) {
            col = (/** @type {?} */ (this.allChildren.filter(c => !c.columnGroup)[0]));
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            /** @type {?} */
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(col);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get level() {
        /** @type {?} */
        let ptr = this.parent;
        /** @type {?} */
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    /**
     * @return {?}
     */
    get isLastPinned() {
        return this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    /**
     * @return {?}
     */
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    /**
     * @return {?}
     */
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filteringExpressionsTree() {
        return (/** @type {?} */ (this.grid.filteringExpressionsTree.find(this.field)));
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     * @param {?} isRow
     * @param {?} isIE
     * @return {?}
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            /** @type {?} */
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    /**
     * @param {?} children
     * @return {?}
     */
    getInitialChildColumnSizes(children) {
        /** @type {?} */
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            /** @type {?} */
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            /** @type {?} */
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 **/
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                /** @type {?} */
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        /** @type {?} */
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width: width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    /**
     * @param {?} children
     * @return {?}
     */
    getFilledChildColumnSizes(children) {
        /** @type {?} */
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        /** @type {?} */
        const result = [];
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
                result.push(columnSizes[i].width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    getColumnSizesString(children) {
        /** @type {?} */
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @return {?}
     */
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        /** @type {?} */
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        /** @type {?} */
        const targets = [];
        /** @type {?} */
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        /** @type {?} */
        const targetsSquashed = [];
        for (let j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(targets[j]);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        /** @type {?} */
        const grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
        index = index !== undefined ? index : grid._pinnedColumns.length;
        /** @type {?} */
        const targetColumn = grid._pinnedColumns[index];
        /** @type {?} */
        const args = { column: this, insertAtIndex: index, isPinned: true };
        grid.onColumnPinning.emit(args);
        if (grid._pinnedColumns.indexOf(this) === -1) {
            grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        // this.grid.refreshSearch(true);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    unpin(index) {
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        /** @type {?} */
        const grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
        }
        index = (index !== undefined ? index :
            this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        /** @type {?} */
        const targetColumn = grid._unpinnedColumns[index];
        grid._unpinnedColumns.splice(index, 0, this);
        if (grid._pinnedColumns.indexOf(this) !== -1) {
            grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        /** @type {?} */
        const insertAtIndex = grid._unpinnedColumns.indexOf(this);
        /** @type {?} */
        const args = { column: this, insertAtIndex, isPinned: false };
        grid.onColumnPinning.emit(args);
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        // this.grid.refreshSearch(true);
        return true;
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get topLevelParent() {
        /** @type {?} */
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    autosize() {
        if (!this.columnGroup) {
            this.width = this.getLargestCellWidth();
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getCalcWidth() {
        if (this._calcWidth !== null && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    getLargestCellWidth() {
        /** @type {?} */
        const range = this.grid.document.createRange();
        /** @type {?} */
        const largest = new Map();
        if (this.cells.length > 0) {
            /** @type {?} */
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            /** @type {?} */
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            /** @type {?} */
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            /** @type {?} */
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            /** @type {?} */
            let headerCell;
            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                headerCell = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                    .map((child) => getNodeSizeViaRange(range, child)));
            }
            else {
                headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }
            if (this.sortable || this.filterable) {
                headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            /** @type {?} */
            const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            /** @type {?} */
            const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                parseFloat(headerStyle.borderRightWidth);
            largest.set(headerCell, headerPadding);
        }
        /** @type {?} */
        const largestCell = Math.max(...Array.from(largest.keys()));
        /** @type {?} */
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getCellWidth() {
        /** @type {?} */
        const colWidth = this.width;
        /** @type {?} */
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            /** @type {?} */
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     * \@internal
     * @protected
     * @return {?}
     */
    cacheCalcWidth() {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const colWidth = this.width;
        /** @type {?} */
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseInt(colWidth, 10) / 100 * (grid.calcWidth - grid.featureColumnsWidth);
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseInt(this._calcWidth, 10);
    }
    /**
     * @hidden
     * @return {?}
     */
    get pinnable() {
        /** @type {?} */
        const gridUnpinnedWidth = ((/** @type {?} */ (this.grid))).getUnpinnedWidth(true);
        /** @type {?} */
        const elementWidth = this.parent ? parseInt(this.topLevelParent.width, 10) : parseInt(this.width, 10);
        return ((/** @type {?} */ (this.grid)))._init || !((gridUnpinnedWidth - elementWidth) < this.grid.unpinnedAreaMinWidth);
    }
    /**
     * @hidden
     * @return {?}
     */
    populateVisibleIndexes() { }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxColumnComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            }] }
];
/** @nocollapse */
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    header: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    sortable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    editable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    resizable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hasSummary: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hiddenChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    disableHiding: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disablePinning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    movable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    widthChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    maxWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    minWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    headerClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    headerGroupClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cellClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cellStyles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    formatter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filteringIgnoreCase: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    sortingIgnoreCase: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dataType: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pinned: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pinnedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    summaries: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    searchable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filters: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    sortStrategy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupingComparer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    bodyTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cellTemplate',] }],
    headerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    inlineEditorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['filterCellTemplate',] }],
    rowEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    colEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    colStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cellTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective, static: false },] }],
    headTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
    editorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective, static: false },] }],
    filterCellTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective, static: false },] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "header", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(true),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "groupable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "filterable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(true),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxColumnComponent.prototype, "hasSummary", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(true),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxColumnComponent.prototype, "hidden", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "disableHiding", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "disablePinning", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "movable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(true),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxColumnComponent.prototype, "width", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxColumnComponent.prototype, "minWidth", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "headerClasses", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "cellClasses", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "cellStyles", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function)
], IgxColumnComponent.prototype, "formatter", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`The property is deprecated. Please, use \`column.grid.id\` instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String)
], IgxColumnComponent.prototype, "gridID", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(true),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxColumnComponent.prototype, "summaries", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxColumnComponent.prototype, "searchable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])
], IgxColumnComponent.prototype, "bodyTemplate", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])
], IgxColumnComponent.prototype, "headerTemplate", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    notifyChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])
], IgxColumnComponent.prototype, "filterCellTemplate", null);
class IgxColumnGroupComponent extends IgxColumnComponent {
    /**
     * @param {?} gridAPI
     * @param {?} cdr
     */
    constructor(gridAPI, cdr) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(gridAPI, cdr);
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.children = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * \@memberof IgxColumnGroupComponent
         */
        this.searchable = true;
        /**
         * @hidden
         */
        this.hiddenChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Gets the column group `summaries`.
     * ```typescript
     * let columnGroupSummaries = this.columnGroup.summaries;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column group `summaries`.
     * ```typescript
     * this.columnGroup.summaries = IgxNumberSummaryOperand;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} classRef
     * @return {?}
     */
    set summaries(classRef) { }
    /**
     * Gets the column group `filters`.
     * ```typescript
     * let columnGroupFilters = this.columnGroup.filters;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column group `filters`.
     * ```typescript
     * this.columnGroup.filters = IgxStringFilteringOperand;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} classRef
     * @return {?}
     */
    set filters(classRef) { }
    /**
     * Returns a reference to the body template.
     * ```typescript
     * let bodyTemplate = this.columnGroup.bodyTemplate;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * @hidden
     * @param {?} template
     * @return {?}
     */
    set bodyTemplate(template) { }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * @hidden
     * @param {?} template
     * @return {?}
     */
    set inlineEditorTemplate(template) { }
    /**
     * Gets the column group cells.
     * ```typescript
     * let columnCells = this.columnGroup.cells;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get cells() {
        return [];
    }
    /**
     * Gets whether the column group is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get hidden() {
        return this.allChildren.every(c => c.hidden);
    }
    /**
     * Sets the column group hidden property.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        this._hidden = value;
        this.hiddenChange.emit(this._hidden);
        this.children.forEach(child => child.hidden = value);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        this.children.reset(this.children.toArray().slice(1));
        this.children.forEach(child => {
            child.parent = this;
        });
        /*
            TO DO: In Angular 9 this need to be removed, because the @ContentChildren will not return the `parent`
            component in the query list.
        */
        this.children.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$))
            .subscribe((change) => {
            if (change.length > 1 && change.first === this) {
                this.children.reset(this.children.toArray().slice(1));
                this.children.forEach(child => {
                    child.parent = this;
                });
            }
        });
    }
    /**
     * Returns the children columns collection.
     * ```typescript
     * let columns =  this.columnGroup.allChildren;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get allChildren() {
        return flatten(this.children.toArray());
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let isColumnGroup =  this.columnGroup.columnGroup
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get columnGroup() {
        return true;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnLayout() {
        return false;
    }
    /**
     * Gets the width of the column group.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get width() {
        /** @type {?} */
        let isChildrenWidthInPercent = false;
        /** @type {?} */
        let width;
        width = `${this.children.reduce((acc, val) => {
            if (val.hidden) {
                return acc;
            }
            if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
                isChildrenWidthInPercent = true;
            }
            return acc + parseInt(val.width, 10);
        }, 0)}`;
        return isChildrenWidthInPercent ? width + '%' : width;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set width(val) { }
}
IgxColumnGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxColumnGroupComponent) }],
                selector: 'igx-column-group',
                template: ``
            }] }
];
/** @nocollapse */
IgxColumnGroupComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxColumnGroupComponent.propDecorators = {
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
    summaries: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    searchable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filters: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hiddenChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
class IgxColumnLayoutComponent extends IgxColumnGroupComponent {
    constructor() {
        super(...arguments);
        this.childrenVisibleIndexes = [];
    }
    /**
     * Gets the width of the column layout.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get width() {
        /** @type {?} */
        const width = this.getFilledChildColumnSizes(this.children).reduce((acc, val) => acc + parseInt(val, 10), 0);
        return width;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set width(val) { }
    /**
     * @return {?}
     */
    get columnLayout() {
        return true;
    }
    /**
     * @hidden
     * @return {?}
     */
    getCalcWidth() {
        /** @type {?} */
        let borderWidth = 0;
        if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            /** @type {?} */
            const headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
        }
        return super.getCalcWidth() + borderWidth;
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        /** @type {?} */
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => c.columnLayout && !c.hidden);
        /** @type {?} */
        const pinnedColumns = this.grid.pinnedColumns.filter(c => c.columnLayout && !c.hidden);
        /** @type {?} */
        let vIndex = -1;
        if (!this.pinned) {
            /** @type {?} */
            const indexInCollection = unpinnedColumns.indexOf(this);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(this);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /*
         * Gets whether the column layout is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * @memberof IgxColumnGroupComponent
         */
    /**
     * @return {?}
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column layout hidden property.
     * ```typescript
     * <igx-column-layout [hidden] = "true"></igx-column->
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        this._hidden = value;
        this.children.forEach(child => child.hidden = value);
        if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
            // reset indexes in case columns are hidden/shown runtime
            this.grid.columns.filter(x => x.columnGroup).forEach(x => x.populateVisibleIndexes());
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (!this.hidden) {
            this.hidden = this.allChildren.some(x => x.hidden);
        }
        else {
            this.children.forEach(child => child.hidden = this.hidden);
        }
        this.children.forEach(child => {
            child.movable = false;
        });
    }
    /*
         * Gets whether the group contains the last pinned child column of the column layout.
         * ```typescript
         * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
         * ```
         * @memberof IgxColumnLayoutComponent
         */
    /**
     * @return {?}
     */
    get hasLastPinnedChildColumn() {
        return this.children.some(child => child.isLastPinned);
    }
    /**
     * @hidden
     * @return {?}
     */
    populateVisibleIndexes() {
        this.childrenVisibleIndexes = [];
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
        /** @type {?} */
        const orderedCols = columns
            .filter(x => !x.columnGroup && !x.hidden)
            .sort((a, b) => a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart);
        this.children.forEach(child => {
            /** @type {?} */
            const rs = child.rowStart || 1;
            /** @type {?} */
            let vIndex = 0;
            // filter out all cols with larger rowStart
            /** @type {?} */
            const cols = orderedCols.filter(c => !c.columnGroup && (c.rowStart || 1) <= rs);
            vIndex = cols.indexOf(child);
            this.childrenVisibleIndexes.push({ column: child, index: vIndex });
        });
    }
}
IgxColumnLayoutComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxColumnLayoutComponent) }],
                selector: 'igx-column-layout',
                template: ``
            }] }
];
IgxColumnLayoutComponent.propDecorators = {
    hidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxColumnResizingService {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     * @return {?}
     */
    get resizerHeight() {
        /** @type {?} */
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        /** @type {?} */
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     * @return {?}
     */
    get restrictResizeMin() {
        /** @type {?} */
        const actualMinWidth = parseFloat(this.column.minWidth);
        /** @type {?} */
        const minWidth = actualMinWidth < parseFloat(this.column.width) ? actualMinWidth : parseFloat(this.column.width);
        return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     * @return {?}
     */
    get restrictResizeMax() {
        /** @type {?} */
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        if (this.column.pinned) {
            /** @type {?} */
            const pinnedMaxWidth = this.pinnedMaxWidth =
                this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;
            if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
                this.pinnedMaxWidth = this.column.maxWidth;
                return parseFloat(this.column.maxWidth) - actualWidth;
            }
            else {
                return pinnedMaxWidth - actualWidth;
            }
        }
        else {
            if (this.column.maxWidth) {
                return parseFloat(this.column.maxWidth) - actualWidth;
            }
            else {
                return Number.MAX_SAFE_INTEGER;
            }
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    autosizeColumnOnDblClick() {
        /** @type {?} */
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        const size = this.column.getLargestCellWidth();
        if (this.column.pinned) {
            /** @type {?} */
            const newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);
            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.column.width = size;
            }
        }
        else if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.minWidth)) {
            this.column.width = this.column.minWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    resizeColumn(event) {
        this.showResizer = false;
        /** @type {?} */
        const diff = event.clientX - this.startResizePos;
        /** @type {?} */
        let currentColWidth = parseFloat(this.column.width);
        /** @type {?} */
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        const colMinWidth = this.getColMinWidth(this.column);
        /** @type {?} */
        const colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    getColMinWidth(column) {
        /** @type {?} */
        let currentColWidth = parseFloat(column.width);
        /** @type {?} */
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    getColMaxWidth(column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    }
    /**
     * @protected
     * @param {?} column
     * @param {?} diff
     * @return {?}
     */
    resizeColumnLayoutFor(column, diff) {
        /** @type {?} */
        const relativeColumns = column.getResizableColUnderEnd();
        /** @type {?} */
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        if (column.pinned) {
            /** @type {?} */
            const pinnedWidth = this.column.grid.getPinnedWidth(true);
            /** @type {?} */
            const maxPinnedWidth = this.column.grid.calcPinnedContainerMaxWidth;
            if (pinnedWidth + diff > maxPinnedWidth) {
                diff = maxPinnedWidth - pinnedWidth;
            }
        }
        // Resize first those who might reach min/max width
        /** @type {?} */
        let columnsToResize = [...relativeColumns];
        /** @type {?} */
        let updatedDiff = diff;
        /** @type {?} */
        let updatedCombinedSpan = combinedSpan;
        /** @type {?} */
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            /** @type {?} */
            let newCombinedSpan = updatedCombinedSpan;
            /** @type {?} */
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                /** @type {?} */
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                /** @type {?} */
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                /** @type {?} */
                const minWidth = this.getColMinWidth(col.target);
                /** @type {?} */
                const maxWidth = this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            /** @type {?} */
            const currentResizeWidth = parseFloat(col.target.calcWidth);
            /** @type {?} */
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    }
}
IgxColumnResizingService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
/** @nocollapse */
IgxColumnResizingService.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_DATE_FORMAT = 'mediumDate';
/** @type {?} */
const DEBOUNCE_TIME = 200;
/**
 * @hidden
 */
class IgxResizeHandleDirective {
    /**
     * @param {?} zone
     * @param {?} element
     * @param {?} colResizingService
     */
    constructor(zone, element, colResizingService) {
        this.zone = zone;
        this.element = element;
        this.colResizingService = colResizingService;
        /**
         * @hidden
         */
        this._dblClick = false;
        /**
         * @hidden
         */
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.column.columnGroup && this.column.resizable) {
            this.zone.runOutsideAngular(() => {
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'mousedown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(DEBOUNCE_TIME), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((event) => {
                    if (this._dblClick) {
                        this._dblClick = false;
                        return;
                    }
                    if (event.button === 0) {
                        this._onResizeAreaMouseDown(event);
                        this.column.grid.resizeLine.resizer.onMousedown(event);
                    }
                });
            });
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'mouseup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(DEBOUNCE_TIME), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => {
                this.colResizingService.isColumnResizing = false;
                this.colResizingService.showResizer = false;
                this.column.grid.cdr.detectChanges();
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onMouseOver() {
        this.colResizingService.resizeCursor = 'col-resize';
    }
    /**
     * @hidden
     * @return {?}
     */
    onDoubleClick() {
        this._dblClick = true;
        this.colResizingService.column = this.column;
        this.colResizingService.autosizeColumnOnDblClick();
    }
    /**
     * @hidden
     * @private
     * @param {?} event
     * @return {?}
     */
    _onResizeAreaMouseDown(event) {
        this.colResizingService.column = this.column;
        this.colResizingService.isColumnResizing = true;
        this.colResizingService.startResizePos = event.clientX;
        this.colResizingService.showResizer = true;
        this.column.grid.cdr.detectChanges();
    }
}
IgxResizeHandleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxResizeHandle]'
            },] }
];
/** @nocollapse */
IgxResizeHandleDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxColumnResizingService }
];
IgxResizeHandleDirective.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxResizeHandle',] }],
    onMouseOver: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mouseover',] }],
    onDoubleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['dblclick',] }]
};
/**
 * @hidden
 */
class IgxColumnResizerDirective {
    /**
     * @param {?} element
     * @param {?} document
     * @param {?} zone
     */
    constructor(element, document, zone) {
        this.element = element;
        this.document = document;
        this.zone = zone;
        this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
        this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
        this.resizeEnd = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.resizeStart = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.resize = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.resizeStart.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])((event) => event.clientX), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["switchMap"])((offset) => this.resize.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])((event) => event.clientX - offset), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.resizeEnd), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)))).subscribe((pos) => {
            /** @type {?} */
            const left = this._left + pos;
            /** @type {?} */
            const min = this._left - this.restrictHResizeMin;
            /** @type {?} */
            const max = this._left + this.restrictHResizeMax;
            this.left = left < min ? min : left;
            if (left > max) {
                this.left = max;
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.document.defaultView, 'mousemove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"])), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy)).subscribe((res) => this.onMousemove(res));
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.document.defaultView, 'mouseup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy))
                .subscribe((res) => this.onMouseup(res));
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set left(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.left = val + 'px');
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set top(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.top = val + 'px');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseup(event) {
        this.resizeEnd.next(event);
        this.resizeEnd.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMousedown(event) {
        event.preventDefault();
        /** @type {?} */
        const parent = this.element.nativeElement.parentElement.parentElement;
        this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
        this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
        this.resizeStart.next(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMousemove(event) {
        event.preventDefault();
        this.resize.next(event);
    }
}
IgxColumnResizerDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxResizer]'
            },] }
];
/** @nocollapse */
IgxColumnResizerDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxColumnResizerDirective.propDecorators = {
    restrictHResizeMin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    restrictHResizeMax: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    resizeEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    resizeStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    resize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class IgxColumnMovingService {
    /**
     * @return {?}
     */
    get column() {
        return this._column;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set column(val) {
        if (val) {
            this._column = val;
        }
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set icon(val) {
        if (val) {
            this._icon = val;
        }
    }
}
IgxColumnMovingService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ IgxColumnMovingService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });
/** @enum {number} */
const DropPosition = {
    BeforeDropTarget: 0,
    AfterDropTarget: 1,
    None: 2,
};
DropPosition[DropPosition.BeforeDropTarget] = 'BeforeDropTarget';
DropPosition[DropPosition.AfterDropTarget] = 'AfterDropTarget';
DropPosition[DropPosition.None] = 'None';
/**
 * @hidden
 */
class IgxColumnMovingDragDirective extends IgxDragDirective {
    /**
     * @param {?} _element
     * @param {?} _viewContainer
     * @param {?} _zone
     * @param {?} _renderer
     * @param {?} _cdr
     * @param {?} cms
     */
    constructor(_element, _viewContainer, _zone, _renderer, _cdr, cms) {
        super(_cdr, _element, _viewContainer, _zone, _renderer);
        this.cms = cms;
        this._ghostClass = 'igx-grid__drag-ghost-image';
        this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
        this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        this._column = val;
    }
    /**
     * @return {?}
     */
    get column() {
        return this._column;
    }
    /**
     * @return {?}
     */
    get draggable() {
        return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
    }
    /**
     * @return {?}
     */
    get icon() {
        return this.cms.icon;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEscape(event) {
        this.cms.cancelDrop = true;
        this.onPointerUp(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPointerDown(event) {
        if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._removeOnDestroy = false;
        this.cms.column = this.column;
        this.ghostClass = this._ghostClass;
        super.onPointerDown(event);
        this.cms.isColumnMoving = true;
        this.column.grid.cdr.detectChanges();
        /** @type {?} */
        const args = {
            source: this.column
        };
        this.column.grid.onColumnMovingStart.emit(args);
        this.subscription$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.column.grid.document.defaultView, 'keydown').subscribe((ev) => {
            if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                this.onEscape(ev);
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPointerMove(event) {
        event.preventDefault();
        super.onPointerMove(event);
        if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
            this.column.grid.draggedColumn = this.column;
            this.column.grid.cdr.detectChanges();
        }
        if (this.cms.isColumnMoving) {
            /** @type {?} */
            const args = {
                source: this.column,
                cancel: false
            };
            this.column.grid.onColumnMoving.emit(args);
            if (args.cancel) {
                this.onEscape(event);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPointerUp(event) {
        // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
        this.zone.run(() => {
            super.onPointerUp(event);
            this.cms.isColumnMoving = false;
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        });
        this._unsubscribe();
    }
    /**
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    createGhost(pageX, pageY) {
        super.createGhost(pageX, pageY);
        this.ghostElement.style.height = null;
        this.ghostElement.style.minWidth = null;
        this.ghostElement.style.flexBasis = null;
        this.ghostElement.style.position = null;
        /** @type {?} */
        const icon = document.createElement('i');
        /** @type {?} */
        const text = document.createTextNode('block');
        icon.appendChild(text);
        icon.classList.add('material-icons');
        this.cms.icon = icon;
        if (!this.column.columnGroup) {
            this.renderer.addClass(icon, this.ghostImgIconClass);
            this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
        else {
            this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
            this.renderer.addClass(icon, this.ghostImgIconGroupClass);
            this.ghostElement.children[0].style.paddingLeft = '0px';
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _unsubscribe() {
        if (this.subscription$) {
            this.subscription$.unsubscribe();
            this.subscription$ = null;
        }
    }
}
IgxColumnMovingDragDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxColumnMovingDrag]'
            },] }
];
/** @nocollapse */
IgxColumnMovingDragDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxColumnMovingService }
];
IgxColumnMovingDragDirective.propDecorators = {
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxColumnMovingDrag',] }]
};
/**
 * @hidden
 */
class IgxColumnMovingDropDirective extends IgxDropDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} zone
     * @param {?} cms
     */
    constructor(elementRef, renderer, zone, cms) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.cms = cms;
        this._dropIndicator = null;
        this._lastDropIndicator = null;
        this._dragLeave = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        if (val instanceof IgxColumnComponent) {
            this._column = val;
        }
        if (val instanceof IgxGridForOfDirective) {
            this._hVirtDir = val;
        }
    }
    /**
     * @return {?}
     */
    get column() {
        return this._column;
    }
    /**
     * @return {?}
     */
    get isDropTarget() {
        return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable &&
            ((!this._column.pinned && this.cms.column.disablePinning) || !this.cms.column.disablePinning);
    }
    /**
     * @return {?}
     */
    get horizontalScroll() {
        if (this._hVirtDir) {
            return this._hVirtDir;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._dragLeave.next(true);
        this._dragLeave.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        /** @type {?} */
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (this._lastDropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            /** @type {?} */
            const clientRect = this.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const pos = clientRect.left + clientRect.width / 2;
            /** @type {?} */
            const parent = this.elementRef.nativeElement.parentElement;
            if (event.detail.pageX < pos) {
                this._dropPos = DropPosition.BeforeDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;
            }
            else {
                this._dropPos = DropPosition.AfterDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;
            }
            if (this.cms.icon.innerText !== 'block') {
                this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        /** @type {?} */
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            this.cms.icon.innerText = 'block';
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                this.cms.icon.innerText = 'swap_horiz';
            }
            if (!this.cms.column.pinned && this.column.pinned) {
                /** @type {?} */
                const nextPinnedWidth = this.column.grid.getPinnedWidth(true) + parseFloat(this.cms.column.width);
                if (nextPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                    this.cms.icon.innerText = 'lock';
                }
                else {
                    this.cms.icon.innerText = 'block';
                }
            }
        }
        else {
            this.cms.icon.innerText = 'block';
        }
        if (this.horizontalScroll) {
            this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._dragLeave)).subscribe(() => {
                this.cms.column.grid.wheelHandler();
                event.target.id === 'right' ? this.horizontalScroll.scrollPosition += 15 :
                    this.horizontalScroll.scrollPosition -= 15;
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        /** @type {?} */
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        this.cms.icon.innerText = 'block';
        if (this._dropIndicator) {
            this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragDrop(event) {
        event.preventDefault();
        /** @type {?} */
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
            return;
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
        if (this.isDropTarget) {
            /** @type {?} */
            const args = {
                source: this.cms.column,
                target: this.column
            };
            /** @type {?} */
            let nextPinnedWidth;
            if (this.column.pinned && !this.cms.column.pinned) {
                nextPinnedWidth = this.column.grid.getPinnedWidth(true) + parseFloat(this.cms.column.width);
            }
            if ((nextPinnedWidth && nextPinnedWidth > this.column.grid.calcPinnedContainerMaxWidth) ||
                this.column.level !== this.cms.column.level ||
                this.column.parent !== this.cms.column.parent ||
                this.cms.cancelDrop) {
                this.cms.cancelDrop = false;
                this.column.grid.onColumnMovingEnd.emit(args);
                return;
            }
            this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        }
    }
}
IgxColumnMovingDropDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxColumnMovingDrop]'
            },] }
];
/** @nocollapse */
IgxColumnMovingDropDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: IgxColumnMovingService }
];
IgxColumnMovingDropDirective.propDecorators = {
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxColumnMovingDrop',] }]
};
class IgxGridBodyDirective {
}
IgxGridBodyDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxGridBody]',
                providers: [IgxForOfSyncService]
            },] }
];
/**
 * @hidden
 */
class IgxDatePipeComponent extends _angular_common__WEBPACK_IMPORTED_MODULE_3__["DatePipe"] {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(locale);
    }
    /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    transform(value, locale) {
        if (value && value instanceof Date) {
            if (locale) {
                return super.transform(value, DEFAULT_DATE_FORMAT, undefined, locale);
            }
            else {
                return super.transform(value);
            }
        }
        else {
            return value;
        }
    }
}
IgxDatePipeComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxdate'
            },] }
];
/** @nocollapse */
IgxDatePipeComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["LOCALE_ID"],] }] }
];
/**
 * @hidden
 */
class IgxDecimalPipeComponent extends _angular_common__WEBPACK_IMPORTED_MODULE_3__["DecimalPipe"] {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(locale);
    }
    /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    transform(value, locale) {
        if (value && typeof value === 'number') {
            if (locale) {
                return super.transform(value, undefined, locale);
            }
            else {
                return super.transform(value);
            }
        }
        else {
            return value;
        }
    }
}
IgxDecimalPipeComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxdecimal'
            },] }
];
/** @nocollapse */
IgxDecimalPipeComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["LOCALE_ID"],] }] }
];
/**
 * @hidden
 */
class RowEditPositionStrategy extends ConnectedPositioningStrategy {
    constructor() {
        super(...arguments);
        this.isTop = false;
        this.isTopInitialPosition = null;
    }
    /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        /** @type {?} */
        const container = this.settings.container;
        // grid.tbody
        /** @type {?} */
        const target = (/** @type {?} */ (this.settings.target));
        // Position of the overlay depends on the available space in the grid.
        // If the bottom space is not enough then the the row overlay will show at the top of the row.
        // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
        // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
        this.isTop = this.isTopInitialPosition !== null ?
            this.isTopInitialPosition :
            container.getBoundingClientRect().bottom <
                target.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
        // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
        contentElement.style.width = target.clientWidth + 'px';
        this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
        this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
        super.position(contentElement, { width: target.clientWidth, height: target.clientHeight }, document, initialCall);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
class ItemPropertyValueChanged {
    /**
     * @param {?} propName
     */
    constructor(propName) {
        this.valueChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._propName = propName;
    }
    /**
     * @return {?}
     */
    get object() {
        return this._object;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set object(value) {
        if (value) {
            this._object = value;
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return (this.object) ? this.object[this._propName] : null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.onValueChanged(value);
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    onValueChanged(value) {
        /** @type {?} */
        const currentValue = this.value;
        if (value !== currentValue) {
            this.object[this._propName] = value;
            this.valueChanged.emit({ oldValue: currentValue, newValue: value });
        }
    }
}
ItemPropertyValueChanged.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    valueChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class ColumnChooserItemBase extends ItemPropertyValueChanged {
    /**
     * @param {?} prop
     */
    constructor(prop) {
        super(prop);
        this.prop = prop;
        this.indentation = 30;
    }
    /**
     * @return {?}
     */
    get column() {
        return this.object;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set column(value) {
        if (value) {
            this.object = value;
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return (this.column) ? ((this.column.header) ? this.column.header : this.column.field) : '';
    }
    /**
     * @return {?}
     */
    get level() {
        return this.column.level;
    }
    /**
     * @return {?}
     */
    get calcIndent() {
        return this.indentation * this.level;
    }
}
ColumnChooserItemBase.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    indentation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    container: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxColumnHidingItemDirective extends ColumnChooserItemBase {
    constructor() {
        super('hidden');
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this.column.disableHiding;
    }
}
IgxColumnHidingItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxColumnHidingItem]'
            },] }
];
/** @nocollapse */
IgxColumnHidingItemDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ColumnDisplayOrder = {
    Alphabetical: 'Alphabetical',
    DisplayOrder: 'DisplayOrder',
};
class CustomFilteringStrategy extends FilteringStrategy {
    /**
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    filter(data, expressionsTree) {
        /** @type {?} */
        const res = [];
        data.forEach((item) => {
            if (this.matchRecord(item, (/** @type {?} */ (expressionsTree.filteringOperands[0])))) {
                res.push(item);
            }
            else if (item.column.columnGroup) {
                if (item.column.allChildren.findIndex((child) => this.matchRecord(child, (/** @type {?} */ (expressionsTree.filteringOperands[1]))) ||
                    this.matchRecord(child, (/** @type {?} */ (expressionsTree.filteringOperands[2])))) > -1) {
                    res.push(item);
                }
            }
        });
        return res;
    }
}
/**
 * @hidden
 * @abstract
 */
class ColumnChooserBase {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * Hides/ shows the filtering columns input from the UI.
         */
        this.disableFilter = false;
        /**
         * Access to the columnHidingUI:
         * ```typescript
         * \@ViewChild('column-hiding-component')
         *  public columnHidingUI: IgxColumnHidingComponent;
         * ```
         * Sets/gets the max height of the column area.
         * ```typescript
         * let columnsAreaMaxHeight =  this.columnHidingUI.columnsAreaMaxHeight;
         * ```
         *
         * ```html
         * <igx-column-hiding [columnsAreaMaxHeight]="200px"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         */
        this.columnsAreaMaxHeight = '100%';
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-hiding"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         * \@memberof ColumnChooserBase
         */
        this.cssClass = 'igx-column-hiding';
        /**
         * @hidden
         */
        this._currentColumns = [];
        /**
         * @hidden
         */
        this._gridColumns = [];
        /**
         * @hidden
         */
        this._rawColumns = [];
        /**
         * @hidden
         */
        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * @hidden
         */
        this._filterCriteria = '';
        /**
         * @hidden
         */
        this._filterColumnsPrompt = '';
        /**
         * @hidden
         */
        this._title = '';
    }
    /**
     * Gets the grid columns that are going to be manipulated.
     * ```typescript
     * let gridColumns = this.columnHidingUI.columns;
     * ```
     * \@memberof ColumnChooserBase
     * @return {?}
     */
    get columns() {
        return this._gridColumns;
    }
    /**
     * Sets the the grid columns that are going to be manipulated.
     * ```html
     * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
     * ```
     * \@memberof ColumnChooserBase
     * @param {?} value
     * @return {?}
     */
    set columns(value) {
        if (value) {
            this._gridColumns = value;
            this.createColumnItems();
            if (this.filterCriteria) {
                this.filter();
            }
        }
    }
    /**
     * Sets/gets the title of the column chooser.
     * ```typescript
     * let title =  this.columnHidingUI.title;
     * ```
     * \@memberof ColumnChooserBase
     * @return {?}
     */
    get title() {
        return this._title;
    }
    /**
     * ```html
     * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
     * ```
     * \@memberof ColumnChooserBase
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this._title = (value) ? value : '';
    }
    /**
     * Gets the prompt that is displayed in the filter input.
     * ```typescript
     * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
     * ```
     * \@memberof ColumnChooserBase
     * @return {?}
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the prompt that is going to be displayed in the filter input.
     * ```html
     * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
     * ```
     * \@memberof ColumnChooserBase
     * @param {?} value
     * @return {?}
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = (value) ? value : '';
    }
    /**
     * Gets the items of the selected columns.
     * ```typescript
     * let columnItems =  this.columnHidingUI.columnItems;
     * ```
     * \@memberof ColumnChooserBase
     * @return {?}
     */
    get columnItems() {
        return this._currentColumns;
    }
    /**
     * Gets the value which filters the columns list.
     * ```typescript
     * let filterCriteria =  this.columnHidingUI.filterCriteria;
     * ```
     * \@memberof ColumnChooserBase
     * @return {?}
     */
    get filterCriteria() {
        return this._filterCriteria;
    }
    /**
     * Sets the value which filters the columns list.
     * ```html
     *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
     * ```
     * \@memberof ColumnChooserBase
     * @param {?} value
     * @return {?}
     */
    set filterCriteria(value) {
        if (!value || value.length === 0) {
            this.clearFiltering();
            this._filterCriteria = '';
            this.cdr.detectChanges();
            return;
        }
        else if (this._filterCriteria && this._filterCriteria.length > value.length) {
            this.clearFiltering();
        }
        this._filterCriteria = value;
        this.filter();
        this.cdr.detectChanges();
    }
    /**
     * Gets the display order of the columns.
     * ```typescript
     * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
     * ```
     * \@memberof ColumnChooserBase
     * @return {?}
     */
    get columnDisplayOrder() {
        return this._columnDisplayOrder;
    }
    /**
     * Sets the display order of the columns.
     * ```typescript
     * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
     * ```
     * \@memberof ColumnChooserBase
     * @param {?} value
     * @return {?}
     */
    set columnDisplayOrder(value) {
        if (value !== undefined) {
            this.orderColumns(value);
            if (this._filterCriteria.length > 0) {
                this.filter();
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        for (const item of this._currentColumns) {
            item.valueChanged.unsubscribe();
        }
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    createColumnItems() {
        if (this._gridColumns.length > 0) {
            this._rawColumns = [];
            this._gridColumns.forEach((column) => {
                /** @type {?} */
                const item = this.createColumnItem(this, column);
                if (item) {
                    this._rawColumns.push(item);
                }
            });
            this._currentColumns = this._rawColumns.slice(0);
            this.orderColumns(this._columnDisplayOrder);
        }
    }
    /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    orderColumns(value) {
        this._columnDisplayOrder = value;
        if (value === ColumnDisplayOrder[ColumnDisplayOrder.Alphabetical] ||
            value === ColumnDisplayOrder.Alphabetical) {
            this._currentColumns = this._rawColumns.slice(0).sort((current, next) => {
                return current.name.toLowerCase().localeCompare(next.name.toLowerCase());
            });
        }
        else {
            this._currentColumns = this._rawColumns;
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    filter() {
        /** @type {?} */
        const filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.Or);
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('name'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('field'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('header'));
        /** @type {?} */
        const strategy = new CustomFilteringStrategy();
        this._currentColumns = strategy.filter(this._currentColumns, filteringExpressionsTree);
    }
    /**
     * @hidden
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    createFilteringExpression(fieldName) {
        return {
            condition: IgxStringFilteringOperand.instance().condition('contains'),
            fieldName: fieldName,
            ignoreCase: true,
            searchVal: this._filterCriteria
        };
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    clearFiltering() {
        this.createColumnItems();
    }
}
ColumnChooserBase.propDecorators = {
    columns: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    title: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterColumnsPrompt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disableFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnItems: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterCriteria: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnDisplayOrder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnsAreaMaxHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxColumnHidingComponent extends ColumnChooserBase {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        super(cdr);
        this.cdr = cdr;
        /**
         * Sets/gets the text of the button that shows all columns if they are hidden.
         * ```typescript
         * let showAllButtonText =  this.columnHiding.showAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [showAllText] = "'Show Columns'"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */
        this.showAllText = 'Show All';
        /**
         * Sets/gets the text of the button that hides all columns if they are shown.
         * ```typescript
         * let hideAllButtonText =  this.columnHiding.hideAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [hideAllText] = "'Hide Columns'"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */
        this.hideAllText = 'Hide All';
        /**
         * An event that is emitted after the columns visibility is changed.
         * Provides references to the `column` and the `newValue` properties as event arguments.
         * ```html
         *  <igx-column-hiding (onColumnVisibilityChanged) = "onColumnVisibilityChanged($event)"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */
        this.onColumnVisibilityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
    }
    /**
     * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
     * ```html
     * <igx-column-hiding #columnHidingUI
     *     [columns]="grid.columns" [title]="'Column Hiding'">
     * </igx-column-hiding>
     * ```
     * ```typescript
     * \@ViewChild("'columnHidingUI'")
     * public columnHiding: IgxColumnHidingComponent;
     * let isHideAlldisabled =  this.columnHiding.disableHideAll;
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    get disableHideAll() {
        if (!this.columnItems || this.columnItems.length < 1 ||
            this.hiddenColumnsCount === this.columns.length) {
            return true;
        }
        else if (this.hidableColumns.length < 1 ||
            this.hidableColumns.length === this.hidableColumns.filter((col) => col.value).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
     * ```typescript
     * let isShowAlldisabled =  this.columnHiding.disableShowAll;
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    get disableShowAll() {
        if (!this.columnItems || this.columnItems.length < 1 ||
            this.hiddenColumnsCount < 1 || this.hidableColumns.length < 1) {
            return true;
        }
        else if (this.hidableColumns.length === this.hidableColumns.filter((col) => !col.value).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Gets the count of the hidden columns.
     * ```typescript
     * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    get hiddenColumnsCount() {
        return (this.columns) ? this.columns.filter((col) => col.hidden).length : 0;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hidableColumns() {
        return this.columnItems.filter((col) => !col.disabled);
    }
    /**
     * @hidden
     * @protected
     * @param {?} container
     * @param {?} column
     * @return {?}
     */
    createColumnItem(container, column) {
        if (column.grid.hasColumnLayouts && !column.columnLayout) {
            return null;
        }
        /** @type {?} */
        const item = new IgxColumnHidingItemDirective();
        item.container = container;
        item.column = column;
        item.valueChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
            this.onVisibilityChanged({ column: item.column, newValue: args.newValue });
        });
        return item;
    }
    /**
     * Shows all columns in the grid.
     * ```typescript
     * this.columnHiding.showAllColumns();
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    showAllColumns() {
        /** @type {?} */
        const collection = this.hidableColumns;
        for (const col of collection) {
            col.value = false;
        }
    }
    /**
     * Hides all columns in the grid.
     * ```typescript
     * this.columnHiding.hideAllColumns();
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    hideAllColumns() {
        /** @type {?} */
        const collection = this.hidableColumns;
        for (const col of collection) {
            col.value = true;
        }
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    onVisibilityChanged(args) {
        this.onColumnVisibilityChanged.emit(args);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxColumnHidingComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                preserveWhitespaces: false,
                selector: 'igx-column-hiding',
                template: "<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let columnItem of hidableColumns\"\n        class=\"igx-column-hiding__columns-item\"\n        (onColumnVisibilityChanged)=\"onVisibilityChanged($event)\"\n        (change)=\"columnItem.value = !columnItem.value\"\n        [checked]=\"columnItem.value\"\n        [disabled]=\"columnItem.disabled\"\n        [style.margin-left.px]=\"columnItem.calcIndent\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-hiding__buttons\">\n    <button igxButton igxRipple (click)=\"showAllColumns()\" [disabled]=\"disableShowAll\">{{ showAllText }}</button>\n    <button igxButton igxRipple (click)=\"hideAllColumns()\" [disabled]=\"disableHideAll\">{{ hideAllText }}</button>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxColumnHidingComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxColumnHidingComponent.propDecorators = {
    disableHideAll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disableShowAll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    showAllText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideAllText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onColumnVisibilityChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class IgxColumnHidingModule {
}
IgxColumnHidingModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxColumnHidingComponent, IgxColumnHidingItemDirective],
                exports: [IgxColumnHidingComponent],
                imports: [
                    IgxButtonModule,
                    IgxCheckboxModule,
                    IgxInputGroupModule,
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxColumnPinningItemDirective extends ColumnChooserItemBase {
    constructor() {
        super('pinned');
    }
    /**
     * Returns whether a column could be pinned.
     * It's not possible to pin a column if there is not enough space for the unpinned area.
     * ```typescript
     * const columnItem: IgxColumnPinningItemDirective;
     * this.columnItem.pinnable;
     * ```
     * @return {?}
     */
    get pinnable() {
        return this.column.pinnable;
    }
}
IgxColumnPinningItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxColumnPinningItem]'
            },] }
];
/** @nocollapse */
IgxColumnPinningItemDirective.ctorParameters = () => [];
class IgxColumnPinningComponent extends ColumnChooserBase {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        super(cdr);
        this.cdr = cdr;
    }
    /**
     * @hidden
     * @param {?} container
     * @param {?} column
     * @return {?}
     */
    createColumnItem(container, column) {
        if (column.level !== 0 || column.disablePinning) {
            return null;
        }
        /** @type {?} */
        const item = new IgxColumnPinningItemDirective();
        item.container = container;
        item.column = column;
        return item;
    }
    /**
     * @hidden
     * @param {?} event
     * @param {?} columnItem
     * @return {?}
     */
    checkboxValueChange(event, columnItem) {
        if (event.checked && !columnItem.pinnable) {
            event.checkbox.checked = false;
            return false;
        }
        columnItem.value = !columnItem.value;
    }
}
IgxColumnPinningComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                preserveWhitespaces: false,
                selector: 'igx-column-pinning',
                template: "\n<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox igxColumnPinningItem\n        *ngFor=\"let columnItem of columnItems\"\n        class=\"igx-column-hiding__columns-item\"\n        (change)=\"checkboxValueChange($event, columnItem)\"\n        [checked]=\"columnItem.value\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxColumnPinningComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
/**
 * @hidden
 */
class IgxColumnPinningModule {
}
IgxColumnPinningModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxColumnPinningComponent, IgxColumnPinningItemDirective],
                exports: [IgxColumnPinningComponent],
                imports: [
                    IgxCheckboxModule,
                    IgxInputGroupModule,
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"]
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class encapsulates the Toolbar's logic and is internally used by
 * the `IgxGridComponent`, `IgxTreeGridComponent` and `IgxHierarchicalGridComponent`.
 */
class IgxGridToolbarComponent extends DisplayDensityBase {
    /**
     * @param {?} gridAPI
     * @param {?} cdr
     * @param {?} excelExporter
     * @param {?} csvExporter
     * @param {?} _displayDensityOptions
     */
    constructor(gridAPI, cdr, excelExporter, csvExporter, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.excelExporter = excelExporter;
        this.csvExporter = csvExporter;
        this._displayDensityOptions = _displayDensityOptions;
        this._filterColumnsPrompt = 'Filter columns list ...';
        this._positionSettings = {
            horizontalDirection: HorizontalAlignment.Left,
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._overlaySettings = {
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludePositionTarget: true
        };
    }
    /**
     * Gets the default text shown in the filtering box.
     * ```typescript
     * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
     * ```
     * @return {?}
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the default text shown in the filtering box.
     * ```typescript
     * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
     * ```
     * @param {?} value
     * @return {?}
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = value;
    }
    /**
     * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
     * ```typescript
     * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
     * ```
     * @return {?}
     */
    get defaultDropDownsMaxHeight() {
        /** @type {?} */
        const gridHeight = this.grid.calcHeight;
        return (gridHeight) ? gridHeight * 0.7 + 'px' : '100%';
    }
    /**
     * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
     * ```typescript
     * const grid = this.igxGrid1.toolbar.grid;
     * ```
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns whether the `IgxGridComponent` renders an export button.
     * ```typescript
     * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
     * ```
     * @return {?}
     */
    get shouldShowExportButton() {
        return (this.grid != null && (this.grid.exportExcel || this.grid.exportCsv));
    }
    /**
     * Returns whether the `IgxGridComponent` renders an Excel export button.
     * ```typescript
     * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
     * ```
     * @return {?}
     */
    get shouldShowExportExcelButton() {
        return (this.grid != null && this.grid.exportExcel);
    }
    /**
     * Returns whether the `IgxGridComponent` renders an CSV export button.
     * ```typescript
     * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
     * ```
     * @return {?}
     */
    get shouldShowExportCsvButton() {
        return (this.grid != null && this.grid.exportCsv);
    }
    /**
     * Returns how many columns are pinned.
     * ```typescript
     * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
     * ```
     * @return {?}
     */
    get pinnedColumnsCount() {
        return this.grid.pinnedColumns.filter(col => !col.columnLayout).length;
    }
    /**
     * Returns the theme of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTheme = this.grid.toolbar.hostClass;
     * ```
     * @return {?}
     */
    get hostClass() {
        return this.getComponentDensityClass('igx-grid-toolbar');
    }
    /**
     * Returns the title of `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
     * ```
     * @return {?}
     */
    getTitle() {
        return this.grid != null ? this.grid.toolbarTitle : '';
    }
    /**
     * Returns the text of the export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
     * ```
     * @return {?}
     */
    getExportText() {
        return this.grid != null ? this.grid.exportText : '';
    }
    /**
     * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
     * ```
     * @return {?}
     */
    getExportExcelText() {
        return this.grid != null ? this.grid.exportExcelText : '';
    }
    /**
     * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
     * ```
     * @return {?}
     */
    getExportCsvText() {
        return this.grid != null ? this.grid.exportCsvText : '';
    }
    /**
     * Toggles the export button's dropdown menu.
     * ```typescript
     * this.igxGrid1.toolbar.exportClicked();
     * ```
     * @return {?}
     */
    exportClicked() {
        this._overlaySettings.positionStrategy.settings.target = this.exportButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.exportDropdown.toggle(this._overlaySettings);
    }
    /**
     * Exports the grid to excel.
     * ```typescript
     * this.igxGrid1.toolbar.exportToExcelClicked();
     * ```
     * @return {?}
     */
    exportToExcelClicked() {
        this.performExport(this.excelExporter, 'excel');
    }
    /**
     * Exports the grid to CSV.
     * ```typescript
     * this.igxGrid1.toolbar.exportToCsvClicked();
     * ```
     * @return {?}
     */
    exportToCsvClicked() {
        this.performExport(this.csvExporter, 'csv');
    }
    /**
     * @private
     * @param {?} exp
     * @param {?} exportType
     * @return {?}
     */
    performExport(exp, exportType) {
        this.exportClicked();
        /** @type {?} */
        const fileName = 'ExportedData';
        /** @type {?} */
        const options = exportType === 'excel' ?
            new IgxExcelExporterOptions(fileName) :
            new IgxCsvExporterOptions(fileName, CsvFileTypes.CSV);
        /** @type {?} */
        const args = { grid: this.grid, exporter: exp, options: options, cancel: false };
        this.grid.onToolbarExporting.emit(args);
        if (args.cancel) {
            return;
        }
        exp.export(this.grid, options);
    }
    /**
     * Toggles the Column Hiding UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnHidingUI();
     * ```
     * @return {?}
     */
    toggleColumnHidingUI() {
        this._overlaySettings.positionStrategy.settings.target = this.columnHidingButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.columnHidingDropdown.toggle(this._overlaySettings);
    }
    /**
     * Toggles the Column Pinning UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnPinningUI();
     * ```
     * @return {?}
     */
    toggleColumnPinningUI() {
        this._overlaySettings.positionStrategy.settings.target = this.columnPinningButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.columnPinningDropdown.toggle(this._overlaySettings);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    showAdvancedFilteringUI() {
        this.grid.openAdvancedFilteringDialog();
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the
     * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
     * ```typescript
     * const context =  this.igxGrid.toolbar.context;
     * ```
     * @return {?}
     */
    get context() {
        return {
            // $implicit: this
            grid: this.grid,
            toolbar: this
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    get customContentTemplate() {
        if (this.grid != null && this.grid.toolbarCustomContentTemplate != null) {
            return this.grid.toolbarCustomContentTemplate.template;
        }
        else {
            return null;
        }
    }
}
IgxGridToolbarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-grid-toolbar',
                template: "<span class=\"igx-grid-toolbar__title\" *ngIf=\"getTitle()\">\n    {{ getTitle() }}\n</span>\n\n<div class=\"igx-grid-toolbar__custom-content\" *ngIf=\"customContentTemplate != null\">\n    <ng-container *ngTemplateOutlet=\"customContentTemplate; context: context\">\n    </ng-container>\n</div>\n\n<div class=\"igx-grid-toolbar__actions\">\n    <div *ngIf=\"grid.allowAdvancedFiltering\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #advancedFilteringButton name=\"btnAdvancedFiltering\" igxRipple\n            [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\"\n            (click)=\"showAdvancedFilteringUI()\">\n            <div class=\"igx-grid-toolbar__button-space\">\n                <igx-icon>\n                    filter_list\n                </igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_title}}</span>\n            </div>\n        </button>\n    </div>\n\n    <div *ngIf=\"grid.columnHiding\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnHidingButton name=\"btnColumnHiding\" igxRipple\n            (click)=\"toggleColumnHidingUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount > 0\">visibility_off</igx-icon>\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount === 0\">visibility</igx-icon>\n                <span>{{ grid.hiddenColumnsCount }}</span>\n                <span>{{ grid.hiddenColumnsText }}</span>\n            </div>\n        </button>\n        <igx-drop-down #columnHidingDropdown>\n            <igx-column-hiding\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnHidingTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"\n                (onColumnVisibilityChanged)=\"grid.toggleColumnVisibility($event)\">\n            </igx-column-hiding>\n        </igx-drop-down>\n    </div>\n    <div *ngIf=\"grid.columnPinning\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnPinningButton name=\"btnColumnPinning\" igxRipple\n            (click)=\"toggleColumnPinningUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"pinnedColumnsCount > 0\">lock</igx-icon>\n                <igx-icon *ngIf=\"pinnedColumnsCount === 0\">lock_open</igx-icon>\n                <span>{{ pinnedColumnsCount }}</span>\n                <span>{{ grid.pinnedColumnsText }}</span>\n                <span></span>\n            </div>\n        </button>\n        <igx-drop-down #columnPinningDropdown>\n            <igx-column-pinning\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnPinningTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"></igx-column-pinning>\n        </igx-drop-down>\n    </div>\n\n    <div class=\"igx-grid-toolbar__dropdown\" *ngIf=\"shouldShowExportButton\" id=\"btnExport\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btnExport\n                (click)=\"exportClicked()\">\n            <span class=\"igx-grid-toolbar__button-space\">\n                <igx-icon fontSet=\"material\">import_export</igx-icon>\n                <span>{{ getExportText() }}</span>\n                <igx-icon fontSet=\"material\">arrow_drop_down</igx-icon>\n            </span>\n        </button>\n\n        <igx-drop-down #exportDropdown>\n            <ul class=\"igx-grid-toolbar__dd-list\">\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportExcelButton\" id=\"btnExportExcel\"\n                (click)=\"exportToExcelClicked()\">{{ getExportExcelText() }}</li>\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportCsvButton\" id=\"btnExportCsv\"\n                (click)=\"exportToCsvClicked()\">{{ getExportCsvText() }}</li>\n            </ul>\n        </igx-drop-down>\n    </div>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxGridToolbarComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxExcelExporterService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
    { type: IgxCsvExporterService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxGridToolbarComponent.propDecorators = {
    gridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid-toolbar',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterColumnsPrompt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    defaultDropDownsMaxHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnHidingDropdown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['columnHidingDropdown', { read: IgxDropDownComponent, static: false },] }],
    columnHidingUI: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxColumnHidingComponent, { static: false },] }],
    columnHidingButton: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['columnHidingButton', { read: IgxButtonDirective, static: false },] }],
    exportDropdown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['exportDropdown', { read: IgxDropDownComponent, static: false },] }],
    exportButton: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['btnExport', { read: IgxButtonDirective, static: false },] }],
    columnPinningDropdown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['columnPinningDropdown', { read: IgxDropDownComponent, static: false },] }],
    columnPinningUI: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxColumnPinningComponent, { static: false },] }],
    columnPinningButton: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['columnPinningButton', { read: IgxButtonDirective, static: false },] }],
    hostClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.class',] }]
};
/**
 * The IgxGridToolbarCustomContentDirective directive is used to mark an 'ng-template' (with
 * the 'igxToolbarCustomContent' selector) defined in the IgxGrid which is used to provide
 * custom content for cener part of the IgxGridToolbar.
 */
class IgxGridToolbarCustomContentDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxGridToolbarCustomContentDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxToolbarCustomContent]'
            },] }
];
/** @nocollapse */
IgxGridToolbarCustomContentDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxRowEditTemplateDirective {
}
IgxRowEditTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowEdit]'
            },] }
];
/**
 * @hidden
 */
class IgxRowEditTextDirective {
}
IgxRowEditTextDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowEditText]'
            },] }
];
/**
 * @hidden
 */
class IgxRowEditActionsDirective {
}
IgxRowEditActionsDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowEditActions]'
            },] }
];
// TODO: Refactor circular ref, deps and logic
/**
 * @hidden
 */
class IgxRowEditTabStopDirective {
    /**
     * @param {?} api
     * @param {?} element
     */
    constructor(api, element) {
        this.api = api;
        this.element = element;
        /**
         * Sets the cell in edit mode and focus its native element
         * @param cellIndex index of the cell to activate
         */
        this.activateCell = () => {
            /** @type {?} */
            const cell = this.grid.rowInEditMode.cells.find(e => e.visibleColumnIndex === this.currentCellIndex);
            cell.nativeElement.focus();
            cell.setEditMode(true);
            this.currentCellIndex = -1;
        };
    }
    /**
     * @return {?}
     */
    get grid() {
        return this.api.grid;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleTab(event) {
        event.stopPropagation();
        if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
            (this.grid.rowEditTabs.first === this && event.shiftKey)) {
            this.move(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleEscape(event) {
        this.grid.endEdit(false, event);
        /** @type {?} */
        const activeNode = this.grid.selectionService.activeElement;
        //  on right click activeNode is deleted, so we may have no one
        if (activeNode) {
            /** @type {?} */
            const cell = this.grid.navigation.getCellElementByVisibleIndex(activeNode.row, activeNode.layout ? activeNode.layout.columnVisibleIndex : activeNode.column);
            cell.focus();
        }
    }
    /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     * @private
     * @param {?} event keyboard event containing information about whether SHIFT key was pressed
     * @return {?}
     */
    move(event) {
        event.preventDefault();
        this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
        if (!this.grid.navigation.isColumnFullyVisible(this.currentCellIndex)) {
            this.grid.navigation.performHorizontalScrollToCell(this.grid.rowInEditMode.index, this.currentCellIndex, false, this.activateCell);
        }
        else {
            this.activateCell();
        }
    }
}
IgxRowEditTabStopDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: `[igxRowEditTabStop]`
            },] }
];
/** @nocollapse */
IgxRowEditTabStopDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxRowEditTabStopDirective.propDecorators = {
    handleTab: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Tab', [`$event`],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Shift.Tab', [`$event`],] }],
    handleEscape: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Escape', [`$event`],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGridGroupByRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} gridSelection
     * @param {?} element
     * @param {?} cdr
     */
    constructor(gridAPI, gridSelection, element, cdr) {
        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */
        this.isFocused = false;
        /**
         * @hidden
         */
        this.tabindex = 0;
    }
    /**
     * Returns whether the row is focused.
     * ```
     * let gridRowFocused = this.grid1.rowList.first.focused;
     * ```
     * @return {?}
     */
    get focused() {
        return this.isFocused;
    }
    /**
     * Returns whether the group row is expanded.
     * ```typescript
     * const groupRowExpanded = this.grid1.rowList.first.expanded;
     * ```
     * @return {?}
     */
    get expanded() {
        return this.grid.isExpandedGroup(this.groupRow);
    }
    /**
     * @hidden
     * @return {?}
     */
    get describedBy() {
        /** @type {?} */
        const grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
        return this.gridID + '_' + grRowExpr;
    }
    /**
     * @return {?}
     */
    get dataRowIndex() {
        return this.index;
    }
    /**
     * Returns a reference to the underlying HTML element.
     * ```typescript
     * const groupRowElement = this.nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Returns the style classes applied to the group rows.
     * ```typescript
     * const groupCssStyles = this.grid1.rowList.first.styleClasses;
     * ```
     * @return {?}
     */
    get styleClasses() {
        return `${this.defaultCssClass} ` + `${this.paddingIndentationCssClass}-` + this.groupRow.level +
            (this.focused ? ` ${this.defaultCssClass}--active` : '');
    }
    /**
     * @hidden
     * @return {?}
     */
    onFocus() {
        this.isFocused = true;
    }
    /**
     * @hidden
     * @return {?}
     */
    onBlur() {
        this.isFocused = false;
    }
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    toggle() {
        /** @type {?} */
        const isVirtualized = !this.grid.verticalScrollContainer.dc.instance.notVirtual;
        /** @type {?} */
        const groupRowIndex = this.index;
        this.grid.toggleGroup(this.groupRow);
        if (isVirtualized) {
            /** @type {?} */
            const groupRow = this.grid.nativeElement.querySelector(`[data-rowIndex="${groupRowIndex}"]`);
            if (groupRow) {
                groupRow.focus();
            }
        }
    }
    /**
     * @return {?}
     */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    get selectionNode() {
        return {
            row: this.index,
            column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
        };
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        // TODO: Refactor
        /** @type {?} */
        const key = event.key.toLowerCase();
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        const keydownArgs = { targetType: 'groupRow', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel) {
            return;
        }
        event.preventDefault();
        if (!this.isKeySupportedInGroupRow(key, event.shiftKey, event.altKey) || event.ctrlKey) {
            return;
        }
        if (this.isToggleKey(key, event.altKey)) {
            if ((this.expanded && ROW_COLLAPSE_KEYS.has(key)) || (!this.expanded && ROW_EXPAND_KEYS.has(key))) {
                this.toggle();
            }
            return;
        }
        /** @type {?} */
        const selection = this.gridSelection;
        selection.keyboardState.shift = event.shiftKey && !(key === 'tab');
        /** @type {?} */
        const activeNode = selection.activeElement ? Object.assign({}, selection.activeElement) : this.selectionNode;
        activeNode.row = this.index;
        switch (key) {
            case 'arrowdown':
            case 'down':
                this.grid.navigation.navigateDown(this.nativeElement, activeNode);
                break;
            case 'arrowup':
            case 'up':
                this.grid.navigation.navigateUp(this.nativeElement, activeNode);
                break;
            case 'tab':
                this.handleTabKey(event.shiftKey, activeNode);
                break;
        }
    }
    /**
     * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
     * ```typescript
     * this.grid1.rowList.first.grid;
     * ```
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * @hidden
     * @return {?}
     */
    get dataType() {
        /** @type {?} */
        const column = this.grid.getColumnByName(this.groupRow.expression.fieldName);
        return (column && column.dataType) || DataType.String;
    }
    /**
     * @private
     * @param {?} shift
     * @param {?} activeNode
     * @return {?}
     */
    handleTabKey(shift, activeNode) {
        if (shift) {
            this.grid.navigation.performShiftTabKey(this.nativeElement, activeNode);
        }
        else {
            if (this.index === this.grid.dataView.length - 1 && this.grid.rootSummariesEnabled) {
                this.grid.navigation.onKeydownHome(0, true);
            }
            else {
                /** @type {?} */
                const orderedColumns = this.grid.navigation.gridOrderedColumns;
                /** @type {?} */
                const lastCol = orderedColumns[orderedColumns.length - 1];
                activeNode.column = lastCol.columnLayoutChild ? lastCol.parent.visibleIndex : lastCol.visibleIndex;
                this.grid.navigation.performTab(this.nativeElement, activeNode);
            }
        }
    }
    /**
     * @private
     * @param {?} key
     * @param {?=} shift
     * @param {?=} alt
     * @return {?}
     */
    isKeySupportedInGroupRow(key, shift = false, alt = false) {
        if (shift) {
            return ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
        }
        return this.isToggleKey(key, alt) ? true : ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} altKey
     * @return {?}
     */
    isToggleKey(key, altKey) {
        return altKey && ['left', 'right', 'up', 'down', 'arrowleft', 'arrowright', 'arrowup', 'arrowdown'].indexOf(key) !== -1;
    }
}
IgxGridGroupByRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-groupby-row',
                template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n            <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n            </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
            }] }
];
/** @nocollapse */
IgxGridGroupByRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridSelectionService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxGridGroupByRowComponent.propDecorators = {
    defaultGroupByExpandedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultGroupByExpandedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultGroupByCollapsedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultGroupByCollapsedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    isFocused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    gridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupRow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['groupContent', { static: true },] }],
    expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-expanded',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    describedBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-describedby',] }],
    dataRowIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-rowIndex',] }],
    styleClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus',] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur',] }],
    onKeydown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const MoveDirection = {
    LEFT: 'left',
    RIGHT: 'right',
};
/**
 * @hidden
 */
class IgxGridNavigationService {
    /**
     * @return {?}
     */
    get displayContainerWidth() {
        return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
    }
    /**
     * @return {?}
     */
    get displayContainerScrollLeft() {
        return Math.ceil(this.grid.headerContainer.scrollPosition);
    }
    /**
     * @return {?}
     */
    get verticalDisplayContainerElement() {
        return this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement;
    }
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    horizontalScroll(rowIndex) {
        /** @type {?} */
        let rowComp = this.grid.dataRowList.find((row) => row.index === rowIndex) || this.grid.dataRowList.first;
        if (!rowComp) {
            rowComp = this.grid.summariesRowList.find((row) => row.index === rowIndex);
        }
        return rowComp.virtDirRow;
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    getColumnUnpinnedIndex(visibleColumnIndex) {
        /** @type {?} */
        const column = this.grid.unpinnedColumns.find((col) => !col.columnGroup && col.visibleIndex === visibleColumnIndex);
        return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter((c) => !c.columnGroup).indexOf(column) :
            visibleColumnIndex;
    }
    /**
     * @param {?} columnIndex
     * @return {?}
     */
    isColumnFullyVisible(columnIndex) {
        return this.isColumnRightEdgeVisible(columnIndex) && this.isColumnLeftEdgeVisible(columnIndex);
    }
    /**
     * @param {?} columnIndex
     * @return {?}
     */
    isColumnRightEdgeVisible(columnIndex) {
        /** @type {?} */
        const forOfDir = this.forOfDir();
        if (this.isColumnPinned(columnIndex, forOfDir)) {
            return true;
        }
        /** @type {?} */
        const index = this.getColumnUnpinnedIndex(columnIndex);
        return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft;
    }
    /**
     * @param {?} columnIndex
     * @return {?}
     */
    isColumnLeftEdgeVisible(columnIndex) {
        /** @type {?} */
        const forOfDir = this.forOfDir();
        if (this.isColumnPinned(columnIndex, forOfDir)) {
            return true;
        }
        /** @type {?} */
        const index = this.getColumnUnpinnedIndex(columnIndex);
        return this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
    }
    /**
     * @private
     * @return {?}
     */
    forOfDir() {
        /** @type {?} */
        let forOfDir;
        if (this.grid.dataRowList.length > 0) {
            forOfDir = this.grid.dataRowList.first.virtDirRow;
        }
        else {
            forOfDir = this.grid.headerContainer;
        }
        return forOfDir;
    }
    /**
     * @private
     * @param {?} columnIndex
     * @param {?} forOfDir
     * @return {?}
     */
    isColumnPinned(columnIndex, forOfDir) {
        /** @type {?} */
        const horizontalScroll = forOfDir.getScroll();
        /** @type {?} */
        const column = this.grid.columnList.filter(c => !c.columnGroup).find((col) => col.visibleIndex === columnIndex);
        return (!horizontalScroll.clientWidth || column.pinned);
    }
    /**
     * @return {?}
     */
    get gridOrderedColumns() {
        return [...this.grid.pinnedColumns, ...this.grid.unpinnedColumns].filter(c => !c.columnGroup);
    }
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    isRowInEditMode(rowIndex) {
        return this.grid.rowEditable && (this.grid.rowInEditMode && this.grid.rowInEditMode.index === rowIndex);
    }
    /**
     * @param {?} direction
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    findNextEditable(direction, visibleColumnIndex) {
        // go trough all columns in one cycle instead of
        // splice().reverse().find()
        /** @type {?} */
        const gridColumns = this.gridOrderedColumns;
        /** @type {?} */
        const start = visibleColumnIndex;
        /** @type {?} */
        let end = 0;
        /** @type {?} */
        let step = 0;
        /** @type {?} */
        let result = -1;
        if (direction === MoveDirection.LEFT) {
            end = 0;
            step = -1;
        }
        else if (direction === MoveDirection.RIGHT) {
            end = gridColumns.length - 1;
            step = 1;
        }
        for (let c = start; (c * step) <= end; c += step) {
            /** @type {?} */
            const column = gridColumns[c];
            if (column.editable) {
                result = c;
                break;
            }
        }
        return result;
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary = false) {
        /** @type {?} */
        const cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
        return (/** @type {?} */ (this.grid.nativeElement.querySelector(`${cellSelector}[data-rowindex="${rowIndex}"][data-visibleIndex="${visibleColumnIndex}"]`)));
    }
    /**
     * @param {?} element
     * @param {?} selectedNode
     * @return {?}
     */
    onKeydownArrowRight(element, selectedNode) {
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const isSummary = selectedNode.isSummaryRow;
        if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            return;
        }
        if (this.isColumnRightEdgeVisible(visibleColumnIndex + 1)) { // if next column is fully visible or is pinned
            if (element.classList.contains('igx-grid__td--pinned-last') || element.classList.contains('igx-grid-summary--pinned-last')) {
                if (this.isColumnLeftEdgeVisible(visibleColumnIndex + 1)) {
                    element.nextElementSibling.firstElementChild.focus({ preventScroll: true });
                }
                else {
                    this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                    this.grid.parentVirtDir.onChunkLoad
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                        .subscribe(() => {
                        element.nextElementSibling.firstElementChild.focus({ preventScroll: true });
                    });
                    this.horizontalScroll(rowIndex).scrollTo(0);
                }
            }
            else {
                element.nextElementSibling.focus({ preventScroll: true });
            }
        }
        else {
            this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex + 1, isSummary);
        }
    }
    /**
     * @param {?} element
     * @param {?} selectedNode
     * @return {?}
     */
    onKeydownArrowLeft(element, selectedNode) {
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const isSummary = selectedNode.isSummaryRow;
        if (visibleColumnIndex === 0) {
            return;
        }
        /** @type {?} */
        const index = this.getColumnUnpinnedIndex(visibleColumnIndex - 1);
        if (!element.previousElementSibling && this.grid.pinnedColumns.length && index === -1) {
            element.parentNode.previousElementSibling.focus({ preventScroll: true });
        }
        else if (!this.isColumnLeftEdgeVisible(visibleColumnIndex - 1)) {
            this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex - 1, isSummary);
        }
        else {
            element.previousElementSibling.focus({ preventScroll: true });
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} currentColumnVisibleIndex
     * @return {?}
     */
    movePreviousEditable(rowIndex, currentColumnVisibleIndex) {
        /** @type {?} */
        const prevEditableColumnIndex = this.findNextEditable(MoveDirection.LEFT, currentColumnVisibleIndex - 1);
        if (prevEditableColumnIndex === -1 && this.grid.rowEditTabs.length) {
            //  TODO: make gridAPI visible for internal use and remove cast to any
            ((/** @type {?} */ (this.grid))).gridAPI.submit_value();
            this.grid.rowEditTabs.last.element.nativeElement.focus();
            return;
        }
        this.focusEditableTarget(rowIndex, prevEditableColumnIndex);
    }
    /**
     * @param {?} rowIndex
     * @param {?} currentColumnVisibleIndex
     * @return {?}
     */
    moveNextEditable(rowIndex, currentColumnVisibleIndex) {
        /** @type {?} */
        const nextEditableColumnIndex = this.findNextEditable(MoveDirection.RIGHT, currentColumnVisibleIndex + 1);
        if (nextEditableColumnIndex === -1 && this.grid.rowEditTabs.length) {
            //  TODO: make gridAPI visible for internal use and remove cast to any
            ((/** @type {?} */ (this.grid))).gridAPI.submit_value();
            this.grid.rowEditTabs.first.element.nativeElement.focus();
            return;
        }
        this.focusEditableTarget(rowIndex, nextEditableColumnIndex);
    }
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    focusEditableTarget(rowIndex, columnIndex) {
        if (this.isColumnFullyVisible(columnIndex)) {
            this.getCellElementByVisibleIndex(rowIndex, columnIndex).focus();
        }
        else {
            this.performHorizontalScrollToCell(rowIndex, columnIndex);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    onKeydownHome(rowIndex, isSummary = false) {
        /** @type {?} */
        const rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
        /** @type {?} */
        let rowElement = rowList.find((row) => row.index === rowIndex);
        /** @type {?} */
        const cellSelector = this.getCellSelector(0, isSummary);
        if (!rowElement) {
            return;
        }
        rowElement = rowElement.nativeElement;
        /** @type {?} */
        let firstCell = rowElement.querySelector(cellSelector);
        if (this.grid.pinnedColumns.length || this.displayContainerScrollLeft === 0) {
            firstCell.focus({ preventScroll: true });
        }
        else {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.parentVirtDir.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(() => {
                firstCell = rowElement.querySelector(cellSelector);
                firstCell.focus({ preventScroll: true });
            });
            this.horizontalScroll(rowIndex).scrollTo(0);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    onKeydownEnd(rowIndex, isSummary = false) {
        /** @type {?} */
        const index = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex;
        /** @type {?} */
        const rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
        /** @type {?} */
        let rowElement = rowList.find((row) => row.index === rowIndex);
        if (!rowElement) {
            return;
        }
        rowElement = rowElement.nativeElement;
        if (this.isColumnRightEdgeVisible(index)) {
            /** @type {?} */
            const allCells = rowElement.querySelectorAll(this.getCellSelector(-1, isSummary));
            allCells[allCells.length - 1].focus({ preventScroll: true });
        }
        else {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.parentVirtDir.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(() => {
                /** @type {?} */
                const allCells = rowElement.querySelectorAll(this.getCellSelector(-1, isSummary));
                allCells[allCells.length - 1].focus({ preventScroll: true });
            });
            this.horizontalScroll(rowIndex).scrollTo(this.getColumnUnpinnedIndex(index));
        }
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    navigateTop(visibleColumnIndex) {
        /** @type {?} */
        const verticalScroll = this.grid.verticalScrollContainer.getScroll();
        /** @type {?} */
        const cellSelector = this.getCellSelector(visibleColumnIndex);
        if (verticalScroll.scrollTop === 0) {
            /** @type {?} */
            const cells = this.grid.nativeElement.querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
            ((/** @type {?} */ (cells[0]))).focus();
        }
        else {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(0);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                /** @type {?} */
                const cells = this.grid.nativeElement.querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
                if (cells.length > 0) {
                    ((/** @type {?} */ (cells[0]))).focus();
                }
            });
        }
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    navigateBottom(visibleColumnIndex) {
        /** @type {?} */
        const verticalScroll = this.grid.verticalScrollContainer.getScroll();
        /** @type {?} */
        const cellSelector = this.getCellSelector(visibleColumnIndex);
        if (verticalScroll.scrollHeight === 0 ||
            verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            const cells = this.grid.nativeElement.querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
            ((/** @type {?} */ (cells[cells.length - 1]))).focus();
        }
        else {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(this.grid.dataView.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                /** @type {?} */
                const cells = this.grid.nativeElement.querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
                if (cells.length > 0) {
                    ((/** @type {?} */ (cells[cells.length - 1]))).focus();
                }
            });
        }
    }
    /**
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    navigateUp(rowElement, selectedNode) {
        /** @type {?} */
        const currentRowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        if (currentRowIndex === 0) {
            return;
        }
        /** @type {?} */
        const containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
        if (!rowElement.previousElementSibling ||
            rowElement.previousElementSibling.offsetTop < Math.abs(containerTopOffset)) {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(currentRowIndex - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(() => {
                /** @type {?} */
                const tag = rowElement.tagName.toLowerCase();
                /** @type {?} */
                const rowSelector = this.getRowSelector();
                if (tag === rowSelector || tag === 'igx-grid-summary-row') {
                    rowElement = this.getRowByIndex(currentRowIndex, tag);
                }
                else {
                    rowElement = this.grid.nativeElement.querySelector(`igx-grid-groupby-row[data-rowindex="${currentRowIndex}"]`);
                }
                this.focusPreviousElement(rowElement, visibleColumnIndex);
            });
        }
        else {
            this.focusPreviousElement(rowElement, visibleColumnIndex);
        }
    }
    /**
     * @protected
     * @param {?} currentRowEl
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    focusPreviousElement(currentRowEl, visibleColumnIndex) {
        this.focusElem(currentRowEl.previousElementSibling, visibleColumnIndex);
    }
    /**
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    navigateDown(rowElement, selectedNode) {
        /** @type {?} */
        const currentRowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        if (currentRowIndex === this.grid.dataView.length - 1 ||
            (currentRowIndex === 0 && rowElement.tagName.toLowerCase() === 'igx-grid-summary-row')) {
            // check if this is rootSummary row
            return;
        }
        /** @type {?} */
        const rowHeight = this.grid.verticalScrollContainer.getSizeAt(currentRowIndex + 1);
        /** @type {?} */
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        /** @type {?} */
        const targetEndTopOffset = rowElement.nextElementSibling ?
            rowElement.nextElementSibling.offsetTop + rowHeight + parseInt(this.verticalDisplayContainerElement.style.top, 10) :
            containerHeight + rowHeight;
        this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
        if (containerHeight && containerHeight < targetEndTopOffset) {
            /** @type {?} */
            const nextIndex = currentRowIndex + 1;
            this.grid.verticalScrollContainer.scrollTo(nextIndex);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(() => {
                rowElement = this.getNextRowByIndex(nextIndex);
                this.focusElem(rowElement, visibleColumnIndex);
            });
        }
        else {
            this.focusNextElement(rowElement, visibleColumnIndex);
        }
    }
    /**
     * @protected
     * @param {?} rowElement
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    focusElem(rowElement, visibleColumnIndex) {
        if (rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row') {
            rowElement.focus();
        }
        else {
            /** @type {?} */
            const isSummaryRow = rowElement.tagName.toLowerCase() === 'igx-grid-summary-row';
            if (this.isColumnFullyVisible(visibleColumnIndex)) {
                /** @type {?} */
                const cellSelector = this.getCellSelector(visibleColumnIndex, isSummaryRow);
                /** @type {?} */
                const cell = rowElement.querySelector(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
                cell.focus();
                return cell;
            }
            this.performHorizontalScrollToCell(parseInt(rowElement.getAttribute('data-rowindex'), 10), visibleColumnIndex, isSummaryRow);
        }
    }
    /**
     * @protected
     * @param {?} rowElement
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    focusNextElement(rowElement, visibleColumnIndex) {
        return this.focusElem(rowElement.nextElementSibling, visibleColumnIndex);
    }
    /**
     * @return {?}
     */
    goToFirstCell() {
        /** @type {?} */
        const verticalScroll = this.grid.verticalScrollContainer.getScroll();
        /** @type {?} */
        const horizontalScroll = this.grid.dataRowList.first.virtDirRow.getScroll();
        if (verticalScroll.scrollTop === 0) {
            this.onKeydownHome(this.grid.dataRowList.first.index);
        }
        else {
            if (!horizontalScroll.clientWidth || parseInt(horizontalScroll.scrollLeft, 10) <= 1 || this.grid.pinnedColumns.length) {
                this.navigateTop(0);
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.horizontalScroll(this.grid.dataRowList.first.index).scrollTo(0);
                this.grid.parentVirtDir.onChunkLoad
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                    .subscribe(() => {
                    this.navigateTop(0);
                });
            }
        }
    }
    /**
     * @return {?}
     */
    goToLastCell() {
        /** @type {?} */
        const verticalScroll = this.grid.verticalScrollContainer.getScroll();
        if (verticalScroll.scrollHeight === 0 ||
            verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            const rows = this.getAllRows();
            /** @type {?} */
            const rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
            this.onKeydownEnd(rowIndex);
        }
        else {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(this.grid.dataView.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                /** @type {?} */
                const rows = this.getAllRows();
                if (rows.length > 0) {
                    /** @type {?} */
                    const rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
                    this.onKeydownEnd(rowIndex);
                }
            });
        }
    }
    /**
     * @return {?}
     */
    goToLastBodyElement() {
        /** @type {?} */
        const verticalScroll = this.grid.verticalScrollContainer.getScroll();
        if (verticalScroll.scrollHeight === 0 ||
            verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            const rowIndex = this.grid.dataView.length - 1;
            /** @type {?} */
            const row = (/** @type {?} */ (this.grid.nativeElement.querySelector(`[data-rowindex="${rowIndex}"]`)));
            if (row && row.tagName.toLowerCase() === 'igx-grid-groupby-row') {
                row.focus();
                return;
            }
            /** @type {?} */
            const isSummary = (row && row.tagName.toLowerCase() === 'igx-grid-summary-row') ? true : false;
            this.onKeydownEnd(rowIndex, isSummary);
        }
        else {
            this.grid.verticalScrollContainer.scrollTo(this.grid.dataView.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                /** @type {?} */
                const rowIndex = this.grid.dataView.length - 1;
                /** @type {?} */
                const row = (/** @type {?} */ (this.grid.nativeElement.querySelector(`[data-rowindex="${rowIndex}"]`)));
                if (row && row.tagName.toLowerCase() === 'igx-grid-groupby-row') {
                    row.focus();
                    return;
                }
                /** @type {?} */
                const isSummary = (row && row.tagName.toLowerCase() === 'igx-grid-summary-row') ? true : false;
                this.onKeydownEnd(rowIndex, isSummary);
            });
        }
    }
    /**
     * @param {?} currentRowEl
     * @param {?} selectedNode
     * @return {?}
     */
    performTab(currentRowEl, selectedNode) {
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const isSummaryRow = selectedNode.isSummaryRow;
        if (isSummaryRow && rowIndex === 0 &&
            this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            return;
        }
        if (this.isRowInEditMode(rowIndex)) {
            this.moveNextEditable(rowIndex, visibleColumnIndex);
            return;
        }
        if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            /** @type {?} */
            const rowEl = this.grid.rowList.find(row => row.index === rowIndex + 1) ?
                this.grid.rowList.find(row => row.index === rowIndex + 1) :
                this.grid.summariesRowList.find(row => row.index === rowIndex + 1);
            if (rowIndex === this.grid.dataView.length - 1 && this.grid.rootSummariesEnabled) {
                this.onKeydownHome(0, true);
                return;
            }
            if (rowEl) {
                this.navigateDown(currentRowEl, { row: rowIndex, column: 0 });
            }
        }
        else {
            /** @type {?} */
            const cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummaryRow);
            if (cell) {
                this.onKeydownArrowRight(cell, selectedNode);
            }
        }
    }
    /**
     * @param {?=} toStart
     * @return {?}
     */
    moveFocusToFilterCell(toStart) {
        if (this.grid.filteringService.isFilterRowVisible) {
            this.grid.filteringService.focusFilterRowCloseButton();
            return;
        }
        /** @type {?} */
        const columns = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        const targetIndex = toStart ? 0 : columns.length - 1;
        /** @type {?} */
        const visibleIndex = columns[targetIndex].visibleIndex;
        /** @type {?} */
        const isVisible = toStart ? this.isColumnLeftEdgeVisible(visibleIndex) : this.isColumnRightEdgeVisible(visibleIndex);
        if (isVisible) {
            this.grid.filteringService.focusFilterCellChip(columns[targetIndex], false);
        }
        else {
            this.grid.filteringService.scrollToFilterCell(columns[targetIndex], false);
        }
    }
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    navigatePrevFilterCell(column, eventArgs) {
        /** @type {?} */
        const cols = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        const prevFilterableIndex = cols.indexOf(column) - 1;
        /** @type {?} */
        const visibleIndex = column.visibleIndex;
        if (visibleIndex === 0 || prevFilterableIndex < 0) {
            // prev is not filter cell
            /** @type {?} */
            const firstFiltarableCol = this.getFirstPinnedFilterableColumn();
            if (!firstFiltarableCol || column === firstFiltarableCol) {
                eventArgs.preventDefault();
            }
            return;
        }
        /** @type {?} */
        const prevColumn = cols[prevFilterableIndex];
        /** @type {?} */
        const prevVisibleIndex = prevColumn.visibleIndex;
        if (prevFilterableIndex >= 0 && visibleIndex > 0 && !this.isColumnLeftEdgeVisible(prevVisibleIndex) && !column.pinned) {
            eventArgs.preventDefault();
            this.grid.filteringService.scrollToFilterCell(prevColumn, false);
        }
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    navigateFirstCellIfPossible(eventArgs) {
        if (this.grid.rowList.length > 0) {
            if (this.grid.rowList.filter(row => row instanceof IgxGridGroupByRowComponent).length > 0) {
                eventArgs.stopPropagation();
                return;
            }
            this.goToFirstCell();
        }
        else if (this.grid.rootSummariesEnabled) {
            this.onKeydownHome(0, true);
        }
        eventArgs.preventDefault();
    }
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    navigateNextFilterCell(column, eventArgs) {
        /** @type {?} */
        const cols = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        const nextFilterableIndex = cols.indexOf(column) + 1;
        if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
            // next is not filter cell
            this.navigateFirstCellIfPossible(eventArgs);
            return;
        }
        /** @type {?} */
        const nextColumn = cols[nextFilterableIndex];
        /** @type {?} */
        const nextVisibleIndex = nextColumn.visibleIndex;
        if (!column.pinned && !this.isColumnRightEdgeVisible(nextVisibleIndex)) {
            eventArgs.preventDefault();
            this.grid.filteringService.scrollToFilterCell(nextColumn, true);
        }
        else if (column === this.getLastPinnedFilterableColumn() && !this.isColumnRightEdgeVisible(nextVisibleIndex)) {
            this.grid.filteringService.scrollToFilterCell(nextColumn, false);
            eventArgs.stopPropagation();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getLastPinnedFilterableColumn() {
        /** @type {?} */
        const pinnedFilterableColums = this.grid.pinnedColumns.filter(col => !(col.columnGroup) && col.filterable);
        return pinnedFilterableColums[pinnedFilterableColums.length - 1];
    }
    /**
     * @private
     * @return {?}
     */
    getFirstPinnedFilterableColumn() {
        return this.grid.pinnedColumns.filter(col => !(col.columnGroup) && col.filterable)[0];
    }
    /**
     * @param {?} currentRowEl
     * @param {?} selectedNode
     * @return {?}
     */
    performShiftTabKey(currentRowEl, selectedNode) {
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const isSummary = selectedNode.isSummaryRow;
        if (isSummary && rowIndex === 0 && visibleColumnIndex === 0 && this.grid.rowList.length) {
            this.goToLastBodyElement();
            return;
        }
        if (this.isRowInEditMode(rowIndex)) {
            this.movePreviousEditable(rowIndex, visibleColumnIndex);
            return;
        }
        if (visibleColumnIndex === 0) {
            if (rowIndex === 0 && this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                this.moveFocusToFilterCell();
            }
            else {
                this.navigateUp(currentRowEl, {
                    row: rowIndex,
                    column: this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex
                });
            }
        }
        else {
            /** @type {?} */
            const cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);
            if (cell) {
                this.onKeydownArrowLeft(cell, selectedNode);
            }
        }
    }
    /**
     * @param {?} targetRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    shouldPerformVerticalScroll(targetRowIndex, visibleColumnIndex) {
        /** @type {?} */
        const containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
        /** @type {?} */
        const targetRow = this.grid.summariesRowList.filter(s => s.index !== 0)
            .concat(this.grid.rowList.toArray()).find(r => r.index === targetRowIndex);
        /** @type {?} */
        const rowHeight = this.grid.verticalScrollContainer.getSizeAt(targetRowIndex);
        /** @type {?} */
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        /** @type {?} */
        const targetEndTopOffset = targetRow ? targetRow.nativeElement.offsetTop + rowHeight + containerTopOffset :
            containerHeight + rowHeight;
        if (!targetRow || targetRow.nativeElement.offsetTop < Math.abs(containerTopOffset)
            || containerHeight && containerHeight < targetEndTopOffset) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    performVerticalScrollToCell(rowIndex, visibleColIndex, cb) {
        this.grid.verticalScrollContainer.scrollTo(rowIndex);
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
            cb();
        });
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @param {?=} cb
     * @return {?}
     */
    performHorizontalScrollToCell(rowIndex, visibleColumnIndex, isSummary = false, cb) {
        /** @type {?} */
        const unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex);
        this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
        this.grid.parentVirtDir.onChunkLoad
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
            .subscribe(() => {
            if (cb) {
                cb();
            }
            else {
                /** @type {?} */
                const cellElement = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);
                if (cellElement) {
                    cellElement.focus({ preventScroll: true });
                }
            }
        });
        this.horizontalScroll(rowIndex).scrollTo(unpinnedIndex);
    }
    /**
     * @protected
     * @return {?}
     */
    getFocusableGrid() {
        return this.grid;
    }
    /**
     * @protected
     * @param {?} index
     * @param {?=} selector
     * @return {?}
     */
    getRowByIndex(index, selector = this.getRowSelector()) {
        return this.grid.nativeElement.querySelector(`${selector}[data-rowindex="${index}"]`);
    }
    /**
     * @protected
     * @param {?} nextIndex
     * @return {?}
     */
    getNextRowByIndex(nextIndex) {
        return this.grid.tbody.nativeElement.querySelector(`[data-rowindex="${nextIndex}"]`);
    }
    /**
     * @private
     * @return {?}
     */
    getAllRows() {
        /** @type {?} */
        const selector = this.getRowSelector();
        return this.grid.nativeElement.querySelectorAll(selector);
    }
    /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    getCellSelector(visibleIndex, isSummary = false) {
        return isSummary ? 'igx-grid-summary-cell' : 'igx-grid-cell';
    }
    /**
     * @protected
     * @return {?}
     */
    getRowSelector() {
        return 'igx-grid-row';
    }
}
IgxGridNavigationService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable */
var icons = [
    {
        name: 'add_filter',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19 15v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3zM5 10h10v2H5zM2 5h16v2H2zM8 15h4v2H8z"/>
      </svg>`
    },
    {
        name: 'contains',
        value: `<svg xmlns="http://www.w3.org/2000/svg" id="Layer_1" data-name="Layer 1" viewBox="0 0 24 24">
        <path d="M3 3v18h18V3zm16 16H5V5h14z"/>
        <path d="M12 11.3a4.39 4.39 0 0 0-2.54.63 2.07 2.07 0 0 0-.9 1.78 2.29 2.29 0 0 0 .66 1.74 2.63 2.63 0 0 0 1.89.63 2.39 2.39 0 0 0 1.32-.37 3.05 3.05 0 0 0 1-.93 3.72 3.72 0 0 0 .08.57c0 .19.1.38.16.58h1.79a4.51 4.51 0 0 1-.21-.88 5.57 5.57 0 0 1-.07-.93v-3.5a2.44 2.44 0 0 0-.84-2 3.34 3.34 0 0 0-2.22-.7 3.54 3.54 0 0 0-2.3.72A1.93 1.93 0 0 0 9 10.29h1.71a.93.93 0 0 1 .29-.71 1.5 1.5 0 0 1 1-.29 1.45 1.45 0 0 1 1 .35 1.3 1.3 0 0 1 .37 1v.69zm1.4 1.08v1.17a1.61 1.61 0 0 1-.71.77 2.27 2.27 0 0 1-1.21.34 1.18 1.18 0 0 1-.84-.27.92.92 0 0 1-.3-.72 1.16 1.16 0 0 1 .44-.9 1.76 1.76 0 0 1 1.22-.39z"/>
      </svg>`
    },
    {
        name: 'does_not_contain',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21,19.74V3H4.26L2.89,1.63,1.63,2.92,3,4.29V21H19.73l1.37,1.37,1.27-1.26ZM5,19V6.28l5.28,5.27a3.19,3.19,0,0,0-.81.38,2.07,2.07,0,0,0-.9,1.78,2.29,2.29,0,0,0,.66,1.74,2.63,2.63,0,0,0,1.89.63,2.39,2.39,0,0,0,1.32-.37,3.05,3.05,0,0,0,1-.93,3.72,3.72,0,0,0,.08.57c0,.19.1.38.16.58h1L17.73,19Zm5.79-6.23a1.31,1.31,0,0,1,.45-.25l1.37,1.36.28.29a1.57,1.57,0,0,1-.19.15,2.27,2.27,0,0,1-1.21.34,1.18,1.18,0,0,1-.84-.27.92.92,0,0,1-.3-.72A1.16,1.16,0,0,1,10.79,12.77Zm2.6-1.47h-.83L10.94,9.68l.08-.1a1.5,1.5,0,0,1,1-.29,1.45,1.45,0,0,1,1,.35,1.3,1.3,0,0,1,.37,1ZM19,17.74l-3.85-3.85V10.62a2.44,2.44,0,0,0-.84-2,3.34,3.34,0,0,0-2.22-.7,3.64,3.64,0,0,0-2.24.67L6.26,5H19Z"/>
    </svg>`
    },
    {
        name: 'all',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M2 14h8v2H2zM2 6h12v2H2zM16 17l-3-3-1.5 1.5L16 20l7-7-1.5-1.5L16 17zM2 10h12v2H2z"/>
      </svg>
      `
    },
    {
        name: 'empty',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5 17h2v2H5zM13 17h2v2h-2zM5 13h2v2H5zM17 17h2v2h-2zM13 5h2v2h-2zM9 17h2v2H9zM17 9h2v2h-2zM17 13h2v2h-2zM17 5h2v2h-2zM5 9h2v2H5zM5 5h2v2H5zM9 5h2v2H9z"/>
      </svg>`
    },
    {
        name: 'end_expression',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M13.14 6.76L17.49 12l-4.35 5.24 1.54 1.28L20.09 12l-5.41-6.52-1.54 1.28z"/>
        <path d="M11.91 11h2v2h-2zM7.91 11h2v2h-2zM3.91 11h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'ends_with',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 14.5h2v2H3zM11 14.5h2v2h-2zM7 14.5h2v2H7zM20.8 14.8v-3A2.1 2.1 0 0 0 20 10a3 3 0 0 0-2-.6 3 3 0 0 0-2 .6 1.7 1.7 0 0 0-.7 1.5h1.5a.8.8 0 0 1 .3-.7 1.3 1.3 0 0 1 .9-.3 1.3 1.3 0 0 1 .9.4 1.1 1.1 0 0 1 .3.8v.6H18a3.8 3.8 0 0 0-2.2.6 1.8 1.8 0 0 0-.8 1.5 2 2 0 0 0 .6 1.6 2.3 2.3 0 0 0 1.6.6 2.1 2.1 0 0 0 1.2-.4 2.8 2.8 0 0 0 .8-.8 4.3 4.3 0 0 0 .1.5l.1.5H21a4.1 4.1 0 0 1-.2-.7 5.4 5.4 0 0 1 0-1zm-1.6-.5a1.5 1.5 0 0 1-.6.7 2 2 0 0 1-1 .2 1.1 1.1 0 0 1-.8-.2.8.8 0 0 1-.2-.6 1 1 0 0 1 .3-.8 1.5 1.5 0 0 1 1.1-.3h1.2z"/>
      </svg>`
    },
    {
        name: 'equals',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5 13.5h14v2H5zM5 8.5h14v2H5z"/>
      </svg>`
    },
    {
        name: 'greater_than_or_equal',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5.99 19h12.02v2H5.99zM18 9.47L6 3v2.11L15.09 10 6 14.9v2.11l12-6.47V9.47z"/>
      </svg>`
    },
    {
        name: 'greater_than',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M6 7.11L15.09 12 6 16.89V19l12-6.46v-1.08L6 5v2.11z"/>
      </svg>
      `
    },
    {
        name: 'is_after',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15 7h4v10h-4v2h6V5h-6v2zM11 3h2v18h-2zM7 5h2v2H7zM3 5h2v2H3zM3 17h2v2H3zM3 13h2v2H3zM3 9h2v2H3zM7 17h2v2H7z"/>
      </svg>`
    },
    {
        name: 'is_before',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 19h6v-2H5V7h4V5H3v14zM11 3h2v18h-2zM15 5h2v2h-2zM19 5h2v2h-2zM19 13h2v2h-2zM15 17h2v2h-2zM19 17h2v2h-2zM19 9h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'is_false',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm4.31 9.79l-1.52 1.52L8 13.52l-2.79 2.79-1.52-1.52L6.48 12 3.69 9.21l1.52-1.52L8 10.48l2.79-2.79 1.52 1.52L9.52 12zM18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7z"/>
        <path d="M17.52 13.85l2.91-2.92-.78-.78-2.13 2.12-1.17-1.15-.38.37-.41.41.42.42L17 13.34l.52.51z"/>
      </svg>`
    },
    {
        name: 'is_not_null',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M16.58 6.07l.79-1.36-1.74-1-.78 1.35a7.5 7.5 0 0 0-7.43 12.87l-.79 1.36 1.74 1 .78-1.35a7.5 7.5 0 0 0 7.43-12.87zM6.5 12A5.5 5.5 0 0 1 12 6.5a5.65 5.65 0 0 1 1.84.32l-5.41 9.36A5.49 5.49 0 0 1 6.5 12zm5.5 5.5a5.65 5.65 0 0 1-1.84-.32l5.41-9.36A5.5 5.5 0 0 1 12 17.5z"/>
      </svg>`
    },
    {
        name: 'is_null',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 4.5a7.5 7.5 0 1 0 7.5 7.5A7.5 7.5 0 0 0 12 4.5zm0 13a5.5 5.5 0 1 1 5.5-5.5 5.5 5.5 0 0 1-5.5 5.5z"/>
      </svg>`
    },
    {
        name: 'is_true',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19.44 14.22zM16.56 14.22zM16.56 14.22L18 12.79l1.44 1.43.78-.78L18.79 12l1.43-1.44-.78-.78L18 11.21l-1.44-1.43-.78.78L17.21 12l-1.43 1.44.78.78z"/>
        <path d="M18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7zM8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm-.93 10.18l-3.38-3.37 1.13-1.12 2.25 2.25 4.11-4.12 1.13 1.12z"/>
      </svg>`
    },
    {
        name: 'last_month',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M17.5 14a4.48 4.48 0 1 0 4.5 4.5 4.47 4.47 0 0 0-4.5-4.5zm3.5 5.5h-4v2l-3-3 3-3v2h4zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z"/>
        <path d="M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z"/>
      </svg>`
    },
    {
        name: 'last_year',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 10v11H7v2h14a2 2 0 0 0 2-2V10z"/>
        <path d="M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z"/>
        <path d="M8.87 9l-2.99 3 2.99 3v-2.25h5.26v-1.5H8.87V9z"/>
      </svg>`
    },
    {
        name: 'less_than_or_equal',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5.99 19h12.02v2H5.99zM18 14.9L8.91 10 18 5.11V3L6 9.47v1.07l12 6.47V14.9z"/>
      </svg>`
    },
    {
        name: 'less_than',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M6 12.54L18 19v-2.11L8.91 12 18 7.11V5L6 11.46v1.08z"/>
      </svg>`
    },
    {
        name: 'next_month',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M20 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2 6.74v-2h-4v-2h4v-2l3 3zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z"/>
        <path d="M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z"/>
      </svg>`
    },
    {
        name: 'next_year',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z"/>
        <path d="M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z"/>
        <path d="M11.13 11.25H5.88v1.5h5.25V15l3-3-3-3v2.25z"/>
      </svg>`
    },
    {
        name: 'not_empty',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5 9h2v2H5zM9 17h2v2H9zM13 17h2v2h-2zM17 9h2v2h-2zM17 5h2v2h-2zM5 17h2v2H5zM13 5h2v2h-2zM5 13h2v2H5zM19 15v-2h-2v.47L18.53 15H19zM11 7V5H9v.46L10.54 7H11zM2.76 1.76L1.5 3.06 20.97 22.5l1.26-1.26-8.89-8.89L2.76 1.76z"/>
      </svg>`
    },
    {
        name: 'not_equal',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M17.37 4.71l-1.74-1-2.76 4.79H5v2h6.71l-1.73 3H5v2h3.82l-2.19 3.79 1.74 1 2.76-4.79H19v-2h-6.71l1.73-3H19v-2h-3.82l2.19-3.79z"/>
      </svg>`
    },
    {
        name: 'start_expression',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M18.1 11h2v2h-2zM10.1 11h2v2h-2z"/>
        <path d="M10.9 6.8L9.3 5.5 4 12l5.4 6.5 1.6-1.3L6.5 12 11 6.8zM14.1 11h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'starts_with',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path fill="none" d="M4.97 13.23h3.06L6.5 9.12l-1.53 4.11z"/>
        <path d="M5.89 7.5L2 16.5h1.72l.73-1.8h4.1l.73 1.8H11l-3.89-9zM5 13.23l1.5-4.11L8 13.23zM12 14.5h2v2h-2zM20 14.5h2v2h-2zM16 14.5h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'this_month',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M6 9h2v2H6zM6 13h2v2H6zM11 13h2v2h-2zM6 17h2v2H6zM11 17h2v2h-2zM11 9h2v2h-2zM16 9h2v2h-2zM21 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2.94 5.41l-1.75-1.76.69-.71 1.05 1L20 16.83l.71.71z"/>
        <path d="M5 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1H6v2H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H5z"/>
      </svg>`
    },
    {
        name: 'this_year',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z"/>
        <path d="M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z"/>
        <path d="M8.85 13.15l-1.77-1.77-.88.89 2.65 2.65 4.95-4.96-.88-.88-4.07 4.07z"/>
      </svg>`
    },
    {
        name: 'today',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z"/>
        <path d="M16.53 12.06L15.47 11l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 18l5.94-5.94z"/>
      </svg>`
    },
    {
        name: 'ungroup',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15 15h5v5h-5zM6 13h5v5H6zM13 6h5v5h-5zM6 6h5v5H6z"/>
        <path d="M20 2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9v-2H4V4h16v9h2V4a2 2 0 0 0-2-2z"/>
      </svg>`
    },
    {
        name: 'yesterday',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M10.68 15.38h6.13v-1.75h-6.13V11l-3.49 3.5 3.49 3.5v-2.62z"/>
        <path d="M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z"/>
      </svg>`
    },
    {
        name: 'pin',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15.18 2.25l7.07 7.07-2.83-.01-3.54 3.55.01 4.24-3.53-3.54-5.66 5.66H5.28V17.8l5.66-5.66L7.4 8.61l4.24.01 3.55-3.54-.01-2.83z"/>
      </svg>`
    },
    {
        name: 'unpin',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path fill="none" d="M0 0h24v25H0V0z"/>
        <path d="M11.84 14.08L6.7 19.22H5.28V17.8l5.14-5.14L2 4.26 3.29 3l18 18L20 22.21zm4-.49l-5-5h.73l3.55-3.54v-2.8l7.07 7.07h-2.77l-3.54 3.54z" />
      </svg>`
    },
    {
        name: 'ungroup',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M18,4.5H6A1.5,1.5,0,0,0,4.5,6V18A1.5,1.5,0,0,0,6,19.5h6.75V18H6V6H18v6.75h1.5V6A1.5,1.5,0,0,0,18,4.5Z"/>
          <rect x="7.5" y="12.75" width="3.75" height="3.75"/>
          <rect x="14.25" y="14.25" width="3.75" height="3.75"/>
          <rect x="7.5" y="7.5" width="3.75" height="3.75"/>
          <rect x="12.75" y="7.5" width="3.75" height="3.75"/>
        </svg>`
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FILTERING_ICONS_FONT_SET = 'filtering-icons';
/**
 * @hidden
 */
class ExpressionUI {
    constructor() {
        this.isSelected = false;
        this.isVisible = true;
    }
}
/**
 * @hidden
 */
class IgxFilteringService {
    /**
     * @param {?} gridAPI
     * @param {?} iconService
     */
    constructor(gridAPI, iconService) {
        this.gridAPI = gridAPI;
        this.iconService = iconService;
        this.columnsWithComplexFilter = new Set();
        this.areEventsSubscribed = false;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.isFiltering = false;
        this.columnToExpressionsMap = new Map();
        this.columnStartIndex = -1;
        this._filterIconsRegistered = false;
        this.isFilterRowVisible = false;
        this.filteredColumn = null;
        this.selectedExpression = null;
        this.columnToFocus = null;
        this.shouldFocusNext = false;
        this.columnToMoreIconHidden = new Map();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @return {?}
     */
    get displayContainerWidth() {
        return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10);
    }
    /**
     * @return {?}
     */
    get displayContainerScrollLeft() {
        return this.grid.headerContainer.scrollPosition;
    }
    /**
     * @return {?}
     */
    get areAllColumnsInView() {
        return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10) === 0;
    }
    /**
     * @return {?}
     */
    get unpinnedFilterableColumns() {
        return this.grid.unpinnedColumns.filter(col => !col.columnGroup && col.filterable);
    }
    /**
     * @return {?}
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns.filter(col => !col.columnGroup);
    }
    /**
     * @return {?}
     */
    get datePipe() {
        if (!this._datePipe) {
            this._datePipe = new IgxDatePipeComponent(this.grid.locale);
        }
        return this._datePipe;
    }
    /**
     * Subscribe to grid's events.
     * @return {?}
     */
    subscribeToEvents() {
        if (!this.areEventsSubscribed) {
            this.areEventsSubscribed = true;
            this.grid.onColumnResized.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((eventArgs) => {
                this.updateFilteringCell(eventArgs.column);
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((eventArgs) => {
                if (eventArgs.startIndex !== this.columnStartIndex) {
                    this.columnStartIndex = eventArgs.startIndex;
                    this.grid.filterCellList.forEach((filterCell) => {
                        filterCell.updateFilterCellArea();
                    });
                }
                if (this.columnToFocus) {
                    this.focusFilterCellChip(this.columnToFocus, false);
                    this.columnToFocus = null;
                }
            });
            this.grid.onColumnMovingEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => {
                this.grid.filterCellList.forEach((filterCell) => {
                    filterCell.updateFilterCellArea();
                });
            });
            this.grid.onColumnVisibilityChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((eventArgs) => {
                if (this.grid.filteringRow && this.grid.filteringRow.column === eventArgs.column) {
                    this.grid.filteringRow.close();
                }
            });
        }
    }
    /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     * @param {?} field
     * @param {?=} expressions
     * @return {?}
     */
    filterInternal(field, expressions = null) {
        this.isFiltering = true;
        /** @type {?} */
        let expressionsTree;
        if (expressions instanceof FilteringExpressionsTree) {
            expressionsTree = expressions;
        }
        else {
            expressionsTree = this.createSimpleFilteringTree(field, expressions);
        }
        if (expressionsTree.filteringOperands.length === 0) {
            this.clearFilter(field);
        }
        else {
            this.filter(field, null, expressionsTree);
        }
        this.isFiltering = false;
    }
    /**
     * Execute filtering on the grid.
     * @param {?} field
     * @param {?} value
     * @param {?=} conditionOrExpressionTree
     * @param {?=} ignoreCase
     * @return {?}
     */
    filter(field, value, conditionOrExpressionTree, ignoreCase) {
        /** @type {?} */
        const col = this.gridAPI.get_column_by_name(field);
        /** @type {?} */
        const filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
        if (conditionOrExpressionTree) {
            this.gridAPI.filter(field, value, conditionOrExpressionTree, filteringIgnoreCase);
        }
        else {
            /** @type {?} */
            const expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
            if (!expressionsTreeForColumn) {
                throw new Error('Invalid condition or Expression Tree!');
            }
            else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                this.gridAPI.filter(field, value, expressionsTreeForColumn, filteringIgnoreCase);
            }
            else {
                /** @type {?} */
                const expressionForColumn = (/** @type {?} */ (expressionsTreeForColumn));
                this.gridAPI.filter(field, value, expressionForColumn.condition, filteringIgnoreCase);
            }
        }
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(col.filteringExpressionsTree));
    }
    /**
     * Clear the filter of a given column.
     * @param {?} field
     * @return {?}
     */
    clearFilter(field) {
        if (field) {
            /** @type {?} */
            const column = this.gridAPI.get_column_by_name(field);
            if (!column) {
                return;
            }
        }
        this.isFiltering = true;
        this.gridAPI.clear_filter(field);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(null));
        if (field) {
            /** @type {?} */
            const expressions = this.getExpressions(field);
            expressions.length = 0;
        }
        this.isFiltering = false;
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * @param {?} value
     * @param {?} condition
     * @param {?=} ignoreCase
     * @return {?}
     */
    filterGlobal(value, condition, ignoreCase) {
        this.gridAPI.filter_global(value, condition, ignoreCase);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(this.grid.filteringExpressionsTree));
    }
    /**
     * Register filtering SVG icons in the icon service.
     * @return {?}
     */
    registerSVGIcons() {
        if (!this._filterIconsRegistered) {
            for (const icon of icons) {
                if (!this.iconService.isSvgIconCached(icon.name, FILTERING_ICONS_FONT_SET)) {
                    this.iconService.addSvgIconFromText(icon.name, icon.value, FILTERING_ICONS_FONT_SET);
                }
            }
            this._filterIconsRegistered = true;
        }
    }
    /**
     * Returns the ExpressionUI array for a given column.
     * @param {?} columnId
     * @return {?}
     */
    getExpressions(columnId) {
        if (!this.columnToExpressionsMap.has(columnId)) {
            /** @type {?} */
            const column = this.grid.columns.find((col) => col.field === columnId);
            /** @type {?} */
            const expressionUIs = new Array();
            if (column) {
                this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
                this.columnToExpressionsMap.set(columnId, expressionUIs);
            }
            return expressionUIs;
        }
        return this.columnToExpressionsMap.get(columnId);
    }
    /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     * @return {?}
     */
    refreshExpressions() {
        if (!this.isFiltering) {
            this.columnsWithComplexFilter.clear();
            this.columnToExpressionsMap.forEach((value, key) => {
                /** @type {?} */
                const column = this.grid.columns.find((col) => col.field === key);
                if (column) {
                    value.length = 0;
                    this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, value);
                    /** @type {?} */
                    const isComplex = this.isFilteringTreeComplex(column.filteringExpressionsTree);
                    if (isComplex) {
                        this.columnsWithComplexFilter.add(key);
                    }
                    this.updateFilteringCell(column);
                }
                else {
                    this.columnToExpressionsMap.delete(key);
                }
            });
        }
    }
    /**
     * Remove an ExpressionUI for a given column.
     * @param {?} columnId
     * @param {?} indexToRemove
     * @return {?}
     */
    removeExpression(columnId, indexToRemove) {
        /** @type {?} */
        const expressionsList = this.getExpressions(columnId);
        if (indexToRemove === 0 && expressionsList.length > 1) {
            expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === expressionsList.length - 1) {
            expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
            expressionsList[0].beforeOperator = null;
            expressionsList[expressionsList.length - 1].afterOperator = null;
        }
        expressionsList.splice(indexToRemove, 1);
    }
    /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     * @param {?} columnId
     * @param {?=} expressionUIList
     * @return {?}
     */
    createSimpleFilteringTree(columnId, expressionUIList = null) {
        /** @type {?} */
        const expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
        /** @type {?} */
        const expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);
        /** @type {?} */
        let currAndBranch;
        /** @type {?} */
        let currExpressionUI;
        for (let i = 0; i < expressionsList.length; i++) {
            currExpressionUI = expressionsList[i];
            if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {
                    currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                    expressionsTree.filteringOperands.push(currAndBranch);
                }
                continue;
            }
            if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                currExpressionUI.beforeOperator === FilteringLogic.Or) &&
                currExpressionUI.afterOperator === FilteringLogic.And) {
                currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                expressionsTree.filteringOperands.push(currAndBranch);
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else if (currExpressionUI.beforeOperator === FilteringLogic.And) {
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else {
                expressionsTree.filteringOperands.push(currExpressionUI.expression);
                currAndBranch = null;
            }
        }
        return expressionsTree;
    }
    /**
     * Returns whether a complex filter is applied to a given column.
     * @param {?} columnId
     * @return {?}
     */
    isFilterComplex(columnId) {
        if (this.columnsWithComplexFilter.has(columnId)) {
            return true;
        }
        /** @type {?} */
        const column = this.grid.columns.find((col) => col.field === columnId);
        /** @type {?} */
        const isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);
        if (isComplex) {
            this.columnsWithComplexFilter.add(columnId);
        }
        return isComplex;
    }
    /**
     * Returns the string representation of the FilteringLogic operator.
     * @param {?} operator
     * @return {?}
     */
    getOperatorAsString(operator) {
        if (operator === 0) {
            return this.grid.resourceStrings.igx_grid_filter_operator_and;
        }
        else {
            return this.grid.resourceStrings.igx_grid_filter_operator_or;
        }
    }
    /**
     * Generate the label of a chip from a given filtering expression.
     * @param {?} expression
     * @return {?}
     */
    getChipLabel(expression) {
        if (expression.condition.isUnary) {
            return this.grid.resourceStrings[`igx_grid_filter_${expression.condition.name}`] || expression.condition.name;
        }
        else if (expression.searchVal instanceof Date) {
            return this.datePipe.transform(expression.searchVal, this.grid.locale);
        }
        else {
            return expression.searchVal;
        }
    }
    /**
     * Updates the content of a filterCell.
     * @param {?} column
     * @return {?}
     */
    updateFilteringCell(column) {
        /** @type {?} */
        const filterCell = column.filterCell;
        if (filterCell) {
            filterCell.updateFilterCellArea();
        }
    }
    /**
     * Focus a chip in a filterCell.
     * @param {?} column
     * @param {?} focusFirst
     * @return {?}
     */
    focusFilterCellChip(column, focusFirst) {
        /** @type {?} */
        const filterCell = column.filterCell;
        if (filterCell) {
            filterCell.focusChip(focusFirst);
        }
    }
    /**
     * Focus the close button in the filtering row.
     * @return {?}
     */
    focusFilterRowCloseButton() {
        this.grid.filteringRow.closeButton.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    get filteredData() {
        return this.grid.filteredData;
    }
    /**
     * Scrolls to a filterCell.
     * @param {?} column
     * @param {?} shouldFocusNext
     * @return {?}
     */
    scrollToFilterCell(column, shouldFocusNext) {
        this.grid.nativeElement.focus({ preventScroll: true });
        this.columnToFocus = column;
        this.shouldFocusNext = shouldFocusNext;
        /** @type {?} */
        let currentColumnRight = 0;
        /** @type {?} */
        let currentColumnLeft = 0;
        for (let index = 0; index < this.unpinnedColumns.length; index++) {
            currentColumnRight += parseInt(this.unpinnedColumns[index].width, 10);
            if (this.unpinnedColumns[index] === column) {
                currentColumnLeft = currentColumnRight - parseInt(this.unpinnedColumns[index].width, 10);
                break;
            }
        }
        /** @type {?} */
        const forOfDir = this.grid.headerContainer;
        /** @type {?} */
        const width = this.displayContainerWidth + this.displayContainerScrollLeft;
        if (shouldFocusNext) {
            forOfDir.scrollPosition += currentColumnRight - width;
        }
        else {
            forOfDir.scrollPosition = currentColumnLeft;
        }
    }
    /**
     * @private
     * @param {?} expressions
     * @return {?}
     */
    isFilteringTreeComplex(expressions) {
        if (!expressions) {
            return false;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            /** @type {?} */
            const expressionsTree = (/** @type {?} */ (expressions));
            if (expressionsTree.operator === FilteringLogic.Or) {
                /** @type {?} */
                const andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                return andOperatorsCount > 1;
            }
            /** @type {?} */
            let isComplex = false;
            for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                isComplex = isComplex || this.isFilteringTreeComplex(expressionsTree.filteringOperands[i]);
            }
            return isComplex;
        }
        return false;
    }
    /**
     * @private
     * @param {?} expressions
     * @return {?}
     */
    getChildAndOperatorsCount(expressions) {
        /** @type {?} */
        let count = 0;
        /** @type {?} */
        let operand;
        for (let i = 0; i < expressions.filteringOperands.length; i++) {
            operand = expressions[i];
            if (operand instanceof FilteringExpressionsTree) {
                if (operand.operator === FilteringLogic.And) {
                    count++;
                }
                count = count + this.getChildAndOperatorsCount(operand);
            }
        }
        return count;
    }
    /**
     * @param {?} expressions
     * @param {?} operator
     * @param {?} expressionsUIs
     * @return {?}
     */
    generateExpressionsList(expressions, operator, expressionsUIs) {
        this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
        // The beforeOperator of the first expression and the afterOperator of the last expression should be null
        if (expressionsUIs.length) {
            expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
        }
    }
    /**
     * @private
     * @param {?} expressions
     * @param {?} operator
     * @param {?} expressionsUIs
     * @return {?}
     */
    generateExpressionsListRecursive(expressions, operator, expressionsUIs) {
        if (!expressions) {
            return;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            /** @type {?} */
            const expressionsTree = (/** @type {?} */ (expressions));
            for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                this.generateExpressionsListRecursive(expressionsTree.filteringOperands[i], expressionsTree.operator, expressionsUIs);
            }
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
            }
        }
        else {
            /** @type {?} */
            const exprUI = new ExpressionUI();
            exprUI.expression = (/** @type {?} */ (expressions));
            exprUI.afterOperator = operator;
            /** @type {?} */
            const prevExprUI = expressionsUIs[expressionsUIs.length - 1];
            if (prevExprUI) {
                exprUI.beforeOperator = prevExprUI.afterOperator;
            }
            expressionsUIs.push(exprUI);
        }
    }
    /**
     * @return {?}
     */
    isFilteringExpressionsTreeEmpty() {
        /** @type {?} */
        const expressionTree = this.grid.filteringExpressionsTree;
        if (FilteringExpressionsTree.empty(expressionTree)) {
            return true;
        }
        /** @type {?} */
        let expr;
        for (let i = 0; i < expressionTree.filteringOperands.length; i++) {
            expr = expressionTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                /** @type {?} */
                const exprTree = (/** @type {?} */ (expr));
                if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
}
IgxFilteringService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
/** @nocollapse */
IgxFilteringService.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxIconService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxExcelStyleLoadingValuesTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStyleLoadingValuesTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxExcelStyleLoading]'
            },] }
];
/** @nocollapse */
IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxExcelStyleSearchComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
    }
    /**
     * @return {?}
     */
    get isLoading() {
        return this._isLoading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isLoading(value) {
        this._isLoading = value;
        if (!((/** @type {?} */ (this.cdr))).destroyed) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get valuesLoadingTemplate() {
        if (this.grid.excelStyleLoadingValuesTemplateDirective) {
            return this.grid.excelStyleLoadingValuesTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleLoadingValuesTemplate;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.refreshSize();
    }
    /**
     * @return {?}
     */
    refreshSize() {
        requestAnimationFrame(() => {
            this.virtDir.recalcUpdateSizes();
        });
    }
    /**
     * @return {?}
     */
    clearInput() {
        this.searchValue = null;
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onCheckboxChange(eventArgs) {
        /** @type {?} */
        const selectedIndex = this.data.indexOf(eventArgs.checkbox.value);
        if (selectedIndex === 0) {
            this.data.forEach(element => {
                element.isSelected = eventArgs.checked;
                this.data[0].indeterminate = false;
            });
        }
        else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;
            if (!this.data.slice(1, this.data.length).find(el => el.isSelected === false)) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = true;
            }
            else if (!this.data.slice(1, this.data.length).find(el => el.isSelected === true)) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = false;
            }
            else {
                this.data[0].indeterminate = true;
            }
        }
        eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
    }
    /**
     * @return {?}
     */
    get itemSize() {
        /** @type {?} */
        let itemSize = '40px';
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                itemSize = '32px';
                break;
            case DisplayDensity.compact:
                itemSize = '24px';
                break;
            default: break;
        }
        return itemSize;
    }
}
IgxExcelStyleSearchComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-search',
                template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"displayDensity\"\n            [supressInputAutofocus]=\"true\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"column.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list [displayDensity]=\"displayDensity\" [style.height.px]=\"250\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n            *igxFor=\"let item of data | excelStyleSearchFilter: searchValue; scrollOrientation : 'vertical'; containerSize: '250px'; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ column.formatter && !item.isSpecial ? column.formatter(item.label) : column.dataType === 'number' ? (item.label | igxdecimal:\n                    column.grid.locale) : column.dataType === 'date' ? (item.label | igxdate: column.grid.locale) : item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>        \n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
IgxExcelStyleSearchComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxExcelStyleSearchComponent.propDecorators = {
    grid: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    searchInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['input', { read: IgxInputDirective, static: true },] }],
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    virtDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxForOfDirective, { static: true },] }],
    defaultExcelStyleLoadingValuesTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExcelStyleLoadingValuesTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExcelStyleDefaultExpressionComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new CloseScrollStrategy()
        };
        this.onExpressionRemoved = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onLogicOperatorChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @protected
     * @return {?}
     */
    get inputValuesElement() {
        return this.inputValuesDirective;
    }
    /**
     * @return {?}
     */
    get isLast() {
        return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
    }
    /**
     * @return {?}
     */
    get isSingle() {
        return this.expressionsList.length === 1;
    }
    /**
     * @return {?}
     */
    get inputConditionsPlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
    }
    /**
     * @return {?}
     */
    get inputValuePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
    }
    /**
     * @return {?}
     */
    get type() {
        switch (this.column.dataType) {
            case DataType.Number:
                return 'number';
            default:
                return 'text';
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._dropDownOverlaySettings.outlet = this.column.grid.outletDirective;
        this._dropDownOverlaySettings.positionStrategy.settings.target = this.inputGroupConditions.element.nativeElement;
    }
    /**
     * @return {?}
     */
    focus() {
        // use requestAnimationFrame to focus the values input because when initializing the component
        // datepicker's input group is not yet fully initialized
        requestAnimationFrame(() => this.inputValuesElement.focus());
    }
    /**
     * @param {?} conditionName
     * @return {?}
     */
    isConditionSelected(conditionName) {
        return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
    }
    /**
     * @param {?} condition
     * @return {?}
     */
    getConditionName(condition) {
        return condition ? this.translateCondition(condition.name) : null;
    }
    /**
     * @return {?}
     */
    getInputWidth() {
        return this.inputGroupConditions.element.nativeElement.offsetWidth + 'px';
    }
    /**
     * @return {?}
     */
    get conditions() {
        return this.column.filters.conditionList();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    translateCondition(value) {
        return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * @return {?}
     */
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else if (!this.expressionUI.expression.condition) {
            return 'filter_list';
        }
        else {
            return this.expressionUI.expression.condition.iconName;
        }
    }
    /**
     * @return {?}
     */
    toggleCustomDialogDropDown() {
        this.dropdownConditions.toggle(this._dropDownOverlaySettings);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onConditionsChanged(eventArgs) {
        /** @type {?} */
        const value = ((/** @type {?} */ (eventArgs.newSelection))).value;
        this.expressionUI.expression.condition = this.getCondition(value);
        this.focus();
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onValuesInput(eventArgs) {
        this.expressionUI.expression.searchVal = this.transformValue(eventArgs.target.value);
    }
    /**
     * @param {?} eventArgs
     * @param {?} buttonIndex
     * @return {?}
     */
    onLogicOperatorButtonClicked(eventArgs, buttonIndex) {
        if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
            eventArgs.stopPropagation();
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
        }
        else {
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: (/** @type {?} */ (buttonIndex))
            });
        }
    }
    /**
     * @param {?} eventArgs
     * @param {?} buttonIndex
     * @return {?}
     */
    onLogicOperatorKeyDown(eventArgs, buttonIndex) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: (/** @type {?} */ (buttonIndex))
            });
        }
    }
    /**
     * @return {?}
     */
    onRemoveButtonClick() {
        this.onExpressionRemoved.emit(this.expressionUI);
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onInputConditionsKeyDown(eventArgs) {
        if (eventArgs.altKey && (eventArgs.key === "ArrowDown" /* DOWN_ARROW */ || eventArgs.key === "Down" /* DOWN_ARROW_IE */)) {
            this.toggleCustomDialogDropDown();
        }
        if (eventArgs.key === "Tab" /* TAB */ && eventArgs.shiftKey && this.expressionsList[0] === this.expressionUI) {
            eventArgs.preventDefault();
        }
        event.stopPropagation();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    transformValue(value) {
        if (this.column.dataType === DataType.Number) {
            value = parseFloat(value);
        }
        else if (this.column.dataType === DataType.Boolean) {
            value = Boolean(value);
        }
        return value;
    }
}
IgxExcelStyleDefaultExpressionComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-default-expression',
                template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        tabindex=\"0\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
            }] }
];
/** @nocollapse */
IgxExcelStyleDefaultExpressionComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxExcelStyleDefaultExpressionComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expressionUI: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expressionsList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    grid: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onExpressionRemoved: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onLogicOperatorChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    inputGroupConditions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputGroupConditions', { read: IgxInputGroupComponent, static: true },] }],
    inputValuesDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputValues', { read: IgxInputDirective, static: true },] }],
    dropdownConditions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dropdownConditions', { read: IgxDropDownComponent, static: true },] }],
    logicOperatorButtonGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent, static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExcelStyleDateExpressionComponent extends IgxExcelStyleDefaultExpressionComponent {
    /**
     * @protected
     * @return {?}
     */
    get inputValuesElement() {
        return this.datePicker.getEditElement();
    }
    /**
     * @return {?}
     */
    get inputDatePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
    }
}
IgxExcelStyleDateExpressionComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-date-expression',
                template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        tabindex=\"0\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outletDirective\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"value | igxdate: grid.locale\"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
            }] }
];
IgxExcelStyleDateExpressionComponent.propDecorators = {
    datePicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['datePicker', { read: IgxDatePickerComponent, static: true },] }],
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExcelStyleCustomDialogComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.expressionsList = new Array();
        this._customDialogPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._customDialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._customDialogPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._customDialogOverlaySettings.outlet = this.grid.outlet;
    }
    /**
     * @return {?}
     */
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.dateExpressionTemplate;
        }
        return this.defaultExpressionTemplate;
    }
    /**
     * @return {?}
     */
    get grid() {
        return this.filteringService.grid;
    }
    /**
     * @return {?}
     */
    onCustomDialogOpening() {
        if (this.selectedOperator) {
            this.createInitialExpressionUIElement();
        }
    }
    /**
     * @return {?}
     */
    onCustomDialogOpened() {
        if (this.expressionComponents.first) {
            this.expressionComponents.first.focus();
        }
    }
    /**
     * @return {?}
     */
    open() {
        this._customDialogOverlaySettings.positionStrategy.settings.target =
            this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement;
        this.toggle.open(this._customDialogOverlaySettings);
    }
    /**
     * @return {?}
     */
    onClearButtonClick() {
        this.filteringService.clearFilter(this.column.field);
        this.createInitialExpressionUIElement();
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    closeDialog() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
        }
    }
    /**
     * @return {?}
     */
    onApplyButtonClick() {
        this.expressionsList = this.expressionsList.filter(element => element.expression.condition &&
            (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary));
        if (this.expressionsList.length > 0) {
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.filteringService.filterInternal(this.column.field, this.expressionsList);
        this.closeDialog();
    }
    /**
     * @return {?}
     */
    onAddButtonClick() {
        /** @type {?} */
        const exprUI = new ExpressionUI();
        exprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;
        exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
        this.expressionsList.push(exprUI);
        this.markChildrenForCheck();
        this.scrollToBottom();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExpressionRemoved(event) {
        /** @type {?} */
        const indexToRemove = this.expressionsList.indexOf(event);
        if (indexToRemove === 0 && this.expressionsList.length > 1) {
            this.expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === this.expressionsList.length - 1) {
            this.expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.expressionsList.splice(indexToRemove, 1);
        this.cdr.detectChanges();
        this.markChildrenForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLogicOperatorChanged(event) {
        /** @type {?} */
        const index = this.expressionsList.indexOf(event.target);
        event.target.afterOperator = event.newValue;
        if (index + 1 < this.expressionsList.length) {
            this.expressionsList[index + 1].beforeOperator = event.newValue;
        }
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onApplyButtonKeyDown(eventArgs) {
        if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
            eventArgs.stopPropagation();
            eventArgs.preventDefault();
        }
    }
    /**
     * @private
     * @param {?} conditionName
     * @return {?}
     */
    createCondition(conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
    /**
     * @private
     * @return {?}
     */
    markChildrenForCheck() {
        this.expressionComponents.forEach(x => x.cdr.markForCheck());
        this.expressionDateComponents.forEach(x => x.cdr.markForCheck());
    }
    /**
     * @private
     * @return {?}
     */
    createInitialExpressionUIElement() {
        this.expressionsList = [];
        /** @type {?} */
        const firstExprUI = new ExpressionUI();
        firstExprUI.expression = {
            condition: this.createCondition(this.selectedOperator),
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        firstExprUI.afterOperator = FilteringLogic.And;
        this.expressionsList.push(firstExprUI);
        /** @type {?} */
        const secondExprUI = new ExpressionUI();
        secondExprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        secondExprUI.beforeOperator = FilteringLogic.And;
        this.expressionsList.push(secondExprUI);
    }
    /**
     * @private
     * @return {?}
     */
    scrollToBottom() {
        requestAnimationFrame(() => {
            this.expressionsContainer.nativeElement.scrollTop = this.expressionsContainer.nativeElement.scrollHeight;
        });
    }
}
IgxExcelStyleCustomDialogComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-custom-dialog',
                template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
            }] }
];
/** @nocollapse */
IgxExcelStyleCustomDialogComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxExcelStyleCustomDialogComponent.propDecorators = {
    expressionsList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectedOperator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filteringService: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    overlayComponentId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    overlayService: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expressionComponents: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxExcelStyleDefaultExpressionComponent,] }],
    expressionDateComponents: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxExcelStyleDateExpressionComponent,] }],
    toggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['toggle', { read: IgxToggleDirective, static: true },] }],
    defaultExpressionTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExpressionTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    dateExpressionTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dateExpressionTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    expressionsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['expressionsContainer', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExcelStyleSortingComponent {
    constructor() { }
    /**
     * @param {?} sortDirection
     * @return {?}
     */
    onSortButtonClicked(sortDirection) {
        if (this.sortButtonGroup.selectedIndexes.length === 0) {
            if (this.grid.isColumnGrouped(this.column.field)) {
                this.selectButton(sortDirection);
            }
            else {
                this.grid.clearSort(this.column.field);
            }
        }
        else {
            this.grid.sort({ fieldName: this.column.field, dir: sortDirection, ignoreCase: true });
        }
    }
    /**
     * @param {?} sortDirection
     * @return {?}
     */
    selectButton(sortDirection) {
        if (sortDirection === 1) {
            this.sortButtonGroup.selectButton(0);
        }
        else {
            this.sortButtonGroup.selectButton(1);
        }
    }
}
IgxExcelStyleSortingComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-sorting',
                template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <span tabindex=\"0\" igxButton type=\"button\" [displayDensity]=\"displayDensity\" [attr.data-togglable]=\"true\" (click)=\"onSortButtonClicked(1)\">\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </span>\n\n    <span tabindex=\"0\" igxButton type=\"button\" [displayDensity]=\"displayDensity\" [attr.data-togglable]=\"true\" (click)=\"onSortButtonClicked(2)\">\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n         }}\n        </span>\n    </span>\n</igx-buttongroup>\n"
            }] }
];
/** @nocollapse */
IgxExcelStyleSortingComponent.ctorParameters = () => [];
IgxExcelStyleSortingComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    grid: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    sortButtonGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['sortButtonGroup', { read: IgxButtonGroupComponent, static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class FilterListItem {
    constructor() {
        this.isSpecial = false;
    }
}
class IgxExcelStyleSortingTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStyleSortingTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxExcelStyleSorting]'
            },] }
];
/** @nocollapse */
IgxExcelStyleSortingTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxExcelStyleMovingTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStyleMovingTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxExcelStyleMoving]'
            },] }
];
/** @nocollapse */
IgxExcelStyleMovingTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxExcelStyleHidingTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStyleHidingTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxExcelStyleHiding]'
            },] }
];
/** @nocollapse */
IgxExcelStyleHidingTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxExcelStylePinningTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStylePinningTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxExcelStylePinning]'
            },] }
];
/** @nocollapse */
IgxExcelStylePinningTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxGridExcelStyleFilteringComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.shouldOpenSubMenu = true;
        this.expressionsList = new Array();
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.containsNullOrEmpty = false;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.filterValues = new Set();
        this.columnMoving = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"]();
        this.listData = new Array();
        this.uniqueValues = [];
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Top
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this.className = 'igx-excel-filter';
    }
    /**
     * @return {?}
     */
    get grid() {
        return this.filteringService.grid;
    }
    /**
     * @return {?}
     */
    get conditions() {
        return this.column.filters.conditionList();
    }
    /**
     * @return {?}
     */
    get subMenuText() {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return this.grid.resourceStrings.igx_grid_excel_boolean_filter;
            case DataType.Number:
                return this.grid.resourceStrings.igx_grid_excel_number_filter;
            case DataType.Date:
                return this.grid.resourceStrings.igx_grid_excel_date_filter;
            default:
                return this.grid.resourceStrings.igx_grid_excel_text_filter;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isColumnPinnable = this.column.pinnable;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.expressionsList = new Array();
        this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
        if (this.expressionsList && this.expressionsList.length &&
            this.expressionsList[0].expression.condition.name !== 'in') {
            this.customDialog.expressionsList = this.expressionsList;
        }
        this.populateColumnData();
        if (this.excelStyleSorting) {
            /** @type {?} */
            const se = this.grid.sortingExpressions.find(expr => expr.fieldName === this.column.field);
            if (se) {
                this.excelStyleSorting.selectButton(se.dir);
            }
        }
        requestAnimationFrame(() => {
            this.excelStyleSearch.searchInput.nativeElement.focus();
        });
    }
    /**
     * @return {?}
     */
    clearFilterClass() {
        if (this.column.filteringExpressionsTree) {
            return 'igx-excel-filter__actions-clear';
        }
        return 'igx-excel-filter__actions-clear--disabled';
    }
    /**
     * @return {?}
     */
    pinClass() {
        return this.isColumnPinnable ? 'igx-excel-filter__actions-pin' : 'igx-excel-filter__actions-pin--disabled';
    }
    /**
     * @param {?} column
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} overlayComponentId
     * @return {?}
     */
    initialize(column, filteringService, overlayService, overlayComponentId) {
        this.column = column;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.overlayComponentId = overlayComponentId;
        this._subMenuOverlaySettings.outlet = this.grid.outlet;
        this.columnMoving = this.grid.onColumnMoving.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => {
            this.closeDropdown();
        });
    }
    /**
     * Returns the filtering operation condition for a given value.
     * @param {?} value
     * @return {?}
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * Returns the translated condition name for a given value.
     * @param {?} value
     * @return {?}
     */
    translateCondition(value) {
        return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * @return {?}
     */
    onPin() {
        this.column.pinned = !this.column.pinned;
        this.closeDropdown();
    }
    /**
     * @return {?}
     */
    onHide() {
        this.column.hidden = true;
        this.grid.onColumnVisibilityChanged.emit({ column: this.column, newValue: true });
        this.closeDropdown();
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onTextFilterClick(eventArgs) {
        if (this.shouldOpenSubMenu) {
            this._subMenuOverlaySettings.positionStrategy.settings.target = eventArgs.currentTarget;
            /** @type {?} */
            const gridRect = this.grid.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const dropdownRect = this.mainDropdown.nativeElement.getBoundingClientRect();
            /** @type {?} */
            let x = dropdownRect.left + dropdownRect.width;
            /** @type {?} */
            let x1 = gridRect.left + gridRect.width;
            x += window.pageXOffset;
            x1 += window.pageXOffset;
            if (Math.abs(x - x1) < 200) {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;
            }
            else {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;
            }
            this.subMenu.open(this._subMenuOverlaySettings);
            this.shouldOpenSubMenu = false;
        }
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onTextFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.onTextFilterClick(eventArgs);
        }
    }
    /**
     * @return {?}
     */
    onSubMenuClosed() {
        requestAnimationFrame(() => {
            this.shouldOpenSubMenu = true;
        });
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onSubMenuSelection(eventArgs) {
        this.customDialog.selectedOperator = eventArgs.newSelection.value;
        eventArgs.cancel = true;
        this.mainDropdown.nativeElement.style.display = 'none';
        this.subMenu.close();
        this.customDialog.open();
    }
    /**
     * @private
     * @return {?}
     */
    areExpressionsSelectable() {
        if (this.expressionsList.length === 1 &&
            (this.expressionsList[0].expression.condition.name === 'equals' ||
                this.expressionsList[0].expression.condition.name === 'true' ||
                this.expressionsList[0].expression.condition.name === 'false' ||
                this.expressionsList[0].expression.condition.name === 'empty' ||
                this.expressionsList[0].expression.condition.name === 'in')) {
            return true;
        }
        /** @type {?} */
        const selectableExpressionsCount = this.expressionsList.filter(exp => (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
            (exp.expression.condition.name === 'equals' ||
                exp.expression.condition.name === 'true' ||
                exp.expression.condition.name === 'false' ||
                exp.expression.condition.name === 'empty' ||
                exp.expression.condition.name === 'in')).length;
        return selectableExpressionsCount === this.expressionsList.length;
    }
    /**
     * @private
     * @return {?}
     */
    areExpressionsValuesInTheList() {
        if (this.column.dataType === DataType.Boolean) {
            return true;
        }
        if (this.filterValues.size === 1) {
            /** @type {?} */
            const firstValue = this.filterValues.values().next().value;
            if (!firstValue && firstValue !== 0) {
                return true;
            }
        }
        for (let index = 0; index < this.uniqueValues.length; index++) {
            if (this.filterValues.has(this.uniqueValues[index])) {
                return true;
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    populateColumnData() {
        if (this.grid.uniqueColumnValuesStrategy) {
            this.renderColumnValuesRemotely();
        }
        else {
            this.renderColumnValuesFromData();
        }
    }
    /**
     * @private
     * @return {?}
     */
    renderColumnValuesRemotely() {
        this.excelStyleSearch.isLoading = true;
        /** @type {?} */
        const expressionsTree = this.getColumnFilterExpressionsTree();
        this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, (colVals) => {
            /** @type {?} */
            const columnValues = (this.column.dataType === DataType.Date) ?
                colVals.map(val => val ? val.toDateString() : val) : colVals;
            this.renderValues(columnValues);
            this.excelStyleSearch.isLoading = false;
            this.excelStyleSearch.refreshSize();
        });
    }
    /**
     * @return {?}
     */
    renderColumnValuesFromData() {
        /** @type {?} */
        let data = this.column.gridAPI.get_all_data(this.grid.id);
        /** @type {?} */
        const expressionsTree = this.getColumnFilterExpressionsTree();
        if (expressionsTree.filteringOperands.length) {
            /** @type {?} */
            const state = { expressionsTree: expressionsTree };
            data = DataUtil.filter(cloneArray(data), state);
        }
        /** @type {?} */
        const columnField = this.column.field;
        /** @type {?} */
        const columnValues = (this.column.dataType === DataType.Date) ?
            data.map(record => record[columnField] ? record[columnField].toDateString() : record[columnField]) :
            data.map(record => record[columnField]);
        this.renderValues(columnValues);
    }
    /**
     * @private
     * @param {?} columnValues
     * @return {?}
     */
    renderValues(columnValues) {
        this.generateUniqueValues(columnValues);
        this.generateFilterValues(this.column.dataType === DataType.Date);
        this.generateListData();
    }
    /**
     * @private
     * @param {?} columnValues
     * @return {?}
     */
    generateUniqueValues(columnValues) {
        this.uniqueValues = Array.from(new Set(columnValues));
    }
    /**
     * @private
     * @param {?=} isDateColumn
     * @return {?}
     */
    generateFilterValues(isDateColumn = false) {
        if (isDateColumn) {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(((/** @type {?} */ (e.expression.searchVal))).values()).map(v => new Date(v).toDateString())];
                }
                return [...arr, ...[e.expression.searchVal ? e.expression.searchVal.toDateString() : e.expression.searchVal]];
            }, []));
        }
        else {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(((/** @type {?} */ (e.expression.searchVal))).values())];
                }
                return [...arr, ...[e.expression.searchVal]];
            }, []));
        }
    }
    /**
     * @private
     * @return {?}
     */
    generateListData() {
        this.listData = new Array();
        /** @type {?} */
        const shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
        if (this.column.dataType === DataType.Boolean) {
            this.addBooleanItems();
        }
        else {
            this.addItems(shouldUpdateSelection);
        }
        this.listData.sort((a, b) => this.sortData(a, b));
        if (this.column.dataType === DataType.Date) {
            this.uniqueValues = this.uniqueValues.map(value => new Date(value));
        }
        if (this.containsNullOrEmpty) {
            this.addBlanksItem(shouldUpdateSelection);
        }
        this.addSelectAllItem();
        if (!((/** @type {?} */ (this.cdr))).destroyed) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getColumnFilterExpressionsTree() {
        /** @type {?} */
        const gridExpressionsTree = this.grid.filteringExpressionsTree;
        /** @type {?} */
        const expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
        for (const operand of gridExpressionsTree.filteringOperands) {
            if (operand instanceof FilteringExpressionsTree) {
                /** @type {?} */
                const columnExprTree = (/** @type {?} */ (operand));
                if (columnExprTree.fieldName === this.column.field) {
                    break;
                }
            }
            expressionsTree.filteringOperands.push(operand);
        }
        return expressionsTree;
    }
    /**
     * @private
     * @return {?}
     */
    addBooleanItems() {
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(element => {
            /** @type {?} */
            const filterListItem = new FilterListItem();
            if (element !== undefined && element !== null && element !== '') {
                if (this.column.filteringExpressionsTree) {
                    if (element === true && this.expressionsList.find(exp => exp.expression.condition.name === 'true')) {
                        filterListItem.isSelected = true;
                        this.selectAllIndeterminate = true;
                    }
                    else if (element === false && this.expressionsList.find(exp => exp.expression.condition.name === 'false')) {
                        filterListItem.isSelected = true;
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                }
                filterListItem.value = element;
                filterListItem.label = element;
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
            else {
                this.containsNullOrEmpty = true;
            }
        });
    }
    /**
     * @private
     * @param {?} shouldUpdateSelection
     * @return {?}
     */
    addItems(shouldUpdateSelection) {
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(element => {
            if (element !== undefined && element !== null && element !== '') {
                /** @type {?} */
                const filterListItem = new FilterListItem();
                if (this.column.filteringExpressionsTree) {
                    if (shouldUpdateSelection) {
                        if (this.filterValues.has(element)) {
                            filterListItem.isSelected = true;
                        }
                        else {
                            filterListItem.isSelected = false;
                        }
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                        this.selectAllSelected = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                }
                if (this.column.dataType === DataType.Date) {
                    filterListItem.value = new Date(element);
                    filterListItem.label = new Date(element);
                }
                else {
                    filterListItem.value = element;
                    filterListItem.label = element;
                }
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
            else {
                this.containsNullOrEmpty = true;
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    addSelectAllItem() {
        /** @type {?} */
        const selectAll = new FilterListItem();
        selectAll.isSelected = this.selectAllSelected;
        selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.indeterminate = this.selectAllIndeterminate;
        selectAll.isSpecial = true;
        this.listData.unshift(selectAll);
    }
    /**
     * @private
     * @param {?} shouldUpdateSelection
     * @return {?}
     */
    addBlanksItem(shouldUpdateSelection) {
        /** @type {?} */
        const blanks = new FilterListItem();
        if (this.column.filteringExpressionsTree) {
            if (shouldUpdateSelection) {
                if (this.filterValues.has(null)) {
                    blanks.isSelected = true;
                }
                else {
                    blanks.isSelected = false;
                }
            }
        }
        else {
            blanks.isSelected = true;
        }
        blanks.value = null;
        blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
        blanks.indeterminate = false;
        blanks.isSpecial = true;
        this.listData.unshift(blanks);
    }
    /**
     * @private
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    sortData(a, b) {
        /** @type {?} */
        let valueA = a.value;
        /** @type {?} */
        let valueB = b.value;
        if (typeof (a) === DataType.String) {
            valueA = a.value.toUpperCase();
            valueB = b.value.toUpperCase();
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     * @return {?}
     */
    selectAllFilterItems() {
        this.listData.forEach(filterListItem => {
            filterListItem.isSelected = true;
            filterListItem.indeterminate = false;
        });
        this.excelStyleSearch.cdr.detectChanges();
    }
    // TODO: sort members by access modifier
    /**
     * @return {?}
     */
    get sortingTemplate() {
        if (this.grid.excelStyleSortingTemplateDirective) {
            return this.grid.excelStyleSortingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleSortingTemplate;
        }
    }
    /**
     * @return {?}
     */
    get movingTemplate() {
        if (this.grid.excelStyleMovingTemplateDirective) {
            return this.grid.excelStyleMovingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleMovingTemplate;
        }
    }
    /**
     * @return {?}
     */
    get pinningTemplate() {
        if (this.grid.excelStylePinningTemplateDirective) {
            return this.grid.excelStylePinningTemplateDirective.template;
        }
        else {
            return this.defaultExcelStylePinningTemplate;
        }
    }
    /**
     * @return {?}
     */
    get hidingTemplate() {
        if (this.grid.excelStyleHidingTemplateDirective) {
            return this.grid.excelStyleHidingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleHidingTemplate;
        }
    }
    /**
     * @return {?}
     */
    get applyButtonDisabled() {
        return (this.excelStyleSearch.filteredData && this.excelStyleSearch.filteredData.length === 0) ||
            (this.listData[0] && !this.listData[0].isSelected && !this.listData[0].indeterminate);
    }
    /**
     * @return {?}
     */
    applyFilter() {
        /** @type {?} */
        const filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.column.field);
        /** @type {?} */
        const selectedItems = this.listData.slice(1, this.listData.length).filter(el => el.isSelected === true);
        /** @type {?} */
        const unselectedItem = this.listData.slice(1, this.listData.length).find(el => el.isSelected === false);
        if (unselectedItem) {
            if (selectedItems.length <= IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold) {
                selectedItems.forEach(element => {
                    /** @type {?} */
                    let condition = null;
                    if (element.value !== null && element.value !== undefined) {
                        if (this.column.dataType === DataType.Boolean) {
                            condition = this.createCondition(element.value.toString());
                        }
                        else {
                            condition = this.createCondition('equals');
                        }
                    }
                    else {
                        condition = this.createCondition('empty');
                    }
                    filterTree.filteringOperands.push({
                        condition: condition,
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: element.value
                    });
                });
            }
            else {
                /** @type {?} */
                const blanksItemIndex = selectedItems.findIndex(e => e.value === null || e.value === undefined);
                /** @type {?} */
                let blanksItem;
                if (blanksItemIndex >= 0) {
                    blanksItem = selectedItems[blanksItemIndex];
                    selectedItems.splice(blanksItemIndex, 1);
                }
                filterTree.filteringOperands.push({
                    condition: this.createCondition('in'),
                    fieldName: this.column.field,
                    ignoreCase: this.column.filteringIgnoreCase,
                    searchVal: new Set(this.column.dataType === DataType.Date ?
                        selectedItems.map(d => new Date(d.value.getFullYear(), d.value.getMonth(), d.value.getDate()).toISOString()) :
                        selectedItems.map(e => e.value))
                });
                if (blanksItem) {
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('empty'),
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: blanksItem.value
                    });
                }
            }
            this.expressionsList = new Array();
            this.filteringService.filterInternal(this.column.field, filterTree);
        }
        else {
            this.filteringService.clearFilter(this.column.field);
        }
        this.closeDropdown();
    }
    /**
     * @return {?}
     */
    closeDropdown() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
            this.overlayComponentId = null;
        }
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onKeyDown(eventArgs) {
        if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */) {
            this.closeDropdown();
        }
        eventArgs.stopPropagation();
    }
    /**
     * @return {?}
     */
    clearFilter() {
        this.filteringService.clearFilter(this.column.field);
        this.selectAllFilterItems();
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onClearFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.clearFilter();
        }
    }
    /**
     * @return {?}
     */
    showCustomFilterItem() {
        /** @type {?} */
        const exprTree = this.column.filteringExpressionsTree;
        return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
            !(((/** @type {?} */ (exprTree.filteringOperands[0]))).condition &&
                ((/** @type {?} */ (exprTree.filteringOperands[0]))).condition.name === 'in');
    }
    /**
     * @private
     * @param {?} conditionName
     * @return {?}
     */
    createCondition(conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
}
IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold = 2;
IgxGridExcelStyleFilteringComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-excel-style-filtering',
                template: "<article #dropdown\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': grid.displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\">\n\n    <header class=\"igx-excel-filter__menu-header\">\n        <h4>{{ column.header || column.field }}</h4>\n        <div *ngIf=\"grid.displayDensity!=='comfortable'\" class=\"igx-excel-filter__menu-header-actions\">\n            <button *ngIf=\"!column.disablePinning && !column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                [disabled]=\"!isColumnPinnable\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disablePinning && column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disableHiding\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                tabindex=\"0\"\n                (click)=\"onHide()\">\n                <igx-icon>visibility_off</igx-icon>\n            </button>\n        </div>\n    </header>\n\n    <ng-template #defaultExcelStyleSortingTemplate>\n        <igx-excel-style-sorting #excelStyleSorting\n            class=\"igx-excel-filter__sort\"\n            [column]=\"column\"\n            [grid]=\"grid\"\n            [displayDensity]=\"grid.displayDensity\">\n        </igx-excel-style-sorting>\n    </ng-template>\n\n    <div *ngIf=\"column.sortable\">\n        <ng-container *ngTemplateOutlet=\"sortingTemplate\"></ng-container>\n    </div>\n\n    <section class=\"igx-excel-filter__actions\">\n\n        <ng-template #defaultExcelStyleMovingTemplate>\n            <igx-excel-style-column-moving\n                class=\"igx-excel-filter__move\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [isColumnPinnable]=\"isColumnPinnable\"\n                [displayDensity]=\"grid.displayDensity\">\n            </igx-excel-style-column-moving>\n        </ng-template>\n\n        <div *ngIf=\"column.movable\">\n            <ng-container *ngTemplateOutlet=\"movingTemplate\"></ng-container>\n        </div>\n\n        <ng-template #defaultExcelStylePinningTemplate>\n            <div [ngClass]=\"pinClass()\"\n                (click)=\"onPin()\"\n                tabindex=\"0\"\n                *ngIf=\"!column.pinned\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_pin }}</span>\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </div>\n\n            <div class=\"igx-excel-filter__actions-unpin\"\n                (click)=\"onPin()\"\n                tabindex=\"0\"\n                *ngIf=\"column.pinned\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_unpin }}</span>\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </div>\n        </ng-template>\n\n        <div *ngIf=\"!column.disablePinning && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"pinningTemplate\"></ng-container>\n        </div>\n\n        <ng-template #defaultExcelStyleHidingTemplate>\n            <div class=\"igx-excel-filter__actions-hide\"\n                tabindex=\"0\"\n                (click)=\"onHide()\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_hide }}</span>\n                <igx-icon>visibility_off</igx-icon>\n            </div>\n        </ng-template>\n\n        <div *ngIf=\"!column.disableHiding && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"hidingTemplate\"></ng-container>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            [ngClass]=\"clearFilterClass()\"\n            (keydown)=\"onClearFilterKeyDown($event)\"\n            (click)=\"clearFilter()\">\n            <span>{{ grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n            <igx-icon>clear</igx-icon>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            class=\"igx-excel-filter__actions-filter\"\n            (keydown)=\"onTextFilterKeyDown($event)\"\n            (click)=\"onTextFilterClick($event)\"\n            [igxDropDownItemNavigation]=\"subMenu\" >\n            <span>{{ subMenuText }}</span>\n            <igx-icon>keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <igx-excel-style-search\n        class=\"igx-excel-filter__menu-main\"\n        #excelStyleSearch\n        [column]=\"column\"\n        [data]=\"listData\"\n        [grid]=\"grid\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-search>\n\n    <footer class=\"igx-excel-filter__menu-footer\">\n        <button igxButton [displayDensity]=\"grid.displayDensity\" (click)=\"closeDropdown()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n        <button igxButton=\"raised\" [displayDensity]=\"grid.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ grid.resourceStrings.igx_grid_excel_apply }}</button>\n    </footer>\n</article>\n\n<igx-drop-down [maxHeight]=\"'397px'\" [displayDensity]=\"grid.displayDensity\" #subMenu (onSelection)=\"onSubMenuSelection($event)\" (onClosed)=\"onSubMenuClosed()\">\n    <div>\n        <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n        </igx-drop-down-item>\n        <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n            <igx-icon>filter_list</igx-icon>\n            <span style=\"margin-left: 16px\">{{ grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n        </igx-drop-down-item>\n    </div>\n</igx-drop-down>\n\n<igx-excel-style-custom-dialog\n    #customDialog\n    [column]=\"column\"\n    [filteringService]=\"filteringService\"\n    [overlayComponentId]=\"overlayComponentId\"\n    [overlayService]=\"overlayService\"\n    [displayDensity]=\"grid.displayDensity\">\n</igx-excel-style-custom-dialog>\n"
            }] }
];
/** @nocollapse */
IgxGridExcelStyleFilteringComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxGridExcelStyleFilteringComponent.propDecorators = {
    className: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-excel-filter',] }],
    mainDropdown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dropdown', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: true },] }],
    subMenu: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['subMenu', { read: IgxDropDownComponent, static: true },] }],
    customDialog: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent, static: true },] }],
    excelStyleSearch: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['excelStyleSearch', { read: IgxExcelStyleSearchComponent, static: true },] }],
    excelStyleSorting: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['excelStyleSorting', { read: IgxExcelStyleSortingComponent, static: false },] }],
    defaultExcelStyleSortingTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExcelStyleSortingTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultExcelStyleHidingTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExcelStyleHidingTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultExcelStyleMovingTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExcelStyleMovingTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultExcelStylePinningTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExcelStylePinningTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridHeaderComponent {
    /**
     * @param {?} gridAPI
     * @param {?} colResizingService
     * @param {?} cdr
     * @param {?} elementRef
     * @param {?} zone
     * @param {?} _filteringService
     * @param {?} _moduleRef
     * @param {?} _overlayService
     */
    constructor(gridAPI, colResizingService, cdr, elementRef, zone, _filteringService, _moduleRef, _overlayService) {
        this.gridAPI = gridAPI;
        this.colResizingService = colResizingService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.zone = zone;
        this._filteringService = _filteringService;
        this._moduleRef = _moduleRef;
        this._overlayService = _overlayService;
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.hostRole = 'columnheader';
        this.tabindex = -1;
        this.sortDirection = SortingDirection.None;
    }
    /**
     * @return {?}
     */
    get styleClasses() {
        /** @type {?} */
        const defaultClasses = [
            'igx-grid__th--fw',
            this.column.headerClasses
        ];
        /** @type {?} */
        const classList = {
            'igx-grid__th': !this.column.columnGroup,
            'asc': this.ascending,
            'desc': this.descending,
            'igx-grid__th--number': this.column.dataType === DataType.Number,
            'igx-grid__th--sortable': this.column.sortable,
            'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
            'igx-grid__th--sorted': this.sorted
        };
        for (const klass of Object.keys(classList)) {
            if (classList[klass]) {
                defaultClasses.push(klass);
            }
        }
        return defaultClasses.join(' ');
    }
    /**
     * @return {?}
     */
    get height() {
        if (this.grid.hasColumnGroups) {
            return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
        }
        return null;
    }
    /**
     * @return {?}
     */
    get ascending() {
        return this.sortDirection === SortingDirection.Asc;
    }
    /**
     * @return {?}
     */
    get descending() {
        return this.sortDirection === SortingDirection.Desc;
    }
    /**
     * @return {?}
     */
    get sortingIcon() {
        if (this.sortDirection !== SortingDirection.None) {
            // arrow_downward and arrow_upward
            // are material icons ligature strings
            return this.sortDirection === SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
        }
        return 'arrow_upward';
    }
    /**
     * @return {?}
     */
    get sorted() {
        return this.sortDirection !== SortingDirection.None;
    }
    /**
     * @return {?}
     */
    get filterIconClassName() {
        return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
    }
    /**
     * @return {?}
     */
    get headerID() {
        return `${this.gridID}_${this.column.field}`;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initFilteringSettings();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.getSortDirection();
        this.cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
        if (this._componentOverlayId) {
            this._overlayService.hide(this._componentOverlayId);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (!this.colResizingService.isColumnResizing) {
            event.stopPropagation();
            if (this.grid.filteringService.isFilterRowVisible) {
                if (this.column.filterable && !this.column.columnGroup &&
                    !this.grid.filteringService.isFilterComplex(this.column.field)) {
                    this.grid.filteringService.filteredColumn = this.column;
                }
            }
            else if (this.column.sortable) {
                this.triggerSort();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFilteringIconClick(event) {
        event.stopPropagation();
        this.toggleFilterDropdown();
    }
    /**
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * @protected
     * @return {?}
     */
    getSortDirection() {
        /** @type {?} */
        const expr = this.gridAPI.grid.sortingExpressions.find((x) => x.fieldName === this.column.field);
        this.sortDirection = expr ? expr.dir : SortingDirection.None;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSortingIconClick(event) {
        if (this.grid.filteringService.isFilterRowVisible) {
            event.stopPropagation();
            this.triggerSort();
        }
    }
    /**
     * @private
     * @return {?}
     */
    triggerSort() {
        /** @type {?} */
        const groupingExpr = this.grid.groupingExpressions ?
            this.grid.groupingExpressions.find((expr) => expr.fieldName === this.column.field) : null;
        /** @type {?} */
        const sortDir = groupingExpr ?
            this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc
            : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;
        this.sortDirection = sortDir;
        this.grid.sort({ fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
            strategy: this.column.sortStrategy });
    }
    /**
     * @private
     * @return {?}
     */
    toggleFilterDropdown() {
        if (!this._componentOverlayId) {
            /** @type {?} */
            const headerTarget = this.elementRef.nativeElement;
            /** @type {?} */
            const filterIconTarget = headerTarget.querySelector('.' + this.filterIconClassName);
            this._filterMenuOverlaySettings.positionStrategy.settings.target = filterIconTarget;
            this._filterMenuOverlaySettings.outlet = this.grid.outlet;
            this._componentOverlayId =
                this._overlayService.attach(IgxGridExcelStyleFilteringComponent, this._filterMenuOverlaySettings, this._moduleRef);
            this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initFilteringSettings() {
        this._filterMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn, {
                params: {
                    duration: '250ms'
                }
            }),
            closeAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeOut, {
                params: {
                    duration: '200ms'
                }
            })
        };
        this._filterMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._filterMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this._overlayService.onOpening.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])((overlay) => overlay.id === this._componentOverlayId), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((eventArgs) => {
            this.onOverlayOpening(eventArgs);
        });
        this._overlayService.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(overlay => overlay.id === this._componentOverlayId), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => {
            this.onOverlayClosed();
        });
    }
    /**
     * @private
     * @param {?} eventArgs
     * @return {?}
     */
    onOverlayOpening(eventArgs) {
        /** @type {?} */
        const instance = (/** @type {?} */ (eventArgs.componentRef.instance));
        if (instance) {
            instance.initialize(this.column, this._filteringService, this._overlayService, eventArgs.id);
        }
    }
    /**
     * @private
     * @return {?}
     */
    onOverlayClosed() {
        this._componentOverlayId = null;
    }
}
IgxGridHeaderComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header',
                template: "<ng-template #defaultColumn>\n    <span [attr.title]=\"column.header || column.field\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon [attr.draggable]=\"false\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <igx-icon [ngClass]=\"filterIconClassName\" [attr.draggable]=\"false\" (click)=\"onFilteringIconClick($event)\"\n        *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\">\n        filter_list\n    </igx-icon>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxGridHeaderComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxColumnResizingService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: IgxFilteringService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"] },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] }
];
IgxGridHeaderComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    gridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    styleClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }],
    height: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.height.rem',] }],
    hostRole: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    headerID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridFilteringCellComponent {
    /**
     * @param {?} cdr
     * @param {?} filteringService
     * @param {?} navService
     */
    constructor(cdr, filteringService, navService) {
        this.cdr = cdr;
        this.filteringService = filteringService;
        this.navService = navService;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.currentTemplate = null;
        this.moreFiltersCount = 0;
        this.cssClass = 'igx-grid__filtering-cell';
        this.filteringService.subscribeToEvents();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.updateFilterCellArea();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.updateFilterCellArea();
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onTabKeyDown(eventArgs) {
        if (this.isLastElementFocused()) {
            this.filteringService.grid.navigation.navigateNextFilterCell(this.column, eventArgs);
        }
        eventArgs.stopPropagation();
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onShiftTabKeyDown(eventArgs) {
        if (this.isFirstElementFocused()) {
            this.filteringService.grid.navigation.navigatePrevFilterCell(this.column, eventArgs);
        }
        eventArgs.stopPropagation();
    }
    /**
     * Returns whether a chip with a given index is visible or not.
     * @param {?} index
     * @return {?}
     */
    isChipVisible(index) {
        /** @type {?} */
        const expression = this.expressionsList[index];
        return !!(expression && expression.isVisible);
    }
    /**
     * Updates the filtering cell area.
     * @return {?}
     */
    updateFilterCellArea() {
        this.expressionsList = this.filteringService.getExpressions(this.column.field);
        this.updateVisibleFilters();
    }
    /**
     * @return {?}
     */
    get template() {
        if (!this.column.filterable) {
            this.currentTemplate = null;
            return null;
        }
        if (this.column.filterCellTemplate) {
            this.currentTemplate = this.column.filterCellTemplate;
            return this.column.filterCellTemplate;
        }
        /** @type {?} */
        const expressionTree = this.column.filteringExpressionsTree;
        if (!expressionTree || expressionTree.filteringOperands.length === 0) {
            this.currentTemplate = this.emptyFilter;
            return this.emptyFilter;
        }
        if (this.filteringService.isFilterComplex(this.column.field)) {
            this.currentTemplate = this.complexFilter;
            return this.complexFilter;
        }
        this.currentTemplate = this.defaultFilter;
        return this.defaultFilter;
    }
    /**
     * Gets the context passed to the filter template.
     * \@memberof IgxGridFilteringCellComponent
     * @return {?}
     */
    get context() {
        return {
            column: this.column
        };
    }
    /**
     * Chip clicked event handler.
     * @param {?=} expression
     * @return {?}
     */
    onChipClicked(expression) {
        if (expression) {
            this.expressionsList.forEach((item) => {
                item.isSelected = (item.expression === expression);
            });
        }
        else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach((item) => {
                item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
        }
        /** @type {?} */
        const index = this.filteringService.unpinnedFilterableColumns.indexOf(this.column);
        if (index >= 0 && !this.isColumnRightVisible(index)) {
            this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], true);
        }
        else if (index >= 0 && !this.isColumnLeftVisible(index)) {
            this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], false);
        }
        this.filteringService.filteredColumn = this.column;
        this.filteringService.isFilterRowVisible = true;
        this.filteringService.selectedExpression = expression;
    }
    /**
     * Chip removed event handler.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    onChipRemoved(eventArgs, item) {
        /** @type {?} */
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove);
        this.focusChip();
    }
    /**
     * Clears the filtering.
     * @return {?}
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.cdr.detectChanges();
    }
    /**
     * Chip keydown event handler.
     * @param {?} eventArgs
     * @param {?=} expression
     * @return {?}
     */
    onChipKeyDown(eventArgs, expression) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            this.onChipClicked(expression);
        }
    }
    /**
     * Returns the filtering indicator class.
     * @return {?}
     */
    filteringIndicatorClass() {
        return {
            [this.baseClass]: !this.isMoreIconHidden(),
            [`${this.baseClass}--hidden`]: this.isMoreIconHidden()
        };
    }
    /**
     * Focus a chip depending on the current visible template.
     * @param {?=} focusFirst
     * @return {?}
     */
    focusChip(focusFirst = false) {
        if (this.currentTemplate === this.defaultFilter) {
            if (focusFirst) {
                this.focusFirstElement();
            }
            else {
                this.focusElement();
            }
        }
        else if (this.currentTemplate === this.emptyFilter) {
            this.ghostChip.elementRef.nativeElement.querySelector(`.igx-chip__item`).focus();
        }
        else if (this.currentTemplate === this.complexFilter) {
            this.complexChip.elementRef.nativeElement.querySelector(`.igx-chip__item`).focus();
        }
    }
    /**
     * @private
     * @param {?} indexToRemove
     * @return {?}
     */
    removeExpression(indexToRemove) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.updateVisibleFilters();
        this.filteringService.filterInternal(this.column.field);
    }
    /**
     * @private
     * @return {?}
     */
    isMoreIconHidden() {
        return this.filteringService.columnToMoreIconHidden.get(this.column.field);
    }
    /**
     * @private
     * @return {?}
     */
    updateVisibleFilters() {
        this.expressionsList.forEach((ex) => ex.isVisible = true);
        if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        this.cdr.detectChanges();
        if (this.chipsArea && this.expressionsList.length > 1) {
            /** @type {?} */
            const areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            /** @type {?} */
            let viewWidth = 0;
            /** @type {?} */
            const chipsAreaElements = this.chipsArea.element.nativeElement.children;
            /** @type {?} */
            let visibleChipsCount = 0;
            /** @type {?} */
            const moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
            for (let index = 0; index < chipsAreaElements.length - 1; index++) {
                if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                    viewWidth += chipsAreaElements[index].offsetWidth;
                    if (index % 2 === 0) {
                        visibleChipsCount++;
                    }
                    else {
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                    }
                }
                else {
                    if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                    this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                    break;
                }
            }
            for (let i = visibleChipsCount; i < this.expressionsList.length; i++) {
                this.expressionsList[i].isVisible = false;
            }
            this.cdr.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    isFirstElementFocused() {
        return !(this.chipsArea && this.chipsArea.chipsList.length > 0 &&
            this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(`.igx-chip__item`) !== document.activeElement);
    }
    /**
     * @private
     * @return {?}
     */
    isLastElementFocused() {
        if (this.chipsArea) {
            if (this.isMoreIconHidden() && this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(`.igx-chip__remove`) !==
                document.activeElement) {
                return false;
            }
            else if (!this.isMoreIconHidden() && this.moreIcon.nativeElement !== document.activeElement) {
                return false;
            }
        }
        return true;
    }
    /**
     * @private
     * @return {?}
     */
    focusFirstElement() {
        if (this.chipsArea.chipsList.length > 0) {
            this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(`.igx-chip__item`).focus();
        }
        else {
            this.moreIcon.nativeElement.focus();
        }
    }
    /**
     * @private
     * @return {?}
     */
    focusElement() {
        if (this.filteringService.shouldFocusNext) {
            if (!this.isMoreIconHidden() && this.chipsArea.chipsList.length === 0) {
                this.moreIcon.nativeElement.focus();
            }
            else {
                this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(`.igx-chip__item`).focus();
            }
        }
        else {
            if (!this.isMoreIconHidden()) {
                this.moreIcon.nativeElement.focus();
            }
            else {
                this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(`.igx-chip__remove`).focus();
            }
        }
    }
    /**
     * @private
     * @param {?} columnIndex
     * @return {?}
     */
    isColumnRightVisible(columnIndex) {
        if (this.filteringService.areAllColumnsInView) {
            return true;
        }
        /** @type {?} */
        let currentColumnRight = 0;
        for (let index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
            currentColumnRight += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
            if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
                break;
            }
        }
        /** @type {?} */
        const width = this.filteringService.displayContainerWidth + this.filteringService.displayContainerScrollLeft;
        return currentColumnRight <= width;
    }
    /**
     * @private
     * @param {?} columnIndex
     * @return {?}
     */
    isColumnLeftVisible(columnIndex) {
        if (this.filteringService.areAllColumnsInView) {
            return true;
        }
        /** @type {?} */
        let currentColumnLeft = 0;
        for (let index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
            if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
                break;
            }
            currentColumnLeft += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
        }
        return currentColumnLeft >= this.filteringService.displayContainerScrollLeft;
    }
}
IgxGridFilteringCellComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-cell',
                template: "<ng-template #emptyFilter>\n        <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n            <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" [displayDensity]=\"'cosy'\">\n                <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n                <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n            </igx-chip>\n        </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip\n                *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                [displayDensity]=\"'cosy'\"\n                (click)=\"onChipClicked(item.expression)\"\n                (keydown)=\"onChipKeyDown($event, item.expression)\"\n                (onRemove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    fontSet=\"filtering-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" tabindex=\"0\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"'cosy'\" (onRemove)=\"clearFiltering()\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
            }] }
];
/** @nocollapse */
IgxGridFilteringCellComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxFilteringService },
    { type: IgxGridNavigationService }
];
IgxGridFilteringCellComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    emptyFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['emptyFilter', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultFilter', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    complexFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['complexFilter', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    chipsArea: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['chipsArea', { read: IgxChipsAreaComponent, static: false },] }],
    moreIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['moreIcon', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    ghostChip: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['ghostChip', { read: IgxChipComponent, static: false },] }],
    complexChip: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['complexChip', { read: IgxChipComponent, static: false },] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__filtering-cell',] }],
    onTabKeyDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.tab', ['$event'],] }],
    onShiftTabKeyDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.shift.tab', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Z_INDEX = 9999;
/**
 * @hidden
 */
class IgxGridHeaderGroupComponent {
    /**
     * @param {?} cdr
     * @param {?} gridAPI
     * @param {?} element
     * @param {?} colResizingService
     * @param {?} filteringService
     */
    constructor(cdr, gridAPI, element, colResizingService, filteringService) {
        this.cdr = cdr;
        this.gridAPI = gridAPI;
        this.element = element;
        this.colResizingService = colResizingService;
        this.filteringService = filteringService;
    }
    /**
     * @return {?}
     */
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    /**
     * @return {?}
     */
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    /**
     * @return {?}
     */
    get rowEnd() {
        return this.column.rowEnd;
    }
    /**
     * @return {?}
     */
    get colEnd() {
        return this.column.colEnd;
    }
    /**
     * @return {?}
     */
    get rowStart() {
        return this.column.rowStart;
    }
    /**
     * @return {?}
     */
    get colStart() {
        return this.column.colStart;
    }
    /**
     * Gets the width of the header group.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get width() {
        return this.grid.getHeaderGroupWidth(this.column);
    }
    /**
     * Gets the style classes of the header group.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get styleClasses() {
        /** @type {?} */
        const defaultClasses = [
            'igx-grid__thead-item',
            this.column.headerGroupClasses
        ];
        /** @type {?} */
        const classList = {
            'igx-grid__th--pinned': this.isPinned,
            'igx-grid__th--pinned-last': this.isLastPinned,
            'igx-grid__drag-col-header': this.isHeaderDragged,
            'igx-grid__th--filtering': this.isFiltered
        };
        for (const className of Object.keys(classList)) {
            if (classList[className]) {
                defaultClasses.push(className);
            }
        }
        return defaultClasses.join(' ');
    }
    /**
     * @hidden
     * @return {?}
     */
    get zIndex() {
        if (!this.column.pinned) {
            return null;
        }
        return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
    }
    /**
     * Gets the grid of the header group.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets whether the header group belongs to a column that is filtered.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get isFiltered() {
        return this.filteringService.filteredColumn === this.column;
    }
    /**
     * Gets whether the header group is stored in the last column in the pinned area.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get isLastPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
    }
    /**
     * @return {?}
     */
    get groupDisplayStyle() {
        return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
    }
    /**
     * Gets whether the header group is stored in a pinned column.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get isPinned() {
        return this.column.pinned;
    }
    /**
     * Gets whether the header group belongs to a column that is moved.
     * \@memberof IgxGridHeaderGroupComponent
     * @return {?}
     */
    get isHeaderDragged() {
        return this.grid.draggedColumn === this.column;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasLastPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isLastPinned);
    }
    /**
     * @hidden
     * @return {?}
     */
    get height() {
        return this.element.nativeElement.getBoundingClientRect().height;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        // hack for preventing text selection in IE and Edge while dragging the resizer
        event.preventDefault();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
}
IgxGridHeaderGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header-group',
                template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.gridID\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outletDirective.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-template #defaultColumn>\n    <span [attr.title]=\"column.header\">{{column.header}}</span>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outletDirective.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\">\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width.px]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis.px]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outletDirective.nativeElement\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n          [igxResizeHandle]=\"column\"\n          [attr.draggable]=\"false\"\n          [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
            }] }
];
/** @nocollapse */
IgxGridHeaderGroupComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxColumnResizingService },
    { type: IgxFilteringService }
];
IgxGridHeaderGroupComponent.propDecorators = {
    gridRowSpan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-row-span',] }],
    gridColumnSpan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-column-span',] }],
    rowEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-row-end',] }],
    colEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-column-end',] }],
    rowStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-row',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-row-start',] }],
    colStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.-ms-grid-column',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.grid-column-start',] }],
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    gridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    headerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxGridHeaderComponent, { static: false },] }],
    filterCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxGridFilteringCellComponent, { static: false },] }],
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxGridHeaderGroupComponent), { read: IgxGridHeaderGroupComponent },] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.min-width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flex-basis',] }],
    styleClasses: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }],
    zIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.z-index',] }],
    groupDisplayStyle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.display',] }],
    onMouseDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mousedown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const GridResourceStringsEN = {
    igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
    igx_grid_emptyFilteredGrid_message: 'No records found.',
    igx_grid_emptyGrid_message: 'Grid has no data.',
    igx_grid_filter: 'Filter',
    igx_grid_filter_row_close: 'Close',
    igx_grid_filter_row_reset: 'Reset',
    igx_grid_filter_row_placeholder: 'Add filter value',
    igx_grid_filter_row_boolean_placeholder: 'All',
    igx_grid_filter_row_date_placeholder: 'Pick up date',
    igx_grid_filter_operator_and: 'And',
    igx_grid_filter_operator_or: 'Or',
    igx_grid_complex_filter: 'Complex Filter',
    igx_grid_filter_contains: 'Contains',
    igx_grid_filter_doesNotContain: 'Does Not Contain',
    igx_grid_filter_startsWith: 'Starts With',
    igx_grid_filter_endsWith: 'Ends With',
    igx_grid_filter_equals: 'Equals',
    igx_grid_filter_doesNotEqual: 'Does Not Equal',
    igx_grid_filter_empty: 'Empty',
    igx_grid_filter_notEmpty: 'Not Empty',
    igx_grid_filter_null: 'Null',
    igx_grid_filter_notNull: 'Not Null',
    igx_grid_filter_before: 'Before',
    igx_grid_filter_after: 'After',
    igx_grid_filter_today: 'Today',
    igx_grid_filter_yesterday: 'Yesterday',
    igx_grid_filter_thisMonth: 'This Month',
    igx_grid_filter_lastMonth: 'Last Month',
    igx_grid_filter_nextMonth: 'Next Month',
    igx_grid_filter_thisYear: 'This Year',
    igx_grid_filter_lastYear: 'Last Year',
    igx_grid_filter_nextYear: 'Next Year',
    igx_grid_filter_greaterThan: 'Greater Than',
    igx_grid_filter_lessThan: 'Less Than',
    igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
    igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
    igx_grid_filter_true: 'True',
    igx_grid_filter_false: 'False',
    igx_grid_filter_all: 'All',
    igx_grid_filter_condition_placeholder: 'Select filter',
    igx_grid_summary_count: 'Count',
    igx_grid_summary_min: 'Min',
    igx_grid_summary_max: 'Max',
    igx_grid_summary_sum: 'Sum',
    igx_grid_summary_average: 'Avg',
    igx_grid_summary_earliest: 'Earliest',
    igx_grid_summary_latest: 'Latest',
    igx_grid_excel_filter_moving_left: 'move left',
    igx_grid_excel_filter_moving_left_short: 'left',
    igx_grid_excel_filter_moving_right: 'move right',
    igx_grid_excel_filter_moving_right_short: 'right',
    igx_grid_excel_filter_moving_header: 'move',
    igx_grid_excel_filter_sorting_asc: 'ascending',
    igx_grid_excel_filter_sorting_asc_short: 'asc',
    igx_grid_excel_filter_sorting_desc: 'descending',
    igx_grid_excel_filter_sorting_desc_short: 'desc',
    igx_grid_excel_filter_sorting_header: 'sort',
    igx_grid_excel_filter_clear: 'Clear column filters',
    igx_grid_excel_custom_dialog_add: 'add filter',
    igx_grid_excel_custom_dialog_clear: 'Clear filter',
    igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
    igx_grid_excel_cancel: 'cancel',
    igx_grid_excel_apply: 'apply',
    igx_grid_excel_search_placeholder: 'Search',
    igx_grid_excel_select_all: 'Select All',
    igx_grid_excel_blanks: '(Blanks)',
    igx_grid_excel_hide: 'Hide column',
    igx_grid_excel_pin: 'Pin column',
    igx_grid_excel_unpin: 'Unpin column',
    igx_grid_excel_text_filter: 'Text filter',
    igx_grid_excel_number_filter: 'Number filter',
    igx_grid_excel_date_filter: 'Date filter',
    igx_grid_excel_boolean_filter: 'Boolean filter',
    igx_grid_excel_custom_filter: 'Custom filter...',
    igx_grid_advanced_filter_title: 'Advanced Filtering',
    igx_grid_advanced_filter_and_group: '"And" Group',
    igx_grid_advanced_filter_or_group: '"Or" Group',
    igx_grid_advanced_filter_end_group: 'End Group',
    igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
    igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
    igx_grid_advanced_filter_and_label: 'and',
    igx_grid_advanced_filter_or_label: 'or',
    igx_grid_advanced_filter_add_condition: 'Condition',
    igx_grid_advanced_filter_ungroup: 'Ungroup',
    igx_grid_advanced_filter_delete: 'Delete',
    igx_grid_advanced_filter_delete_filters: 'Delete filters',
    igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
    igx_grid_advanced_filter_column_placeholder: 'Select column',
    igx_grid_advanced_filter_value_placeholder: 'Value'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TimePickerResourceStringsEN = {
    igx_time_picker_ok: 'OK',
    igx_time_picker_cancel: 'Cancel'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PaginatorResourceStringsEN = {
    igx_paginator_label: 'Items per page'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
const CurrentResourceStrings = {
    GridResStrings: cloneValue(GridResourceStringsEN),
    TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
    PaginatorResStrings: cloneValue(PaginatorResourceStringsEN)
};
/**
 * @param {?} currentStrings
 * @param {?} newStrings
 * @return {?}
 */
function updateResourceStrings(currentStrings, newStrings) {
    for (const key of Object.keys(newStrings)) {
        if (key in currentStrings) {
            currentStrings[key] = newStrings[key];
        }
    }
}
/**
 * Changes the resource strings for all components in the application
 * ```
 * @param {?} resourceStrings to be applied
 * @return {?}
 */
function changei18n(resourceStrings) {
    for (const key of Object.keys(CurrentResourceStrings)) {
        updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
    }
}
/**
 * Returns current resource strings for all components
 * @return {?}
 */
function getCurrentResourceStrings() {
    return Object.assign({}, CurrentResourceStrings.GridResStrings, CurrentResourceStrings.TimePickerResStrings);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridSummaryService {
    constructor() {
        this.summaryCacheMap = new Map();
        this.rootSummaryID = 'igxGridRootSummary';
        this.summaryHeight = 0;
        this.maxSummariesLenght = 0;
        this.groupingExpressions = [];
        this.retriggerRootPipe = 0;
        this.deleteOperation = false;
    }
    /**
     * @return {?}
     */
    recalculateSummaries() {
        this.resetSummaryHeight();
        this.grid.notifyChanges(true);
    }
    /**
     * @param {?=} args
     * @return {?}
     */
    clearSummaryCache(args) {
        if (!this.summaryCacheMap.size) {
            return;
        }
        if (!args) {
            this.summaryCacheMap.clear();
            if (this.grid && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
            return;
        }
        if (args.data) {
            /** @type {?} */
            const rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
            this.removeSummaries(rowID);
        }
        if (args.rowID !== undefined && args.rowID !== null) {
            /** @type {?} */
            let columnName = args.cellID ? this.grid.columnList.find(col => col.index === args.cellID.columnID).field : undefined;
            if (columnName && this.grid.rowEditable) {
                return;
            }
            /** @type {?} */
            const isGroupedColumn = this.grid.groupingExpressions &&
                this.grid.groupingExpressions.map(expr => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && isGroupedColumn) {
                columnName = undefined;
            }
            this.removeSummaries(args.rowID, columnName);
        }
    }
    /**
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    removeSummaries(rowID, columnName) {
        this.deleteSummaryCache(this.rootSummaryID, columnName);
        if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
            return;
        }
        if (this.isTreeGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                // TODO: this.removeChildRowSummaries(rowID, columnName);
                this.summaryCacheMap.clear();
                return;
            }
            this.removeAllTreeGridSummaries(rowID, columnName);
        }
        else if (this.isHierarchicalGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                this.summaryCacheMap.clear();
            }
        }
        else {
            /** @type {?} */
            const summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
            summaryIds.forEach(id => {
                this.deleteSummaryCache(id, columnName);
            });
        }
    }
    /**
     * @param {?} columnName
     * @return {?}
     */
    removeSummariesCachePerColumn(columnName) {
        this.summaryCacheMap.forEach((cache) => {
            if (cache.get(columnName)) {
                cache.delete(columnName);
            }
        });
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    /**
     * @return {?}
     */
    calcMaxSummaryHeight() {
        if (this.summaryHeight) {
            return this.summaryHeight;
        }
        if (!this.grid.data) {
            return this.summaryHeight = 0;
        }
        /** @type {?} */
        let maxSummaryLength = 0;
        this.grid.columnList.filter((col) => col.hasSummary && !col.hidden).forEach((column) => {
            /** @type {?} */
            const getCurrentSummaryColumn = column.summaries.operate([]).length;
            if (getCurrentSummaryColumn) {
                if (maxSummaryLength < getCurrentSummaryColumn) {
                    maxSummaryLength = getCurrentSummaryColumn;
                }
            }
        });
        this.maxSummariesLenght = maxSummaryLength;
        this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
        return this.summaryHeight;
    }
    /**
     * @param {?} rowID
     * @param {?} data
     * @return {?}
     */
    calculateSummaries(rowID, data) {
        /** @type {?} */
        let rowSummaries = this.summaryCacheMap.get(rowID);
        if (!rowSummaries) {
            rowSummaries = new Map();
            this.summaryCacheMap.set(rowID, rowSummaries);
        }
        if (!this.hasSummarizedColumns || !data) {
            return rowSummaries;
        }
        this.grid.columnList.filter(col => col.hasSummary).forEach((column) => {
            if (!rowSummaries.get(column.field)) {
                rowSummaries.set(column.field, column.summaries.operate(data.map(r => r[column.field]), data, column.field));
            }
        });
        return rowSummaries;
    }
    /**
     * @return {?}
     */
    resetSummaryHeight() {
        this.summaryHeight = 0;
        ((/** @type {?} */ (this.grid)))._summaryPipeTrigger++;
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    /**
     * @param {?} groupingArgs
     * @return {?}
     */
    updateSummaryCache(groupingArgs) {
        if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
            return;
        }
        if (this.groupingExpressions.length === 0) {
            this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
            return;
        }
        if (groupingArgs.length === 0) {
            this.groupingExpressions = [];
            this.clearSummaryCache();
            return;
        }
        this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
        this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
    }
    /**
     * @return {?}
     */
    get hasSummarizedColumns() {
        /** @type {?} */
        const summarizedColumns = this.grid.columnList.filter(col => col.hasSummary && !col.hidden);
        return summarizedColumns.length > 0;
    }
    /**
     * @private
     * @param {?} id
     * @param {?} columnName
     * @return {?}
     */
    deleteSummaryCache(id, columnName) {
        if (this.summaryCacheMap.get(id)) {
            /** @type {?} */
            const filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                this.grid.filteringExpressionsTree.filteringOperands.map((expr) => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                this.summaryCacheMap.get(id).delete(columnName);
            }
            else {
                this.summaryCacheMap.delete(id);
            }
            if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        }
    }
    /**
     * @private
     * @param {?} rowID
     * @param {?} groupingExpressions
     * @return {?}
     */
    getSummaryID(rowID, groupingExpressions) {
        if (groupingExpressions.length === 0) {
            return [];
        }
        /** @type {?} */
        const summaryIDs = [];
        /** @type {?} */
        let data = this.grid.data;
        if (this.grid.transactions.enabled) {
            data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
        }
        /** @type {?} */
        const rowData = this.grid.primaryKey ? data.find(rec => rec[this.grid.primaryKey] === rowID) : rowID;
        /** @type {?} */
        let id = '{ ';
        groupingExpressions.forEach(expr => {
            id += `'${expr.fieldName}': '${rowData[expr.fieldName]}'`;
            summaryIDs.push(id.concat(' }'));
            id += ', ';
        });
        return summaryIDs;
    }
    /**
     * @private
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    removeAllTreeGridSummaries(rowID, columnName) {
        /** @type {?} */
        let row = this.grid.records.get(rowID);
        if (!row) {
            return;
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowID = row.rowID;
            this.deleteSummaryCache(rowID, columnName);
            row = row.parent;
        }
    }
    // TODO: remove only deleted rows
    /**
     * @private
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    removeChildRowSummaries(rowID, columnName) {
    }
    /**
     * @private
     * @param {?} current
     * @param {?} groupingArgs
     * @return {?}
     */
    compareGroupingExpressions(current, groupingArgs) {
        /** @type {?} */
        const newExpressions = groupingArgs.expressions.map(record => record.fieldName);
        /** @type {?} */
        const removedCols = groupingArgs.ungroupedColumns;
        if (current.length <= newExpressions.length) {
            /** @type {?} */
            const newExpr = newExpressions.slice(0, current.length).toString();
            if (current.toString() !== newExpr) {
                this.clearSummaryCache();
            }
        }
        else {
            /** @type {?} */
            const currExpr = current.slice(0, newExpressions.length).toString();
            if (currExpr !== newExpressions.toString()) {
                this.clearSummaryCache();
                return;
            }
            removedCols.map(col => col.field).forEach(colName => {
                this.summaryCacheMap.forEach((cache, id) => {
                    if (id.indexOf(colName) !== -1) {
                        this.summaryCacheMap.delete(id);
                    }
                });
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    get isTreeGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
    }
    /**
     * @private
     * @return {?}
     */
    get isHierarchicalGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
}
IgxGridSummaryService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxSummaryCellComponent {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.firstCellIndentation = 0;
        this.hasSummary = false;
        this.tabindex = 0;
    }
    /**
     * @return {?}
     */
    get visibleColumnIndex() {
        return this.column.visibleIndex;
    }
    /**
     * @return {?}
     */
    get describeby() {
        return `Summary_${this.column.field}`;
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.focused = true;
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.focused = false;
    }
    /**
     * @protected
     * @return {?}
     */
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            isSummaryRow: true
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dispatchEvent(event) {
        // TODO: Refactor
        /** @type {?} */
        const key = event.key.toLowerCase();
        /** @type {?} */
        const ctrl = event.ctrlKey;
        /** @type {?} */
        const shift = event.shiftKey;
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        const args = { targetType: 'summaryCell', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(args);
        if (args.cancel) {
            return;
        }
        event.preventDefault();
        if (!this.isKeySupportedInCell(key, ctrl)) {
            return;
        }
        this.grid.selectionService.keyboardState.shift = shift && !(key === 'tab');
        /** @type {?} */
        const row = this.getRowElementByIndex(this.rowIndex);
        switch (key) {
            case 'tab':
                if (shift) {
                    this.grid.navigation.performShiftTabKey(row, this.selectionNode);
                    break;
                }
                this.grid.navigation.performTab(row, this.selectionNode);
                break;
            case 'arrowleft':
            case 'home':
            case 'left':
                if (ctrl || key === 'home') {
                    this.grid.navigation.onKeydownHome(this.rowIndex, true);
                    break;
                }
                this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.selectionNode);
                break;
            case 'end':
            case 'arrowright':
            case 'right':
                if (ctrl || key === 'end') {
                    this.grid.navigation.onKeydownEnd(this.rowIndex, true);
                    break;
                }
                this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.selectionNode);
                break;
            case 'arrowup':
            case 'up':
                this.grid.navigation.navigateUp(row, this.selectionNode);
                break;
            case 'arrowdown':
            case 'down':
                this.grid.navigation.navigateDown(row, this.selectionNode);
                break;
        }
    }
    /**
     * @return {?}
     */
    get width() {
        return this.column.getCellWidth();
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @return {?}
     */
    get columnDatatype() {
        return this.column.dataType;
    }
    /**
     * @return {?}
     */
    get itemHeight() {
        return this.column.grid.defaultSummaryHeight;
    }
    /**
     * @hidden
     * @return {?}
     */
    get grid() {
        return ((/** @type {?} */ (this.column.grid)));
    }
    /**
     * @private
     * @param {?} rowIndex
     * @return {?}
     */
    getRowElementByIndex(rowIndex) {
        /** @type {?} */
        const summaryRows = this.grid.summariesRowList.toArray();
        return summaryRows.find((sr) => sr.dataRowIndex === rowIndex).nativeElement;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} ctrl
     * @return {?}
     */
    isKeySupportedInCell(key, ctrl) {
        if (ctrl) {
            return ['arrowup', 'arrowdown', 'up', 'down', 'end', 'home'].indexOf(key) === -1;
        }
        return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'tab'].indexOf(key) !== -1;
    }
    /**
     * @param {?} summary
     * @return {?}
     */
    translateSummary(summary) {
        return this.grid.resourceStrings[`igx_grid_summary_${summary.key}`] || summary.label;
    }
}
IgxSummaryCellComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-cell',
                template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" title=\"{{ summary.label }}\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" title=\"{{ summary.summaryResult }}\">\n                    {{ columnDatatype === 'number' ? (summary.summaryResult | igxdecimal: grid.locale) : columnDatatype === 'date' ? (summary.summaryResult | igxdate: grid.locale) : (summary.summaryResult) }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
            }] }
];
/** @nocollapse */
IgxSummaryCellComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxSummaryCellComponent.propDecorators = {
    summaryResults: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    firstCellIndentation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hasSummary: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    density: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-rowIndex',] }],
    visibleColumnIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-visibleIndex',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    describeby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-describedby',] }],
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid-summary--active',] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus',] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur',] }],
    dispatchEvent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.min-width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.max-width',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flex-basis',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxSummaryRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} element
     * @param {?} cdr
     */
    constructor(gridAPI, element, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        this.firstCellIndentation = -1;
    }
    /**
     * @return {?}
     */
    get dataRowIndex() {
        return this.index;
    }
    /**
     * @return {?}
     */
    get minHeight() {
        return this.grid.summaryService.calcMaxSummaryHeight() - 1;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @param {?} columnName
     * @return {?}
     */
    getColumnSummaries(columnName) {
        if (!this.summaries.get(columnName)) {
            return [];
        }
        return this.summaries.get(columnName);
    }
    /**
     * @hidden
     * @return {?}
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
}
IgxSummaryRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-row',
                template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\">\n        </igx-grid-summary-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\">\n        </igx-grid-summary-cell>\n    </ng-template>\n</ng-container>\n",
                providers: [IgxForOfSyncService]
            }] }
];
/** @nocollapse */
IgxSummaryRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxSummaryRowComponent.propDecorators = {
    summaries: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    gridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    firstCellIndentation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dataRowIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-rowIndex',] }],
    summaryCells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent },] }],
    virtDirRow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['igxDirRef', { read: IgxGridForOfDirective, static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const DragScrollDirection = {
    NONE: 0,
    LEFT: 1,
    TOP: 2,
    RIGHT: 3,
    BOTTOM: 4,
    TOPLEFT: 5,
    TOPRIGHT: 6,
    BOTTOMLEFT: 7,
    BOTTOMRIGHT: 8,
};
DragScrollDirection[DragScrollDirection.NONE] = 'NONE';
DragScrollDirection[DragScrollDirection.LEFT] = 'LEFT';
DragScrollDirection[DragScrollDirection.TOP] = 'TOP';
DragScrollDirection[DragScrollDirection.RIGHT] = 'RIGHT';
DragScrollDirection[DragScrollDirection.BOTTOM] = 'BOTTOM';
DragScrollDirection[DragScrollDirection.TOPLEFT] = 'TOPLEFT';
DragScrollDirection[DragScrollDirection.TOPRIGHT] = 'TOPRIGHT';
DragScrollDirection[DragScrollDirection.BOTTOMLEFT] = 'BOTTOMLEFT';
DragScrollDirection[DragScrollDirection.BOTTOMRIGHT] = 'BOTTOMRIGHT';
class IgxGridDragSelectDirective {
    /**
     * @param {?} ref
     * @param {?} zone
     */
    constructor(ref, zone) {
        this.ref = ref;
        this.zone = zone;
        this.onDragStop = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onDragScroll = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.end$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = (ev) => {
            if (!this.activeDrag) {
                return;
            }
            /** @type {?} */
            const x = ev.clientX;
            /** @type {?} */
            const y = ev.clientY;
            /** @type {?} */
            const direction = this._measureDimensions(x, y);
            if (direction === this.lastDirection) {
                return;
            }
            this.unsubscribe();
            this._sub = this._interval$.subscribe(() => this.onDragScroll.emit(direction));
            this.lastDirection = direction;
        };
        this.stopDragSelection = () => {
            if (!this.activeDrag) {
                return;
            }
            this.onDragStop.emit(false);
            this.unsubscribe();
            this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.end$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(() => this.activeDrag));
    }
    /**
     * @return {?}
     */
    get activeDrag() {
        return this._activeDrag;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set activeDrag(val) {
        if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
        }
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.ref.nativeElement;
    }
    /**
     * @return {?}
     */
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerover', this.startDragSelection);
            this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerover', this.startDragSelection);
            this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    _measureDimensions(x, y) {
        /** @type {?} */
        let direction;
        /** @type {?} */
        const rect = this.clientRect;
        /** @type {?} */
        const RATIO = 0.15;
        /** @type {?} */
        const offsetX = Math.trunc(x - rect.left);
        /** @type {?} */
        const offsetY = Math.trunc(y - rect.top);
        /** @type {?} */
        const left = offsetX <= rect.width * RATIO;
        /** @type {?} */
        const right = offsetX >= rect.width * (1 - RATIO);
        /** @type {?} */
        const top = offsetY <= rect.height * RATIO;
        /** @type {?} */
        const bottom = offsetY >= rect.height * (1 - RATIO);
        if (top && left) {
            direction = DragScrollDirection.TOPLEFT;
        }
        else if (top && right) {
            direction = DragScrollDirection.TOPRIGHT;
        }
        else if (bottom && left) {
            direction = DragScrollDirection.BOTTOMLEFT;
        }
        else if (bottom && right) {
            direction = DragScrollDirection.BOTTOMRIGHT;
        }
        else if (top) {
            direction = DragScrollDirection.TOP;
        }
        else if (bottom) {
            direction = DragScrollDirection.BOTTOM;
        }
        else if (left) {
            direction = DragScrollDirection.LEFT;
        }
        else if (right) {
            direction = DragScrollDirection.RIGHT;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return direction;
    }
    /**
     * @protected
     * @return {?}
     */
    unsubscribe() {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    }
}
IgxGridDragSelectDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxGridDragSelect]'
            },] }
];
/** @nocollapse */
IgxGridDragSelectDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxGridDragSelectDirective.propDecorators = {
    activeDrag: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxGridDragSelect',] }],
    onDragStop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDragScroll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxTemplateOutletDirective {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _zone
     * @param {?} cdr
     */
    constructor(_viewContainerRef, _zone, cdr) {
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this.cdr = cdr;
        /**
         * The embedded views cache. Collection is key-value paired.
         * Key is the template id, value is the embedded view for the related template.
         */
        this._embeddedViewsMap = new Map();
        this.onViewCreated = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onViewMoved = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onCachedViewLoaded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const actionType = this._getActionType(changes);
        switch (actionType) {
            case TemplateOutletAction.CreateView:
                this._recreateView();
                break;
            case TemplateOutletAction.MoveView:
                this._moveView();
                break;
            case TemplateOutletAction.UseCachedView:
                this._useCachedView();
                break;
            case TemplateOutletAction.UpdateViewContext:
                this._updateExistingContext(this.igxTemplateOutletContext);
                break;
        }
    }
    /**
     * @return {?}
     */
    cleanCache() {
        this._embeddedViewsMap.forEach((item) => {
            if (!item.destroyed) {
                item.destroy();
            }
        });
        this._embeddedViewsMap.clear();
    }
    /**
     * @param {?} tmplID
     * @return {?}
     */
    cleanView(tmplID) {
        /** @type {?} */
        const embView = this._embeddedViewsMap.get(tmplID);
        if (embView) {
            embView.destroy();
            this._embeddedViewsMap.delete(tmplID);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _recreateView() {
        // detach old and create new
        if (this._viewRef) {
            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        }
        if (this.igxTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
            this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            /** @type {?} */
            const tmplId = this.igxTemplateOutletContext['templateID'];
            if (tmplId) {
                // if context contains a template id, check if we have a view for that template already stored in the cache
                // if not create a copy and add it to the cache in detached state.
                // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                /** @type {?} */
                const res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                if (!res) {
                    this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    _moveView() {
        // using external view and inserting it in current view.
        /** @type {?} */
        const view = this.igxTemplateOutletContext['moveView'];
        /** @type {?} */
        const owner = this.igxTemplateOutletContext['owner'];
        if (view !== this._viewRef) {
            if (owner._viewContainerRef.indexOf(view) !== -1) {
                // detach in case view it is attached somewhere else at the moment.
                owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
            }
            if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = view;
            this._viewContainerRef.insert(view, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
        }
    }
    /**
     * @private
     * @return {?}
     */
    _useCachedView() {
        // use view for specific template cached in the current template outlet
        /** @type {?} */
        const tmplID = this.igxTemplateOutletContext['templateID'];
        /** @type {?} */
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        // if view exists, but template has been changed and there is a view in the cache with the related template
        // then detach old view and insert the stored one with the matching template
        // after that update its context.
        this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        this._viewRef = cachedView;
        /** @type {?} */
        const oldContext = this._cloneContext(cachedView.context);
        this._viewContainerRef.insert(this._viewRef, 0);
        this._updateExistingContext(this.igxTemplateOutletContext);
        this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext });
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    _shouldRecreateView(changes) {
        /** @type {?} */
        const ctxChange = changes['igxTemplateOutletContext'];
        return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
    }
    /**
     * @private
     * @param {?} ctxChange
     * @return {?}
     */
    _hasContextShapeChanged(ctxChange) {
        /** @type {?} */
        const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        /** @type {?} */
        const currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * @private
     * @param {?} ctx
     * @return {?}
     */
    _updateExistingContext(ctx) {
        for (const propName of Object.keys(ctx)) {
            ((/** @type {?} */ (this._viewRef.context)))[propName] = ((/** @type {?} */ (this.igxTemplateOutletContext)))[propName];
        }
    }
    /**
     * @private
     * @param {?} ctx
     * @return {?}
     */
    _cloneContext(ctx) {
        /** @type {?} */
        const clone = {};
        for (const propName of Object.keys(ctx)) {
            clone[propName] = ctx[propName];
        }
        return clone;
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    _getActionType(changes) {
        /** @type {?} */
        const movedView = this.igxTemplateOutletContext['moveView'];
        /** @type {?} */
        const tmplID = this.igxTemplateOutletContext['templateID'];
        /** @type {?} */
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        /** @type {?} */
        const shouldRecreate = this._shouldRecreateView(changes);
        if (movedView) {
            // view is moved from external source
            return TemplateOutletAction.MoveView;
        }
        else if (shouldRecreate && cachedView) {
            // should recreate (template or context change) and there is a matching template in cache
            return TemplateOutletAction.UseCachedView;
        }
        else if (!this._viewRef || shouldRecreate) {
            // no view or should recreate
            return TemplateOutletAction.CreateView;
        }
        else if (this.igxTemplateOutletContext) {
            // has context, update context
            return TemplateOutletAction.UpdateViewContext;
        }
    }
}
IgxTemplateOutletDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[igxTemplateOutlet]' },] }
];
/** @nocollapse */
IgxTemplateOutletDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxTemplateOutletDirective.propDecorators = {
    igxTemplateOutletContext: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    igxTemplateOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onViewCreated: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onViewMoved: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCachedViewLoaded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/** @enum {number} */
const TemplateOutletAction = {
    CreateView: 0,
    MoveView: 1,
    UseCachedView: 2,
    UpdateViewContext: 3,
};
TemplateOutletAction[TemplateOutletAction.CreateView] = 'CreateView';
TemplateOutletAction[TemplateOutletAction.MoveView] = 'MoveView';
TemplateOutletAction[TemplateOutletAction.UseCachedView] = 'UseCachedView';
TemplateOutletAction[TemplateOutletAction.UpdateViewContext] = 'UpdateViewContext';
/**
 * @hidden
 */
class IgxTemplateOutletModule {
}
IgxTemplateOutletModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxTemplateOutletDirective],
                entryComponents: [],
                exports: [IgxTemplateOutletDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGridColumnResizerComponent {
    /**
     * @param {?} colResizingService
     */
    constructor(colResizingService) {
        this.colResizingService = colResizingService;
    }
}
IgxGridColumnResizerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-column-resizer',
                template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>"
            }] }
];
/** @nocollapse */
IgxGridColumnResizerComponent.ctorParameters = () => [
    { type: IgxColumnResizingService }
];
IgxGridColumnResizerComponent.propDecorators = {
    resizer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxColumnResizerDirective, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridFilteringRowComponent {
    /**
     * @param {?} filteringService
     * @param {?} element
     * @param {?} cdr
     */
    constructor(filteringService, element, cdr) {
        this.filteringService = filteringService;
        this.element = element;
        this.cdr = cdr;
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._conditionsOverlaySettings = {
            excludePositionTarget: true,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this._operatorsOverlaySettings = {
            excludePositionTarget: true,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this.chipAreaScrollOffset = 0;
        this._column = null;
        this.isKeyPressed = false;
        this.isComposing = false;
        this._cancelChipClick = false;
        this.cssClass = 'igx-grid__filtering-row';
    }
    /**
     * @return {?}
     */
    get column() {
        return this._column;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set column(val) {
        if (this._column) {
            this.expressionsList.forEach(exp => exp.isSelected = false);
        }
        if (val) {
            this._column = val;
            this.expressionsList = this.filteringService.getExpressions(this._column.field);
            this.resetExpression();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this.expression ? this.expression.searchVal : null;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        if (!val && val !== 0) {
            this.expression.searchVal = null;
            this.showHideArrowButtons();
        }
        else {
            this.expression.searchVal = this.transformValue(val);
            if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
                this.addExpression(true);
            }
        }
        this.filter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._conditionsOverlaySettings.outlet = this.column.grid.outletDirective;
        this._operatorsOverlaySettings.outlet = this.column.grid.outletDirective;
        /** @type {?} */
        const selectedItem = this.expressionsList.find(expr => expr.isSelected === true);
        if (selectedItem) {
            this.expression = selectedItem.expression;
        }
        this.input.nativeElement.focus();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTabKeydown(event) {
        event.stopPropagation();
        if (document.activeElement === this.closeButton.nativeElement && !event.shiftKey) {
            this.filteringService.grid.navigation.navigateFirstCellIfPossible(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEscKeydown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.close();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
    }
    /**
     * @return {?}
     */
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.defaultDateUI;
        }
        return this.defaultFilterUI;
    }
    /**
     * @return {?}
     */
    get type() {
        switch (this.column.dataType) {
            case DataType.String:
            case DataType.Boolean:
                return 'text';
            case DataType.Number:
                return 'number';
        }
    }
    /**
     * @return {?}
     */
    get conditions() {
        return this.column.filters.conditionList();
    }
    /**
     * @return {?}
     */
    get isUnaryCondition() {
        if (this.expression.condition) {
            return this.expression.condition.isUnary;
        }
        else {
            return true;
        }
    }
    /**
     * @return {?}
     */
    get placeholder() {
        if (this.expression.condition && this.expression.condition.isUnary) {
            return this.filteringService.getChipLabel(this.expression);
        }
        else if (this.column.dataType === DataType.Date) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
        }
        else if (this.column.dataType === DataType.Boolean) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
        }
        else {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
        }
    }
    /**
     * Event handler for keydown on the input group's prefix.
     * @param {?} event
     * @return {?}
     */
    onPrefixKeyDown(event) {
        if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            event.stopImmediatePropagation();
        }
        else if (event.key === "Tab" /* TAB */) {
            if (event.shiftKey) {
                event.preventDefault();
                event.stopPropagation();
            }
            else if (!this.dropDownConditions.collapsed) {
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
        }
    }
    /**
     * Event handler for keydown on the input.
     * @param {?} event
     * @return {?}
     */
    onInputKeyDown(event) {
        this.isKeyPressed = true;
        if (this.column.dataType === DataType.Boolean) {
            if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                event.stopPropagation();
                return;
            }
        }
        if (event.key === "Enter" /* ENTER */) {
            if (this.isComposing) {
                return;
            }
            this.commitInput();
        }
        else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
        else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */) {
            event.preventDefault();
            this.close();
        }
        event.stopPropagation();
    }
    /**
     * Event handler for keyup on the input.
     * @param {?} eventArgs
     * @return {?}
     */
    onInputKeyUp(eventArgs) {
        this.isKeyPressed = false;
    }
    /**
     * Event handler for input on the input.
     * @param {?} eventArgs
     * @return {?}
     */
    onInput(eventArgs) {
        // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
        // when you have a japanese character as a placeholder, on init the value here is empty string .
        if (isEdge() || this.isKeyPressed || eventArgs.target.value) {
            this.value = eventArgs.target.value;
        }
    }
    /**
     * Event handler for compositionstart on the input.
     * @return {?}
     */
    onCompositionStart() {
        this.isComposing = true;
    }
    /**
     * Event handler for compositionend on the input.
     * @return {?}
     */
    onCompositionEnd() {
        this.isComposing = false;
    }
    /**
     * Event handler for input click event.
     * @return {?}
     */
    onInputClick() {
        if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for datepicker's close.
     * @return {?}
     */
    datePickerClose() {
        this.input.nativeElement.focus();
    }
    /**
     * Returns the filtering operation condition for a given value.
     * @param {?} value
     * @return {?}
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * Returns the translated condition name for a given value.
     * @param {?} value
     * @return {?}
     */
    translateCondition(value) {
        return this.filteringService.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * Returns the icon name of the current condition.
     * @return {?}
     */
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else {
            return this.expression.condition.iconName;
        }
    }
    /**
     * Returns whether a given condition is selected in dropdown.
     * @param {?} conditionName
     * @return {?}
     */
    isConditionSelected(conditionName) {
        if (this.expression.condition) {
            return this.expression.condition.name === conditionName;
        }
        else {
            return false;
        }
    }
    /**
     * Clears the current filtering.
     * @return {?}
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.resetExpression();
        if (this.input) {
            this.input.nativeElement.focus();
        }
        this.cdr.detectChanges();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /**
     * Commits the value of the input.
     * @return {?}
     */
    commitInput() {
        /** @type {?} */
        const selectedItem = this.expressionsList.filter(ex => ex.isSelected === true);
        selectedItem.forEach(e => e.isSelected = false);
        /** @type {?} */
        let indexToDeselect = -1;
        for (let index = 0; index < this.expressionsList.length; index++) {
            /** @type {?} */
            const expression = this.expressionsList[index].expression;
            if (expression.searchVal === null && !expression.condition.isUnary) {
                indexToDeselect = index;
            }
        }
        if (indexToDeselect !== -1) {
            this.removeExpression(indexToDeselect, this.expression);
        }
        this.resetExpression();
        this.scrollChipsWhenAddingExpression();
    }
    /**
     * Clears the value of the input.
     * @return {?}
     */
    clearInput() {
        this.value = null;
    }
    /**
     * Event handler for keydown on clear button.
     * @param {?} eventArgs
     * @return {?}
     */
    onClearKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.clearInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on clear button.
     * @return {?}
     */
    onClearClick() {
        this.clearInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for keydown on commit button.
     * @param {?} eventArgs
     * @return {?}
     */
    onCommitKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.commitInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on commit button.
     * @return {?}
     */
    onCommitClick() {
        this.commitInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for focusout on the input group.
     * @return {?}
     */
    onInputGroupFocusout() {
        if (!this.value && this.value !== 0 &&
            this.expression.condition && !this.expression.condition.isUnary) {
            return;
        }
        requestAnimationFrame(() => {
            /** @type {?} */
            const focusedElement = document.activeElement;
            if (focusedElement.className === 'igx-chip__remove') {
                return;
            }
            if (!(focusedElement && this.inputGroup.nativeElement.contains(focusedElement))
                && this.dropDownConditions.collapsed) {
                this.commitInput();
            }
        });
    }
    /**
     * Closes the filtering edit row.
     * @return {?}
     */
    close() {
        if (this.expressionsList.length === 1 &&
            this.expressionsList[0].expression.searchVal === null &&
            this.expressionsList[0].expression.condition.isUnary === false) {
            this.filteringService.getExpressions(this.column.field).pop();
        }
        else {
            this.expressionsList.forEach((item) => {
                if (item.expression.searchVal === null && !item.expression.condition.isUnary) {
                    this.filteringService.removeExpression(this.column.field, this.expressionsList.indexOf(item));
                }
            });
        }
        this.filteringService.isFilterRowVisible = false;
        this.filteringService.updateFilteringCell(this.column);
        this.filteringService.focusFilterCellChip(this.column, true);
        this.filteringService.filteredColumn = null;
        this.filteringService.selectedExpression = null;
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /*
        * noop
        */
    /**
     * @return {?}
     */
    noop() { }
    /**
     *  Event handler for date picker's selection.
     * @param {?} value
     * @return {?}
     */
    onDateSelected(value) {
        this.value = value;
        this.commitInput();
    }
    /**
     * Opens the conditions dropdown.
     * @param {?} target
     * @return {?}
     */
    toggleConditionsDropDown(target) {
        this._conditionsOverlaySettings.positionStrategy.settings.target = target;
        this.dropDownConditions.toggle(this._conditionsOverlaySettings);
    }
    /**
     * Opens the logic operators dropdown.
     * @param {?} eventArgs
     * @param {?} index
     * @return {?}
     */
    toggleOperatorsDropDown(eventArgs, index) {
        this._operatorsOverlaySettings.positionStrategy.settings.target = eventArgs.target.parentElement;
        this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
    }
    /**
     * Event handler for change event in conditions dropdown.
     * @param {?} eventArgs
     * @return {?}
     */
    onConditionsChanged(eventArgs) {
        /** @type {?} */
        const value = ((/** @type {?} */ (eventArgs.newSelection))).value;
        this.expression.condition = this.getCondition(value);
        if (this.expression.condition.isUnary) {
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.unaryConditionChangedCallback());
        }
        else {
            requestAnimationFrame(() => this.conditionChangedCallback());
        }
        if (this.input) {
            // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
            // if it has been focused and then set to readonly.
            requestAnimationFrame(() => this.input.nativeElement.focus());
        }
    }
    /**
     * @param {?} args
     * @param {?} chip
     * @return {?}
     */
    onChipPointerdown(args, chip) {
        /** @type {?} */
        const activeElement = document.activeElement;
        this._cancelChipClick = chip.selected && activeElement &&
            this.inputGroup.nativeElement.contains(activeElement);
    }
    /**
     * @param {?} args
     * @param {?} item
     * @return {?}
     */
    onChipClick(args, item) {
        if (this._cancelChipClick) {
            return;
        }
        this._cancelChipClick = false;
        this.expressionsList.forEach(ex => ex.isSelected = false);
        this.toggleChip(item);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    toggleChip(item) {
        item.isSelected = !item.isSelected;
        if (item.isSelected) {
            this.expression = item.expression;
            if (this.input) {
                this.input.nativeElement.focus();
            }
        }
    }
    /**
     * Event handler for chip keydown event.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    onChipKeyDown(eventArgs, item) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            this.toggleChip(item);
        }
    }
    /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     * @param {?} event
     * @return {?}
     */
    onLeftArrowKeyDown(event) {
        if (event.key === "Tab" /* TAB */) {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * Event handler for chip removed event.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    onChipRemoved(eventArgs, item) {
        /** @type {?} */
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove, item.expression);
        this.scrollChipsOnRemove();
    }
    /**
     * Event handler for logic operator changed event.
     * @param {?} eventArgs
     * @param {?} expression
     * @return {?}
     */
    onLogicOperatorChanged(eventArgs, expression) {
        if (eventArgs.oldSelection) {
            expression.afterOperator = ((/** @type {?} */ (eventArgs.newSelection))).value;
            this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.filter());
        }
    }
    /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     * @param {?} arrowPosition
     * @return {?}
     */
    scrollChipsOnArrowPress(arrowPosition) {
        /** @type {?} */
        let count = 0;
        /** @type {?} */
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        /** @type {?} */
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        if (arrowPosition === 'right') {
            for (let index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                    count++;
                }
            }
            if (count < chipAraeChildren.length) {
                this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                    Math.ceil(containerRect.right) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
        if (arrowPosition === 'left') {
            for (let index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                    count++;
                }
            }
            if (count > 0) {
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                    Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    showHideArrowButtons() {
        requestAnimationFrame(() => {
            if (this.filteringService.isFilterRowVisible) {
                /** @type {?} */
                const containerWidth = this.container.nativeElement.getBoundingClientRect().width;
                this.chipsAreaWidth = this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                this.showArrows = this.chipsAreaWidth >= containerWidth && this.isColumnFiltered;
                // TODO: revise the cdr.detectChanges() usage here
                if (!((/** @type {?} */ (this.cdr))).destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    transformValue(value) {
        if (this.column.dataType === DataType.Number) {
            value = parseFloat(value);
        }
        else if (this.column.dataType === DataType.Boolean) {
            value = Boolean(value);
        }
        return value;
    }
    /**
     * @private
     * @param {?} isSelected
     * @return {?}
     */
    addExpression(isSelected) {
        /** @type {?} */
        const exprUI = new ExpressionUI();
        exprUI.expression = this.expression;
        exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;
        exprUI.isSelected = isSelected;
        this.expressionsList.push(exprUI);
        /** @type {?} */
        const length = this.expressionsList.length;
        if (this.expressionsList[length - 2]) {
            this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
        }
        this.showHideArrowButtons();
    }
    /**
     * @private
     * @param {?} indexToRemove
     * @param {?} expression
     * @return {?}
     */
    removeExpression(indexToRemove, expression) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.filter();
        if (this.expression === expression) {
            this.resetExpression();
        }
        this.showHideArrowButtons();
    }
    /**
     * @private
     * @return {?}
     */
    resetExpression() {
        this.expression = {
            fieldName: this.column.field,
            condition: null,
            searchVal: null,
            ignoreCase: this.column.filteringIgnoreCase
        };
        if (this.column.dataType !== DataType.Boolean) {
            this.expression.condition = this.getCondition(this.conditions[0]);
        }
        if (this.column.dataType === DataType.Date && this.input) {
            this.input.nativeElement.value = null;
        }
        this.showHideArrowButtons();
    }
    /**
     * @private
     * @return {?}
     */
    scrollChipsWhenAddingExpression() {
        /** @type {?} */
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        if (!chipAraeChildren || chipAraeChildren.length === 0) {
            return;
        }
        /** @type {?} */
        const containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
        /** @type {?} */
        const lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
        if (lastChipRectRight >= containerRectRight) {
            this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * @hidden
     * Resets the chips area
     * \@memberof IgxGridFilteringRowComponent
     * @return {?}
     */
    resetChipsArea() {
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
        this.showHideArrowButtons();
    }
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    transform(offset) {
        requestAnimationFrame(() => {
            this.chipsArea.element.nativeElement.style.transform = `translate(${offset}px)`;
        });
    }
    /**
     * @private
     * @return {?}
     */
    scrollChipsOnRemove() {
        /** @type {?} */
        let count = 0;
        /** @type {?} */
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        /** @type {?} */
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        for (let index = 0; index < chipAraeChildren.length; index++) {
            if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
                count++;
            }
        }
        if (count <= 2) {
            this.chipAreaScrollOffset = 0;
        }
        else {
            /** @type {?} */
            const dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
            this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
        }
        this.transform(this.chipAreaScrollOffset);
    }
    /**
     * @private
     * @return {?}
     */
    conditionChangedCallback() {
        if (!!this.expression.searchVal || this.expression.searchVal === 0) {
            this.filter();
        }
        else if (this.value) {
            this.value = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    unaryConditionChangedCallback() {
        if (this.value) {
            this.value = null;
        }
        if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
            this.addExpression(true);
        }
        this.filter();
    }
    /**
     * @private
     * @return {?}
     */
    filter() {
        this.filteringService.filterInternal(this.column.field);
    }
    /**
     * @private
     * @return {?}
     */
    get isColumnFiltered() {
        return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
    }
}
IgxGridFilteringRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-row',
                template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item\n        *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp($event)\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outletDirective\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClose)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon fontSet=\"filtering-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? noop() : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"value | igxdate: filteringService.grid.locale\"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\" (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">\n                    <igx-icon>clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (onRemove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"'cosy'\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer class=\"igx-grid__filtering-row-editing-buttons\">\n    <button igxButton igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</button>\n    <button #closeButton igxButton igxRipple (click)=\"close()\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</button>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxGridFilteringRowComponent.ctorParameters = () => [
    { type: IgxFilteringService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxGridFilteringRowComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    defaultFilterUI: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultFilterUI', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultDateUI: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultDateUI', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['input', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    dropDownConditions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputGroupConditions', { read: IgxDropDownComponent, static: true },] }],
    chipsArea: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['chipsArea', { read: IgxChipsAreaComponent, static: true },] }],
    dropDownOperators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: ['operators', { read: IgxDropDownComponent },] }],
    inputGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputGroup', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    inputGroupPrefix: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputGroupPrefix', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    container: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['container', { static: true },] }],
    operand: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['operand', { static: false },] }],
    closeButton: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['closeButton', { static: true },] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__filtering-row',] }],
    onTabKeydown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.shift.tab', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.tab', ['$event'],] }],
    onEscKeydown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxSelectItemComponent extends IgxDropDownItemComponent {
    /**
     * An \@Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
     *
     * ```typescript
     *  //get
     *  let mySelectedItem = this.dropDown.selectedItem;
     *  let selectedItemText = mySelectedItem.text;
     * ```
     * ```html
     * // set
     * <igx-select-item [text]="'London'"></igx-select-item>
     * ```
     * @return {?}
     */
    get text() {
        return this._text;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    set text(text) {
        this._text = text;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get itemText() {
        if (this._text !== undefined) {
            return this._text;
        }
        return this.elementRef.nativeElement.innerText.trim();
    }
    /**
     * Sets/Gets if the item is the currently selected one in the select
     *
     * ```typescript
     *  let mySelectedItem = this.select.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     * @return {?}
     */
    get selected() {
        return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        if (value && !this.isHeader && !this.disabled) {
            this.dropDown.selectItem(this);
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
    }
}
IgxSelectItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-select-item',
                template: '<ng-content></ng-content>'
            }] }
];
IgxSelectItemComponent.propDecorators = {
    text: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const Direction$2 = {
    Top: -1,
    Bottom: 1,
    None: 0,
};
Direction$2[Direction$2.Top] = 'Top';
Direction$2[Direction$2.Bottom] = 'Bottom';
Direction$2[Direction$2.None] = 'None';
/**
 * @hidden \@internal
 */
class SelectPositioningStrategy extends ConnectedPositioningStrategy {
    /**
     * @param {?} select
     * @param {?=} settings
     */
    constructor(select, settings) {
        super();
        this.select = select;
        this._selectDefaultSettings = {
            target: null,
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Top,
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this.defaultWindowToListOffset = 5;
        this.viewPort = Util.getViewportRect(document);
        this.settings = Object.assign({}, this._selectDefaultSettings, settings);
    }
    /**
     * @private
     * @param {?} contentElement
     * @param {?} outBoundsAmount
     * @return {?}
     */
    positionAndScrollBottom(contentElement, outBoundsAmount) {
        contentElement.style.top = `${this.viewPort.bottom - this.listContainerBoundRect.height - this.defaultWindowToListOffset}px`;
        contentElement.firstElementChild.scrollTop -= outBoundsAmount - (this.defaultWindowToListOffset);
        this.deltaY = this.viewPort.bottom - this.listContainerBoundRect.height -
            this.defaultWindowToListOffset - ((/** @type {?} */ (this.select.input.nativeElement.getBoundingClientRect()))).top;
    }
    /**
     * @private
     * @param {?} contentElement
     * @param {?} CURRENT_POSITION_Y
     * @return {?}
     */
    positionNoScroll(contentElement, CURRENT_POSITION_Y) {
        contentElement.style.top = `${CURRENT_POSITION_Y - this.itemTextToInputTextDiff}px`;
        this.deltaY = CURRENT_POSITION_Y -
            ((/** @type {?} */ (this.select.input.nativeElement.getBoundingClientRect()))).top - this.itemTextToInputTextDiff;
    }
    /**
     * @private
     * @param {?} contentElement
     * @param {?} outBoundsAmount
     * @return {?}
     */
    positionAndScrollTop(contentElement, outBoundsAmount) {
        contentElement.style.top = `${this.viewPort.top + this.defaultWindowToListOffset}px`;
        contentElement.firstElementChild.scrollTop += outBoundsAmount + this.itemTextToInputTextDiff + this.defaultWindowToListOffset;
        this.deltaY = this.viewPort.top + this.defaultWindowToListOffset -
            ((/** @type {?} */ (this.select.input.nativeElement.getBoundingClientRect()))).top;
    }
    /**
     * @private
     * @param {?} contentElement
     * @param {?} itemHeight
     * @return {?}
     */
    getItemsOutOfView(contentElement, itemHeight) {
        if (contentElement.firstElementChild.scrollHeight <= contentElement.firstElementChild.clientHeight) {
            return {
                'currentScroll': 0,
                'remainingScroll': 0
            };
        }
        /** @type {?} */
        const currentScroll = contentElement.firstElementChild.scrollTop;
        /** @type {?} */
        const remainingScroll = this.select.items.length * itemHeight - currentScroll - this.listContainerBoundRect.height;
        return {
            'currentScroll': currentScroll,
            'remainingScroll': remainingScroll
        };
    }
    /**
     * @private
     * @param {?} elementContainer
     * @param {?} document
     * @return {?}
     */
    listOutOfBounds(elementContainer, document) {
        /** @type {?} */
        const container = {
            TOP: elementContainer.top,
            BOTTOM: elementContainer.bottom,
        };
        /** @type {?} */
        const viewPort = Util.getViewportRect(document);
        /** @type {?} */
        const documentElement = {
            TOP: viewPort.top,
            BOTTOM: viewPort.bottom
        };
        /** @type {?} */
        const returnVals = {
            Direction: Direction$2.None,
            Amount: 0
        };
        if (documentElement.TOP + this.defaultWindowToListOffset > container.TOP) {
            returnVals.Direction = Direction$2.Top;
            returnVals.Amount = documentElement.TOP - container.TOP;
        }
        else if (documentElement.BOTTOM - this.defaultWindowToListOffset < container.BOTTOM) {
            returnVals.Direction = Direction$2.Bottom;
            returnVals.Amount = container.BOTTOM - documentElement.BOTTOM;
        }
        else {
            return null;
        }
        return returnVals;
    }
    /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        /** @type {?} */
        const inputElement = this.select.input.nativeElement;
        /** @type {?} */
        const inputRect = (/** @type {?} */ (inputElement.getBoundingClientRect()));
        this.listContainerBoundRect = (/** @type {?} */ (contentElement.getBoundingClientRect()));
        /** @type {?} */
        const LIST_HEIGHT = this.listContainerBoundRect.height;
        if (!initialCall) {
            this.deltaX = inputRect.left - this.itemTextPadding - this.itemTextIndent;
            /** @type {?} */
            const point = new Point(this.deltaX, inputRect.top + this.deltaY);
            this.settings.target = point;
            super.position(contentElement, size);
            return;
        }
        /** @type {?} */
        const START = {
            X: inputRect.left,
            Y: inputRect.top
        };
        /** @type {?} */
        let itemElement;
        if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement;
            // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
            if (isIE()) {
                contentElement.firstElementChild.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
            }
        }
        else {
            itemElement = this.select.getFirstItemElement();
        }
        /** @type {?} */
        const inputHeight = inputRect.height;
        /** @type {?} */
        const itemBoundRect = (/** @type {?} */ (itemElement.getBoundingClientRect()));
        /** @type {?} */
        const itemTopListOffset = itemBoundRect.top - this.listContainerBoundRect.top;
        /** @type {?} */
        const itemHeight = itemBoundRect.height;
        /** @type {?} */
        const inputFontSize = window.getComputedStyle(inputElement).fontSize;
        /** @type {?} */
        const numericInputFontSize = parseInt(inputFontSize.slice(0, inputFontSize.indexOf('p')), 10) || 0;
        /** @type {?} */
        const itemFontSize = window.getComputedStyle(itemElement).fontSize;
        /** @type {?} */
        const numericItemFontSize = parseInt(itemFontSize.slice(0, itemFontSize.indexOf('p')), 10) || 0;
        /** @type {?} */
        const inputTextToInputTop = (inputHeight - numericInputFontSize) / 2;
        /** @type {?} */
        const itemTextToItemTop = (itemHeight - numericItemFontSize) / 2;
        this.itemTextToInputTextDiff = itemTextToItemTop - inputTextToInputTop;
        /** @type {?} */
        let CURRENT_POSITION_Y = START.Y - itemTopListOffset;
        /** @type {?} */
        const CURRENT_BOTTOM_Y = CURRENT_POSITION_Y + this.listContainerBoundRect.height;
        /** @type {?} */
        const OUT_OF_BOUNDS = this.listOutOfBounds({ top: CURRENT_POSITION_Y, bottom: CURRENT_BOTTOM_Y }, document);
        if (OUT_OF_BOUNDS) {
            if (OUT_OF_BOUNDS.Direction === Direction$2.Top) {
                CURRENT_POSITION_Y = START.Y;
            }
            else {
                CURRENT_POSITION_Y = -1 * (LIST_HEIGHT - (itemHeight - (itemHeight - inputHeight) / 2));
                CURRENT_POSITION_Y += START.Y;
            }
        }
        /** @type {?} */
        const selectItemPaddingHorizontal = 24;
        /** @type {?} */
        const itemLeftPadding = window.getComputedStyle(itemElement).paddingLeft;
        /** @type {?} */
        const itemTextIndent = window.getComputedStyle(itemElement).textIndent;
        /** @type {?} */
        const numericLeftPadding = parseInt(itemLeftPadding.slice(0, itemLeftPadding.indexOf('p')), 10) || 0;
        /** @type {?} */
        const numericTextIndent = parseInt(itemTextIndent.slice(0, itemTextIndent.indexOf('r')), 10) || 0;
        this.itemTextPadding = numericLeftPadding;
        this.itemTextIndent = numericTextIndent;
        contentElement.style.left += `${START.X - numericLeftPadding - numericTextIndent}px`;
        contentElement.style.width = inputRect.width + 24 + selectItemPaddingHorizontal * 2 + 'px';
        this.deltaX = START.X - numericLeftPadding - numericTextIndent;
        /** @type {?} */
        const currentScroll = this.getItemsOutOfView(contentElement, itemHeight)['currentScroll'];
        /** @type {?} */
        const remainingScroll = this.getItemsOutOfView(contentElement, itemHeight)['remainingScroll'];
        // (5 items or less) no scroll and respectively no remaining scroll
        if (remainingScroll === 0 && currentScroll === 0) {
            this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
        }
        // (more than 5 items) there is scroll OR remaining scroll
        if (remainingScroll !== 0 || currentScroll !== 0) {
            if (remainingScroll !== 0 && !OUT_OF_BOUNDS) {
                this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
            }
            // (more than 5 items) and container getting out of the visible port
            if (remainingScroll !== 0 && OUT_OF_BOUNDS) {
                // if there is enough remaining scroll to scroll the item
                if (remainingScroll > itemHeight) {
                    if (OUT_OF_BOUNDS.Direction === Direction$2.Top) {
                        this.positionAndScrollTop(contentElement, OUT_OF_BOUNDS.Amount);
                        return;
                    }
                    if (OUT_OF_BOUNDS.Direction === Direction$2.Bottom) {
                        // (more than 5 items) and no current scroll
                        if (currentScroll === 0) {
                            this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
                            return;
                            // (more than 5 items) and current scroll
                        }
                        else {
                            this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                            return;
                        }
                    }
                }
                // if there is no enough remaining scroll to scroll the item
                if (remainingScroll < itemHeight) {
                    if (OUT_OF_BOUNDS.Direction === Direction$2.Top) {
                        this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
                    }
                    if (OUT_OF_BOUNDS.Direction === Direction$2.Bottom) {
                        this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                    }
                }
            }
            // (more than 5 items) and no remaining scroll
            if (remainingScroll === 0 && currentScroll !== 0) {
                if (OUT_OF_BOUNDS) {
                    if (OUT_OF_BOUNDS.Direction === Direction$2.Bottom) {
                        this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                        return;
                    }
                }
                this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden \@internal
 */
class IgxSelectToggleIconDirective {
}
IgxSelectToggleIconDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxSelectToggleIcon]'
            },] }
];
/** @type {?} */
const noop$5 = () => { };
/**
 * **Ignite UI for Angular Select** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select.html)
 *
 * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
 *
 * Example:
 * ```html
 * <igx-select #select1 [placeholder]="'Pick One'">
 *   <label igxLabel>Select Label</label>
 *   <igx-select-item *ngFor="let item of items" [value]="item.field">
 *     {{ item.field }}
 *   </igx-select-item>
 * </igx-select>
 * ```
 */
class IgxSelectComponent extends IgxDropDownComponent {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} selection
     * @param {?} _displayDensityOptions
     * @param {?} _injector
     */
    constructor(elementRef, cdr, selection, _displayDensityOptions, _injector) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this._injector = _injector;
        this.ngControl = null;
        /**
         * @hidden \@internal do not use the drop-down container class
         */
        this.cssClass = false;
        /**
         * @hidden \@internal
         */
        this.allowItemsFocus = false;
        /**
         * An \@Input property that disables the `IgxSelectComponent`.
         * ```html
         * <igx-select [disabled]="'true'"></igx-select>
         * ```
         */
        this.disabled = false;
        /**
         * @hidden \@internal
         */
        this.maxHeight = '256px';
        /**
         * An \@Input property that sets how the select will be styled.
         * The allowed values are `line`, `box` and `border`. The default is `line`.
         * ```html
         * <igx-select [type]="'box'"></igx-select>
         * ```
         */
        this.type = 'line';
        /**
         * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * @hidden \@internal
         */
        this._onChangeCallback = noop$5;
        /**
         * @hidden \@internal
         */
        this.writeValue = (value) => {
            this.value = value;
        };
    }
    /**
     * An \@Input property that gets/sets the component value.
     *
     * ```typescript
     * // get
     * let selectValue = this.select.value;
     * ```
     *
     * ```typescript
     * // set
     * this.select.value = 'London';
     * ```
     * ```html
     * <igx-select [value]="value"></igx-select>
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.setSelection(this.items.find(x => x.value === this.value));
        this.cdr.detectChanges();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get selectionValue() {
        /** @type {?} */
        const selectedItem = this.selectedItem;
        return selectedItem ? selectedItem.itemText : '';
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get selectedItem() {
        return this.selection.first_item(this.id);
    }
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @hidden \@internal
     * @return {?}
     */
    getEditElement() {
        return this.input.nativeElement;
    }
    /**
     * @hidden \@internal
     * @param {?} newSelection
     * @param {?=} event
     * @return {?}
     */
    selectItem(newSelection, event) {
        /** @type {?} */
        const oldSelection = this.selectedItem;
        if (event) {
            this.toggleDirective.close();
        }
        if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
            return;
        }
        /** @type {?} */
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (args.cancel) {
            return;
        }
        this.setSelection(newSelection);
        this._value = newSelection.value;
        this.cdr.detectChanges();
        this._onChangeCallback(this.value);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    getFirstItemElement() {
        return this.children.first.element.nativeElement;
    }
    /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    open(overlaySettings) {
        if (this.disabled || this.items.length === 0) {
            return;
        }
        if (!this.selectedItem) {
            this.navigateFirst();
        }
        super.open(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngAfterContentInit() {
        this._overlayDefaults = {
            modal: false,
            closeOnOutsideClick: false,
            positionStrategy: new SelectPositioningStrategy(this, { target: this.inputGroup.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            excludePositionTarget: true
        };
        this.children.changes.subscribe(() => {
            this.setSelection(this.items.find(x => x.value === this.value));
            this.cdr.detectChanges();
        });
        Promise.resolve().then(() => this.children.notifyOnChanges());
    }
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    onToggleOpening(event) {
        this.onOpening.emit(event);
        if (event.cancel) {
            return;
        }
        this.scrollToItem(this.selectedItem);
    }
    /**
     * @protected
     * @param {?} direction
     * @param {?=} currentIndex
     * @return {?}
     */
    navigate(direction, currentIndex) {
        if (this.collapsed && this.selectedItem) {
            this.navigateItem(this.selectedItem.itemIndex);
        }
        super.navigate(direction, currentIndex);
    }
    /**
     * @protected
     * @return {?}
     */
    manageRequiredAsterisk() {
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            /** @type {?} */
            const error = this.ngControl.control.validator((/** @type {?} */ ({})));
            this.inputGroup.isRequired = error && error.required;
            this.cdr.markForCheck();
        }
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    setSelection(item) {
        if (item && item.value !== undefined && item.value !== null) {
            this.selection.set(this.id, new Set([item]));
        }
        else {
            this.selection.clear(this.id);
        }
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    onBlur() {
        if (this.ngControl && !this.ngControl.valid) {
            this.input.valid = IgxInputState.INVALID;
        }
        else {
            this.input.valid = IgxInputState.INITIAL;
        }
        if (!this.collapsed) {
            this.toggleDirective.close();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    onStatusChanged() {
        if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
            (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this.input.valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                this.input.valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        this.manageRequiredAsterisk();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this._injector.get((/** @type {?} */ (_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"])), null);
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            this.manageRequiredAsterisk();
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.selection.clear(this.id);
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
}
IgxSelectComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-select',
                template: "<igx-input-group #inputGroup class=\"input-group\" [disabled]=\"disabled\" (click)=\"toggle()\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n        <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n            readonly=\"true\"\n            [attr.placeholder]=\"this.placeholder\"\n            [value]=\"this.selectionValue\"\n            role=\"combobox\"\n            aria-haspopup=\"listbox\"\n            [attr.aria-labelledby]=\"this.label ? this.label.id : ''\"\n            [attr.aria-expanded]=\"!this.collapsed\"\n            [attr.aria-owns]=\"this.listId\"\n            [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n            (blur)=\"onBlur()\"\n            />\n        <ng-container ngProjectAs=\"igx-suffix\">\n                <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n            </ng-container>\n        <igx-suffix>\n            <ng-container *ngIf=\"toggleIconTemplate\">\n                <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n                </ng-container>\n            <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n    <div class=\"igx-drop-down__list--select\" igxToggle [style.maxHeight]=\"maxHeight\"\n        (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n        (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\"\n        [attr.id]=\"this.listId\" role=\"listbox\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\">\n        </ng-content>\n    </div>\n",
                providers: [
                    { provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxSelectComponent, multi: true },
                    { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent }
                ],
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxSelectComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] }
];
IgxSelectComponent.propDecorators = {
    inputGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
    input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['input', { read: IgxInputDirective, static: true },] }],
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxSelectItemComponent), { descendants: true },] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxLabelDirective), { static: true },] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    overlaySettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    maxHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.maxHeight',] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    toggleIconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxSelectToggleIconDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class ExpressionItem {
    /**
     * @param {?=} parent
     */
    constructor(parent) {
        this.parent = parent;
    }
}
/**
 * @hidden
 */
class ExpressionGroupItem extends ExpressionItem {
    /**
     * @param {?} operator
     * @param {?=} parent
     */
    constructor(operator, parent) {
        super(parent);
        this.operator = operator;
        this.children = [];
    }
}
/**
 * @hidden
 */
class ExpressionOperandItem extends ExpressionItem {
    /**
     * @param {?} expression
     * @param {?} parent
     */
    constructor(expression, parent) {
        super(parent);
        this.expression = expression;
    }
}
/**
 * @hidden
 */
class IgxAdvancedFilteringDialogComponent {
    /**
     * @param {?} element
     * @param {?} cdr
     */
    constructor(element, cdr) {
        this.element = element;
        this.cdr = cdr;
        this.selectedExpressions = [];
        this.selectedGroups = [];
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalStartPoint: VerticalAlignment.Top
        };
        this._overlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new CloseScrollStrategy()
        };
        this.columnSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            excludePositionTarget: true
        };
        this.conditionSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            excludePositionTarget: true
        };
        this.display = 'block';
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._dblClickDelay = 200;
        this._preventChipClick = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set editingInputsContainer(value) {
        if ((value && !this._editingInputsContainer) ||
            (value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._editingInputsContainer = value;
    }
    /**
     * @return {?}
     */
    get editingInputsContainer() {
        return this._editingInputsContainer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set addModeContainer(value) {
        if ((value && !this._addModeContainer) ||
            (value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._addModeContainer = value;
    }
    /**
     * @return {?}
     */
    get addModeContainer() {
        return this._addModeContainer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currentGroupButtonsContainer(value) {
        if ((value && !this._currentGroupButtonsContainer) ||
            (value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._currentGroupButtonsContainer = value;
    }
    /**
     * @return {?}
     */
    get currentGroupButtonsContainer() {
        return this._currentGroupButtonsContainer;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.addRootAndGroupButton) {
            this.addRootAndGroupButton.nativeElement.focus();
        }
        else if (this.addConditionButton) {
            this.addConditionButton.nativeElement.focus();
        }
        this._overlaySettings.outlet = this.overlayOutlet;
        this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
        this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
        this.contextMenuToggle.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
            this.contextualGroup = null;
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @return {?}
     */
    get displayDensity() {
        return this.grid.displayDensity;
    }
    /**
     * @return {?}
     */
    get selectedColumn() {
        return this._selectedColumn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedColumn(value) {
        /** @type {?} */
        const oldValue = this._selectedColumn;
        if (this._selectedColumn !== value) {
            this._selectedColumn = value;
            if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
                this.selectedCondition = null;
                this.searchValue = null;
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * @return {?}
     */
    get grid() {
        return this.filteringService.grid;
    }
    /**
     * @return {?}
     */
    get filterableColumns() {
        return this.grid.columns.filter((col) => !col.columnGroup && col.filterable);
    }
    /**
     * @param {?} dragArgs
     * @return {?}
     */
    dragStart(dragArgs) {
        if (!this.contextMenuToggle.collapsed) {
            this.contextMenuToggle.element.style.display = 'none';
        }
    }
    /**
     * @param {?} dragArgs
     * @return {?}
     */
    dragEnd(dragArgs) {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
            this.contextMenuToggle.element.style.display = '';
        }
    }
    /**
     * @param {?} parent
     * @param {?=} afterExpression
     * @return {?}
     */
    addCondition(parent, afterExpression) {
        this.cancelOperandAdd();
        /** @type {?} */
        const operandItem = new ExpressionOperandItem({
            fieldName: null,
            condition: null,
            ignoreCase: true,
            searchVal: null
        }, parent);
        if (afterExpression) {
            /** @type {?} */
            const index = parent.children.indexOf(afterExpression);
            parent.children.splice(index + 1, 0, operandItem);
        }
        else {
            parent.children.push(operandItem);
        }
        this.enterExpressionEdit(operandItem);
    }
    /**
     * @param {?=} parent
     * @param {?=} afterExpression
     * @return {?}
     */
    addAndGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.And, parent, afterExpression);
    }
    /**
     * @param {?=} parent
     * @param {?=} afterExpression
     * @return {?}
     */
    addOrGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.Or, parent, afterExpression);
    }
    /**
     * @param {?} groupItem
     * @return {?}
     */
    endGroup(groupItem) {
        this.currentGroup = groupItem.parent;
    }
    /**
     * @return {?}
     */
    commitOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.expression.fieldName = this.selectedColumn.field;
            this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
            this.editedExpression.expression.searchVal = this.searchValue;
            this.editedExpression.inEditMode = false;
            this.editedExpression = null;
        }
    }
    /**
     * @return {?}
     */
    cancelOperandAdd() {
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
            this.addModeExpression = null;
        }
    }
    /**
     * @return {?}
     */
    cancelOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
            if (!this.editedExpression.expression.fieldName) {
                this.deleteItem(this.editedExpression);
            }
            this.editedExpression = null;
        }
    }
    /**
     * @return {?}
     */
    operandCanBeCommitted() {
        return this.selectedColumn && this.selectedCondition &&
            (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
    }
    /**
     * @return {?}
     */
    exitOperandEdit() {
        if (!this.editedExpression) {
            return;
        }
        if (this.operandCanBeCommitted()) {
            this.commitOperandEdit();
        }
        else {
            this.cancelOperandEdit();
        }
    }
    /**
     * @param {?} expression
     * @return {?}
     */
    isExpressionGroup(expression) {
        return expression instanceof ExpressionGroupItem;
    }
    /**
     * @private
     * @param {?} operator
     * @param {?=} parent
     * @param {?=} afterExpression
     * @return {?}
     */
    addGroup(operator, parent, afterExpression) {
        this.cancelOperandAdd();
        /** @type {?} */
        const groupItem = new ExpressionGroupItem(operator, parent);
        if (parent) {
            if (afterExpression) {
                /** @type {?} */
                const index = parent.children.indexOf(afterExpression);
                parent.children.splice(index + 1, 0, groupItem);
            }
            else {
                parent.children.push(groupItem);
            }
        }
        else {
            this.rootGroup = groupItem;
        }
        this.addCondition(groupItem);
        this.currentGroup = groupItem;
    }
    /**
     * @private
     * @param {?} expressionTree
     * @param {?=} parent
     * @return {?}
     */
    createExpressionGroupItem(expressionTree, parent) {
        /** @type {?} */
        let groupItem;
        if (expressionTree) {
            groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
            for (const expr of expressionTree.filteringOperands) {
                if (expr instanceof FilteringExpressionsTree) {
                    groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                }
                else {
                    /** @type {?} */
                    const filteringExpr = (/** @type {?} */ (expr));
                    /** @type {?} */
                    const exprCopy = {
                        fieldName: filteringExpr.fieldName,
                        condition: filteringExpr.condition,
                        searchVal: filteringExpr.searchVal,
                        ignoreCase: filteringExpr.ignoreCase
                    };
                    /** @type {?} */
                    const operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                    groupItem.children.push(operandItem);
                }
            }
        }
        return groupItem;
    }
    /**
     * @private
     * @param {?} groupItem
     * @return {?}
     */
    createExpressionsTreeFromGroupItem(groupItem) {
        if (!groupItem) {
            return null;
        }
        /** @type {?} */
        const expressionsTree = new FilteringExpressionsTree(groupItem.operator);
        for (const item of groupItem.children) {
            if (item instanceof ExpressionGroupItem) {
                /** @type {?} */
                const subTree = this.createExpressionsTreeFromGroupItem(((/** @type {?} */ (item))));
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                expressionsTree.filteringOperands.push(((/** @type {?} */ (item))).expression);
            }
        }
        return expressionsTree;
    }
    /**
     * @param {?} expressionItem
     * @return {?}
     */
    onChipRemove(expressionItem) {
        this.deleteItem(expressionItem);
    }
    /**
     * @param {?} expressionItem
     * @return {?}
     */
    onChipClick(expressionItem) {
        this._clickTimer = setTimeout(() => {
            if (!this._preventChipClick) {
                this.onToggleExpression(expressionItem);
            }
            this._preventChipClick = false;
        }, this._dblClickDelay);
    }
    /**
     * @param {?} expressionItem
     * @return {?}
     */
    onChipDblClick(expressionItem) {
        clearTimeout(this._clickTimer);
        this._preventChipClick = true;
        this.enterExpressionEdit(expressionItem);
    }
    /**
     * @param {?} expressionItem
     * @return {?}
     */
    enterExpressionEdit(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        this.cancelOperandAdd();
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
        }
        expressionItem.hovered = false;
        this.selectedColumn = expressionItem.expression.fieldName ?
            this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
        this.selectedCondition = expressionItem.expression.condition ?
            expressionItem.expression.condition.name : null;
        this.searchValue = expressionItem.expression.searchVal;
        expressionItem.inEditMode = true;
        this.editedExpression = expressionItem;
        this.cdr.detectChanges();
        this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({ target: this.columnSelect.element });
        this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({ target: this.conditionSelect.element });
        if (!this.selectedColumn) {
            this.columnSelect.input.nativeElement.focus();
        }
        else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
            this.conditionSelect.input.nativeElement.focus();
        }
        else {
            this.searchValueInput.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    clearSelection() {
        for (const group of this.selectedGroups) {
            group.selected = false;
        }
        this.selectedGroups = [];
        for (const expr of this.selectedExpressions) {
            expr.selected = false;
        }
        this.selectedExpressions = [];
        this.toggleContextMenu();
    }
    /**
     * @param {?} expressionItem
     * @return {?}
     */
    enterExpressionAdd(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
        }
        expressionItem.inAddMode = true;
        this.addModeExpression = expressionItem;
        if (expressionItem.selected) {
            this.toggleExpression(expressionItem);
        }
    }
    /**
     * @private
     * @param {?} expressionItem
     * @return {?}
     */
    onToggleExpression(expressionItem) {
        this.exitOperandEdit();
        this.toggleExpression(expressionItem);
        this.toggleContextMenu();
    }
    /**
     * @private
     * @param {?} expressionItem
     * @return {?}
     */
    toggleExpression(expressionItem) {
        expressionItem.selected = !expressionItem.selected;
        if (expressionItem.selected) {
            this.selectedExpressions.push(expressionItem);
        }
        else {
            /** @type {?} */
            const index = this.selectedExpressions.indexOf(expressionItem);
            this.selectedExpressions.splice(index, 1);
            this.deselectParentRecursive(expressionItem);
        }
    }
    /**
     * @private
     * @return {?}
     */
    toggleContextMenu() {
        /** @type {?} */
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            if (contextualGroup) {
                this.filteringLogics = [
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                        selected: contextualGroup.operator === FilteringLogic.And
                    },
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                        selected: contextualGroup.operator === FilteringLogic.Or
                    }
                ];
            }
        }
        else {
            this.contextMenuToggle.close();
        }
    }
    /**
     * @private
     * @return {?}
     */
    findSingleSelectedGroup() {
        for (const group of this.selectedGroups) {
            /** @type {?} */
            const containsAllSelectedExpressions = this.selectedExpressions.every(op => this.isInsideGroup(op, group));
            if (containsAllSelectedExpressions) {
                return group;
            }
        }
        return null;
    }
    /**
     * @private
     * @param {?} item
     * @param {?} group
     * @return {?}
     */
    isInsideGroup(item, group) {
        if (!item) {
            return false;
        }
        if (item.parent === group) {
            return true;
        }
        return this.isInsideGroup(item.parent, group);
    }
    /**
     * @private
     * @param {?} expressionItem
     * @return {?}
     */
    deleteItem(expressionItem) {
        if (!expressionItem.parent) {
            this.rootGroup = null;
            this.currentGroup = null;
            return;
        }
        if (expressionItem === this.currentGroup) {
            this.currentGroup = this.currentGroup.parent;
        }
        /** @type {?} */
        const children = expressionItem.parent.children;
        /** @type {?} */
        const index = children.indexOf(expressionItem);
        children.splice(index, 1);
        if (!children.length) {
            this.deleteItem(expressionItem.parent);
        }
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
        if (!this.contextMenuToggle.collapsed &&
            (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */)) {
            this.clearSelection();
        }
    }
    /**
     * @return {?}
     */
    createAndGroup() {
        this.createGroup(FilteringLogic.And);
    }
    /**
     * @return {?}
     */
    createOrGroup() {
        this.createGroup(FilteringLogic.Or);
    }
    /**
     * @private
     * @param {?} operator
     * @return {?}
     */
    createGroup(operator) {
        /** @type {?} */
        const chips = this.chips.toArray();
        /** @type {?} */
        const minIndex = this.selectedExpressions.reduce((i, e) => Math.min(i, chips.findIndex(c => c.data === e)), Number.MAX_VALUE);
        /** @type {?} */
        const firstExpression = chips[minIndex].data;
        /** @type {?} */
        const parent = firstExpression.parent;
        /** @type {?} */
        const groupItem = new ExpressionGroupItem(operator, parent);
        /** @type {?} */
        const index = parent.children.indexOf(firstExpression);
        parent.children.splice(index, 0, groupItem);
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
            groupItem.children.push(expr);
            expr.parent = groupItem;
        }
        this.clearSelection();
    }
    /**
     * @return {?}
     */
    deleteFilters() {
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
        }
        this.clearSelection();
    }
    /**
     * @param {?} groupItem
     * @return {?}
     */
    onGroupClick(groupItem) {
        this.toggleGroup(groupItem);
    }
    /**
     * @private
     * @param {?} groupItem
     * @return {?}
     */
    toggleGroup(groupItem) {
        this.exitOperandEdit();
        if (groupItem.children && groupItem.children.length) {
            this.toggleGroupRecursive(groupItem, !groupItem.selected);
            if (!groupItem.selected) {
                this.deselectParentRecursive(groupItem);
            }
            this.toggleContextMenu();
        }
    }
    /**
     * @private
     * @param {?} groupItem
     * @param {?} selected
     * @return {?}
     */
    toggleGroupRecursive(groupItem, selected) {
        if (groupItem.selected !== selected) {
            groupItem.selected = selected;
            if (groupItem.selected) {
                this.selectedGroups.push(groupItem);
            }
            else {
                /** @type {?} */
                const index = this.selectedGroups.indexOf(groupItem);
                this.selectedGroups.splice(index, 1);
            }
        }
        for (const expr of groupItem.children) {
            if (expr instanceof ExpressionGroupItem) {
                this.toggleGroupRecursive(expr, selected);
            }
            else {
                /** @type {?} */
                const operandExpression = (/** @type {?} */ (expr));
                if (operandExpression.selected !== selected) {
                    this.toggleExpression(operandExpression);
                }
            }
        }
    }
    /**
     * @private
     * @param {?} expressionItem
     * @return {?}
     */
    deselectParentRecursive(expressionItem) {
        /** @type {?} */
        const parent = expressionItem.parent;
        if (parent) {
            if (parent.selected) {
                parent.selected = false;
                /** @type {?} */
                const index = this.selectedGroups.indexOf(parent);
                this.selectedGroups.splice(index, 1);
            }
            this.deselectParentRecursive(parent);
        }
    }
    /**
     * @private
     * @return {?}
     */
    calculateContextMenuTarget() {
        /** @type {?} */
        const containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const chips = this.chips.filter(c => this.selectedExpressions.indexOf(c.data) !== -1);
        /** @type {?} */
        let minTop = chips.reduce((t, c) => Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top), Number.MAX_VALUE);
        minTop = Math.max(containerRect.top, minTop);
        minTop = Math.min(containerRect.bottom, minTop);
        /** @type {?} */
        let maxRight = chips.reduce((r, c) => Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right), 0);
        maxRight = Math.max(maxRight, containerRect.left);
        maxRight = Math.min(maxRight, containerRect.right);
        this._overlaySettings.positionStrategy.settings.target = new Point(maxRight, minTop);
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    scrollElementIntoView(target) {
        /** @type {?} */
        const container = this.expressionsContainer.nativeElement;
        /** @type {?} */
        const targetOffset = target.offsetTop - container.offsetTop;
        /** @type {?} */
        const delta = 10;
        if (container.scrollTop + delta > targetOffset) {
            container.scrollTop = targetOffset - delta;
        }
        else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
            container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
        }
    }
    /**
     * @return {?}
     */
    ungroup() {
        /** @type {?} */
        const selectedGroup = this.contextualGroup;
        /** @type {?} */
        const parent = selectedGroup.parent;
        if (parent) {
            /** @type {?} */
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1, ...selectedGroup.children);
            for (const expr of selectedGroup.children) {
                expr.parent = parent;
            }
        }
        this.clearSelection();
    }
    /**
     * @return {?}
     */
    deleteGroup() {
        /** @type {?} */
        const selectedGroup = this.contextualGroup;
        /** @type {?} */
        const parent = selectedGroup.parent;
        if (parent) {
            /** @type {?} */
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1);
        }
        else {
            this.rootGroup = null;
        }
        this.clearSelection();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    selectFilteringLogic(event) {
        this.contextualGroup.operator = (/** @type {?} */ (event.index));
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getConditionFriendlyName(name) {
        return this.grid.resourceStrings[`igx_grid_filter_${name}`] || name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isDate(value) {
        return value instanceof Date;
    }
    /**
     * @return {?}
     */
    onExpressionsScrolled() {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
        }
    }
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    invokeClick(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            ((/** @type {?} */ (eventArgs.currentTarget))).click();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onOutletPointerDown(event) {
        // This prevents closing the select's dropdown when clicking the scroll
        event.preventDefault();
    }
    /**
     * @return {?}
     */
    getConditionList() {
        return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
    }
    /**
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} overlayComponentId
     * @return {?}
     */
    initialize(filteringService, overlayService, overlayComponentId) {
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.overlayComponentId = overlayComponentId;
        this.filteringService.registerSVGIcons();
        // Set pointer-events to none of the overlay content element which blocks the grid interaction after dragging
        this.overlayService.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
            if (this.element.nativeElement.parentElement) {
                this.element.nativeElement.parentElement.style['pointer-events'] = 'none';
            }
        });
        if (this.grid.advancedFilteringExpressionsTree) {
            this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
            this.currentGroup = this.rootGroup;
        }
    }
    /**
     * @param {?} expression
     * @param {?=} afterExpression
     * @return {?}
     */
    context(expression, afterExpression) {
        return {
            $implicit: expression,
            afterExpression
        };
    }
    /**
     * @return {?}
     */
    onClearButtonClick() {
        this.clearSelection();
        this.cancelOperandAdd();
        this.cancelOperandEdit();
        this.currentGroup = null;
        this.rootGroup = null;
        this.grid.advancedFilteringExpressionsTree = null;
    }
    /**
     * @return {?}
     */
    closeDialog() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
        }
    }
    /**
     * @return {?}
     */
    applyChanges() {
        this.exitOperandEdit();
        this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
    }
    /**
     * @return {?}
     */
    onApplyButtonClick() {
        this.applyChanges();
        this.closeDialog();
    }
    /**
     * @return {?}
     */
    onChipSelectionEnd() {
        /** @type {?} */
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            this.calculateContextMenuTarget();
            if (this.contextMenuToggle.collapsed) {
                this.contextMenuToggle.open(this._overlaySettings);
            }
            else {
                this.contextMenuToggle.reposition();
            }
        }
    }
}
IgxAdvancedFilteringDialogComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-advanced-filtering-dialog',
                template: "<article\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact'\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (onRemove)=\"onChipRemove(expressionItem)\"\n                          (onSelectionDone)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.expression.fieldName }}</span>\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"expressionItem.expression.condition.iconName\"\n                    >\n                    </igx-icon>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{ isDate(expressionItem.expression.searchVal) ? (expressionItem.expression.searchVal | igxdate:grid.locale) : expressionItem.expression.searchVal }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-icon *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\"\n                              igxPrefix\n                              fontSet=\"filtering-icons\"\n                              [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                    </igx-icon>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <igx-icon fontSet=\"filtering-icons\"\n                                  [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                        </igx-icon>\n                        <span>{{getConditionFriendlyName(condition)}}</span>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outletDirective\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"value | igxdate: grid.locale\"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon fontSet=\"material\">check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon fontSet=\"material\">close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon fontSet=\"material\">close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (onSelect)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon fontSet=\"filtering-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            }] }
];
/** @nocollapse */
IgxAdvancedFilteringDialogComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxAdvancedFilteringDialogComponent.propDecorators = {
    filteringService: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    overlayComponentId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    overlayService: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['columnSelect', { read: IgxSelectComponent, static: false },] }],
    conditionSelect: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['conditionSelect', { read: IgxSelectComponent, static: false },] }],
    searchValueInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['searchValueInput', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    addRootAndGroupButton: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['addRootAndGroupButton', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    addConditionButton: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['addConditionButton', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    editingInputsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['editingInputsContainer', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    addModeContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['addModeContainer', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    currentGroupButtonsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['currentGroupButtonsContainer', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    contextMenuToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxToggleDirective, { static: true },] }],
    chips: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxChipComponent,] }],
    expressionsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['expressionsContainer', { static: true },] }],
    overlayOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    display: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.display',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxRowSelectorDirective {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxRowSelectorDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowSelector]'
            },] }
];
/** @nocollapse */
IgxRowSelectorDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxHeadSelectorDirective {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxHeadSelectorDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxHeadSelector]'
            },] }
];
/** @nocollapse */
IgxHeadSelectorDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxRowSelectorsModule {
}
IgxRowSelectorsModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxRowSelectorDirective, IgxHeadSelectorDirective],
                exports: [IgxRowSelectorDirective, IgxHeadSelectorDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGroupByRowTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxGroupByRowTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxGroupByRow]'
            },] }
];
/** @nocollapse */
IgxGroupByRowTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * @hidden
 */
class IgxRowExpandedIndicatorDirective {
}
IgxRowExpandedIndicatorDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowExpandedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxRowCollapsedIndicatorDirective {
}
IgxRowCollapsedIndicatorDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowCollapsedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxHeaderExpandIndicatorDirective {
}
IgxHeaderExpandIndicatorDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxHeaderExpandedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxHeaderCollapseIndicatorDirective {
}
IgxHeaderCollapseIndicatorDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxHeaderCollapsedIndicator]'
            },] }
];
/**
 * @hidden
 */
class IgxGroupAreaDropDirective extends IgxDropDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} zone
     */
    constructor(elementRef, renderer, zone) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.hovered = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        /** @type {?} */
        const drag = event.detail.owner;
        /** @type {?} */
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        /** @type {?} */
        const grid = (/** @type {?} */ (column.grid));
        /** @type {?} */
        const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
        if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
            drag.icon.innerText = 'group_work';
            this.hovered = true;
        }
        else {
            drag.icon.innerText = 'block';
            this.hovered = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        /** @type {?} */
        const drag = event.detail.owner;
        /** @type {?} */
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        event.detail.owner.icon.innerText = 'block';
        this.hovered = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragDrop(event) {
        /** @type {?} */
        const drag = event.detail.owner;
        if (drag instanceof IgxColumnMovingDragDirective) {
            /** @type {?} */
            const column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            /** @type {?} */
            const grid = (/** @type {?} */ (column.grid));
            /** @type {?} */
            const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
                grid.groupBy({ fieldName: column.field, dir: SortingDirection.Asc, ignoreCase: column.sortingIgnoreCase,
                    strategy: column.sortStrategy, groupingComparer: column.groupingComparer });
            }
        }
    }
    /**
     * @private
     * @param {?} elem
     * @param {?} attr
     * @return {?}
     */
    closestParentByAttr(elem, attr) {
        return elem.hasAttribute(attr) ?
            elem :
            this.closestParentByAttr(elem.parentElement, attr);
    }
    /**
     * @private
     * @param {?} column
     * @return {?}
     */
    columnBelongsToGrid(column) {
        /** @type {?} */
        const elem = this.elementRef.nativeElement;
        /** @type {?} */
        const closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
        if (!column) {
            return false;
        }
        else {
            /** @type {?} */
            const grid = (/** @type {?} */ (column.grid));
            if (!grid || grid.id !== closestGridID) {
                return false;
            }
            return true;
        }
    }
}
IgxGroupAreaDropDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxGroupAreaDrop]'
            },] }
];
/** @nocollapse */
IgxGroupAreaDropDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxGroupAreaDropDirective.propDecorators = {
    hovered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-drop-area--hover',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MINIMUM_COLUMN_WIDTH = 136;
/** @type {?} */
const FILTER_ROW_HEIGHT = 50;
// By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
// In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
// Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
// More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
// but in the same time we need to set row editing overlay outlet before opening the overlay itself.
/** @type {?} */
const MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
/** @type {?} */
const IgxGridTransaction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('IgxGridTransaction');
/**
 * @abstract
 */
class IgxGridBaseComponent extends DisplayDensityBase {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} colResizingService
     * @param {?} gridAPI
     * @param {?} _transactions
     * @param {?} elementRef
     * @param {?} zone
     * @param {?} document
     * @param {?} cdr
     * @param {?} resolver
     * @param {?} differs
     * @param {?} viewRef
     * @param {?} navigation
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} summaryService
     * @param {?} _displayDensityOptions
     */
    constructor(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.colResizingService = colResizingService;
        this.gridAPI = gridAPI;
        this._transactions = _transactions;
        this.elementRef = elementRef;
        this.zone = zone;
        this.document = document;
        this.cdr = cdr;
        this.resolver = resolver;
        this.differs = differs;
        this.viewRef = viewRef;
        this.navigation = navigation;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this._init = true;
        this._cdrRequests = false;
        this._cdrRequestRepaint = false;
        this._resourceStrings = CurrentResourceStrings.GridResStrings;
        this._emptyGridMessage = null;
        this._emptyFilteredGridMessage = null;
        this._isLoading = false;
        this._locale = null;
        this._destroyed = false;
        this.overlayIDs = [];
        this._advancedFilteringPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._advancedFilteringOverlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._advancedFilteringPositionSettings),
        };
        /**
         * An \@Input property that autogenerates the `IgxGridComponent` columns.
         * The default value is false.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.autoGenerate = false;
        /**
         * @hidden
         */
        this.filteringExpressionsTreeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.perPageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         * \@internal
         */
        this.rowDragging = false;
        /**
         * An \@Input property that adds styling classes applied to all even `IgxGridRowComponent`s in the grid.
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.evenRowCSS = 'igx-grid__tr--even';
        /**
         * An \@Input property that adds styling classes applied to all odd `IgxGridRowComponent`s in the grid.
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.oddRowCSS = 'igx-grid__tr--odd';
        /**
         * An \@Input property that sets the title to be displayed in the built-in column hiding UI.
         * ```html
         * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.columnHidingTitle = '';
        /**
         * An \@Input property that sets the title to be displayed in the UI of the column pinning.
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.columnPinningTitle = '';
        /**
         * Emitted when `IgxGridCellComponent` is clicked. Returns the `IgxGridCellComponent`.
         * ```html
         * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellClick(e){
         *     alert("The cell has been clicked!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onCellClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxGridCellComponent` is selected. Returns the `IgxGridCellComponent`.
         * ```html
         * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellSelect(e){
         *     alert("The cell has been selected!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         *  Emitted when `IgxGridRowComponent` is selected.
         * ```html
         * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellClickChange(e){
         *     alert("The selected row has been changed!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onRowSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` is pinned.
         * The index that the column is inserted at may be changed through the `insertAtIndex` property.
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnPinning = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent`
         * editing has been performed in the grid and the values have **not** been submitted (e.g. `Esc` key was pressed).
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      newValue: object,
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editCancel(event: IGridEditEventArgs){
         *    const rowID: IgxColumnComponent = event.rowID;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEditCancel)="editCancel($event)" [data]="remote | async" [primaryKey]="'ProductID'">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.onCellEditCancel = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent` enters edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editStart(event: IGridEditEventArgs){
         *    const value: IgxColumnComponent = event.newValue;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEditEnter)="editStart($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.onCellEditEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent` editing has been performed in the grid.
         * Event is fired after editing is completed, when the cell is exiting edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      newValue: object,
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editDone(event: IGridEditEventArgs){
         *    const value: IgxColumnComponent = event.newValue;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEdit)="editDone($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onCellEdit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" a row enters edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEditEnter)="editStart($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * ```typescript
         *      editStart(event: IGridEditEventArgs) {
         *          const editedRowObj = event.oldValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridComponent
         */
        this.onRowEditEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting  `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      newValue: <rowObj>,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEdit)="editDone($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         *
         * ```typescript
         *      editDone(event: IGridEditEventArgs) {
         *          const originalRowObj = event.oldValue;
         *          const updatedRowObj = event.newValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onRowEdit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" & `endEdit(false)` is called.
         * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
         * in the row editing overlay.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      newValue: <rowObj>,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEditCancel)="editCancel($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * ```typescript
         *      editCancel(emitted: { row: IgxGridRowComponent, newValue: any, oldValue: any }): void {
         *          const originalRowObj = event.oldValue;
         *          const updatedRowObj = event.newValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onRowEditCancel = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a grid column is initialized. Returns the column object.
         * ```html
         * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * initColumns(event: IgxColumnComponent) {
         * const column: IgxColumnComponent = event;
         *       column.filterable = true;
         *       column.sortable = true;
         *       column.editable = true;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnInit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when sorting is performed through the UI. Returns the sorting expression.
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
         * ```
         * ```typescript
         * sortingDone(event: SortingDirection){
         *     const sortingDirection = event;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onSortingDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when filtering is performed through the UI.
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * ```typescript
         * filteringDone(event: IFilteringExpressionsTree){
         *     const filteringTree = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onFilteringDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when paging is performed. Returns an object consisting of the previous and next pages.
         * ```typescript
         * pagingDone(event: IPageEventArgs){
         *     const paging = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onPagingDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridRowComponent` is being added to the `IgxGridComponent` through the API.
         * Returns the data for the new `IgxGridRowComponent` object.
         * ```typescript
         * rowAdded(event: IRowDataEventArgs){
         *    const rowInfo = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onRowAdded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridRowComponent` is deleted through the `IgxGridComponent` API.
         * Returns an `IRowDataEventArgs` object.
         * ```typescript
         * rowDeleted(event: IRowDataEventArgs){
         *    const rowInfo = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onRowDeleted = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onDataPreLoad = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` is resized.
         * Returns the `IgxColumnComponent` object's old and new width.
         * ```typescript
         * resizing(event: IColumnResizeEventArgs){
         *     const grouping = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnResized = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridCellComponent` is right clicked. Returns the `IgxGridCellComponent` object.
         * ```typescript
         * contextMenu(event: IGridCellEventArgs){
         *     const resizing = event;
         *     console.log(resizing);
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onContextMenu = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridCellComponent` is double clicked. Returns the `IgxGridCellComponent` object.
         * ```typescript
         * dblClick(event: IGridCellEventArgs){
         *     const dblClick = event;
         *     console.log(dblClick);
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onDoubleClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` visibility is changed. Args: { column: any, newValue: boolean }
         * ```typescript
         * visibilityChanged(event: IColumnVisibilityChangedEventArgs){
         *    const visiblity = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnVisibilityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` moving starts. Returns the moved `IgxColumnComponent` object.
         * ```typescript
         * movingStart(event: IColumnMovingStartEventArgs){
         *     const movingStarts = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnMovingStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted throughout the `IgxColumnComponent` moving operation.
         * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
         * ```typescript
         * moving(event: IColumnMovingEventArgs){
         *     const moving = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnMoving = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` moving ends.
         * Returns the source and target `IgxColumnComponent` objects.
         * ```typescript
         * movingEnds(event: IColumnMovingEndEventArgs){
         *     const movingEnds = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onColumnMovingEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when keydown is triggered over element inside grid's body.
         * This event is fired only if the key combination is supported in the grid.
         * Return the target type, target object and the original event. This event is cancelable.
         * ```typescript
         * customKeydown(args: IGridKeydownEventArgs) {
         *  const keydownEvent = args.event;
         * }
         * ```
         * ```html
         *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
         * ```
         */
        this.onGridKeydown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when start dragging a row.
         * Return the dragged row.
         */
        this.onRowDragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when dropping a row.
         * Return the dropped row.
         */
        this.onRowDragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a copy operation is executed.
         * Fired only if copy behavior is enabled through the [`clipboardOptions`]{\@link IgxGridBaseComponent#clipboardOptions}.
         */
        this.onGridCopy = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.columnList = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */
        this.tmpOutlets = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * The custom template, if any, that should be used when rendering a row expand indicator.
         */
        this.rowExpandedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a row collapse indicator.
         */
        this.rowCollapsedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header expand indicator.
         */
        this.headerExpandIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header collapse indicator.
         */
        this.headerCollapseIndicatorTemplate = null;
        /**
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.hostRole = 'grid';
        /**
         * @hidden
         */
        this.sortingExpressionsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.columnsWithNoSetWidths = null;
        /* Toolbar related definitions */
        this._showToolbar = false;
        this._exportExcel = false;
        this._exportCsv = false;
        this._toolbarTitle = null;
        this._exportText = null;
        this._exportExcelText = null;
        this._exportCsvText = null;
        this._rowEditable = false;
        this._filteredSortedData = null;
        /**
         * Provides access to the `IgxToolbarComponent`.
         * ```typescript
         * const gridToolbar = this.grid.toolbar;
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.toolbar = null;
        this.toolbarHtml = null;
        /**
         * Controls the copy behavior of the grid.
         */
        this.clipboardOptions = {
            /**
             * Enables/disables the copy behavior
             */
            enabled: true,
            /**
             * Include the columns headers in the clipboard output.
             */
            copyHeaders: true,
            /**
             * Apply the columns formatters (if any) on the data in the clipboard output.
             */
            copyFormatters: true,
            /**
             * The separator used for formatting the copy output. Defaults to `\t`.
             */
            separator: '\t'
        };
        /**
         * Emitted when an export process is initiated by the user.
         * ```typescript
         * toolbarExporting(event: IGridToolbarExportEventArgs){
         *     const toolbarExporting = event;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        this.onToolbarExporting = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /* End of toolbar related definitions */
        /**
         * Emitted when making a range selection either through
         * drag selection or through keyboard selection.
         */
        this.onRangeSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.calcHeight = 0;
        /**
         * @hidden
         */
        this.chipsGoupingExpressions = [];
        /**
         * @hidden
         */
        this.disableTransitions = false;
        /**
         * @hidden
         */
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        /**
         * @hidden
         */
        this.columnWidthSetByUser = false;
        /**
         * @hidden
         */
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this._perPage = 15;
        /**
         * @hidden
         */
        this._page = 0;
        /**
         * @hidden
         */
        this._paging = false;
        /**
         * @hidden
         */
        this._hideRowSelectors = false;
        /**
         * @hidden
         */
        this._rowDrag = false;
        /**
         * @hidden
         */
        this._pipeTrigger = 0;
        /**
         * @hidden
         */
        this._summaryPipeTrigger = 0;
        /**
         * @hidden
         */
        this._columns = [];
        /**
         * @hidden
         */
        this._pinnedColumns = [];
        /**
         * @hidden
         */
        this._unpinnedColumns = [];
        /**
         * @hidden
         */
        this._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        /**
         * @hidden
         */
        this._sortingExpressions = [];
        /**
         * @hidden
         */
        this._maxLevelHeaderDepth = null;
        /**
         * @hidden
         */
        this._columnHiding = false;
        /**
         * @hidden
         */
        this._columnPinning = false;
        this._allowFiltering = false;
        this._allowAdvancedFiltering = false;
        this._filterMode = FilterMode.quickFilter;
        this.observer = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](() => { });
        this.resizeNotify = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._hiddenColumnsText = '';
        this._pinnedColumnsText = '';
        this._height = '100%';
        this._width = '100%';
        this._horizontalForOfs = [];
        this._multiRowLayoutRowSize = 1;
        // Caches
        this._totalWidth = NaN;
        this._pinnedVisible = [];
        this._unpinnedVisible = [];
        this._pinnedWidth = NaN;
        this._unpinnedWidth = NaN;
        this._visibleColumns = [];
        this._columnGroups = false;
        this._defaultTargetRecordNumber = 10;
        this._summaryPosition = GridSummaryPosition.bottom;
        this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
        this._cellSelectionMode = GridSelectionMode.multiple;
        this._rowSelectionMode = GridSelectionMode.none;
        this.rowEditPositioningStrategy = new RowEditPositionStrategy({
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: null
        });
        this.rowEditSettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            outlet: this.rowOutletDirective,
            positionStrategy: this.rowEditPositioningStrategy
        };
        this.verticalScrollHandler = (event) => {
            this.verticalScrollContainer.onScroll(event);
            if (isEdge()) {
                this.wheelHandler(false);
            }
            this.disableTransitions = true;
            this.zone.run(() => {
                this.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                    this.verticalScrollContainer.onChunkLoad.emit(this.verticalScrollContainer.state);
                });
                if (this.rowEditable) {
                    this.changeRowEditingOverlayStateOnScroll(this.rowInEditMode);
                }
                this.disableTransitions = false;
            });
            this.hideOverlays();
        };
        this.horizontalScrollHandler = (event) => {
            /** @type {?} */
            const scrollLeft = event.target.scrollLeft;
            if (isEdge()) {
                this.wheelHandler(true);
            }
            this.headerContainer.onHScroll(scrollLeft);
            this._horizontalForOfs.forEach(vfor => vfor.onHScroll(scrollLeft));
            this.cdr.markForCheck();
            this.zone.run(() => {
                this.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                    this.parentVirtDir.onChunkLoad.emit(this.headerContainer.state);
                });
            });
            this.hideOverlays();
        };
        this.keydownHandler = (event) => {
            /** @type {?} */
            const key = event.key.toLowerCase();
            if ((isNavigationKey(key) && event.keyCode !== 32) || key === 'tab' || key === 'pagedown' || key === 'pageup') {
                event.preventDefault();
                if (key === 'pagedown') {
                    this.verticalScrollContainer.scrollNextPage();
                    this.nativeElement.focus();
                }
                else if (key === 'pageup') {
                    this.verticalScrollContainer.scrollPrevPage();
                    this.nativeElement.focus();
                }
            }
        };
        /**
         * @hidden
         */
        this.scrollHandler = (event) => {
            this.headerContainer.scrollPosition += event.target.scrollLeft;
            this.verticalScrollContainer.scrollPosition += event.target.scrollTop;
            event.target.scrollLeft = 0;
            event.target.scrollTop = 0;
        };
        /**
         * @hidden
         */
        this.wheelHandler = (isScroll = false) => {
            if (this.document.activeElement &&
                // tslint:disable-next-line:no-bitwise
                (this.document.activeElement.compareDocumentPosition(this.tbody.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS ||
                    // tslint:disable-next-line:no-bitwise
                    (this.document.activeElement.
                        compareDocumentPosition(this.tfoot.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS && isScroll))) {
                ((/** @type {?} */ (this.document.activeElement))).blur();
            }
        };
        /**
         * @hidden
         */
        this.rowEditingWheelHandler = (event) => {
            if (event.deltaY > 0) {
                this.verticalScrollContainer.scrollNext();
            }
            else {
                this.verticalScrollContainer.scrollPrev();
            }
        };
        this.cdr.detach();
    }
    /**
     * @return {?}
     */
    get scrollWidth() {
        return this._scrollWidth;
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     * @param {?} value
     * @return {?}
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     * @return {?}
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * @return {?}
     */
    get filteringLogic() {
        return this._filteringExpressionsTree.operator;
    }
    /**
     * Sets the filtering logic of the `IgxGridComponent`.
     * The default is AND.
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set filteringLogic(value) {
        this._filteringExpressionsTree.operator = value;
    }
    /**
     * Returns the filtering state of `IgxGridComponent`.
     * ```typescript
     * let filteringExpressionsTree = this.grid.filteringExpressionsTree;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get filteringExpressionsTree() {
        return this._filteringExpressionsTree;
    }
    /**
     * Sets the filtering state of the `IgxGridComponent`.
     * ```typescript
     * const logic = new FilteringExpressionsTree(FilteringLogic.And, "ID");
     * logic.filteringOperands = [
     *     {
     *          condition: IgxNumberFilteringOperand.instance().condition('greaterThan'),
     *          fieldName: 'ID',
     *          searchVal: 1
     *     }
     * ];
     * this.grid.filteringExpressionsTree = (logic);
     * ```
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set filteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            /** @type {?} */
            const val = ((/** @type {?} */ (value)));
            for (let index = 0; index < val.filteringOperands.length; index++) {
                if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                    /** @type {?} */
                    const newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);
                    newExpressionsTree.filteringOperands.push((/** @type {?} */ (val.filteringOperands[index])));
                    val.filteringOperands[index] = newExpressionsTree;
                }
            }
            // clone the filtering expression tree in order to trigger the filtering pipe
            /** @type {?} */
            const filteringExpressionTreeClone = new FilteringExpressionsTree(value.operator, value.fieldName);
            filteringExpressionTreeClone.type = FilteringExpressionsTreeType.Regular;
            filteringExpressionTreeClone.filteringOperands = value.filteringOperands;
            this._filteringExpressionsTree = filteringExpressionTreeClone;
            this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);
            if (this.filteringService.isFilteringExpressionsTreeEmpty() && !this.advancedFilteringExpressionsTree) {
                this.filteredData = null;
            }
            this.filteringService.refreshExpressions();
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this.notifyChanges();
        }
    }
    /**
     * Returns the advanced filtering state of `IgxGridComponent`.
     * ```typescript
     * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get advancedFilteringExpressionsTree() {
        return this._advancedFilteringExpressionsTree;
    }
    /**
     * Sets the advanced filtering state of the `IgxGridComponent`.
     * ```typescript
     * const logic = new FilteringExpressionsTree(FilteringLogic.And);
     * logic.filteringOperands = [
     *     {
     *          condition: IgxNumberFilteringOperand.instance().condition('greaterThan'),
     *          fieldName: 'ID',
     *          searchVal: 1
     *     },
     *     {
     *          condition: IgxStringFilteringOperand.instance().condition('contains'),
     *          fieldName: 'CompanyName',
     *          searchVal: 'a'
     *     }
     * ];
     * this.grid.advancedFilteringExpressionsTree = logic;
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set advancedFilteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            // clone the filtering expression tree in order to trigger the filtering pipe
            /** @type {?} */
            const filteringExpressionTreeClone = new FilteringExpressionsTree(value.operator, value.fieldName);
            filteringExpressionTreeClone.type = FilteringExpressionsTreeType.Advanced;
            filteringExpressionTreeClone.filteringOperands = value.filteringOperands;
            this._advancedFilteringExpressionsTree = filteringExpressionTreeClone;
        }
        else {
            this._advancedFilteringExpressionsTree = null;
        }
        if (this.filteringService.isFilteringExpressionsTreeEmpty() && !this.advancedFilteringExpressionsTree) {
            this.filteredData = null;
        }
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache();
        this.markForCheck();
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.onFilteringDone.emit(this._advancedFilteringExpressionsTree));
    }
    /**
     * Returns the locale of the grid.
     * If not set, returns browser's language.
     * @return {?}
     */
    get locale() {
        if (this._locale) {
            return this._locale;
        }
        else {
            return 'en';
        }
    }
    /**
     * Sets the locale of the grid.
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
    }
    /**
     * Returns whether the paging feature is enabled/disabled.
     * The default state is disabled (false).
     * ```
     * const paging = this.grid.paging;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get paging() {
        return this._paging;
    }
    /**
     * Enables/Disables the paging feature.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set paging(value) {
        this._paging = value;
        this._pipeTrigger++;
        this.notifyChanges(true);
    }
    /**
     * Returns the current page index.
     * ```html
     * let gridPage = this.grid.page;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get page() {
        return this._page;
    }
    /**
     * Sets the current page index.
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [page]="5" [autoGenerate]="true"></igx-grid>
     * ```
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    set page(val) {
        if (val === this._page || val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.selectionService.clear(true);
        this.onPagingDone.emit({ previous: this._page, current: val });
        this._page = val;
        this.pageChange.emit(this._page);
        this.notifyChanges();
    }
    /**
     * Returns the number of visible items per page of the `IgxGridComponent`.
     * The default is 15.
     * ```html
     * let itemsPerPage = this.grid.perPage;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get perPage() {
        return this._perPage;
    }
    /**
     * Sets the number of visible items per page of the `IgxGridComponent`.
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [perPage]="5" [autoGenerate]="true"></igx-grid>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    set perPage(val) {
        if (val < 0) {
            return;
        }
        this.selectionService.clear(true);
        this._perPage = val;
        this.perPageChange.emit(this._perPage);
        this.page = 0;
        this.endEdit(true);
        this.notifyChanges();
    }
    /**
     * Returns whether the column hiding UI for the `IgxGridComponent` is enabled.
     * By default it is disabled (false).
     * ```typescript
     * let gridColHiding = this.grid.columnHiding;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get columnHiding() {
        return this._columnHiding;
    }
    /**
     * Sets whether the column hiding UI for the `IgxGridComponent` is enabled.
     * In order for the UI to work, you need to enable the toolbar as shown in the example below.
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set columnHiding(value) {
        if (this._columnHiding !== value) {
            this._columnHiding = value;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * @return {?}
     */
    get rowSelectable() {
        return this.isRowSelectable;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set rowSelectable(val) {
        this.rowSelection = val ? GridSelectionMode.multiple : GridSelectionMode.none;
    }
    /**
     * Returns if the row selectors are hidden
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hideRowSelectors() {
        return this._hideRowSelectors;
    }
    /**
     * Allows you to change the visibility of the row selectors
     * By default row selectors are shown
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set hideRowSelectors(value) {
        this._hideRowSelectors = value;
        this.notifyChanges(true);
    }
    /**
     * @return {?}
     */
    get rowDraggable() {
        return this._rowDrag && this.hasVisibleColumns;
    }
    /**
     * Sets whether rows can be moved.
     * ```html
     * <igx-grid #grid [rowDraggable]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    set rowDraggable(val) {
        this._rowDrag = val;
        this.notifyChanges(true);
    }
    /**
     * Sets whether the `IgxGridRowComponent` is editable.
     * By default it is set to false.
     * ```typescript
     * let rowEditable = this.grid.rowEditable;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get rowEditable() {
        return this._rowEditable;
    }
    /**
     * Sets whether rows can be edited.
     * ```html
     * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    set rowEditable(val) {
        if (!this._init) {
            this.refreshGridState();
        }
        this._rowEditable = val;
        this.notifyChanges();
    }
    /**
     * Returns the height of the `IgxGridComponent`.
     * ```typescript
     * let gridHeight = this.grid.height;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get height() {
        return this._height;
    }
    /**
     * Sets the height of the `IgxGridComponent`.
     * ```html
     * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set height(value) {
        if (this._height !== value) {
            this._height = value;
            this.nativeElement.style.height = value;
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get hostWidth() {
        return this._width || this._hostWidth;
    }
    /**
     * Returns the width of the `IgxGridComponent`.
     * ```typescript
     * let gridWidth = this.grid.width;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get width() {
        return this._width;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        if (this._width !== value) {
            this._width = value;
            this.nativeElement.style.width = value;
            this.notifyChanges(true);
        }
    }
    /**
     * Returns the width of the header of the `IgxGridComponent`.
     * ```html
     * let gridHeaderWidth = this.grid.headerWidth;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get headerWidth() {
        return parseInt(this.width, 10) - 17;
    }
    /**
     * Returns the row height.
     * ```typescript
     * const rowHeight = this.grid.rowHeight;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get rowHeight() {
        return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
    }
    /**
     * Sets the row height.
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set rowHeight(value) {
        this._rowHeight = parseInt(value, 10);
    }
    /**
     * An \@Input property that sets the default width of the `IgxGridComponent`'s columns.
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get columnWidth() {
        return this._columnWidth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set columnWidth(value) {
        this._columnWidth = value;
        this.columnWidthSetByUser = true;
        this.notifyChanges(true);
    }
    /**
     * An \@Input property that sets the message displayed when there are no records.
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set emptyGridMessage(value) {
        this._emptyGridMessage = value;
    }
    /**
     * An accessor that returns the message displayed when there are no records.
     * @return {?}
     */
    get emptyGridMessage() {
        return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
    }
    /**
     * An \@Input property that sets whether the grid is going to show loading indicator.
     * ```html
     * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set isLoading(value) {
        if (this._isLoading !== value) {
            this._isLoading = value;
            this.evaluateLoadingState();
        }
        Promise.resolve().then(() => {
            // wait for the current detection cycle to end before triggering a new one.
            this.notifyChanges();
        });
    }
    /**
     * An accessor that returns whether the grid is showing loading indicator.
     * @return {?}
     */
    get isLoading() {
        return this._isLoading;
    }
    /**
     * An \@Input property that sets the message displayed when there are no records and the grid is filtered.
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set emptyFilteredGridMessage(value) {
        this._emptyFilteredGridMessage = value;
    }
    /**
     * An accessor that returns the message displayed when there are no records and the grid is filtered.
     * @return {?}
     */
    get emptyFilteredGridMessage() {
        return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
    }
    /**
     * Returns if the built-in column pinning UI should be shown in the toolbar.
     * ```typescript
     *  let colPinning = this.grid.columnPinning;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get columnPinning() {
        return this._columnPinning;
    }
    /**
     * Sets if the built-in column pinning UI should be shown in the toolbar.
     * By default it's disabled.
     * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set columnPinning(value) {
        if (this._columnPinning !== value) {
            this._columnPinning = value;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns if the filtering is enabled.
     * ```typescript
     *  let filtering = this.grid.allowFiltering;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get allowFiltering() {
        return this._allowFiltering;
    }
    /**
     * Sets if the filtering is enabled.
     * By default it's disabled.
     * ```html
     * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set allowFiltering(value) {
        if (this._allowFiltering !== value) {
            this._allowFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.calcGridHeadRow();
            }
            this.filteringService.isFilterRowVisible = false;
            this.filteringService.filteredColumn = null;
            this.notifyChanges(true);
        }
    }
    /**
     * Returns a value indicating whether the advanced filtering is enabled.
     * ```typescript
     *  let filtering = this.grid.allowAdvancedFiltering;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get allowAdvancedFiltering() {
        return this._allowAdvancedFiltering;
    }
    /**
     * Sets a value indicating whether the advanced filtering is enabled.
     * By default it's disabled.
     * ```html
     * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set allowAdvancedFiltering(value) {
        if (this._allowAdvancedFiltering !== value) {
            this._allowAdvancedFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns the filter mode.
     * ```typescript
     *  let filtering = this.grid.filterMode;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get filterMode() {
        return this._filterMode;
    }
    /**
     * Sets filter mode.
     * By default it's set to FilterMode.quickFilter.
     * ```html
     * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set filterMode(value) {
        this._filterMode = value;
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.close();
        }
        this.notifyChanges(true);
    }
    /**
     * Returns the summary position.
     * ```typescript
     *  let summaryPosition = this.grid.summaryPosition;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get summaryPosition() {
        return this._summaryPosition;
    }
    /**
     * Sets summary position.
     * By default it is bottom.
     * ```html
     * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set summaryPosition(value) {
        this._summaryPosition = value;
        this.notifyChanges();
    }
    /**
     * Returns the summary calculation mode.
     * ```typescript
     *  let summaryCalculationMode = this.grid.summaryCalculationMode;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get summaryCalculationMode() {
        return this._summaryCalculationMode;
    }
    /**
     * Sets summary calculation mode.
     * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
     * ```html
     * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set summaryCalculationMode(value) {
        this._summaryCalculationMode = value;
        if (!this._init) {
            this.endEdit(true);
            this.summaryService.resetSummaryHeight();
            this.notifyChanges(true);
        }
    }
    /**
     * Gets the filtering strategy of the grid.
     * ```typescript
     *  let filterStrategy = this.grid.filterStrategy
     * ```
     * @return {?}
     */
    get filterStrategy() {
        return this._filteringStrategy;
    }
    /**
     * Sets the filtering strategy of the grid.
     * ```html
     *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
     * ```
     * @param {?} classRef
     * @return {?}
     */
    set filterStrategy(classRef) {
        this._filteringStrategy = classRef;
    }
    /**
     * A list of all `IgxGridHeaderGroupComponent`.
     * ```typescript
     * const headerGroupsList = this.grid.headerGroupsList;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get headerGroupsList() {
        return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
    }
    /**
     * A list of all `IgxGridHeaderComponent`.
     * ```typescript
     * const headers = this.grid.headerCellList;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get headerCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.headerCell).filter((headerCell) => headerCell);
    }
    /**
     * A list of all `IgxGridFilteringCellComponent`.
     * ```typescript
     * const filterCells = this.grid.filterCellList;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get filterCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.filterCell).filter((filterCell) => filterCell);
    }
    /**
     * @return {?}
     */
    get summariesRowList() {
        /** @type {?} */
        const res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        if (!this._summaryRowList) {
            return res;
        }
        /** @type {?} */
        const sumList = this._summaryRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        });
        res.reset(sumList);
        return res;
    }
    /**
     * A list of `IgxGridRowComponent`.
     * ```typescript
     * const rowList = this.grid.rowList;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get rowList() {
        /** @type {?} */
        const res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        if (!this._rowList) {
            return res;
        }
        /** @type {?} */
        const rList = this._rowList
            .filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        })
            .sort((a, b) => {
            return a.index - b.index;
        });
        res.reset(rList);
        return res;
    }
    /**
     * A list of `IgxGridRowComponent`, currently rendered.
     * ```typescript
     * const dataList = this.grid.dataRowList;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get dataRowList() {
        /** @type {?} */
        const res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        if (!this._dataRowList) {
            return res;
        }
        /** @type {?} */
        const rList = this._dataRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        }).sort((a, b) => {
            return a.index - b.index;
        });
        res.reset(rList);
        return res;
    }
    /**
     * Returns the template which will be used by the toolbar to show custom content.
     * ```typescript
     * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get toolbarCustomContentTemplate() {
        return this.toolbarCustomContentTemplates.first;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get headSelectorTemplate() {
        if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
            return this.headSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get rowSelectorTemplate() {
        if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
            return this.rowSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden
     * @return {?}
     */
    get outletDirective() {
        return this._outletDirective;
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowOutletDirective() {
        return this.rowEditingOutletDirective;
    }
    /**
     * @hidden
     * @return {?}
     */
    get parentRowOutletDirective() {
        return null;
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowEditContainer() {
        return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowInEditMode() {
        /** @type {?} */
        const editRowState = this.crudService.row;
        return editRowState !== null ? this.rowList.find(e => e.rowID === editRowState.id) : null;
    }
    /**
     * @hidden
     * @return {?}
     */
    get firstEditableColumnIndex() {
        /** @type {?} */
        const index = this.navigation.gridOrderedColumns.findIndex(e => e.editable);
        return index !== -1 ? index : null;
    }
    /**
     * @hidden
     * @return {?}
     */
    get lastEditableColumnIndex() {
        /** @type {?} */
        const orderedColumns = this.navigation.gridOrderedColumns;
        /** @type {?} */
        const index = orderedColumns.reverse().findIndex(e => e.editable);
        return index !== -1 ? orderedColumns.length - 1 - index : null;
    }
    /**
     * @hidden
     * TODO: Nav service logic doesn't handle 0 results from this querylist
     * @return {?}
     */
    get rowEditTabs() {
        return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hostClass() {
        return this.getComponentDensityClass('igx-grid');
    }
    /**
     * @return {?}
     */
    get bannerClass() {
        /** @type {?} */
        const position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
        return `${this.getComponentDensityClass('igx-banner')} ${position}`;
    }
    /**
     * @hidden
     * @return {?}
     */
    get pipeTrigger() {
        return this._pipeTrigger;
    }
    /**
     * @hidden
     * @return {?}
     */
    get summaryPipeTrigger() {
        return this._summaryPipeTrigger;
    }
    /**
     * Returns the sorting state of the `IgxGridComponent`.
     * ```typescript
     * const sortingState = this.grid.sortingExpressions;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get sortingExpressions() {
        return this._sortingExpressions;
    }
    /**
     * Sets the sorting state of the `IgxGridComponent`.
     * ```typescript
     * this.grid.sortingExpressions = [{
     *     fieldName: "ID",
     *     dir: SortingDirection.Desc,
     *     ignoreCase: true
     * }];
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set sortingExpressions(value) {
        this._sortingExpressions = cloneArray(value);
        this.sortingExpressionsChange.emit(this._sortingExpressions);
        this.notifyChanges();
    }
    /**
     * @hidden
     * @return {?}
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                this.columnList.reduce((acc, col) => Math.max(acc, col.rowStart), 0) :
                this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * Returns the number of hidden `IgxColumnComponent`.
     * ```typescript
     * const hiddenCol = this.grid.hiddenColumnsCount;
     * ``
     * @return {?}
     */
    get hiddenColumnsCount() {
        return this.columnList.filter((col) => col.columnGroup === false && col.hidden === true).length;
    }
    /**
     * Returns the text to be displayed inside the toggle button
     * for the built-in column hiding UI of the`IgxColumnComponent`.
     * ```typescript
     * const hiddenColText = this.grid.hiddenColumnsText;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hiddenColumnsText() {
        return this._hiddenColumnsText;
    }
    /**
     * Sets the text to be displayed inside the toggle button
     * for the built-in column hiding UI of the`IgxColumnComponent`.
     * ```typescript
     * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set hiddenColumnsText(value) {
        this._hiddenColumnsText = value;
    }
    /**
     * Returns the text to be displayed inside the toggle button
     * for the built-in column pinning UI of the`IgxColumnComponent`.
     * ```typescript
     * const pinnedText = this.grid.pinnedColumnsText;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get pinnedColumnsText() {
        return this._pinnedColumnsText;
    }
    /**
     * Sets the text to be displayed inside the toggle button
     * for the built-in column pinning UI of the`IgxColumnComponent`.
     * ```html
     * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @return {?}
     */
    set pinnedColumnsText(value) {
        this._pinnedColumnsText = value;
    }
    /**
     * Get transactions service for the grid.
     * @return {?}
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * @hidden
     * @return {?}
     */
    get currentRowState() {
        return this._currentRowState;
    }
    /**
     * Returns whether the `IgxGridComponent`'s toolbar is shown or hidden.
     * ```typescript
     * const toolbarGrid = this.grid.showToolbar;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get showToolbar() {
        return this._showToolbar;
    }
    /**
     * Shows or hides the `IgxGridComponent`'s toolbar.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set showToolbar(newValue) {
        if (this._showToolbar !== newValue) {
            this._showToolbar = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns the toolbar's title.
     * ```typescript
     * const toolbarTitle  = this.grid.toolbarTitle;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get toolbarTitle() {
        return this._toolbarTitle;
    }
    /**
     * Sets the toolbar's title.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set toolbarTitle(newValue) {
        if (this._toolbarTitle !== newValue) {
            this._toolbarTitle = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns whether the option for exporting to MS Excel is enabled or disabled.
     * ```typescript
     * cosnt excelExporter = this.grid.exportExcel;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get exportExcel() {
        return this.getExportExcel();
    }
    /**
     * Enable or disable the option for exporting to MS Excel.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set exportExcel(newValue) {
        if (this._exportExcel !== newValue) {
            this._exportExcel = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns whether the option for exporting to CSV is enabled or disabled.
     * ```typescript
     * const exportCsv = this.grid.exportCsv;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get exportCsv() {
        return this.getExportCsv();
    }
    /**
     * Enable or disable the option for exporting to CSV.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set exportCsv(newValue) {
        if (this._exportCsv !== newValue) {
            this._exportCsv = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns the textual content for the main export button.
     * ```typescript
     * const exportText = this.grid.exportText;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get exportText() {
        return this._exportText;
    }
    /**
     * Sets the textual content for the main export button.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set exportText(newValue) {
        if (this._exportText !== newValue) {
            this._exportText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns the textual content for the MS Excel export button.
     * ```typescript
     * const excelText = this.grid.exportExcelText;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get exportExcelText() {
        return this._exportExcelText;
    }
    /**
     * Sets the textual content for the MS Excel export button.
     * ```html
     * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set exportExcelText(newValue) {
        if (this._exportExcelText !== newValue) {
            this._exportExcelText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns the textual content for the CSV export button.
     * ```typescript
     * const csvText = this.grid.exportCsvText;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get exportCsvText() {
        return this._exportCsvText;
    }
    /**
     * Sets the textual content for the CSV export button.
     * ```html
     * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} newValue
     * @return {?}
     */
    set exportCsvText(newValue) {
        if (this._exportCsvText !== newValue) {
            this._exportCsvText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Returns the current cell selection state, which can be none, single or multiple
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get cellSelection() {
        return this._cellSelectionMode;
    }
    /**
     * Allows you to set cell selection mode
     * By default the cell selection mode is multiple
     * \@memberof IgxGridBaseComponent
     * @param {?} selectionMode
     * @return {?}
     */
    set cellSelection(selectionMode) {
        this._cellSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clear(true);
            this.notifyChanges();
        }
    }
    /**
     * Returns the current row selection state, which can be none, single or multiple
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get rowSelection() {
        return this._rowSelectionMode;
    }
    /**
     * Allows you to set row selection mode
     * By default the row selection mode is none
     * \@memberof IgxGridBaseComponent
     * @param {?} selectionMode
     * @return {?}
     */
    set rowSelection(selectionMode) {
        this._rowSelectionMode = selectionMode;
        if (this.gridAPI.grid && this.columnList) {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    hideOverlays() {
        this.overlayIDs.forEach(overlayID => {
            this.overlayService.hide(overlayID);
            this.overlayService.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(o => o.id === overlayID), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => {
                this.nativeElement.focus();
            });
        });
    }
    /**
     * @return {?}
     */
    _setupServices() {
        this.gridAPI.grid = this;
        this.crudService.grid = this;
        this.selectionService.grid = this;
        this.navigation.grid = this;
        this.filteringService.grid = this;
        this.summaryService.grid = this;
    }
    /**
     * @return {?}
     */
    _setupListeners() {
        /** @type {?} */
        const destructor = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$);
        this.onRowAdded.pipe(destructor).subscribe(args => this.refreshGridState(args));
        this.onRowDeleted.pipe(destructor).subscribe(args => {
            this.summaryService.deleteOperation = true;
            this.summaryService.clearSummaryCache(args);
        });
        this.transactions.onStateUpdate.pipe(destructor).subscribe(() => {
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this._pipeTrigger++;
            this.notifyChanges();
            if (this.transactions.getAggregatedChanges(false).length === 0) {
                // Needs better check, calling 'transactions.clear()' will also trigger this
                if (this.gridAPI.atInexistingPage()) {
                    this.page--;
                }
            }
        });
        this.resizeNotify.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(() => !this._init), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttleTime"])(100))
            .subscribe(() => {
            this.zone.run(() => {
                this.notifyChanges(true);
            });
        });
        this.onPagingDone.pipe(destructor).subscribe(() => {
            this.endEdit(true);
            this.selectionService.clear(true);
        });
        this.onColumnMoving.pipe(destructor).subscribe(() => this.endEdit(true));
        this.onColumnResized.pipe(destructor).subscribe(() => this.endEdit(true));
        this.overlayService.onOpening.pipe(destructor).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                /** @type {?} */
                const instance = (/** @type {?} */ (event.componentRef.instance));
                if (instance) {
                    instance.initialize(this.filteringService, this.overlayService, event.id);
                }
            }
        });
        this.overlayService.onOpened.pipe(destructor).subscribe((event) => {
            // do not hide the advanced filtering overlay on scroll
            if (this._advancedFilteringOverlayId === event.id) {
                return;
            }
            if (this.overlayService.getOverlayById(event.id).settings.outlet === this.outletDirective &&
                this.overlayIDs.indexOf(event.id) < 0) {
                this.overlayIDs.push(event.id);
            }
        });
        this.overlayService.onClosed.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(() => !this._init)).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                this._advancedFilteringOverlayId = null;
                return;
            }
            /** @type {?} */
            const ind = this.overlayIDs.indexOf(event.id);
            if (ind !== -1) {
                this.overlayIDs.splice(ind, 1);
            }
        });
        this.verticalScrollContainer.onDataChanging.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(() => !this._init)).subscribe(($event) => {
            this.calculateGridHeight();
            $event.containerSize = this.calcHeight;
            this.evaluateLoadingState();
            this.notifyChanges(true);
        });
        this.verticalScrollContainer.onContentSizeChange.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(() => !this._init)).subscribe(($event) => {
            this.calculateGridSizes();
        });
        this.onDensityChanged.pipe(destructor).subscribe(() => {
            this.summaryService.summaryHeight = 0;
            this.endEdit(true);
            this.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this._setupServices();
        this._setupListeners();
        this.columnListDiffer = this.differs.find([]).create(null);
        this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
        this.shouldGenerate = this.autoGenerate;
        this._scrollWidth = this.getScrollWidth();
    }
    /**
     * @protected
     * @return {?}
     */
    setupColumns() {
        if (this.autoGenerate) {
            this.autogenerateColumns();
        }
        this.initColumns(this.columnList, (col) => this.onColumnInit.emit(col));
        this.columnListDiffer.diff(this.columnList);
        this.columnList.changes
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$))
            .subscribe((change) => { this.onColumnsChanged(change); });
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetColumnsCaches() {
        this.columnList.forEach(column => column.resetCaches());
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetForOfCache() {
        /** @type {?} */
        const firstVirtRow = this.dataRowList.first;
        if (firstVirtRow) {
            if (this._cdrRequests) {
                firstVirtRow.virtDirRow.cdr.detectChanges();
            }
            firstVirtRow.virtDirRow.assumeMaster();
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetColumnCollections() {
        this._visibleColumns.length = 0;
        this._pinnedVisible.length = 0;
        this._unpinnedVisible.length = 0;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetCachedWidths() {
        this._unpinnedWidth = NaN;
        this._pinnedWidth = NaN;
        this._totalWidth = NaN;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetCaches() {
        this.resetForOfCache();
        this.resetColumnsCaches();
        this.resetColumnCollections();
        this.resetCachedWidths();
        this.hasVisibleColumns = undefined;
        this._columnGroups = this.columnList.some(col => col.columnGroup);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        this.setupColumns();
    }
    /**
     * @return {?}
     */
    _setupRowObservers() {
        /** @type {?} */
        const elementFilter = (item) => this.isDefined(item.nativeElement.parentElement);
        /** @type {?} */
        const extractForOfs = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["pipe"])(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])((collection) => collection.filter(elementFilter).map(item => item.virtDirRow)));
        /** @type {?} */
        const rowListObserver = extractForOfs(this._dataRowList.changes);
        /** @type {?} */
        const summaryRowObserver = extractForOfs(this._summaryRowList.changes);
        Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["combineLatest"])([rowListObserver, summaryRowObserver]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$))
            .subscribe(([row, summary]) => this._horizontalForOfs = [...row, ...summary]);
        this._horizontalForOfs = [
            ...this._dataRowList.filter(elementFilter).map(item => item.virtDirRow),
            ...this._summaryRowList.filter(elementFilter).map(item => item.virtDirRow)
        ];
    }
    /**
     * @return {?}
     */
    _zoneBegoneListeners() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('keydown', this.keydownHandler);
            this.verticalScrollContainer.getScroll().addEventListener('scroll', this.verticalScrollHandler);
            this.headerContainer.getScroll().addEventListener('scroll', this.horizontalScrollHandler);
            this.observer = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](() => this.resizeNotify.next());
            this.observer.observe(this.nativeElement);
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.initPinning();
        this.calculateGridSizes();
        this._init = false;
        this.cdr.reattach();
        this._setupRowObservers();
        this._zoneBegoneListeners();
        /** @type {?} */
        const vertScrDC = this.verticalScrollContainer.displayContainer;
        vertScrDC.addEventListener('scroll', this.scrollHandler);
        vertScrDC.addEventListener('wheel', () => this.wheelHandler());
    }
    /**
     * @param {?=} repaint
     * @return {?}
     */
    notifyChanges(repaint = false) {
        this._cdrRequests = true;
        this._cdrRequestRepaint = repaint;
        this.cdr.markForCheck();
    }
    /**
     * @protected
     * @return {?}
     */
    resetNotifyChanges() {
        this._cdrRequestRepaint = false;
        this._cdrRequests = false;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
        if (this._init) {
            return;
        }
        if (this._cdrRequestRepaint) {
            this.resetNotifyChanges();
            this.calculateGridSizes();
            this.refreshSearch(true);
            return;
        }
        if (this._cdrRequests) {
            this.resetNotifyChanges();
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.tmpOutlets.forEach((tmplOutlet) => {
            tmplOutlet.cleanCache();
        });
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        if (this._advancedFilteringOverlayId) {
            this.overlayService.hide(this._advancedFilteringOverlayId);
        }
        this.zone.runOutsideAngular(() => {
            this.observer.disconnect();
            this.nativeElement.removeEventListener('keydown', this.keydownHandler);
            this.verticalScrollContainer.getScroll().removeEventListener('scroll', this.verticalScrollHandler);
            this.headerContainer.getScroll().removeEventListener('scroll', this.horizontalScrollHandler);
            /** @type {?} */
            const vertScrDC = this.verticalScrollContainer.displayContainer;
            vertScrDC.removeEventListener('scroll', this.scrollHandler);
            vertScrDC.removeEventListener('wheel', () => this.wheelHandler());
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /**
     * Toggles the specified column's visibility.
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} args
     * @return {?}
     */
    toggleColumnVisibility(args) {
        /** @type {?} */
        const col = args.column ? this.columnList.find((c) => c === args.column) : undefined;
        if (!col) {
            return;
        }
        col.hidden = args.newValue;
        this.onColumnVisibilityChanged.emit(args);
    }
    /**
     * Returns the native element of the `IgxGridComponent`.
     * ```typescript
     * const nativeEl = this.grid.nativeElement.
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get outlet() {
        return this.outletDirective;
    }
    /**
     * Returns the `IgxGridComponent`'s rows height.
     * ```typescript
     * const rowHeigh = this.grid.defaultRowHeight;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get defaultRowHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 40;
            case DisplayDensity.compact:
                return 32;
            default:
                return 50;
        }
    }
    /**
     * @return {?}
     */
    get defaultSummaryHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 30;
            case DisplayDensity.compact:
                return 24;
            default:
                return 36;
        }
    }
    /**
     * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
     * Used internally for restricting header group component width.
     * The values below depend on the header cell default right/left padding values.
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get defaultHeaderGroupMinWidth() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 32;
            case DisplayDensity.compact:
                return 24;
            default:
                return 48;
        }
    }
    /**
     * @return {?}
     */
    paginatorClassName() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 'igx-paginator--cosy';
            case DisplayDensity.compact:
                return 'igx-paginator--compact';
            default:
                return 'igx-paginator';
        }
    }
    /**
     * Returns the maximum width of the container for the pinned `IgxColumnComponent`s.
     * The width is 80% of the total grid width.
     * ```typescript
     * const maxPinnedColWidth = this.grid.calcPinnedContainerMaxWidth;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get calcPinnedContainerMaxWidth() {
        return (this.calcWidth * 80) / 100;
    }
    /**
     * Returns the minimum width of the container for the unpinned `IgxColumnComponent`s.
     * The width is 20% of the total grid width.
     * ```typescript
     * const minUnpinnedColWidth = this.grid.unpinnedAreaMinWidth;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get unpinnedAreaMinWidth() {
        return (this.calcWidth * 20) / 100;
    }
    /**
     * Returns the current width of the container for the pinned `IgxColumnComponent`s.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get pinnedWidth() {
        if (!isNaN(this._pinnedWidth)) {
            return this._pinnedWidth;
        }
        this._pinnedWidth = this.getPinnedWidth();
        return this._pinnedWidth;
    }
    /**
     * Returns the current width of the container for the unpinned `IgxColumnComponent`s.
     * ```typescript
     * const unpinnedWidth = this.grid.getUnpinnedWidth;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get unpinnedWidth() {
        if (!isNaN(this._unpinnedWidth)) {
            return this._unpinnedWidth;
        }
        this._unpinnedWidth = this.getUnpinnedWidth();
        return this._unpinnedWidth;
    }
    /**
     * @return {?}
     */
    get isHorizontalScrollHidden() {
        /** @type {?} */
        const diff = this.unpinnedWidth - this.totalWidth;
        return this.width === null || diff >= 0;
    }
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Update for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    get featureColumnsWidth() {
        return this.getFeatureColumnsWidth();
    }
    /**
     * @hidden
     * @return {?}
     */
    get summariesMargin() {
        return this.featureColumnsWidth;
    }
    /**
     * Returns an array of `IgxColumnComponent`s.
     * ```typescript
     * const colums = this.grid.columns.
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get columns() {
        return this._columns;
    }
    /**
     * Returns an array of the pinned `IgxColumnComponent`s.
     * ```typescript
     * const pinnedColumns = this.grid.pinnedColumns.
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get pinnedColumns() {
        if (this._pinnedVisible.length) {
            return this._pinnedVisible;
        }
        this._pinnedVisible = this._pinnedColumns.filter(col => !col.hidden);
        return this._pinnedVisible;
    }
    /**
     * Returns an array of unpinned `IgxColumnComponent`s.
     * ```typescript
     * const unpinnedColumns = this.grid.unpinnedColumns.
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get unpinnedColumns() {
        if (this._unpinnedVisible.length) {
            return this._unpinnedVisible;
        }
        this._unpinnedVisible = this._unpinnedColumns.filter((col) => !col.hidden);
        return this._unpinnedVisible;
    }
    /**
     * Returns the `width` to be set on `IgxGridHeaderGroupComponent`.
     * \@memberof IgxGridBaseComponent
     * @param {?} column
     * @return {?}
     */
    getHeaderGroupWidth(column) {
        if (this.hasColumnLayouts) {
            return '';
        }
        /** @type {?} */
        const colWidth = column.width;
        /** @type {?} */
        const minWidth = this.defaultHeaderGroupMinWidth;
        /** @type {?} */
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (!isPercentageWidth && parseInt(column.width, 10) < minWidth) {
            return minWidth.toString();
        }
        return column.width;
    }
    /**
     * Returns the `IgxColumnComponent` by field name.
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} name
     * @return {?}
     */
    getColumnByName(name) {
        return this.columnList.find((col) => col.field === name);
    }
    /**
     * Returns the `IgxRowComponent` by index.
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} index
     * @return {?}
     */
    getRowByIndex(index) {
        return this.gridAPI.get_row_by_index(index);
    }
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} keyValue
     * @return {?}
     */
    getRowByKey(keyValue) {
        return this.gridAPI.get_row_by_key(keyValue);
    }
    /**
     * Returns an array of visible `IgxColumnComponent`s.
     * ```typescript
     * const visibleColumns = this.grid.visibleColumns.
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get visibleColumns() {
        if (this._visibleColumns.length) {
            return this._visibleColumns;
        }
        this._visibleColumns = this.columnList.filter(c => !c.hidden);
        return this._visibleColumns;
    }
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIndex
     * @param {?} columnField
     * @return {?}
     */
    getCellByColumn(rowIndex, columnField) {
        /** @type {?} */
        const columnId = this.columnList.map((column) => column.field).indexOf(columnField);
        if (columnId !== -1) {
            return this.gridAPI.get_cell_by_index(rowIndex, columnId);
        }
    }
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * Requires that the primaryKey property is set.
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowSelector match any rowID
     * @param {?} columnField
     * @return {?}
     */
    getCellByKey(rowSelector, columnField) {
        return this.gridAPI.get_cell_by_key(rowSelector, columnField);
    }
    /**
     * Returns the total number of pages.
     * ```typescript
     * const totalPages = this.grid.totalPages;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get totalPages() {
        if (this.pagingState) {
            return this.pagingState.metadata.countPages;
        }
        return -1;
    }
    /**
     * Returns if the current page is the first page.
     * ```typescript
     * const firstPage = this.grid.isFirstPage;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Goes to the next page of the `IgxGridComponent`, if the grid is not already at the last page.
     * ```typescript
     * this.grid1.nextPage();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page of the `IgxGridComponent`, if the grid is not already at the first page.
     * ```typescript
     * this.grid1.previousPage();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Returns the total number of records.
     * Only functions when paging is enabled.
     * ```typescript
     * const totalRecords = this.grid.totalRecords;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get totalRecords() {
        if (this.pagingState) {
            return this.pagingState.metadata.countRecords;
        }
    }
    /**
     * Returns if the current page is the last page.
     * ```typescript
     * const lastPage = this.grid.isLastPage;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns the total width of the `IgxGridComponent`.
     * ```typescript
     * const gridWidth = this.grid.totalWidth;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get totalWidth() {
        if (!isNaN(this._totalWidth)) {
            return this._totalWidth;
        }
        // Take only top level columns
        /** @type {?} */
        const cols = this.visibleColumns.filter(col => col.level === 0 && !col.pinned);
        /** @type {?} */
        let totalWidth = 0;
        /** @type {?} */
        let i = 0;
        for (i; i < cols.length; i++) {
            totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
        }
        this._totalWidth = totalWidth;
        return totalWidth;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get showRowSelectors() {
        return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get showDragIcons() {
        return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
    }
    /**
     * @hidden
     * @protected
     * @param {?} from
     * @param {?} to
     * @param {?} pos
     * @return {?}
     */
    _moveColumns(from, to, pos) {
        /** @type {?} */
        const list = this.columnList.toArray();
        /** @type {?} */
        const fromIndex = list.indexOf(from);
        /** @type {?} */
        let toIndex = list.indexOf(to);
        if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
            if (toIndex < 0) {
                toIndex = 0;
            }
        }
        if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
        }
        list.splice(toIndex, 0, ...list.splice(fromIndex, 1));
        /** @type {?} */
        const newList = this._resetColumnList(list);
        this.columnList.reset(newList);
        this.columnList.notifyOnChanges();
        this._columns = this.columnList.toArray();
    }
    /**
     * @hidden
     * @protected
     * @param {?=} list
     * @return {?}
     */
    _resetColumnList(list) {
        if (!list) {
            list = this.columnList.toArray();
        }
        /** @type {?} */
        let newList = [];
        list.filter(c => c.level === 0).forEach(p => {
            newList.push(p);
            if (p.columnGroup) {
                newList = newList.concat(p.allChildren);
            }
        });
        return newList;
    }
    /**
     * @hidden
     * @protected
     * @param {?} from
     * @param {?} to
     * @param {?} position
     * @return {?}
     */
    _reorderPinnedColumns(from, to, position) {
        /** @type {?} */
        const pinned = this._pinnedColumns;
        /** @type {?} */
        let dropIndex = pinned.indexOf(to);
        if (to.columnGroup) {
            dropIndex += to.allChildren.length;
        }
        if (position === DropPosition.BeforeDropTarget) {
            dropIndex--;
        }
        if (position === DropPosition.AfterDropTarget) {
            dropIndex++;
        }
        pinned.splice(dropIndex, 0, ...pinned.splice(pinned.indexOf(from), 1));
    }
    /**
     * @hidden
     * @protected
     * @param {?} parent
     * @param {?} from
     * @param {?} to
     * @param {?} pos
     * @return {?}
     */
    _moveChildColumns(parent, from, to, pos) {
        /** @type {?} */
        const buffer = parent.children.toArray();
        /** @type {?} */
        const fromIndex = buffer.indexOf(from);
        /** @type {?} */
        let toIndex = buffer.indexOf(to);
        if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
        }
        if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
        }
        buffer.splice(toIndex, 0, ...buffer.splice(fromIndex, 1));
        parent.children.reset(buffer);
    }
    /**
     * Moves a column to the specified drop target.
     * ```typescript
     * grid.moveColumn(compName, persDetails);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} column
     * @param {?} dropTarget
     * @param {?=} pos
     * @return {?}
     */
    moveColumn(column, dropTarget, pos = DropPosition.None) {
        /** @type {?} */
        let position = pos;
        /** @type {?} */
        const fromIndex = column.visibleIndex;
        /** @type {?} */
        const toIndex = dropTarget.visibleIndex;
        if (pos === DropPosition.BeforeDropTarget && fromIndex < toIndex) {
            position = DropPosition.BeforeDropTarget;
        }
        else if (pos === DropPosition.AfterDropTarget && fromIndex > toIndex) {
            position = DropPosition.AfterDropTarget;
        }
        else {
            position = DropPosition.None;
        }
        if ((column.level !== dropTarget.level) ||
            (column.topLevelParent !== dropTarget.topLevelParent)) {
            return;
        }
        this.endEdit(true);
        if (column.level) {
            this._moveChildColumns(column.parent, column, dropTarget, position);
        }
        if (dropTarget.pinned && column.pinned) {
            this._reorderPinnedColumns(column, dropTarget, position);
        }
        if (dropTarget.pinned && !column.pinned) {
            column.pin();
            this._reorderPinnedColumns(column, dropTarget, position);
        }
        if (!dropTarget.pinned && column.pinned) {
            column.unpin();
            /** @type {?} */
            const list = this.columnList.toArray();
            /** @type {?} */
            const fi = list.indexOf(column);
            /** @type {?} */
            const ti = list.indexOf(dropTarget);
            if (pos === DropPosition.BeforeDropTarget && fi < ti) {
                position = DropPosition.BeforeDropTarget;
            }
            else if (pos === DropPosition.AfterDropTarget && fi > ti) {
                position = DropPosition.AfterDropTarget;
            }
            else {
                position = DropPosition.None;
            }
        }
        this._moveColumns(column, dropTarget, position);
        this.notifyChanges();
        if (this.hasColumnLayouts) {
            this.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        /** @type {?} */
        const args = {
            source: column,
            target: dropTarget
        };
        this.onColumnMovingEnd.emit(args);
    }
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    markForCheck() {
        this.cdr.detectChanges();
    }
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * ```typescript
     * const record = {
     *     ID: this.grid1.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid1.addRow(record);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} data
     * @return {?}
     */
    addRow(data) {
        // commit pending states prior to adding a row
        this.endEdit(true);
        this.gridAPI.addRowToData(data);
        this.onRowAdded.emit({ data });
        this._pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowSelector
     * @return {?}
     */
    deleteRow(rowSelector) {
        if (this.primaryKey !== undefined && this.primaryKey !== null) {
            this.deleteRowById(rowSelector);
        }
    }
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    deleteRowById(rowId) {
        this.gridAPI.deleteRowById(rowId);
    }
    /**
     * @hidden
     * @protected
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        if (index !== -1) {
            if (this.transactions.enabled) {
                /** @type {?} */
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                this.transactions.add(transaction, this.data[index]);
            }
            else {
                this.data.splice(index, 1);
            }
        }
        else {
            /** @type {?} */
            const state = this.transactions.getState(rowID);
            this.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value the new value which is to be set.
     * @param {?} rowSelector corresponds to rowID.
     * @param {?} column corresponds to column field.
     * @return {?}
     */
    updateCell(value, rowSelector, column) {
        if (this.isDefined(this.primaryKey)) {
            /** @type {?} */
            const col = this.columnList.toArray().find(c => c.field === column);
            if (col) {
                // Simplify
                /** @type {?} */
                const rowData = this.gridAPI.getRowData(rowSelector);
                /** @type {?} */
                const index = this.gridAPI.get_row_index_in_data(rowSelector);
                // If row passed is invalid
                if (index < 0) {
                    return;
                }
                /** @type {?} */
                const id = {
                    rowID: rowSelector,
                    columnID: col.index,
                    rowIndex: index
                };
                /** @type {?} */
                const cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData);
                /** @type {?} */
                const args = this.gridAPI.update_cell(cell, value);
                if (this.crudService.cell && this.crudService.sameCell(cell)) {
                    if (args.cancel) {
                        return;
                    }
                    this.gridAPI.escape_editMode();
                }
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * Updates the `IgxGridRowComponent`, which is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @param {?} rowSelector correspond to rowID
     * @return {?}
     */
    updateRow(value, rowSelector) {
        if (this.isDefined(this.primaryKey)) {
            /** @type {?} */
            const editableCell = this.crudService.cell;
            if (editableCell && editableCell.id.rowID === rowSelector) {
                this.gridAPI.escape_editMode();
            }
            /** @type {?} */
            const row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector));
            this.gridAPI.update_row(row, value);
            // TODO: fix for #5934 and probably break for #5763
            // consider adding of third optional boolean parameter in updateRow.
            // If developer set this parameter to true we should call notifyChanges(true), and
            // vise-versa if developer set it to false we should call notifyChanges(false).
            // The parameter should default to false
            this.notifyChanges();
        }
    }
    /**
     * Sort a single `IgxColumnComponent`.
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} expression
     * @return {?}
     */
    sort(expression) {
        this.endEdit(false);
        if (expression instanceof Array) {
            this.gridAPI.sort_multiple(expression);
        }
        else {
            this.gridAPI.sort(expression);
        }
        this.onSortingDone.emit(expression);
    }
    /**
     * Filters a single `IgxColumnComponent`.
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} name
     * @param {?} value
     * @param {?=} conditionOrExpressionTree
     * @param {?=} ignoreCase
     * @return {?}
     */
    filter(name, value, conditionOrExpressionTree, ignoreCase) {
        this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @param {?} condition
     * @param {?=} ignoreCase
     * @return {?}
     */
    filterGlobal(value, condition, ignoreCase) {
        this.filteringService.filterGlobal(value, condition, ignoreCase);
    }
    /**
     * Enables summaries for the specified column and applies your customSummary.
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {...?} rest
     * @return {?}
     */
    enableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._multipleSummaries(rest[0], true);
        }
        else {
            this._summaries(rest[0], true, rest[1]);
        }
    }
    /**
     * Disable summaries for the specified column.
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     *
     * Disable summaries for the listed columns.
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {...?} rest
     * @return {?}
     */
    disableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._disableMultipleSummaries(rest[0]);
        }
        else {
            this._summaries(rest[0], false);
        }
    }
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`,
     * otherwise clears the filtering state of all `IgxColumnComponent`s.
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} name
     * @return {?}
     */
    clearFilter(name) {
        this.filteringService.clearFilter(name);
    }
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`,
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * ```typescript
     * this.grid.clearSort();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} name
     * @return {?}
     */
    clearSort(name) {
        if (!name) {
            this.sortingExpressions = [];
            return;
        }
        if (!this.gridAPI.get_column_by_name(name)) {
            return;
        }
        this.gridAPI.clear_sort(name);
    }
    /**
     * @hidden
     * @param {?=} args
     * @return {?}
     */
    refreshGridState(args) {
        this.endEdit(true);
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache(args);
    }
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} columnName
     * @param {?=} index
     * @return {?}
     */
    pinColumn(columnName, index) {
        /** @type {?} */
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.pin(index);
    }
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} columnName
     * @param {?=} index
     * @return {?}
     */
    unpinColumn(columnName, index) {
        /** @type {?} */
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.unpin(index);
    }
    /**
     * Recalculates grid width/height dimensions. Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * ```typescript
     * this.grid.reflow();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    reflow() {
        this.calculateGridSizes();
    }
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} text the string to search.
     * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param {?=} exactMatch optionally, if the text should match the entire value  (defaults to false).
     * @return {?}
     */
    findNext(text, caseSensitive, exactMatch) {
        return this.find(text, 1, caseSensitive, exactMatch);
    }
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findPrev("financial");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} text the string to search.
     * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param {?=} exactMatch optionally, if the text should match the entire value (defaults to false).
     * @return {?}
     */
    findPrev(text, caseSensitive, exactMatch) {
        return this.find(text, -1, caseSensitive, exactMatch);
    }
    /**
     * Reapplies the existing search.
     * Returns how many times the grid contains the last search.
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} updateActiveInfo
     * @return {?}
     */
    refreshSearch(updateActiveInfo) {
        if (this.lastSearchInfo.searchText) {
            this.rebuildMatchCache();
            if (updateActiveInfo) {
                /** @type {?} */
                const activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                this.lastSearchInfo.matchInfoCache.forEach((match, i) => {
                    if (match.column === activeInfo.column &&
                        match.row === activeInfo.row &&
                        match.index === activeInfo.index) {
                        this.lastSearchInfo.activeMatchIndex = i;
                    }
                });
            }
            return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false);
        }
        else {
            return 0;
        }
    }
    /**
     * Removes all the highlights in the cell.
     * ```typescript
     * this.grid.clearSearch();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    clearSearch() {
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        this.rowList.forEach((row) => {
            if (row.cells) {
                row.cells.forEach((c) => {
                    c.clearHighlight();
                });
            }
        });
    }
    /**
     * Returns if the `IgxGridComponent` has sortable columns.
     * ```typescript
     * const sortableGrid = this.grid.hasSortableColumns;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasSortableColumns() {
        return this.columnList.some((col) => col.sortable);
    }
    /**
     * Returns if the `IgxGridComponent` has editable columns.
     * ```typescript
     * const editableGrid = this.grid.hasEditableColumns;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasEditableColumns() {
        return this.columnList.some((col) => col.editable);
    }
    /**
     * Returns if the `IgxGridComponent` has fiterable columns.
     * ```typescript
     * const filterableGrid = this.grid.hasFilterableColumns;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasFilterableColumns() {
        return this.columnList.some((col) => col.filterable);
    }
    /**
     * Returns if the `IgxGridComponent` has summarized columns.
     * ```typescript
     * const summarizedGrid = this.grid.hasSummarizedColumns;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasSummarizedColumns() {
        return this.summaryService.hasSummarizedColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get rootSummariesEnabled() {
        return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasVisibleColumns() {
        if (this._hasVisibleColumns === undefined) {
            return this.columnList ? this.columnList.some(c => !c.hidden) : false;
        }
        return this._hasVisibleColumns;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hasVisibleColumns(value) {
        this._hasVisibleColumns = value;
    }
    /**
     * Returns if the `IgxGridComponent` has moveable columns.
     * ```typescript
     * const movableGrid = this.grid.hasMovableColumns;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasMovableColumns() {
        return this.columnList && this.columnList.some((col) => col.movable);
    }
    /**
     * Returns if the `IgxGridComponent` has column groups.
     * ```typescript
     * const groupGrid = this.grid.hasColumnGroups;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasColumnGroups() {
        return this._columnGroups;
    }
    /**
     * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
     * ```typescript
     * const layoutGrid = this.grid.hasColumnLayouts;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get hasColumnLayouts() {
        return !!this.columnList.some(col => col.columnLayout);
    }
    /**
     * Returns an array of the selected `IgxGridCellComponent`s.
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get selectedCells() {
        if (this.dataRowList) {
            return this.dataRowList.map((row) => row.cells.filter((cell) => cell.selected))
                .reduce((a, b) => a.concat(b), []);
        }
        return [];
    }
    /**
     * @hidden
     * @return {?}
     */
    get multiRowLayoutRowSize() {
        return this._multiRowLayoutRowSize;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get rowBasedHeight() {
        return this.dataLength * this.rowHeight;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get isPercentWidth() {
        return this.width && this.width.indexOf('%') !== -1;
    }
    /**
     * @hidden \@internal
     * @return {?}
     */
    get isPercentHeight() {
        return this._height && this._height.indexOf('%') !== -1;
    }
    /**
     * @hidden
     * Sets columns defaultWidth property
     * @protected
     * @return {?}
     */
    _derivePossibleWidth() {
        if (!this.columnWidthSetByUser) {
            this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
        }
        this.columnList.forEach((column) => {
            if (this.hasColumnLayouts && parseInt(this._columnWidth, 10)) {
                /** @type {?} */
                const columnWidthCombined = parseInt(this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                column.defaultWidth = columnWidthCombined + 'px';
            }
            else {
                column.defaultWidth = this._columnWidth;
                column.resetCaches();
            }
        });
        this.resetCachedWidths();
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get defaultTargetBodyHeight() {
        /** @type {?} */
        const allItems = this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden \@internal
     * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
     * @return {?}
     */
    get renderedRowHeight() {
        return this.rowHeight + 1;
    }
    /**
     * @hidden
     * \@internal
     * @protected
     * @return {?}
     */
    calcGridHeadRow() {
        if (this.maxLevelHeaderDepth) {
            this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
            /** @type {?} */
            let minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;
            if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {
                minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
            }
            this.theadRow.nativeElement.style.minHeight = `${minSize}rem`;
        }
    }
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     * @protected
     * @return {?}
     */
    calculateGridHeight() {
        this.calcGridHeadRow();
        this.summariesHeight = 0;
        if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
            this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
        }
        this.calcHeight = this._calculateGridBodyHeight();
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getGroupAreaHeight() {
        return 0;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getToolbarHeight() {
        /** @type {?} */
        let toolbarHeight = 0;
        if (this.showToolbar && this.toolbarHtml != null) {
            toolbarHeight = this.toolbarHtml.nativeElement.firstElementChild ?
                this.toolbarHtml.nativeElement.offsetHeight : 0;
        }
        return toolbarHeight;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getPagingHeight() {
        /** @type {?} */
        let pagingHeight = 0;
        if (this.paging && this.footer) {
            pagingHeight = this.footer.nativeElement.firstElementChild ?
                this.footer.nativeElement.offsetHeight : 0;
        }
        return pagingHeight;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getFilterCellHeight() {
        /** @type {?} */
        const headerGroupNativeEl = (this.headerGroupsList.length !== 0) ?
            this.headerGroupsList[0].element.nativeElement : null;
        /** @type {?} */
        const filterCellNativeEl = (headerGroupNativeEl) ?
            headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
        return (filterCellNativeEl) ? filterCellNativeEl.offsetHeight : 0;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _calculateGridBodyHeight() {
        if (!this._height) {
            return null;
        }
        /** @type {?} */
        const actualTheadRow = (!this.allowFiltering || (this.allowFiltering && this.filterMode !== FilterMode.quickFilter)) ?
            this.theadRow.nativeElement.offsetHeight - this.getFilterCellHeight() :
            this.theadRow.nativeElement.offsetHeight;
        /** @type {?} */
        const footerHeight = this.summariesHeight || this.tfoot.nativeElement.offsetHeight - this.tfoot.nativeElement.clientHeight;
        /** @type {?} */
        const toolbarHeight = this.getToolbarHeight();
        /** @type {?} */
        const pagingHeight = this.getPagingHeight();
        /** @type {?} */
        const groupAreaHeight = this.getGroupAreaHeight();
        /** @type {?} */
        const renderedHeight = toolbarHeight + actualTheadRow +
            footerHeight + pagingHeight + groupAreaHeight +
            this.scr.nativeElement.clientHeight;
        /** @type {?} */
        const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
        /** @type {?} */
        let gridHeight = 0;
        if (this.isPercentHeight) {
            /** @type {?} */
            const autoSize = this._shouldAutoSize(renderedHeight);
            if (autoSize || computed.indexOf('%') !== -1) {
                /** @type {?} */
                const bodyHeight = this.getDataBasedBodyHeight();
                return bodyHeight > 0 ? bodyHeight : null;
            }
            gridHeight = parseInt(computed, 10);
        }
        else {
            gridHeight = parseInt(this._height, 10);
        }
        /** @type {?} */
        const height = Math.abs(gridHeight - renderedHeight);
        if (height === 0 || isNaN(gridHeight)) {
            /** @type {?} */
            const bodyHeight = this.defaultTargetBodyHeight;
            return bodyHeight > 0 ? bodyHeight : null;
        }
        return height;
    }
    /**
     * @protected
     * @return {?}
     */
    checkContainerSizeChange() {
        /** @type {?} */
        const origHeight = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = 'none';
        /** @type {?} */
        const height = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = '';
        return origHeight !== height;
    }
    /**
     * @protected
     * @param {?} renderedHeight
     * @return {?}
     */
    _shouldAutoSize(renderedHeight) {
        this.tbody.nativeElement.style.display = 'none';
        /** @type {?} */
        let res = !this.nativeElement.parentElement ||
            this.nativeElement.parentElement.clientHeight === 0 ||
            this.nativeElement.parentElement.clientHeight === renderedHeight;
        if (!isChromium()) {
            // If grid causes the parent container to extend (for example when container is flex)
            // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
            res = this.checkContainerSizeChange();
        }
        this.tbody.nativeElement.style.display = '';
        return res;
    }
    /**
     * @return {?}
     */
    get outerWidth() {
        return this.hasVerticalSroll() ? this.calcWidth + this.scrollWidth : this.calcWidth;
    }
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * @return {?}
     */
    getVisibleContentHeight() {
        /** @type {?} */
        let height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
        if (this.hasSummarizedColumns) {
            height += this.tfoot.nativeElement.clientHeight;
        }
        return height;
    }
    /**
     * @hidden
     * @param {?=} baseWidth
     * @return {?}
     */
    getPossibleColumnWidth(baseWidth = null) {
        /** @type {?} */
        let computedWidth;
        if (baseWidth !== null) {
            computedWidth = baseWidth;
        }
        else {
            computedWidth = this.calcWidth ||
                parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
        }
        computedWidth -= this.getFeatureColumnsWidth();
        if (this.showDragIcons) {
            computedWidth -= this.headerDragContainer ? this.headerDragContainer.nativeElement.offsetWidth : 0;
        }
        /** @type {?} */
        const visibleChildColumns = this.visibleColumns.filter(c => !c.columnGroup);
        // Column layouts related
        /** @type {?} */
        let visibleCols = [];
        /** @type {?} */
        const columnBlocks = this.visibleColumns.filter(c => c.columnGroup);
        /** @type {?} */
        const colsPerBlock = columnBlocks.map(block => block.getInitialChildColumnSizes(block.children));
        /** @type {?} */
        const combinedBlocksSize = colsPerBlock.reduce((acc, item) => acc + item.length, 0);
        colsPerBlock.forEach(blockCols => visibleCols = visibleCols.concat(blockCols));
        //
        /** @type {?} */
        const columnsWithSetWidths = this.hasColumnLayouts ?
            visibleCols.filter(c => c.widthSetByUser) :
            visibleChildColumns.filter(c => c.widthSetByUser);
        /** @type {?} */
        const columnsToSize = this.hasColumnLayouts ?
            combinedBlocksSize - columnsWithSetWidths.length :
            visibleChildColumns.length - columnsWithSetWidths.length;
        /** @type {?} */
        const sumExistingWidths = columnsWithSetWidths
            .reduce((prev, curr) => {
            /** @type {?} */
            const colWidth = curr.width;
            /** @type {?} */
            const widthValue = parseInt(colWidth, 10);
            /** @type {?} */
            const currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                widthValue / 100 * computedWidth :
                widthValue;
            return prev + currWidth;
        }, 0);
        /** @type {?} */
        const columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
            Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
            Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
        return columnWidth.toString();
    }
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     * @protected
     * @return {?}
     */
    calculateGridWidth() {
        /** @type {?} */
        let width;
        /** @type {?} */
        const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');
        if (this.isPercentWidth) {
            /* width in %*/
            width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
        }
        else {
            width = parseInt(this.width, 10);
        }
        if (!width && this.nativeElement) {
            width = this.nativeElement.offsetWidth;
        }
        if (this.width === null || !width) {
            width = this.getColumnWidthSum();
        }
        if (this.hasVerticalSroll() && this.width !== null) {
            width -= this.scrollWidth;
        }
        if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
            this.calcWidth = width;
        }
        this._derivePossibleWidth();
    }
    /**
     * @private
     * @return {?}
     */
    getColumnWidthSum() {
        /** @type {?} */
        let colSum = 0;
        /** @type {?} */
        const cols = this.hasColumnLayouts ?
            this.visibleColumns.filter(x => x.columnLayout) : this.visibleColumns.filter(x => !x.columnGroup);
        cols.forEach((item) => {
            /** @type {?} */
            const isWidthInPercent = item.width && typeof item.width === 'string' && item.width.indexOf('%') !== -1;
            if (isWidthInPercent) {
                item.width = MINIMUM_COLUMN_WIDTH + 'px';
            }
            colSum += parseInt((item.width || item.defaultWidth), 10) || MINIMUM_COLUMN_WIDTH;
        });
        if (!colSum) {
            return null;
        }
        this.cdr.detectChanges();
        colSum += this.getFeatureColumnsWidth();
        return colSum;
    }
    /**
     * @return {?}
     */
    hasVerticalSroll() {
        if (this._init) {
            return false;
        }
        /** @type {?} */
        const isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
        return !!(this.calcWidth && this.dataView &&
            this.dataView.length > 0 &&
            isScrollable);
    }
    /**
     * @hidden \@internal
     * @protected
     * @return {?}
     */
    getDataBasedBodyHeight() {
        return !this.data || (this.data.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     * @protected
     * @param {?} change
     * @return {?}
     */
    onColumnsChanged(change) {
        /** @type {?} */
        const diff = this.columnListDiffer.diff(change);
        if (diff) {
            /** @type {?} */
            let added = false;
            /** @type {?} */
            let removed = false;
            this.initColumns(this.columnList);
            diff.forEachAddedItem((record) => {
                this.onColumnInit.emit(record.item);
                added = true;
            });
            diff.forEachRemovedItem((record) => {
                /** @type {?} */
                const isColumnGroup = record.item instanceof IgxColumnGroupComponent;
                if (!isColumnGroup) {
                    // Clear Grouping
                    this.gridAPI.clear_groupby(record.item.field);
                    // Clear Filtering
                    this.gridAPI.clear_filter(record.item.field);
                    // Close filter row
                    if (this.filteringService.isFilterRowVisible
                        && this.filteringService.filteredColumn
                        && this.filteringService.filteredColumn.field === record.item.field) {
                        this.filteringRow.close();
                    }
                    // Clear Sorting
                    this.gridAPI.clear_sort(record.item.field);
                }
                removed = true;
            });
            this.resetCaches();
            if (added || removed) {
                this.summaryService.clearSummaryCache();
                Promise.resolve().then(() => {
                    // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                    // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                    this.notifyChanges(true);
                });
            }
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    calculateGridSizes() {
        /*
            TODO: (R.K.) This layered lasagne should be refactored
            ASAP. The reason I have to reset the caches so many times is because
            after teach `detectChanges` call they are filled with invalid
            state. Of course all of this happens midway through the grid
            sizing process which of course, uses values from the caches, thus resulting
            in a broken layout.
        */
        this.resetCaches();
        this.cdr.detectChanges();
        /** @type {?} */
        const hasScroll = this.hasVerticalSroll();
        this.calculateGridWidth();
        this.resetCaches();
        this.cdr.detectChanges();
        this.calculateGridHeight();
        if (this.rowEditable) {
            this.repositionRowEditingOverlay(this.rowInEditMode);
        }
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.resetChipsArea();
        }
        this.cdr.detectChanges();
        // in case scrollbar has appeared recalc to size correctly.
        if (hasScroll !== this.hasVerticalSroll()) {
            this.calculateGridWidth();
            this.cdr.detectChanges();
        }
        if (this.zone.isStable) {
            this.zone.run(() => {
                this._applyWidthHostBinding();
                this.cdr.detectChanges();
            });
        }
        else {
            this.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                this.zone.run(() => {
                    this._applyWidthHostBinding();
                });
            });
        }
        this.resetCaches();
    }
    /**
     * @private
     * @return {?}
     */
    _applyWidthHostBinding() {
        /** @type {?} */
        let width = this._width;
        if (width === null) {
            /** @type {?} */
            let currentWidth = this.calcWidth;
            if (this.hasVerticalSroll()) {
                currentWidth += this.scrollWidth;
            }
            width = currentWidth + 'px';
            this.resetCaches();
        }
        this._hostWidth = width;
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * Method used to override the calculations.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    getFeatureColumnsWidth() {
        /** @type {?} */
        let width = 0;
        if (this.isRowSelectable) {
            width += this.headerSelectorContainer ? this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
        }
        if (this.rowDraggable) {
            width += this.headerDragContainer ? this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
        }
        return width;
    }
    /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    getPinnedWidth(takeHidden = false) {
        /** @type {?} */
        const fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
        /** @type {?} */
        let sum = 0;
        for (const col of fc) {
            if (col.level === 0) {
                sum += parseInt(col.calcWidth, 10);
            }
        }
        sum += this.featureColumnsWidth;
        return sum;
    }
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * \@memberof IgxGridBaseComponent
     * @protected
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    getUnpinnedWidth(takeHidden = false) {
        /** @type {?} */
        let width = this.isPercentWidth ?
            this.calcWidth :
            parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;
        if (this.hasVerticalSroll() && !this.isPercentWidth) {
            width -= this.scrollWidth;
        }
        return width - this.getPinnedWidth(takeHidden);
    }
    /**
     * @hidden
     * @protected
     * @param {?} fieldName
     * @param {?} hasSummary
     * @param {?=} summaryOperand
     * @return {?}
     */
    _summaries(fieldName, hasSummary, summaryOperand) {
        /** @type {?} */
        const column = this.gridAPI.get_column_by_name(fieldName);
        if (column) {
            column.hasSummary = hasSummary;
            if (summaryOperand) {
                if (this.rootSummariesEnabled) {
                    this.summaryService.retriggerRootPipe++;
                }
                column.summaries = summaryOperand;
            }
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} expressions
     * @param {?} hasSummary
     * @return {?}
     */
    _multipleSummaries(expressions, hasSummary) {
        expressions.forEach((element) => {
            this._summaries(element.fieldName, hasSummary, element.customSummary);
        });
    }
    /**
     * @hidden
     * @protected
     * @param {?} expressions
     * @return {?}
     */
    _disableMultipleSummaries(expressions) {
        expressions.forEach((column) => {
            /** @type {?} */
            const columnName = column && column.fieldName ? column.fieldName : column;
            this._summaries(columnName, false);
        });
    }
    /**
     * @hidden
     * @protected
     * @param {?} rec
     * @return {?}
     */
    resolveDataTypes(rec) {
        if (typeof rec === 'number') {
            return DataType.Number;
        }
        else if (typeof rec === 'boolean') {
            return DataType.Boolean;
        }
        else if (typeof rec === 'object' && rec instanceof Date) {
            return DataType.Date;
        }
        return DataType.String;
    }
    /**
     * @private
     * @return {?}
     */
    getScrollWidth() {
        /** @type {?} */
        const div = document.createElement('div');
        /** @type {?} */
        const style = div.style;
        style.width = '100px';
        style.height = '100px';
        style.position = 'absolute';
        style.top = '-10000px';
        style.top = '-10000px';
        style.overflow = 'scroll';
        document.body.appendChild(div);
        /** @type {?} */
        const scrollWidth = div.offsetWidth - div.clientWidth;
        document.body.removeChild(div);
        return scrollWidth;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    autogenerateColumns() {
        /** @type {?} */
        const data = this.gridAPI.get_data();
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
        /** @type {?} */
        const fields = this.generateDataFields(data);
        /** @type {?} */
        const columns = [];
        fields.forEach((field) => {
            /** @type {?} */
            const ref = factory.create(this.viewRef.injector);
            ref.instance.field = field;
            ref.instance.dataType = this.resolveDataTypes(data[0][field]);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        this.columnList.reset(columns);
        if (data && data.length > 0) {
            this.shouldGenerate = false;
        }
    }
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    generateDataFields(data) {
        return Object.keys(data && data.length !== 0 ? data[0] : []);
    }
    /**
     * @hidden
     * @param {?} arr
     * @return {?}
     */
    onlyTopLevel(arr) {
        return arr.filter(c => c.level === 0);
    }
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    initColumns(collection, cb = null) {
        this._columnGroups = this.columnList.some(col => col.columnGroup);
        if (this.hasColumnLayouts) {
            // Set overall row layout size
            this.columnList.forEach((col) => {
                if (col.columnLayout) {
                    /** @type {?} */
                    const layoutSize = col.children ?
                        col.children.reduce((acc, val) => Math.max(val.rowStart + val.gridRowSpan - 1, acc), 1) :
                        1;
                    this._multiRowLayoutRowSize = Math.max(layoutSize, this._multiRowLayoutRowSize);
                }
            });
        }
        if (this.hasColumnLayouts && this.hasColumnGroups) {
            // invalid configuration - multi-row and column groups
            // remove column groups
            /** @type {?} */
            const columnLayoutColumns = this.columnList.filter((col) => col.columnLayout || col.columnLayoutChild);
            this.columnList.reset(columnLayoutColumns);
        }
        this._maxLevelHeaderDepth = null;
        this._columns = this.columnList.toArray();
        collection.forEach((column) => {
            column.defaultWidth = this.columnWidthSetByUser ? this._columnWidth : column.defaultWidth ? column.defaultWidth : '';
            if (cb) {
                cb(column);
            }
        });
        this.reinitPinStates();
        if (this.hasColumnLayouts) {
            collection.forEach((column) => {
                column.populateVisibleIndexes();
            });
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    reinitPinStates() {
        this._pinnedColumns = (this.hasColumnGroups) ? this.columnList.filter((c) => c.pinned) :
            this.columnList.filter((c) => c.pinned).sort((a, b) => this._pinnedColumns.indexOf(a) - this._pinnedColumns.indexOf(b));
        this._unpinnedColumns = this.columnList.filter((c) => !c.pinned);
    }
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    isColumnGrouped(fieldName) {
        return false;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onHeaderSelectorClick(event) {
        if (!this.isMultiRowSelectionEnabled) {
            return;
        }
        this.selectionService.areAllRowSelected() ?
            this.selectionService.clearRowSelection(event) : this.selectionService.selectAllRows(event);
    }
    /**
     * @hidden
     * @return {?}
     */
    get headSelectorBaseAriaLabel() {
        if (this._filteringExpressionsTree.filteringOperands.length > 0) {
            return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
        }
        return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get totalRowsCountAfterFilter() {
        if (this.data) {
            return this.selectionService.allData.length;
        }
        return 0;
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped data, displayed in the grid.
     * ```typescript
     *      const dataView = this.grid.dataView;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get dataView() {
        return this.verticalScrollContainer.igxForOf;
    }
    /**
     * Get current selection state.
     * Returns an array with selected rows' IDs (primaryKey or rowData)
     * ```typescript
     * const selectedRows = this.grid.selectedRows();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    selectedRows() {
        return this.selectionService.getSelectedRows();
    }
    /**
     * Select specified rows by ID.
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIDs
     * @param {?=} clearCurrentSelection if true clears the current selection
     * @return {?}
     */
    selectRows(rowIDs, clearCurrentSelection) {
        this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified rows by ID.
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIDs
     * @return {?}
     */
    deselectRows(rowIDs) {
        this.selectionService.deselectRowsWithNoEvent(rowIDs);
        this.notifyChanges();
    }
    /**
     * Selects all rows
     * Note: By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * ```typescript
     * this.grid.selectAllRows();
     * this.grid.selectAllRows(false);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} onlyFilterData
     * @return {?}
     */
    selectAllRows(onlyFilterData = true) {
        /** @type {?} */
        const data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
        /** @type {?} */
        const rowIDs = this.selectionService.getRowIDs(data).filter(rID => !this.gridAPI.row_deleted_transaction(rID));
        this.selectRows(rowIDs);
    }
    /**
     * Deselects all rows
     * Note: By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} onlyFilterData
     * @return {?}
     */
    deselectAllRows(onlyFilterData = true) {
        if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
            this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
        }
        else {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges();
        }
    }
    /**
     * @return {?}
     */
    clearCellSelection() {
        this.selectionService.clear(true);
        this.notifyChanges();
    }
    /**
     * @param {?} dir
     * @return {?}
     */
    dragScroll(dir) {
        /** @type {?} */
        const scrollDelta = 48;
        /** @type {?} */
        const horizontal = this.headerContainer.getScroll();
        /** @type {?} */
        const vertical = this.verticalScrollContainer.getScroll();
        switch (dir) {
            case DragScrollDirection.LEFT:
                horizontal.scrollLeft -= scrollDelta;
                break;
            case DragScrollDirection.RIGHT:
                horizontal.scrollLeft += scrollDelta;
                break;
            case DragScrollDirection.TOP:
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.BOTTOM:
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.TOPLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.TOPRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            default:
                return;
        }
        this.wheelHandler();
    }
    /**
     * @param {?} arg
     * @return {?}
     */
    isDefined(arg) {
        return arg !== undefined && arg !== null;
    }
    /**
     * @param {?} arg
     * @return {?}
     */
    selectRange(arg) {
        if (!this.isDefined(arg)) {
            this.clearCellSelection();
            return;
        }
        if (arg instanceof Array) {
            arg.forEach(range => this.setSelection(range));
        }
        else {
            this.setSelection(arg);
        }
        this.notifyChanges();
    }
    /**
     * @param {?} field
     * @return {?}
     */
    columnToVisibleIndex(field) {
        /** @type {?} */
        const visibleColumns = this.visibleColumns;
        if (typeof field === 'number') {
            return field;
        }
        return visibleColumns.find(column => column.field === field).visibleIndex;
    }
    /**
     * @param {?} range
     * @return {?}
     */
    setSelection(range) {
        /** @type {?} */
        const startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
        /** @type {?} */
        const endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
        this.selectionService.pointerState.node = startNode;
        this.selectionService.selectRange(endNode, this.selectionService.pointerState);
        this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
        this.selectionService.initPointerState();
    }
    /**
     * @return {?}
     */
    getSelectedRanges() {
        return this.selectionService.ranges;
    }
    /**
     * @protected
     * @param {?} source
     * @param {?=} formatters
     * @param {?=} headers
     * @return {?}
     */
    extractDataFromSelection(source, formatters = false, headers = false) {
        /** @type {?} */
        let columnsArray;
        /** @type {?} */
        let record = {};
        /** @type {?} */
        const selectedData = [];
        /** @type {?} */
        const activeEl = this.selectionService.activeElement;
        /** @type {?} */
        const selectionMap = Array.from(this.selectionService.selection)
            .filter((tuple) => tuple[0] < source.length);
        if (this.cellSelection === GridSelectionMode.single && activeEl) {
            selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
        }
        for (const [row, set] of selectionMap) {
            if (!source[row]) {
                continue;
            }
            /** @type {?} */
            const temp = Array.from(set);
            for (const each of temp) {
                columnsArray = this.getSelectableColumnsAt(each);
                columnsArray.forEach((col) => {
                    if (col) {
                        /** @type {?} */
                        const key = headers ? col.header || col.field : col.field;
                        record[key] = formatters && col.formatter ? col.formatter(source[row][col.field])
                            : source[row][col.field];
                    }
                });
            }
            if (Object.keys(record).length) {
                selectedData.push(record);
            }
            record = {};
        }
        return selectedData;
    }
    /**
     * @protected
     * @param {?} index
     * @return {?}
     */
    getSelectableColumnsAt(index) {
        if (this.hasColumnLayouts) {
            /** @type {?} */
            const visibleLayoutColumns = this.visibleColumns
                .filter(col => col.columnLayout)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            /** @type {?} */
            const colLayout = visibleLayoutColumns[index];
            return colLayout ? colLayout.children.toArray() : [];
        }
        else {
            /** @type {?} */
            const visibleColumns = this.visibleColumns
                .filter(col => !col.columnGroup)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            return [visibleColumns[index]];
        }
    }
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     * @param {?=} formatters
     * @param {?=} headers
     * @return {?}
     */
    getSelectedData(formatters = false, headers = false) {
        /** @type {?} */
        const source = this.dataView;
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * @return {?}
     */
    copyHandlerIE() {
        if (isIE()) {
            this.copyHandler(null, true);
        }
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @param {?=} ie11
     * @return {?}
     */
    copyHandler(event, ie11 = false) {
        if (!this.clipboardOptions.enabled || this.crudService.inEditMode) {
            return;
        }
        /** @type {?} */
        const data = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
        /** @type {?} */
        const ev = (/** @type {?} */ ({ data, cancel: false }));
        this.onGridCopy.emit(ev);
        if (ev.cancel) {
            return;
        }
        /** @type {?} */
        const transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
        /** @type {?} */
        let result = transformer.prepareData();
        if (!this.clipboardOptions.copyHeaders) {
            result = result.substring(result.indexOf('\n') + 1);
        }
        if (ie11) {
            ((/** @type {?} */ (window))).clipboardData.setData('Text', result);
            return;
        }
        event.preventDefault();
        /* Necessary for the hiearachical case but will probably have to
           change how getSelectedData is propagated in the hiearachical grid
        */
        event.stopPropagation();
        event.clipboardData.setData('text/plain', result);
    }
    /**
     * This method allows you to navigate to a position
     * in the grid based on provided `rowindex` and `visibleColumnIndex`,
     * also to execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIndex
     * @param {?=} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    navigateTo(rowIndex, visibleColIndex = -1, cb = null) {
        if (rowIndex < 0 || rowIndex > this.dataView.length - 1
            || (visibleColIndex !== -1 && this.columnList.map(col => col.visibleIndex).indexOf(visibleColIndex) === -1)) {
            return;
        }
        this.wheelHandler();
        if (this.dataView.slice(rowIndex, rowIndex + 1).find(rec => rec.expression || rec.childGridsData)) {
            visibleColIndex = -1;
        }
        /** @type {?} */
        const shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
        /** @type {?} */
        const shouldScrollHorizontally = visibleColIndex !== -1 && !this.navigation.isColumnFullyVisible(visibleColIndex);
        if (shouldScrollVertically) {
            this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => { this.navigateTo(rowIndex, visibleColIndex, cb); });
        }
        else if (shouldScrollHorizontally) {
            this.navigation.performHorizontalScrollToCell(rowIndex, visibleColIndex, false, () => { this.navigateTo(rowIndex, visibleColIndex, cb); });
        }
        else {
            this.executeCallback(rowIndex, visibleColIndex, cb);
        }
    }
    /**
     * Returns `ICellPosition` which defines the next cell,
     * according to the current position, that match specific criteria.
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * ```typescript
     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} currRowIndex
     * @param {?} curVisibleColIndex
     * @param {?=} callback
     * @return {?}
     */
    getNextCell(currRowIndex, curVisibleColIndex, callback = null) {
        /** @type {?} */
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        /** @type {?} */
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => a - b) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => a - b);
        /** @type {?} */
        const nextCellIndex = colIndexes.find(index => index > curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData) && nextCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    /**
     * Returns `ICellPosition` which defines the previous cell,
     * according to the current position, that match specific criteria.
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * ```typescript
     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} currRowIndex
     * @param {?} curVisibleColIndex
     * @param {?=} callback
     * @return {?}
     */
    getPreviousCell(currRowIndex, curVisibleColIndex, callback = null) {
        /** @type {?} */
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        /** @type {?} */
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => b - a) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => b - a);
        /** @type {?} */
        const prevCellIndex = colIndexes.find(index => index < curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData) && prevCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getPrevDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getPrevDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    /**
     * @private
     * @param {?} rowIndex
     * @param {?=} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    executeCallback(rowIndex, visibleColIndex = -1, cb = null) {
        if (!cb) {
            return;
        }
        /** @type {?} */
        let targetType;
        /** @type {?} */
        let target;
        /** @type {?} */
        const row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            return;
        }
        switch (row.nativeElement.tagName.toLowerCase()) {
            case 'igx-grid-groupby-row':
                targetType = GridKeydownTargetType.groupRow;
                target = row;
                break;
            case 'igx-grid-summary-row':
                targetType = GridKeydownTargetType.summaryCell;
                target = visibleColIndex !== -1 ?
                    row.summaryCells.find(c => c.visibleColumnIndex === visibleColIndex) : row.summaryCells.first;
                break;
            case 'igx-child-grid-row':
                targetType = GridKeydownTargetType.hierarchicalRow;
                target = row;
                break;
            default:
                targetType = GridKeydownTargetType.dataCell;
                target = visibleColIndex !== -1 ? row.cells.find(c => c.visibleColumnIndex === visibleColIndex) : row.cells.first;
                break;
        }
        /** @type {?} */
        const args = { targetType: targetType, target: target };
        cb(args);
    }
    /**
     * @private
     * @param {?} currentRowIndex
     * @return {?}
     */
    getPrevDataRowIndex(currentRowIndex) {
        if (currentRowIndex <= 0) {
            return currentRowIndex;
        }
        /** @type {?} */
        const prevRow = this.dataView.slice(0, currentRowIndex).reverse()
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData);
        return prevRow ? this.dataView.indexOf(prevRow) : currentRowIndex;
    }
    /**
     * @private
     * @param {?} currentRowIndex
     * @return {?}
     */
    getNextDataRowIndex(currentRowIndex) {
        if (currentRowIndex === this.dataView.length) {
            return currentRowIndex;
        }
        /** @type {?} */
        const nextRow = this.dataView.slice(currentRowIndex + 1, this.dataView.length)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData);
        return nextRow ? this.dataView.indexOf(nextRow) : currentRowIndex;
    }
    /**
     * @private
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    isValidPosition(rowIndex, colIndex) {
        /** @type {?} */
        const rows = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).length;
        /** @type {?} */
        const cols = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0).length;
        if (rows < 1 || cols < 1) {
            return false;
        }
        if (rowIndex > -1 && rowIndex < this.dataView.length &&
            colIndex > -1 && colIndex <= this.unpinnedColumns[this.unpinnedColumns.length - 1].visibleIndex) {
            return true;
        }
        return false;
    }
    /**
     * @hidden
     * @param {?} index
     * @param {?} col
     * @return {?}
     */
    trackColumnChanges(index, col) {
        return col.field + col._calcWidth;
    }
    /**
     * @private
     * @param {?} text
     * @param {?} increment
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @param {?=} scroll
     * @return {?}
     */
    find(text, increment, caseSensitive, exactMatch, scroll) {
        if (!this.rowList) {
            return 0;
        }
        this.endEdit(false);
        if (!text) {
            this.clearSearch();
            return 0;
        }
        /** @type {?} */
        const caseSensitiveResolved = caseSensitive ? true : false;
        /** @type {?} */
        const exactMatchResolved = exactMatch ? true : false;
        /** @type {?} */
        let rebuildCache = false;
        if (this.lastSearchInfo.searchText !== text ||
            this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
            this.lastSearchInfo.exactMatch !== exactMatchResolved) {
            this.lastSearchInfo = {
                searchText: text,
                activeMatchIndex: 0,
                caseSensitive: caseSensitiveResolved,
                exactMatch: exactMatchResolved,
                matchInfoCache: []
            };
            rebuildCache = true;
        }
        else {
            this.lastSearchInfo.activeMatchIndex += increment;
        }
        if (rebuildCache) {
            this.rowList.forEach((row) => {
                if (row.cells) {
                    row.cells.forEach((c) => {
                        c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                    });
                }
            });
            this.rebuildMatchCache();
        }
        if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
            this.lastSearchInfo.activeMatchIndex = 0;
        }
        else if (this.lastSearchInfo.activeMatchIndex < 0) {
            this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
        }
        if (this.lastSearchInfo.matchInfoCache.length) {
            /** @type {?} */
            const matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
            this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);
            if (scroll !== false) {
                this.scrollTo(matchInfo.row, matchInfo.column);
            }
            IgxTextHighlightDirective.setActiveHighlight(this.id, {
                column: matchInfo.column,
                row: matchInfo.row,
                index: matchInfo.index,
            });
        }
        else {
            IgxTextHighlightDirective.clearActiveHighlight(this.id);
        }
        return this.lastSearchInfo.matchInfoCache.length;
    }
    /**
     * Returns an array containing the filtered sorted data.
     * ```typescript
     * const filteredSortedData = this.grid1.filteredSortedData;
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    get filteredSortedData() {
        return this._filteredSortedData;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set filteredSortedData(value) {
        this._filteredSortedData = value;
        this.refreshSearch(true);
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    initPinning() {
        /** @type {?} */
        let currentPinnedWidth = 0;
        /** @type {?} */
        const pinnedColumns = [];
        /** @type {?} */
        const unpinnedColumns = [];
        /** @type {?} */
        const newUnpinnedCols = [];
        this.calculateGridWidth();
        this.resetCaches();
        // When a column is a group or is inside a group, pin all related.
        this._pinnedColumns.forEach(col => {
            if (col.parent) {
                col.parent.pinned = true;
            }
            if (col.columnGroup) {
                col.children.forEach(child => child.pinned = true);
            }
        });
        // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
        // We take into account top level columns (top level groups and non groups).
        // If top level is unpinned the pinning handles all children to be unpinned as well.
        for (let i = 0; i < this._columns.length; i++) {
            if (this._columns[i].pinned && !this._columns[i].parent) {
                // Pinned column. Check if with it the unpinned min width is exceeded.
                /** @type {?} */
                const colWidth = parseInt(this._columns[i].width, 10);
                if (currentPinnedWidth + colWidth > this.calcWidth - this.unpinnedAreaMinWidth) {
                    // unpinned min width is exceeded. Unpin the columns and add it to the unpinned collection.
                    this._columns[i].pinned = false;
                    unpinnedColumns.push(this._columns[i]);
                    newUnpinnedCols.push(this._columns[i]);
                }
                else {
                    // unpinned min width is not exceeded. Keep it pinned and add it to the pinned collection.
                    currentPinnedWidth += colWidth;
                    pinnedColumns.push(this._columns[i]);
                }
            }
            else if (this._columns[i].pinned && this._columns[i].parent) {
                if (this._columns[i].topLevelParent.pinned) {
                    pinnedColumns.push(this._columns[i]);
                }
                else {
                    this._columns[i].pinned = false;
                    unpinnedColumns.push(this._columns[i]);
                }
            }
            else {
                unpinnedColumns.push(this._columns[i]);
            }
        }
        if (newUnpinnedCols.length) {
            console.warn('igxGrid - The pinned area exceeds maximum pinned width. ' +
                'The following columns were unpinned to prevent further issues:' +
                newUnpinnedCols.map(col => '"' + col.header + '"').toString() + '. For more info see our documentation.');
        }
        // Assign the applicaple collections.
        this._pinnedColumns = pinnedColumns;
        this._unpinnedColumns = unpinnedColumns;
        this.notifyChanges();
    }
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @param {?=} inCollection
     * @return {?}
     */
    scrollTo(row, column, inCollection = this.filteredSortedData) {
        /** @type {?} */
        let delayScrolling = false;
        if (this.paging && typeof (row) !== 'number') {
            /** @type {?} */
            const rowIndex = inCollection.indexOf(row);
            /** @type {?} */
            const page = Math.floor(rowIndex / this.perPage);
            if (this.page !== page) {
                delayScrolling = true;
                this.page = page;
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(row));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(row));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     * @protected
     * @param {?} column
     * @return {?}
     */
    scrollToHorizontally(column) {
        /** @type {?} */
        let columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
        /** @type {?} */
        const scrollRow = this.rowList.find(r => r.virtDirRow);
        /** @type {?} */
        const virtDir = scrollRow ? scrollRow.virtDirRow : null;
        if (this.pinnedColumns.length) {
            if (columnIndex >= this.pinnedColumns.length) {
                columnIndex -= this.pinnedColumns.length;
                this.scrollDirective(virtDir, columnIndex);
            }
        }
        else {
            this.scrollDirective(virtDir, columnIndex);
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} directive
     * @param {?} goal
     * @return {?}
     */
    scrollDirective(directive, goal) {
        if (!directive) {
            return;
        }
        directive.scrollTo(goal);
    }
    /**
     * @private
     * @return {?}
     */
    rebuildMatchCache() {
        this.lastSearchInfo.matchInfoCache = [];
        /** @type {?} */
        const caseSensitive = this.lastSearchInfo.caseSensitive;
        /** @type {?} */
        const exactMatch = this.lastSearchInfo.exactMatch;
        /** @type {?} */
        const searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
        /** @type {?} */
        const data = this.filteredSortedData;
        /** @type {?} */
        const columnItems = this.visibleColumns.filter((c) => !c.columnGroup).sort((c1, c2) => c1.visibleIndex - c2.visibleIndex);
        /** @type {?} */
        const numberPipe = new IgxDecimalPipeComponent(this.locale);
        /** @type {?} */
        const datePipe = new IgxDatePipeComponent(this.locale);
        data.forEach((dataRow) => {
            columnItems.forEach((c) => {
                /** @type {?} */
                const value = c.formatter ? c.formatter(dataRow[c.field]) :
                    c.dataType === 'number' ? numberPipe.transform(dataRow[c.field], this.locale) :
                        c.dataType === 'date' ? datePipe.transform(dataRow[c.field], this.locale)
                            : dataRow[c.field];
                if (value !== undefined && value !== null && c.searchable) {
                    /** @type {?} */
                    let searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                    if (exactMatch) {
                        if (searchValue === searchText) {
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: 0,
                            });
                        }
                    }
                    else {
                        /** @type {?} */
                        let occurenceIndex = 0;
                        /** @type {?} */
                        let searchIndex = searchValue.indexOf(searchText);
                        while (searchIndex !== -1) {
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: occurenceIndex++,
                            });
                            searchValue = searchValue.substring(searchIndex + searchText.length);
                            searchIndex = searchValue.indexOf(searchText);
                        }
                    }
                }
            });
        });
    }
    /**
     * @hidden
     * @param {?} _group
     * @return {?}
     */
    isExpandedGroup(_group) {
        return undefined;
    }
    /**
     * @protected
     * @param {?} row
     * @return {?}
     */
    changeRowEditingOverlayStateOnScroll(row) {
        if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
            return;
        }
        if (!row) {
            this.toggleRowEditingOverlay(false);
        }
        else {
            this.repositionRowEditingOverlay(row);
        }
    }
    /**
     * Should be called when data and/or isLoading input changes so that the overlay can be
     * hidden/shown based on the current value of shouldOverlayLoading
     * @protected
     * @return {?}
     */
    evaluateLoadingState() {
        if (this.shouldOverlayLoading) {
            // a new overlay should be shown
            /** @type {?} */
            const overlaySettings = {
                outlet: this.loadingOutlet,
                closeOnOutsideClick: false,
                positionStrategy: new ContainerPositionStrategy()
            };
            if (!this._loadingId) {
                this._loadingId = this.overlayService.attach(this.loadingOverlay, overlaySettings);
                this.overlayService.show(this._loadingId, overlaySettings);
            }
        }
        else {
            if (this._loadingId) {
                this.overlayService.hide(this._loadingId);
                this._loadingId = null;
            }
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    openRowOverlay(id) {
        this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
        this.rowEditingOverlay.open(this.rowEditSettings);
        this.rowEditPositioningStrategy.isTopInitialPosition = this.rowEditPositioningStrategy.isTop;
        this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler);
    }
    /**
     * @hidden
     * @return {?}
     */
    closeRowEditingOverlay() {
        this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
        this.rowEditPositioningStrategy.isTopInitialPosition = null;
        this.rowEditingOverlay.close();
        this.rowEditingOverlay.element.parentElement.style.display = '';
    }
    /**
     * @hidden
     * @param {?} show
     * @return {?}
     */
    toggleRowEditingOverlay(show) {
        /** @type {?} */
        const rowStyle = this.rowEditingOverlay.element.style;
        if (show) {
            rowStyle.display = 'block';
        }
        else {
            rowStyle.display = 'none';
        }
    }
    /**
     * @hidden
     * @param {?} row
     * @return {?}
     */
    repositionRowEditingOverlay(row) {
        if (row && !this.rowEditingOverlay.collapsed) {
            /** @type {?} */
            const rowStyle = this.rowEditingOverlay.element.parentElement.style;
            if (row) {
                rowStyle.display = '';
                this.configureRowEditingOverlay(row.rowID);
                this.rowEditingOverlay.reposition();
            }
            else {
                rowStyle.display = 'none';
            }
        }
    }
    /**
     * @private
     * @param {?} rowID
     * @param {?=} useOuter
     * @return {?}
     */
    configureRowEditingOverlay(rowID, useOuter = false) {
        this.rowEditSettings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
        this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
        /** @type {?} */
        const targetRow = this.gridAPI.get_row_by_key(rowID);
        if (!targetRow) {
            return;
        }
        this.rowEditPositioningStrategy.settings.target = targetRow.element.nativeElement;
        this.toggleRowEditingOverlay(true);
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowChangesCount() {
        if (!this.crudService.row) {
            return 0;
        }
        /** @type {?} */
        const rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
        return rowChanges ? Object.keys(rowChanges).length : 0;
    }
    /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    writeToData(rowIndex, value) {
        mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
    }
    /**
     * @param {?} commit
     * @param {?} row
     * @return {?}
     */
    endRowTransaction(commit, row) {
        row.newData = this.transactions.getAggregatedValue(row.id, true);
        /** @type {?} */
        let args = row.createEditEventArgs();
        if (!commit) {
            this.onRowEditCancel.emit(args);
            this.transactions.endPending(false);
        }
        else {
            args = this.gridAPI.update_row(row, row.newData);
        }
        if (args.cancel) {
            this.transactions.startPending();
            return;
        }
        this.crudService.endRowEdit();
        this.closeRowEditingOverlay();
    }
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     *
     * Binding to the event
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param {?=} commit
     * @param {?=} event
     * @return {?}
     */
    endEdit(commit = true, event) {
        /** @type {?} */
        const row = this.crudService.row;
        /** @type {?} */
        const cell = this.crudService.cell;
        // TODO: Merge the crudService with wht BaseAPI service
        if (!row && !cell) {
            return;
        }
        commit ? this.gridAPI.submit_value() : this.gridAPI.escape_editMode();
        if (!this.rowEditable || this.rowEditingOverlay && this.rowEditingOverlay.collapsed || !row) {
            return;
        }
        this.endRowTransaction(commit, row);
        /** @type {?} */
        const activeCell = this.selectionService.activeElement;
        if (event && activeCell) {
            /** @type {?} */
            const rowIndex = activeCell.row;
            /** @type {?} */
            const visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
            this.navigateTo(rowIndex, visibleColIndex, (c) => {
                if (c.targetType === GridKeydownTargetType.dataCell && c.target) {
                    c.target.nativeElement.focus();
                }
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get dataWithAddedInTransactionRows() {
        /** @type {?} */
        const result = (/** @type {?} */ (cloneArray(this.gridAPI.get_all_data())));
        if (this.transactions.enabled) {
            result.push(...this.transactions.getAggregatedChanges(true)
                .filter(t => t.type === TransactionType.ADD)
                .map(t => t.newValue));
        }
        return result;
    }
    /**
     * @return {?}
     */
    get dataLength() {
        return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
    }
    /**
     * @return {?}
     */
    hasHorizontalScroll() {
        return this.totalWidth - this.unpinnedWidth > 0;
    }
    /**
     * @protected
     * @param {?} row
     * @return {?}
     */
    _restoreVirtState(row) {
        // check virtualization state of data record added from cache
        // in case state is no longer valid - update it.
        /** @type {?} */
        const rowForOf = row.virtDirRow;
        /** @type {?} */
        const gridScrLeft = rowForOf.getScroll().scrollLeft;
        /** @type {?} */
        const left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
        /** @type {?} */
        const actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
        if (gridScrLeft !== actualScrollLeft) {
            rowForOf.onHScroll(gridScrLeft);
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getExportExcel() {
        return this._exportExcel;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getExportCsv() {
        return this._exportCsv;
    }
    /**
     * @hidden
     * @return {?}
     */
    get shouldOverlayLoading() {
        return this.isLoading && this.data && this.data.length > 0;
    }
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    isSummaryRow(rowData) {
        return rowData.summaries && (rowData.summaries instanceof Map);
    }
    /**
     * @hidden
     * @return {?}
     */
    get isMultiRowSelectionEnabled() {
        return this.rowSelection === GridSelectionMode.multiple;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isRowSelectable() {
        return this.rowSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden
     * @return {?}
     */
    get isCellSelectable() {
        return this.cellSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    cachedViewLoaded(args) {
        if (args.context['templateID'] === 'dataRow' && args.context['$implicit'] === args.oldContext['$implicit']) {
            args.view.detectChanges();
            /** @type {?} */
            const row = this.getRowByIndex(args.context.index);
            if (row && row.cells) {
                row.cells.forEach((c) => {
                    c.highlightText(this.lastSearchInfo.searchText, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch);
                });
            }
        }
        if (this.hasHorizontalScroll()) {
            /** @type {?} */
            const tmplId = args.context.templateID;
            /** @type {?} */
            const index = args.context.index;
            args.view.detectChanges();
            /** @type {?} */
            const row = tmplId === 'dataRow' ? this.getRowByIndex(index) : null;
            /** @type {?} */
            const summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.find((sr) => sr.dataRowIndex === index) : null;
            if (row && row instanceof IgxRowComponent) {
                this._restoreVirtState(row);
            }
            else if (summaryRow) {
                this._restoreVirtState(summaryRow);
            }
        }
    }
    /**
     * Opens the advanced filtering dialog.
     * @return {?}
     */
    openAdvancedFilteringDialog() {
        if (!this._advancedFilteringOverlayId) {
            this._advancedFilteringOverlaySettings.positionStrategy.settings.target =
                ((/** @type {?} */ (this))).rootGrid ? ((/** @type {?} */ (this))).rootGrid.nativeElement : this.nativeElement;
            this._advancedFilteringOverlaySettings.outlet = this.outletDirective;
            this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
                injector: this.viewRef.injector,
                componentFactoryResolver: this.resolver
            });
            this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
        }
    }
    /**
     * Closes the advanced filtering dialog.
     * @param {?} applyChanges indicates whether the changes should be applied
     * @return {?}
     */
    closeAdvancedFilteringDialog(applyChanges) {
        if (this._advancedFilteringOverlayId) {
            /** @type {?} */
            const advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
            /** @type {?} */
            const advancedFilteringDialog = (/** @type {?} */ (advancedFilteringOverlay.componentRef.instance));
            if (applyChanges) {
                advancedFilteringDialog.applyChanges();
            }
            advancedFilteringDialog.closeDialog();
        }
    }
}
IgxGridBaseComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
/** @nocollapse */
IgxGridBaseComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxGridTransaction,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: IgxGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxGridBaseComponent.propDecorators = {
    defaultExpandedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExpandedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultCollapsedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultCollapsedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    resourceStrings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    autoGenerate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    emptyGridTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    loadingGridTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filteringLogic: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filteringExpressionsTree: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filteringExpressionsTreeChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    advancedFilteringExpressionsTree: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    locale: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    paging: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    page: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pageChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    perPage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    perPageChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    paginationTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnHiding: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowSelectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideRowSelectors: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowDraggable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowEditable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    height: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.height',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hostWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.width',] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    evenRowCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    oddRowCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    primaryKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    emptyGridMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isLoading: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    emptyFilteredGridMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnHidingTitle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnPinning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    columnPinningTitle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    allowFiltering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    allowAdvancedFiltering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    summaryPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    summaryCalculationMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    filterStrategy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    uniqueColumnValuesStrategy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onCellClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowSelectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnPinning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCellEditCancel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCellEditEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onCellEdit: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowEditEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowEdit: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowEditCancel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnInit: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onSortingDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onFilteringDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onPagingDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowAdded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowDeleted: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDataPreLoad: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnResized: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onContextMenu: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onDoubleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnVisibilityChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnMovingStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnMoving: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onColumnMovingEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onGridKeydown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowDragStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRowDragEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onGridCopy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    resizeLine: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxGridColumnResizerComponent, { static: false },] }],
    loadingOverlay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['loadingOverlay', { static: true },] }],
    loadingOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    columnList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true },] }],
    excelStyleSortingTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxExcelStyleSortingTemplateDirective, { read: IgxExcelStyleSortingTemplateDirective, static: false },] }],
    excelStyleMovingTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxExcelStyleMovingTemplateDirective, { read: IgxExcelStyleMovingTemplateDirective, static: false },] }],
    excelStyleHidingTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxExcelStyleHidingTemplateDirective, { read: IgxExcelStyleHidingTemplateDirective, static: false },] }],
    excelStylePinningTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxExcelStylePinningTemplateDirective, { read: IgxExcelStylePinningTemplateDirective, static: false },] }],
    excelStyleLoadingValuesTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true },] }],
    headerGroups: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent },] }],
    _rowList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: ['row',] }],
    _summaryRowList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: ['summaryRow', { read: IgxSummaryRowComponent },] }],
    _dataRowList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxRowComponent, { read: IgxRowComponent },] }],
    emptyFilteredGridTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['emptyFilteredGrid', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    emptyGridDefaultTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultEmptyGrid', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    loadingGridDefaultTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultLoadingGrid', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    parentVirtDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['scrollContainer', { read: IgxGridForOfDirective, static: true },] }],
    toolbarCustomContentTemplates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false },] }],
    headSelectorsTemplates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false },] }],
    rowSelectorsTemplates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false },] }],
    verticalScrollContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['verticalScrollContainer', { read: IgxGridForOfDirective, static: true },] }],
    verticalScroll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['verticalScrollHolder', { read: IgxGridForOfDirective, static: true },] }],
    scr: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['scr', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: true },] }],
    footer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['footer', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    headerContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['hContainer', { read: IgxGridForOfDirective, static: true },] }],
    headerSelectorContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['headerSelectorContainer', { static: false },] }],
    headerDragContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['headerDragContainer', { static: false },] }],
    headerGroupContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['headerGroupContainer', { static: false },] }],
    filteringRow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['filteringRow', { read: IgxGridFilteringRowComponent, static: false },] }],
    theadRow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['theadRow', { static: true },] }],
    tbody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['tbody', { static: true },] }],
    tfoot: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['tfoot', { static: true },] }],
    _outletDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    rowEditingOutletDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    tmpOutlets: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
    dragIndicatorIconBase: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dragIndicatorIconBase', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultRowEditTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultRowEditTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    rowEditCustom: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxRowEditTemplateDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    rowEditText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxRowEditTextDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    rowEditActions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxRowEditActionsDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    rowExpandedIndicatorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxRowExpandedIndicatorDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    rowCollapsedIndicatorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxRowCollapsedIndicatorDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    headerExpandIndicatorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxHeaderExpandIndicatorDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    headerCollapseIndicatorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxHeaderCollapseIndicatorDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    rowEditTabsDEFAULT: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxRowEditTabStopDirective,] }],
    rowEditTabsCUSTOM: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxRowEditTabStopDirective,] }],
    rowEditingOverlay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxToggleDirective, { static: false },] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    hostClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.class',] }],
    hostRole: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    sortingExpressions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    sortingExpressionsChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    hiddenColumnsText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pinnedColumnsText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    toolbar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['toolbar', { read: IgxGridToolbarComponent, static: false },] }],
    toolbarHtml: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['toolbar', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    showToolbar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    toolbarTitle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    exportExcel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    exportCsv: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    exportText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    exportExcelText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    exportCsvText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    clipboardOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cellSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onToolbarExporting: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRangeSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Number),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Number])
], IgxGridBaseComponent.prototype, "filteringLogic", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "filteringExpressionsTree", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "advancedFilteringExpressionsTree", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty('rowSelectable property is deprecated. Use rowSelection property instead.'),
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "rowSelectable", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "hideRowSelectors", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "rowEditable", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "height", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "width", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "rowHeight", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "columnWidth", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)
], IgxGridBaseComponent.prototype, "primaryKey", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "isLoading", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "columnPinning", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Array),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Array])
], IgxGridBaseComponent.prototype, "sortingExpressions", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "hiddenColumnsText", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])
], IgxGridBaseComponent.prototype, "pinnedColumnsText", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "showToolbar", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "toolbarTitle", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "exportExcel", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxGridBaseComponent.prototype, "exportCsv", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "exportText", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "exportExcelText", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "exportCsvText", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "cellSelection", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    WatchChanges(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])
], IgxGridBaseComponent.prototype, "rowSelection", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGridFooterComponent {
}
IgxGridFooterComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-grid-footer',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxSummaryDataPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} id
     * @param {?=} trigger
     * @return {?}
     */
    transform(id, trigger = 0) {
        /** @type {?} */
        const summaryService = this.gridAPI.grid.summaryService;
        return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
    }
}
IgxSummaryDataPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxGridSummaryDataPipe',
                pure: true
            },] }
];
/** @nocollapse */
IgxSummaryDataPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxProcessBarTextTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxProcessBarTextTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxProcessBarText]'
            },] }
];
/** @nocollapse */
IgxProcessBarTextTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ONE_PERCENT = 0.01;
/** @type {?} */
const MIN_VALUE = 0;
/** @enum {string} */
const IgxTextAlign = {
    START: 'start',
    CENTER: 'center',
    END: 'end',
};
/** @enum {string} */
const IgxProgressType = {
    DANGER: 'danger',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success',
};
/**
 * @abstract
 */
class BaseProgress {
    constructor() {
        /**
         * @hidden
         */
        this.requestAnimationId = undefined;
        /**
         * @hidden
         */
        this._valueInPercent = MIN_VALUE;
        /**
         * @hidden
         */
        this._max = 100;
        /**
         * @hidden
         */
        this._value = MIN_VALUE;
        /**
         * @hidden
         */
        this._animate = true;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *    let percentValue = this.progressBar.valueInPercent;
     *    alert(percentValue);
     * }
     * ```
     * @return {?}
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *    public setValue(event){
     *    this.progressBar.valueInPercent = 56;
     * }
     * //...
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
     * ```
     * @param {?} value
     * @return {?}
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    updateProgressSmoothly(val, step) {
        this._value += step;
        /** @type {?} */
        const passedValue = convertInPercentage(val, this._max);
        /** @type {?} */
        const progressValue = convertInPercentage(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @return {?}
     */
    updateProgressDirectly(val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    }
    /**
     * @hidden
     * @protected
     * @param {?} currentValue
     * @param {?} prevValue
     * @param {?} step
     * @return {?}
     */
    directionFlow(currentValue, prevValue, step) {
        if (currentValue < prevValue) {
            return step;
        }
        return -step;
    }
    /**
     * @hidden
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @private
     * @param {?} val
     * @return {?}
     */
    updateProgress(val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    }
}
/** @type {?} */
let NEXT_LINEAR_ID = 0;
/** @type {?} */
let NEXT_CIRCULAR_ID = 0;
class IgxLinearProgressBarComponent extends BaseProgress {
    constructor() {
        super();
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * An \@Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *    this.positionCenter = IgxTextAlign.CENTER;
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
         * ```
         */
        this.onProgressChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @param {?} animate
     * @return {?}
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     * }
     * ```
     * @return {?}
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
     * ```
     * @param {?} maxNum
     * @return {?}
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     * }
     * ```
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     * }
     * ```
     * @return {?}
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     * }
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        val = Number(val);
        if (this._value === val || this.indeterminate) {
            return;
        }
        /** @type {?} */
        const valueInRange = getValueInProperRange(val, this.max);
        if (isNaN(valueInRange)) {
            return;
        }
        /** @type {?} */
        const changedValues = {
            currentValue: valueInRange,
            previousValue: this._value
        };
        /** @type {?} */
        const updateValue = super.directionFlow(this._value, val, this.step);
        if (this._animate && val >= this.step) {
            super.runAnimation(valueInRange, updateValue);
        }
        else {
            super.updateProgressDirectly(valueInRange);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     * @return {?}
     */
    get danger() {
        return this.type === IgxProgressType.DANGER;
    }
    /**
     * @hidden
     * @return {?}
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     * @return {?}
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     * @return {?}
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
}
IgxLinearProgressBarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\"\n    [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            }] }
];
/** @nocollapse */
IgxLinearProgressBarComponent.ctorParameters = () => [];
IgxLinearProgressBarComponent.propDecorators = {
    animate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-valuemax',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    valueMin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-valuemin',] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar',] }],
    striped: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar--striped',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    indeterminate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar--indeterminate',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    textAlign: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    textVisibility: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    textTop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    text: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-valuenow',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onProgressChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    danger: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar--danger',] }],
    info: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar--info',] }],
    warning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar--warning',] }],
    success: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-linear-bar--success',] }]
};
class IgxCircularProgressBarComponent extends BaseProgress {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super();
        this.renderer = renderer;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        /**
         * @hidden
         */
        this.cssClass = 'igx-circular-bar';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * ```
         */
        this.onProgressChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * An \@Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
    }
    /**
     * @hidden
     * @return {?}
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
     * ```html
     * <igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
     * ```
     * @param {?} animate
     * @return {?}
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     * }
     * ```
     * @return {?}
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     * @param {?} maxNum
     * @return {?}
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     * }
     * ```
     * ```html
     * <igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
     * ```
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     * }
     * ```
     * @return {?}
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        val = Number(val);
        if (this._value === val || this.indeterminate) {
            return;
        }
        /** @type {?} */
        const valueInProperRange = getValueInProperRange(val, this.max);
        if (isNaN(valueInProperRange)) {
            return;
        }
        /** @type {?} */
        const changedValues = {
            currentValue: valueInProperRange,
            previousValue: this._value
        };
        /** @type {?} */
        const updateValue = super.directionFlow(this._value, val, this.step);
        if (this.animate && val >= this.step) {
            super.runAnimation(valueInProperRange, updateValue);
        }
        else {
            this.updateProgressDirectly(valueInProperRange);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        /** @type {?} */
        const FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     * @return {?}
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    /**
     * @private
     * @param {?} percentage
     * @return {?}
     */
    getProgress(percentage) {
        // Reverse the sign here: '-' should become '+' in RTL mode
        return this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <text [class.igx-circular-bar__text--hidden]=\"!textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate; context: context\">\n        </ng-container>\n    </text>\n\n    <ng-template #defaultTextTemplate>\n        <tspan class=\"igx-circular-bar__text\"> {{textContent ? textContent: valueInPercent + '%'}}</tspan>\n    </ng-template>\n</svg>\n"
            }] }
];
/** @nocollapse */
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
IgxCircularProgressBarComponent.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-circular-bar',] }],
    onProgressChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    indeterminate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-circular-bar--indeterminate',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    textVisibility: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    text: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    textTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective, static: false },] }],
    animate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    _svgCircle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['circle', { static: true },] }]
};
/**
 * @param {?} value
 * @param {?} max
 * @param {?=} min
 * @return {?}
 */
function getValueInProperRange(value, max, min = 0) {
    return Math.max(Math.min(value, max), min);
}
/**
 * @param {?} value
 * @param {?} max
 * @return {?}
 */
function convertInPercentage(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
class IgxProgressBarModule {
}
IgxProgressBarModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                exports: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The `<igx-select-item>` is a container intended for row items in
 * a `<igx-select>` container.
 */
class IgxSelectGroupComponent extends IgxDropDownGroupComponent {
}
IgxSelectGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-select-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-select-item"></ng-content>
    `
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden \@internal
 */
class IgxSelectItemNavigationDirective extends IgxDropDownItemNavigationDirective {
    constructor() {
        super(null);
        // tslint:disable:member-ordering
        this.inputStream = '';
        this.clearStream$ = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
    }
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     * @param {?} event
     * @return {?}
     */
    handleKeyDown(event) {
        if (!event || event.shiftKey) {
            return;
        }
        /** @type {?} */
        const key = event.key.toLowerCase();
        if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
            this.target.toggle();
            return;
        }
        if (this.target.collapsed) {
            switch (key) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'enter':
                    event.preventDefault();
                    this.target.open();
                    return;
                case 'arrowdown':
                case 'down':
                    this.target.navigateNext();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                case 'arrowup':
                case 'up':
                    this.target.navigatePrev();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                default:
                    break;
            }
        }
        super.handleKeyDown(event);
    }
    /**
     * Handle continuous letter typing navigation
     * @param {?} event
     * @return {?}
     */
    captureKey(event) {
        // relying only on key, available on all major browsers:
        // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
        if (!event || !event.key || event.key.length > 1) {
            // ignore longer keys ('Alt', 'ArrowDown', etc)
            return;
        }
        this.clearStream$.unsubscribe();
        this.clearStream$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["timer"])(500).subscribe(() => {
            this.inputStream = '';
        });
        this.inputStream += event.key;
        /** @type {?} */
        const focusedItem = (/** @type {?} */ (this.target.focusedItem));
        // select the item
        if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
            return;
        }
        this.activateItemByText(this.inputStream);
    }
    /**
     * @param {?} text
     * @return {?}
     */
    activateItemByText(text) {
        /** @type {?} */
        const items = (/** @type {?} */ (this.target.items));
        /** @type {?} */
        const activeItemIndex = items.indexOf((/** @type {?} */ (this.target.focusedItem))) || 0;
        // ^ this is focused OR selected if the dd is closed
        /** @type {?} */
        let nextItem = items.slice(activeItemIndex + 1).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
        if (!nextItem) {
            nextItem = items.slice(0, activeItemIndex).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
        }
        if (!nextItem) {
            return;
        }
        if (this.target.collapsed) {
            this.target.selectItem(nextItem);
        }
        this.target.navigateItem(items.indexOf(nextItem));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.clearStream$.unsubscribe();
    }
}
IgxSelectItemNavigationDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxSelectItemNavigation]'
            },] }
];
/** @nocollapse */
IgxSelectItemNavigationDirective.ctorParameters = () => [];
IgxSelectItemNavigationDirective.propDecorators = {
    target: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxSelectItemNavigation',] }],
    captureKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keyup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxSelectModule {
}
IgxSelectModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective, IgxSelectGroupComponent],
                exports: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective, IgxSelectGroupComponent],
                imports: [IgxRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxInputGroupModule, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"],
                    IgxToggleModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxPaginatorComponent extends DisplayDensityBase {
    /**
     * @param {?} _displayDensityOptions
     */
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
        this._page = 0;
        this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
        this._perPage = 15;
        /**
         * An \@Input property that sets if the pager in the paginator should be enabled.
         * ```html
         * <igx-paginator [pagerEnabled]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */
        this.pagerEnabled = true;
        /**
         * An \@Input property that sets if the pager in the paginator should be hidden.
         * ```html
         * <igx-paginator [pagerHidden]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */
        this.pagerHidden = false;
        /**
         * An \@Input property that sets if the dropdown in the paginator should be enabled.
         * ```html
         * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */
        this.dropdownEnabled = true;
        /**
         * An \@Input property that sets if the dropdown in the paginator should be hidden.
         * ```html
         * <igx-paginator [dropdownHidden]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */
        this.dropdownHidden = false;
        /**
         * An \@Input property, sets number of label of the select.
         * The default is 'Items per page' localized string.
         * ```html
         * <igx-paginator label="My custom label"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */
        this.selectLabel = CurrentResourceStrings.PaginatorResStrings.igx_paginator_label;
        /**
         * An event that is emitted when the select in the `IgxPaginatorComponent` changes its value.
         */
        this.perPageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the paginating is used.
         */
        this.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Sets the class of the IgxPaginatorComponent based
     * on the provided displayDensity.
     * @return {?}
     */
    get classCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @return {?}
     */
    get classCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @return {?}
     */
    get classComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * An \@Input property, sets current page of the `IgxPaginatorComponent`.
     * The default is 0.
     * ```typescript
     * let page = this.paginator.page;
     * ```
     * \@memberof IgxPaginatorComponent
     * @return {?}
     */
    get page() {
        return this._page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this._page = value;
        this.pageChange.emit(this._page);
    }
    /**
     * An \@Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
     * The default is 15.
     * ```typescript
     * let itemsPerPage = this.paginator.perPage;
     * ```
     * \@memberof IgxPaginatorComponent
     * @return {?}
     */
    get perPage() {
        return this._perPage;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set perPage(value) {
        this._perPage = Number(value);
        this.perPageChange.emit(this._perPage);
        this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
        this.totalPages = Math.ceil(this.totalRecords / this._perPage);
    }
    /**
     * An \@Input property that sets the total records.
     * ```typescript
     * let totalRecords = this.paginator.totalRecords;
     * ```
     * \@memberof IgxPaginatorComponent
     * @return {?}
     */
    get totalRecords() {
        return this._totalRecords;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set totalRecords(value) {
        this._totalRecords = value;
        this.totalPages = Math.ceil(this.totalRecords / this.perPage);
    }
    /**
     * An \@Input property that sets custom options in the select of the paginator
     * ```typescript
     * let options = this.paginator.selectOptions;
     * ```
     * \@memberof IgxPaginatorComponent
     * @return {?}
     */
    get selectOptions() {
        return this._selectOptions;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectOptions(value) {
        this._selectOptions = this.sortUniqueOptions(value, this._perPage);
        this.defaultSelectValues = [...this._selectOptions];
    }
    /**
     * Returns if the current page is the last page.
     * ```typescript
     * const lastPage = this.paginator.isLastPage;
     * ```
     * @return {?}
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns if the current page is the first page.
     * ```typescript
     * const lastPage = this.paginator.isFirstPage;
     * ```
     * @return {?}
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * @private
     * @param {?} values
     * @param {?} newOption
     * @return {?}
     */
    sortUniqueOptions(values, newOption) {
        return Array.from(new Set([...values, newOption])).sort((a, b) => a - b);
    }
    /**
     * Sets DisplayDensity for the <select> inside the paginator
     * @hidden
     * @return {?}
     */
    paginatorSelectDisplayDensity() {
        if (this.displayDensity === DisplayDensity.comfortable) {
            return DisplayDensity.cosy;
        }
        return DisplayDensity.compact;
    }
    /**
     * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
     * ```typescript
     * this.paginator.nextPage();
     * ```
     * \@memberof IgxPaginatorComponent
     * @return {?}
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
     * ```typescript
     * this.paginator.previousPage();
     * ```
     * \@memberof IgxPaginatorComponent
     * @return {?}
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.pagiantor.paginate(1);
     * ```
     * \@memberof IgxPaginatorComponent
     * @param {?} val
     * @return {?}
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
}
IgxPaginatorComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-paginator',
                template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ selectLabel }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\">\n    <button [disabled]=\"isFirstPage || !pagerEnabled ? true: false\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"isFirstPage || !pagerEnabled ? true: false\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text'>\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;of&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [disabled]=\"isLastPage || !pagerEnabled ? true: false\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n    <button [disabled]=\"isLastPage || !pagerEnabled ? true: false\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxPaginatorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxPaginatorComponent.propDecorators = {
    classCosy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-paginator--cosy',] }],
    classCompact: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-paginator--compact',] }],
    classComfortable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-paginator',] }],
    page: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    perPage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    totalRecords: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pagerEnabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pagerHidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropdownEnabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropdownHidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    perPageChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    pageChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
class IgxPaginatorModule {
}
IgxPaginatorModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxPaginatorComponent],
                exports: [IgxPaginatorComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxSelectModule, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxIconModule, IgxButtonModule, IgxRippleModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * \@internal
 */
class IgxGridCellStyleClassesPipe {
    /**
     * @param {?} cssClasses
     * @param {?} value
     * @param {?} data
     * @param {?} field
     * @param {?} index
     * @return {?}
     */
    transform(cssClasses, value, data, field, index) {
        if (!cssClasses) {
            return '';
        }
        /** @type {?} */
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            /** @type {?} */
            const callbackOrValue = cssClasses[cssClass];
            /** @type {?} */
            const apply = typeof callbackOrValue === 'function' ? callbackOrValue(data, field, value, index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
}
IgxGridCellStyleClassesPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxCellStyleClasses'
            },] }
];
/**
 * @hidden
 * \@internal
 */
class IgxGridCellStylesPipe {
    /**
     * @param {?} styles
     * @param {?} value
     * @param {?} data
     * @param {?} field
     * @param {?} index
     * @return {?}
     */
    transform(styles, value, data, field, index) {
        /** @type {?} */
        const css = {};
        if (!styles) {
            return css;
        }
        for (const prop of Object.keys(styles)) {
            /** @type {?} */
            const res = styles[prop];
            css[prop] = typeof res === 'function' ? res(data, field, value, index) : res;
        }
        return css;
    }
}
IgxGridCellStylesPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxCellStyles'
            },] }
];
/**
 * @hidden
 * \@internal
 */
class IgxGridNotGroupedPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return value.filter(item => !item.columnGroup);
    }
}
IgxGridNotGroupedPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxNotGrouped'
            },] }
];
class IgxGridTopLevelColumns {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return value.filter(item => item.level === 0);
    }
}
IgxGridTopLevelColumns.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'igxTopLevel'
            },] }
];
/**
 * @hidden
 */
class IgxGridFilterConditionPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return value.split(/(?=[A-Z])/).join(' ');
    }
}
IgxGridFilterConditionPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'filterCondition',
                pure: true
            },] }
];
/**
 * @hidden
 */
class IgxGridTransactionPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            /** @type {?} */
            const result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
            return result;
        }
        return collection;
    }
}
IgxGridTransactionPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridTransaction',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridPaginatorOptionsPipe {
    /**
     * @param {?} values
     * @return {?}
     */
    transform(values) {
        return Array.from(new Set([...values])).sort((a, b) => a - b);
    }
}
IgxGridPaginatorOptionsPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'paginatorOptions',
                pure: true,
            },] }
];
class IgxHasVisibleColumnsPipe {
    /**
     * @param {?} values
     * @param {?} hasVisibleColumns
     * @return {?}
     */
    transform(values, hasVisibleColumns) {
        if (!(values && values.length)) {
            return values;
        }
        return hasVisibleColumns ? values : [];
    }
}
IgxHasVisibleColumnsPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'visibleColumns',
                pure: true
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGridPipesModule {
}
IgxGridPipesModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxDatePipeComponent,
                    IgxDecimalPipeComponent,
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe
                ],
                exports: [
                    IgxDatePipeComponent,
                    IgxDecimalPipeComponent,
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExcelStyleColumnMovingComponent {
    constructor() { }
    /**
     * @private
     * @return {?}
     */
    get visibleColumns() {
        return this.grid.visibleColumns.filter(col => !(col instanceof IgxColumnGroupComponent));
    }
    /**
     * @return {?}
     */
    get canNotMoveLeft() {
        return this.column.visibleIndex === 0 ||
            (this.grid.unpinnedColumns.indexOf(this.column) === 0 && this.column.disablePinning) ||
            (this.grid.unpinnedColumns.indexOf(this.column) === 0 && !this.isColumnPinnable) ||
            (this.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
    }
    /**
     * @return {?}
     */
    get canNotMoveRight() {
        return this.column.visibleIndex === this.visibleColumns.length - 1 ||
            (this.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
    }
    /**
     * @param {?} moveDirection
     * @return {?}
     */
    onMoveButtonClicked(moveDirection) {
        /** @type {?} */
        let targetColumn;
        if (this.column.pinned) {
            if (this.column.isLastPinned && moveDirection === 1) {
                targetColumn = this.grid.unpinnedColumns[0];
                moveDirection = 0;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.grid.pinnedColumns);
            }
        }
        else if (this.grid.unpinnedColumns.indexOf(this.column) === 0 && moveDirection === 0) {
            targetColumn = this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1];
            if (targetColumn.parent) {
                targetColumn = targetColumn.topLevelParent;
            }
            moveDirection = 1;
        }
        else {
            targetColumn = this.findColumn(moveDirection, this.grid.unpinnedColumns);
        }
        this.grid.moveColumn(this.column, targetColumn, moveDirection);
    }
    /**
     * @private
     * @param {?} moveDirection
     * @param {?} columns
     * @return {?}
     */
    findColumn(moveDirection, columns) {
        /** @type {?} */
        let index = columns.indexOf(this.column);
        if (moveDirection === 0) {
            while (index > 0) {
                index--;
                if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                    return columns[index];
                }
            }
        }
        else {
            while (index < columns.length - 1) {
                index++;
                if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                    return columns[index];
                }
            }
        }
    }
}
IgxExcelStyleColumnMovingComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-column-moving',
                template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n"
            }] }
];
/** @nocollapse */
IgxExcelStyleColumnMovingComponent.ctorParameters = () => [];
IgxExcelStyleColumnMovingComponent.propDecorators = {
    column: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    grid: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayDensity: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isColumnPinnable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
class IgxListBase extends DisplayDensityBase {
    /**
     * @param {?} _displayDensityOptions
     */
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
    }
}
/** @nocollapse */
IgxListBase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
/** @enum {number} */
const IgxListPanState = {
    NONE: 0, LEFT: 1, RIGHT: 2,
};
IgxListPanState[IgxListPanState.NONE] = 'NONE';
IgxListPanState[IgxListPanState.LEFT] = 'LEFT';
IgxListPanState[IgxListPanState.RIGHT] = 'RIGHT';
class IgxEmptyListTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxEmptyListTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxEmptyList]'
            },] }
];
/** @nocollapse */
IgxEmptyListTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxDataLoadingTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxDataLoadingTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDataLoading]'
            },] }
];
/** @nocollapse */
IgxDataLoadingTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxListItemLeftPanningTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxListItemLeftPanningTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxListItemLeftPanning]'
            },] }
];
/** @nocollapse */
IgxListItemLeftPanningTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxListItemRightPanningTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxListItemRightPanningTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxListItemRightPanning]'
            },] }
];
/** @nocollapse */
IgxListItemRightPanningTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
class IgxListItemComponent {
    /**
     * @param {?} list
     * @param {?} elementRef
     * @param {?} _renderer
     */
    constructor(list, elementRef, _renderer) {
        this.list = list;
        this.elementRef = elementRef;
        this._renderer = _renderer;
        /**
         * @hidden
         */
        this._panState = IgxListPanState.NONE;
        /**
         * @hidden
         */
        this.panOffset = 0;
        /**
         * @hidden
         */
        this._index = null;
        /**
         * @hidden
         */
        this.lastPanDir = IgxListPanState.NONE;
        /**
         * Sets/gets whether the `list item` is hidden.
         * By default the `hidden` value is `false`.
         * ```html
         * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
         * ```
         * ```typescript
         * let isHidden =  this.listItem.hidden;
         * ```
         * \@memberof IgxListItemComponent
         */
        this.hidden = false;
        /**
         * Gets the `touch-action` style of the `list item`.
         * ```typescript
         * let touchAction = this.listItem.touchAction;
         * ```
         */
        this.touchAction = 'pan-y';
    }
    /**
     * Gets the `role` attribute of the `list item`.
     * ```typescript
     * let itemRole =  this.listItem.role;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get role() {
        return this.isHeader ? 'separator' : 'listitem';
    }
    /**
     * Indicates whether `list item` should have header style.
     * ```typescript
     * let headerStyle =  this.listItem.headerStyle;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get headerStyle() {
        return this.isHeader;
    }
    /**
     * Applies the inner style of the `list item` if the item is not counted as header.
     * ```typescript
     * let innerStyle =  this.listItem.innerStyle;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get innerStyle() {
        return !this.isHeader;
    }
    /**
     * Returns string value which describes the display mode of the `list item`.
     * ```typescript
     * let isHidden = this.listItem.display;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get display() {
        return this.hidden ? 'none' : '';
    }
    /**
     * @hidden
     * @param {?} evt
     * @return {?}
     */
    clicked(evt) {
        this.list.onItemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
        this.lastPanDir = IgxListPanState.NONE;
    }
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    panStart(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
    }
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    panMove(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        /** @type {?} */
        const isPanningToLeft = ev.deltaX < 0;
        if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
            this.showLeftPanTemplate();
            this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
        }
        else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
            this.showRightPanTemplate();
            this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
        }
    }
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    panEnd(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        // the translation offset of the current list item content
        /** @type {?} */
        const relativeOffset = this.panOffset;
        /** @type {?} */
        const widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
        if (relativeOffset === 0) {
            return; // no panning has occured
        }
        /** @type {?} */
        const dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;
        this.lastPanDir = dir;
        /** @type {?} */
        const oldPanState = this._panState;
        if (Math.abs(relativeOffset) < widthTriggeringGrip) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
            this.hideLeftAndRightPanTemplates();
            return;
        }
        /** @type {?} */
        const args = { item: this, direction: dir, keepItem: false };
        if (dir === IgxListPanState.LEFT) {
            this.list.onLeftPan.emit(args);
        }
        else {
            this.list.onRightPan.emit(args);
        }
        if (args.keepItem === true) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
        }
        else {
            if (dir === IgxListPanState.LEFT) {
                this.setContentElementLeft(this.maxLeft);
                this._panState = IgxListPanState.LEFT;
            }
            else {
                this.setContentElementLeft(this.maxRight);
                this._panState = IgxListPanState.RIGHT;
            }
        }
        if (oldPanState !== this._panState) {
            /** @type {?} */
            const args2 = { oldState: oldPanState, newState: this._panState, item: this };
            this.list.onPanStateChange.emit(args2);
        }
        this.hideLeftAndRightPanTemplates();
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    showLeftPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    showRightPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    hideLeftAndRightPanTemplates() {
        setTimeout(() => {
            this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
        }, 500);
    }
    /**
     * @hidden
     * @private
     * @param {?} leftVisibility
     * @param {?} rightVisibility
     * @return {?}
     */
    setLeftAndRightTemplatesVisibility(leftVisibility, rightVisibility) {
        if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
            this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
        }
        if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
            this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
        }
    }
    /**
     * Gets the `panState` of a `list item`.
     * ```typescript
     * let itemPanState =  this.listItem.panState;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get panState() {
        return this._panState;
    }
    /**
     * Gets the `index` of a `list item`.
     * ```typescript
     * let itemIndex =  this.listItem.index;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get index() {
        return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
    }
    /**
     * Sets the `index` of the `list item`.
     * ```typescript
     * this.listItem.index = index;
     * ```
     * \@memberof IgxListItemComponent
     * @param {?} value
     * @return {?}
     */
    set index(value) {
        this._index = value;
    }
    /**
     * Returns an element reference to the list item.
     * ```typescript
     * let listItemElement =  this.listItem.element.
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns a reference container which contains the list item's content.
     * ```typescript
     * let listItemContainer =  this.listItem.contentElement.
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get contentElement() {
        /** @type {?} */
        const candidates = this.element.getElementsByClassName('igx-list__item-content');
        return (candidates && candidates.length > 0) ? candidates[0] : null;
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the `list item container`
     * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
     * ```typescript
     * let listItemComponent = this.listItem.context;
     * ```
     * @return {?}
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets the width of a `list item`.
     * ```typescript
     * let itemWidth = this.listItem.width;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get width() {
        if (this.element) {
            return this.element.offsetWidth;
        }
    }
    /**
     * Gets the maximum left position of the `list item`.
     * ```typescript
     * let maxLeft = this.listItem.maxLeft;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get maxLeft() {
        return -this.width;
    }
    /**
     * Gets the maximum right position of the `list item`.
     * ```typescript
     * let maxRight = this.listItem.maxRight;
     * ```
     * \@memberof IgxListItemComponent
     * @return {?}
     */
    get maxRight() {
        return this.width;
    }
    /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    setContentElementLeft(value) {
        this.panOffset = value;
        this.contentElement.style.transform = 'translateX(' + value + 'px)';
    }
    /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    isTrue(value) {
        if (typeof (value) === 'boolean') {
            return value;
        }
        else {
            return value === 'true';
        }
    }
}
IgxListItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-list-item',
                template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush
            }] }
];
/** @nocollapse */
IgxListItemComponent.ctorParameters = () => [
    { type: IgxListBase },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
IgxListItemComponent.propDecorators = {
    leftPanningTemplateElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['leftPanningTmpl', { static: false },] }],
    rightPanningTemplateElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['rightPanningTmpl', { static: false },] }],
    isHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-label',] }],
    touchAction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.touch-action',] }],
    headerStyle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list__header',] }],
    innerStyle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list__item-base',] }],
    display: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.display',] }],
    clicked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }],
    panStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['panstart', ['$event'],] }],
    panMove: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['panmove', ['$event'],] }],
    panEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['panend', ['$event'],] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$l = 0;
/**
 * **Ignite UI for Angular List** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/list.html)
 *
 * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
 * of list items. Each list item is completely templateable and will support any valid HTML or Angular component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
/**
 * igxListThumbnail is container for the List media
 * Use it to wrap anything you want to be used as a thumbnail.
 */
class IgxListThumbnailDirective {
}
IgxListThumbnailDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListThumbnail]'
            },] }
];
/**
 * igxListAction is container for the List action
 * Use it to wrap anything you want to be used as a list action: icon, checkbox...
 */
class IgxListActionDirective {
}
IgxListActionDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListAction]'
            },] }
];
/**
 * igxListLine is container for the List text content
 * Use it to wrap anything you want to be used as a plane text.
 */
class IgxListLineDirective {
}
IgxListLineDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLine]'
            },] }
];
/**
 * igxListLineTitle is a directive that add class to the target element
 * Use it to make anything to look like list Title.
 */
class IgxListLineTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-title';
    }
}
IgxListLineTitleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineTitle]'
            },] }
];
IgxListLineTitleDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list__item-line-title',] }]
};
/**
 * igxListLineSubTitle is a directive that add class to the target element
 * Use it to make anything to look like list Subtitle.
 */
class IgxListLineSubTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-subtitle';
    }
}
IgxListLineSubTitleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineSubTitle]'
            },] }
];
IgxListLineSubTitleDirective.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list__item-line-subtitle',] }]
};
class IgxListComponent extends IgxListBase {
    /**
     * @param {?} element
     * @param {?} _displayDensityOptions
     */
    constructor(element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Provides a threshold after which the item's panning will be completed automatically.
         * By default this property is set to 0.5 which is 50% of the list item's width.
         * ```typescript
         * this.list.panEndTriggeringThreshold = 0.8;
         * ```
         */
        this.panEndTriggeringThreshold = 0.5;
        /**
         * Sets/gets the `id` of the list.
         * If not set, the `id` of the first list component will be `"igx-list-0"`.
         * ```html
         * <igx-list id = "my-first-list"></igx-list>
         * ```
         * ```typescript
         * let listId =  this.list.id;
         * ```
         * \@memberof IgxListComponent
         */
        this.id = `igx-list-${NEXT_ID$l++}`;
        /**
         * Sets/gets whether the left panning of an item is allowed.
         * Default value is `false`.
         * ```html
         *  <igx-list [allowLeftPanning] = "true"></igx-list>
         * ```
         * ```typescript
         * let isLeftPanningAllowed = this.list.allowLeftPanning;
         * ```
         * \@memberof IgxListComponent
         */
        this.allowLeftPanning = false;
        /**
         * Sets/gets whether the right panning of an item is allowed.
         * Default value is `false`.
         * ```html
         *  <igx-list [allowRightPanning] = "true"></igx-list>
         * ```
         * ```typescript
         * let isRightPanningAllowed = this.list.allowRightPanning;
         * ```
         * \@memberof IgxListComponent
         */
        this.allowRightPanning = false;
        /**
         * Sets/gets whether the list is currently loading data.
         * Set it to display the dataLoadingTemplate while data is being retrieved.
         * Default value is `false`.
         * ```html
         *  <igx-list [isLoading]="true"></igx-list>
         * ```
         * ```typescript
         * let isLoading = this.list.isLoading;
         * ```
         * \@memberof IgxListComponent
         */
        this.isLoading = false;
        /**
         * Emits an event within the current list when left pan gesture is executed on a list item.
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         * ```html
         * <igx-list [allowLeftPanning]="true" (onLeftPan)="onLeftPan($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        this.onLeftPan = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event within the current list when right pan gesture is executed on a list item.
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         * ```html
         * <igx-list [allowRightPanning]="true" (onRightPan)="onRightPan($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        this.onRightPan = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event within the current list when pan gesture is executed on list item.
         * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
         * ```html
         * <igx-list (onPanStateChange) = "onPanStateChange($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        this.onPanStateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event within the current list when a list item has been clicked.
         * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
         *  ```html
         * <igx-list (onItemClicked) = "onItemClicked($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        this.onItemClicked = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @hidden
     * \@internal
     * @protected
     * @return {?}
     */
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => {
                return a.index - b.index;
            });
        }
        return null;
    }
    /**
     * Gets the `role` attribute.
     * ```typescript
     * let listRole =  this.list.role;
     * ```
     * \@memberof IgxListComponent
     * @return {?}
     */
    get role() {
        return 'list';
    }
    /**
     * Returns boolean indicating if the list is empty.
     * ```typescript
     * let isEmpty =  this.list.isListEmpty;
     * ```
     * \@memberof IgxListComponent
     * @return {?}
     */
    get isListEmpty() {
        return !this.children || this.children.length === 0;
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClass() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClassCompact() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClassCosy() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * Returns the `items` in the list excluding the headers.
     * ```typescript
     * let listItems: IgxListItemComponent[] = this.list.items;
     * ```
     * \@memberof IgxListComponent
     * @return {?}
     */
    get items() {
        /** @type {?} */
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Returns the headers in the list.
     * ```typescript
     * let listHeaders: IgxListItemComponent[] =  this.list.headers;
     * ```
     * \@memberof IgxListComponent
     * @return {?}
     */
    get headers() {
        /** @type {?} */
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the `list container`
     * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
     * ```typescript
     * let listComponent =  this.list.context;
     * ```
     * @return {?}
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Returns the `template` of an empty list.
     * ```typescript
     * let listTemplate = this.list.template;
     * ```
     * \@memberof IgxListComponent
     * @return {?}
     */
    get template() {
        if (this.isLoading) {
            return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
        }
        else {
            return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
        }
    }
}
IgxListComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-list',
                template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"message\">\n        There are no items in the list.\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"message\">\n        Loading data from the server...\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                providers: [{ provide: IgxListBase, useExisting: IgxListComponent }]
            }] }
];
/** @nocollapse */
IgxListComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxListComponent.propDecorators = {
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxListItemComponent),] }],
    emptyListTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective, static: false },] }],
    dataLoadingTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective, static: false },] }],
    listItemLeftPanningTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective, static: false },] }],
    listItemRightPanningTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective, static: false },] }],
    panEndTriggeringThreshold: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    defaultEmptyListTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultEmptyList', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultDataLoadingTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultDataLoading', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    allowLeftPanning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    allowRightPanning: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isLoading: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onLeftPan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onRightPan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onPanStateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onItemClicked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    isListEmpty: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list-empty',] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list',] }],
    cssClassCompact: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list--compact',] }],
    cssClassCosy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-list--cosy',] }]
};
/**
 * @hidden
 */
class IgxListModule {
}
IgxListModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                exports: [
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    IgxRippleModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxExcelStyleSearchFilterPipe {
    /**
     * @param {?} esf
     */
    constructor(esf) {
        this.esf = esf;
    }
    /**
     * @param {?} items
     * @param {?} searchText
     * @return {?}
     */
    transform(items, searchText) {
        if (!items || !items.length) {
            return [];
        }
        if (!searchText) {
            this.esf.excelStyleSearch.filteredData = null;
            return items;
        }
        searchText = searchText.toLowerCase();
        /** @type {?} */
        const result = items.filter((it, i) => (i === 0 && it.isSpecial) ||
            (it.value !== null && it.value !== undefined) &&
                it.value.toString().toLowerCase().indexOf(searchText) > -1);
        // If 'result' contains the 'Select All' item and at least one more, we use it as a 'finalResult',
        // otherwise we use an empty array as a 'finalResult' of the filtering.
        /** @type {?} */
        const finalResult = result.length > 1 ? result : [];
        // Update the filteredData of the search component.
        this.esf.excelStyleSearch.filteredData = cloneArray(finalResult);
        this.esf.cdr.detectChanges();
        return finalResult;
    }
}
IgxExcelStyleSearchFilterPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'excelStyleSearchFilter'
            },] }
];
/** @nocollapse */
IgxExcelStyleSearchFilterPipe.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridExcelStyleFilteringModule {
}
IgxGridExcelStyleFilteringModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStyleColumnMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleCustomDialogComponent,
                    IgxExcelStyleDefaultExpressionComponent,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleSortingTemplateDirective,
                    IgxExcelStyleHidingTemplateDirective,
                    IgxExcelStyleMovingTemplateDirective,
                    IgxExcelStylePinningTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleSearchFilterPipe
                ],
                exports: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleSortingTemplateDirective,
                    IgxExcelStyleHidingTemplateDirective,
                    IgxExcelStyleMovingTemplateDirective,
                    IgxExcelStylePinningTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleDateExpressionComponent
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                    IgxGridPipesModule,
                    IgxButtonModule,
                    IgxButtonGroupModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxDropDownModule,
                    IgxForOfModule,
                    IgxCheckboxModule,
                    IgxFilterModule,
                    IgxToggleModule,
                    IgxListModule,
                    IgxProgressBarModule
                ],
                entryComponents: [
                    IgxGridExcelStyleFilteringComponent
                ],
                providers: [
                    IgxSelectionAPIService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ghostBackgroundClass = 'igx-grid__tr--ghost';
/** @type {?} */
const gridCellClass = 'igx-grid__td';
/** @type {?} */
const rowSelectedClass = 'igx-grid__tr--selected';
/** @type {?} */
const cellSelectedClass = 'igx-grid__td--selected';
/** @type {?} */
const cellActiveClass = 'igx-grid__td--active';
/**
 * @hidden
 */
class IgxRowDragDirective extends IgxDragDirective {
    constructor() {
        super(...arguments);
        this._rowDragStarted = false;
        this.transitionEndEvent = (evt) => {
            if (this.ghostElement) {
                this.ghostElement.removeEventListener('transitionend', this.transitionEndEvent, false);
            }
            this.endDragging();
        };
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        this.row = val;
    }
    /**
     * @return {?}
     */
    get data() {
        return this.row;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPointerDown(event) {
        event.preventDefault();
        this._rowDragStarted = false;
        this._removeOnDestroy = false;
        super.onPointerDown(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPointerMove(event) {
        super.onPointerMove(event);
        if (this._dragStarted && !this._rowDragStarted) {
            this._rowDragStarted = true;
            /** @type {?} */
            const args = {
                dragDirective: this,
                dragData: this.row,
                cancel: false,
                owner: this.row.grid
            };
            this.row.grid.onRowDragStart.emit(args);
            if (args.cancel) {
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
                this._dragStarted = false;
                this._clicked = false;
                return;
            }
            this.row.dragging = true;
            this.row.grid.rowDragging = true;
            this.row.grid.markForCheck();
            this.subscription$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.row.grid.document.defaultView, 'keydown').subscribe((ev) => {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    this._lastDropArea = false;
                    this.onPointerUp(event);
                }
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        const args = {
            dragDirective: this,
            dragData: this.row,
            animation: false,
            owner: this.row.grid
        };
        this.zone.run(() => {
            this.row.grid.onRowDragEnd.emit(args);
        });
        /** @type {?} */
        const dropArea = this._lastDropArea;
        super.onPointerUp(event);
        if (!dropArea && this.ghostElement) {
            this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
        }
        else {
            this.endDragging();
        }
    }
    /**
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    createGhost(pageX, pageY) {
        this.row.grid.endEdit(true);
        this.row.grid.markForCheck();
        super.createGhost(pageX, pageY, this.row.nativeElement);
        /** @type {?} */
        const ghost = this.ghostElement;
        /** @type {?} */
        const gridRect = this.row.grid.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const rowRect = this.row.nativeElement.getBoundingClientRect();
        ghost.style.overflow = 'hidden';
        ghost.style.width = gridRect.width + 'px';
        ghost.style.height = rowRect.height + 'px';
        this.renderer.addClass(ghost, ghostBackgroundClass);
        this.renderer.removeClass(ghost, rowSelectedClass);
        /** @type {?} */
        const ghostCells = ghost.getElementsByClassName(gridCellClass);
        for (let index = 0; index < ghostCells.length; index++) {
            this.renderer.removeClass(ghostCells[index], cellSelectedClass);
            this.renderer.removeClass(ghostCells[index], cellActiveClass);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _unsubscribe() {
        if (this.subscription$ && !this.subscription$.closed) {
            this.subscription$.unsubscribe();
        }
    }
    /**
     * @private
     * @return {?}
     */
    endDragging() {
        this.onTransitionEnd(null);
        this.row.dragging = false;
        this.row.grid.rowDragging = false;
        this.row.grid.markForCheck();
        this._unsubscribe();
    }
}
IgxRowDragDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowDrag]'
            },] }
];
IgxRowDragDirective.propDecorators = {
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxRowDrag',] }]
};
/**
 * @hidden
 */
class IgxDragIndicatorIconDirective {
}
IgxDragIndicatorIconDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDragIndicatorIcon]'
            },] }
];
class IgxRowDragModule {
}
IgxRowDragModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective],
                entryComponents: [],
                exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective],
                imports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridCommonModule {
}
IgxGridCommonModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxGridCellComponent,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent,
                    IgxGridHeaderComponent,
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxColumnResizerDirective,
                    IgxResizeHandleDirective,
                    IgxColumnMovingDragDirective,
                    IgxColumnMovingDropDirective,
                    IgxGridBodyDirective,
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent,
                    IgxSummaryDataPipe,
                    IgxGridHeaderGroupComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryCellComponent,
                    IgxGridDragSelectDirective,
                    IgxGridColumnResizerComponent,
                    IgxFilterCellTemplateDirective,
                    IgxGridFooterComponent,
                    IgxAdvancedFilteringDialogComponent
                ],
                entryComponents: [
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent,
                    IgxAdvancedFilteringDialogComponent
                ],
                exports: [
                    IgxGridCellComponent,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent,
                    IgxGridHeaderComponent,
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxColumnResizerDirective,
                    IgxColumnMovingDragDirective,
                    IgxColumnMovingDropDirective,
                    IgxGridBodyDirective,
                    IgxSummaryDataPipe,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxFocusModule,
                    IgxTextHighlightModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxColumnHidingModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxColumnPinningModule,
                    IgxProgressBarModule,
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent,
                    IgxGridHeaderGroupComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryCellComponent,
                    IgxGridDragSelectDirective,
                    IgxGridColumnResizerComponent,
                    IgxFilterModule,
                    IgxGridPipesModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxFilterCellTemplateDirective,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridFooterComponent,
                    IgxAdvancedFilteringDialogComponent,
                    IgxRowSelectorsModule
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxFocusModule,
                    IgxTextHighlightModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxColumnHidingModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxColumnPinningModule,
                    IgxProgressBarModule,
                    IgxFilterModule,
                    IgxGridPipesModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxSelectModule,
                    IgxPaginatorModule,
                    IgxRowSelectorsModule
                ],
                providers: [
                    IgxGridSelectionService,
                    IgxSelectionAPIService,
                    IgxColumnMovingService,
                    IgxGridNavigationService,
                    IgxColumnResizingService,
                    IgxGridSummaryService,
                    { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGridAPIService extends GridBaseAPIService {
    /**
     * @param {?} expression
     * @return {?}
     */
    groupBy(expression) {
        /** @type {?} */
        const groupingState = cloneArray(this.grid.groupingExpressions);
        /** @type {?} */
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState, groupingState], expression);
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    /**
     * @param {?} expressions
     * @return {?}
     */
    groupBy_multiple(expressions) {
        /** @type {?} */
        const groupingState = cloneArray(this.grid.groupingExpressions);
        /** @type {?} */
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            this.prepare_sorting_expression([sortingState, groupingState], each);
        }
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    clear_groupby(name) {
        /** @type {?} */
        const groupingState = cloneArray(this.grid.groupingExpressions);
        /** @type {?} */
        const sortingState = cloneArray(this.grid.sortingExpressions);
        if (name) {
            /** @type {?} */
            const names = typeof name === 'string' ? [name] : name;
            /** @type {?} */
            const groupedCols = groupingState.filter((state) => names.indexOf(state.fieldName) < 0);
            /** @type {?} */
            const newSortingExpr = sortingState.filter((state) => names.indexOf(state.fieldName) < 0);
            this.grid.groupingExpressions = groupedCols;
            this.grid.sortingExpressions = newSortingExpr;
            names.forEach((colName) => {
                /** @type {?} */
                const grExprIndex = groupingState.findIndex((exp) => exp.fieldName === colName);
                /** @type {?} */
                const grpExpandState = this.grid.groupingExpansionState;
                /* remove expansion states related to the cleared group
                and all with deeper hierarchy than the cleared group */
                this.grid.groupingExpansionState = grpExpandState
                    .filter((val) => {
                    return val.hierarchy && val.hierarchy.length <= grExprIndex;
                });
            });
        }
        else {
            // clear all
            this.grid.groupingExpressions = [];
            this.grid.groupingExpansionState = [];
            for (const grExpr of groupingState) {
                /** @type {?} */
                const sortExprIndex = sortingState.findIndex((exp) => exp.fieldName === grExpr.fieldName);
                if (sortExprIndex > -1) {
                    sortingState.splice(sortExprIndex, 1);
                }
            }
            this.grid.sortingExpressions = sortingState;
        }
    }
    /**
     * @param {?} groupRow
     * @return {?}
     */
    groupBy_get_expanded_for_group(groupRow) {
        /** @type {?} */
        const grState = this.grid.groupingExpansionState;
        /** @type {?} */
        const hierarchy = DataUtil.getHierarchy(groupRow);
        return grState.find((state) => DataUtil.isHierarchyMatch(state.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
    }
    /**
     * @param {?} groupRow
     * @param {?} rowID
     * @return {?}
     */
    groupBy_is_row_in_group(groupRow, rowID) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        let rowInGroup = false;
        groupRow.records.forEach(row => {
            if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                rowInGroup = true;
            }
        });
        return rowInGroup;
    }
    /**
     * @param {?} groupRow
     * @return {?}
     */
    groupBy_toggle_group(groupRow) {
        /** @type {?} */
        const grid = this.grid;
        if (grid.crudService.isInEditMode) {
            grid.endEdit(true);
        }
        /** @type {?} */
        const expansionState = grid.groupingExpansionState;
        /** @type {?} */
        const state = this.groupBy_get_expanded_for_group(groupRow);
        if (state) {
            state.expanded = !state.expanded;
        }
        else {
            expansionState.push({
                expanded: !grid.groupsExpanded,
                hierarchy: DataUtil.getHierarchy(groupRow)
            });
        }
        this.grid.groupingExpansionState = [...expansionState];
        if (grid.rowEditable) {
            grid.repositionRowEditingOverlay(grid.rowInEditMode);
        }
    }
    /**
     * @param {?} groupRow
     * @return {?}
     */
    groupBy_fully_expand_group(groupRow) {
        /** @type {?} */
        const state = this.groupBy_get_expanded_for_group(groupRow);
        /** @type {?} */
        const expanded = state ? state.expanded : this.grid.groupsExpanded;
        if (!expanded) {
            this.groupBy_toggle_group(groupRow);
        }
        if (groupRow.groupParent) {
            this.groupBy_fully_expand_group(groupRow.groupParent);
        }
    }
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    remove_grouping_expression(fieldName) {
        /** @type {?} */
        const groupingExpressions = this.grid.groupingExpressions;
        /** @type {?} */
        const index = groupingExpressions.findIndex((expr) => expr.fieldName === fieldName);
        if (index !== -1) {
            groupingExpressions.splice(index, 1);
        }
    }
    /**
     * @return {?}
     */
    arrange_sorting_expressions() {
        /** @type {?} */
        const groupingState = this.grid.groupingExpressions;
        this.grid.sortingExpressions.sort((a, b) => {
            /** @type {?} */
            const groupExprA = groupingState.find((expr) => expr.fieldName === a.fieldName);
            /** @type {?} */
            const groupExprB = groupingState.find((expr) => expr.fieldName === b.fieldName);
            if (groupExprA && groupExprB) {
                return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
            }
            else if (groupExprA) {
                return -1;
            }
            else if (groupExprB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    /**
     * @param {?} gRow
     * @return {?}
     */
    get_groupBy_record_id(gRow) {
        /** @type {?} */
        let recordId = '{ ';
        /** @type {?} */
        const hierrarchy = DataUtil.getHierarchy(gRow);
        for (let i = 0; i < hierrarchy.length; i++) {
            /** @type {?} */
            const groupByKey = hierrarchy[i];
            recordId += `'${groupByKey.fieldName}': '${groupByKey.value}'`;
            if (i < hierrarchy.length - 1) {
                recordId += ', ';
            }
        }
        recordId += ' }';
        return recordId;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const NavigationDirection = {
    horizontal: 'horizontal',
    vertical: 'vertical',
};
/**
 * @hidden
 */
class IgxGridMRLNavigationService extends IgxGridNavigationService {
    /**
     * @hidden
     * \@internal
     * @param {?} colStart
     * @param {?} rowStart
     * @param {?} dir
     * @return {?}
     */
    setStartNavigationCell(colStart, rowStart, dir) {
        this.startNavigationCell = {
            colStart: colStart,
            rowStart: rowStart,
            direction: dir
        };
    }
    /**
     * @private
     * @param {?} colStart
     * @param {?} rowStart
     * @param {?} navDirection
     * @return {?}
     */
    applyNavigationCell(colStart, rowStart, navDirection) {
        /** @type {?} */
        const oppositeDir = navDirection === NavigationDirection.vertical ?
            NavigationDirection.horizontal : NavigationDirection.vertical;
        if (this.startNavigationCell && this.startNavigationCell.direction !== navDirection) {
            this.startNavigationCell.direction = oppositeDir;
        }
        else {
            this.setStartNavigationCell(colStart, rowStart, oppositeDir);
        }
        return navDirection === NavigationDirection.vertical ?
            this.startNavigationCell.colStart : this.startNavigationCell.rowStart;
    }
    /**
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    navigateUp(rowElement, selectedNode) {
        this.focusCellUpFromLayout(rowElement, selectedNode);
    }
    /**
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    navigateDown(rowElement, selectedNode) {
        this.focusCellDownFromLayout(rowElement, selectedNode);
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    isColumnRightEdgeVisible(visibleColumnIndex) {
        /** @type {?} */
        const column = this.grid.columnList.filter(c => !c.columnGroup).find((col) => col.visibleIndex === visibleColumnIndex);
        /** @type {?} */
        const forOfDir = this.grid.headerContainer;
        /** @type {?} */
        const horizontalScroll = forOfDir.getScroll();
        if (!horizontalScroll.clientWidth || (column && column.pinned)) {
            return true;
        }
        else if (column) {
            if (this.isParentColumnFullyVisible(column)) {
                return true;
            }
            /** @type {?} */
            const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
            return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft &&
                this.displayContainerScrollLeft <= scrollPos.leftScroll;
        }
        return false;
    }
    /**
     * @private
     * @param {?} parent
     * @return {?}
     */
    isParentColumnFullyVisible(parent) {
        /** @type {?} */
        const forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
        /** @type {?} */
        const horizontalScroll = forOfDir.getScroll();
        if (!horizontalScroll.clientWidth || parent.pinned) {
            return true;
        }
        /** @type {?} */
        const index = forOfDir.igxForOf.indexOf(parent);
        return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    isColumnLeftEdgeVisible(visibleColumnIndex) {
        /** @type {?} */
        const forOfDir = this.grid.headerContainer;
        /** @type {?} */
        const horizontalScroll = forOfDir.getScroll();
        /** @type {?} */
        const column = this.grid.columnList.filter(c => !c.columnGroup).find((col) => col.visibleIndex === visibleColumnIndex);
        if (!horizontalScroll.clientWidth || column.pinned) {
            return true;
        }
        if (this.isParentColumnFullyVisible(column)) {
            return true;
        }
        /** @type {?} */
        const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
        return this.displayContainerScrollLeft <= scrollPos.leftScroll;
    }
    /**
     * @param {?} element
     * @param {?} selectedNode
     * @return {?}
     */
    onKeydownArrowRight(element, selectedNode) {
        this.focusNextCellFromLayout(element, selectedNode);
    }
    /**
     * @param {?} element
     * @param {?} selectedNode
     * @return {?}
     */
    onKeydownArrowLeft(element, selectedNode) {
        this.focusPrevCellFromLayout(element, selectedNode);
    }
    /**
     * @return {?}
     */
    get gridOrderedColumns() {
        return [...this.grid.pinnedColumns, ...this.grid.unpinnedColumns].filter(c => !c.columnGroup)
            .sort((a, b) => a.visibleIndex - b.visibleIndex);
    }
    /**
     * @param {?} currentRowEl
     * @param {?} selectedNode
     * @return {?}
     */
    performTab(currentRowEl, selectedNode) {
        /** @type {?} */
        const visibleColumnIndex = selectedNode.layout ? selectedNode.layout.columnVisibleIndex : 0;
        /** @type {?} */
        const nextElementColumn = this.grid.columns.find(x => !x.columnGroup && x.visibleIndex === visibleColumnIndex + 1);
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const row = this.grid.getRowByIndex(rowIndex);
        this._moveFocusToCell(currentRowEl, nextElementColumn, row, selectedNode, 'next');
        if (nextElementColumn) {
            this.setStartNavigationCell(nextElementColumn.colStart, nextElementColumn.rowStart, null);
        }
    }
    /**
     * @protected
     * @param {?} currentRowEl
     * @param {?} nextElementColumn
     * @param {?} row
     * @param {?} selectedNode
     * @param {?} dir
     * @return {?}
     */
    _moveFocusToCell(currentRowEl, nextElementColumn, row, selectedNode, dir) {
        if (nextElementColumn && row.cells) {
            /** @type {?} */
            let nextCell = row.cells.find(currCell => currCell.column === nextElementColumn);
            /** @type {?} */
            const isVisible = this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex);
            if (!nextCell || !isVisible) {
                this.grid.nativeElement.focus({ preventScroll: true });
                /** @type {?} */
                const cb = () => {
                    nextCell = row.cells.find(currCell => currCell.column === nextElementColumn);
                    if (this.grid.rowEditable && this.isRowInEditMode(row.index)) {
                        if (dir === 'next') {
                            this.moveNextEditable(row.index, selectedNode.layout.columnVisibleIndex);
                        }
                        else {
                            this.movePreviousEditable(row.index, selectedNode.layout.columnVisibleIndex);
                        }
                        return;
                    }
                    this._focusCell(nextCell.nativeElement);
                };
                this.performHorizontalScrollToCell(row.index, nextElementColumn.visibleIndex, false, cb);
            }
            else {
                if (this.grid.rowEditable && this.isRowInEditMode(row.index)) {
                    if (dir === 'next') {
                        this.moveNextEditable(row.index, selectedNode.layout.columnVisibleIndex);
                    }
                    else {
                        this.movePreviousEditable(row.index, selectedNode.layout.columnVisibleIndex);
                    }
                    return;
                }
                this._focusCell(nextCell.nativeElement);
            }
        }
        else {
            // end of layout reached
            if (this.isRowInEditMode(row.index)) {
                //  TODO: make gridAPI visible for internal use and remove cast to any
                ((/** @type {?} */ (this.grid))).gridAPI.submit_value();
                if (dir === 'next') {
                    this.grid.rowEditTabs.first.element.nativeElement.focus();
                }
                else {
                    this.grid.rowEditTabs.last.element.nativeElement.focus();
                }
                return;
            }
            if (dir === 'next') {
                super.navigateDown(currentRowEl, { row: row.index, column: 0 });
            }
            else {
                /** @type {?} */
                let lastVisibleIndex = 0;
                this.grid.unpinnedColumns.forEach((col) => {
                    lastVisibleIndex = Math.max(lastVisibleIndex, col.visibleIndex);
                });
                super.navigateUp(currentRowEl, { row: row.index, column: lastVisibleIndex });
            }
        }
    }
    /**
     * @param {?} currentRowEl
     * @param {?} selectedNode
     * @return {?}
     */
    performShiftTabKey(currentRowEl, selectedNode) {
        /** @type {?} */
        const visibleColumnIndex = selectedNode.layout ? selectedNode.layout.columnVisibleIndex : 0;
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const row = this.grid.getRowByIndex(rowIndex);
        /** @type {?} */
        const prevElementColumn = this.grid.columns.find(x => !x.columnGroup && x.visibleIndex === visibleColumnIndex - 1 && !x.hidden);
        this._moveFocusToCell(currentRowEl, prevElementColumn, row, selectedNode, 'prev');
        if (prevElementColumn) {
            this.setStartNavigationCell(prevElementColumn.colStart, prevElementColumn.rowStart, null);
        }
    }
    /**
     * @private
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    focusCellUpFromLayout(rowElement, selectedNode) {
        /** @type {?} */
        const isGroupRow = rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row';
        /** @type {?} */
        const currentRowStart = selectedNode.layout ? selectedNode.layout.rowStart : 1;
        /** @type {?} */
        const currentColStart = this.applyNavigationCell(selectedNode.layout ? selectedNode.layout.colStart : 1, currentRowStart, NavigationDirection.vertical);
        /** @type {?} */
        const parentIndex = selectedNode.column;
        /** @type {?} */
        const columnLayout = this.grid.columns.find(x => x.columnLayout && x.visibleIndex === parentIndex);
        /** @type {?} */
        let movePrev;
        // check if element up is from the same layout
        /** @type {?} */
        let upperElementColumn = columnLayout.children.find(c => (c.rowEnd === currentRowStart || c.rowStart + c.gridRowSpan === currentRowStart) &&
            c.colStart <= currentColStart &&
            (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan));
        if (isGroupRow || !upperElementColumn) {
            // no prev row in current row layout, go to next row last rowstart
            /** @type {?} */
            const layoutRowEnd = this.grid.multiRowLayoutRowSize + 1;
            upperElementColumn = columnLayout.children.find(c => (c.rowEnd === layoutRowEnd || c.rowStart + c.gridRowSpan === layoutRowEnd) &&
                c.colStart <= currentColStart &&
                (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan));
            movePrev = true;
        }
        /** @type {?} */
        const rowIndex = movePrev ? selectedNode.row - 1 : selectedNode.row;
        if (rowIndex < 0) {
            // end of rows reached.
            return;
        }
        /** @type {?} */
        let prevRow;
        /** @type {?} */
        const cb = () => {
            prevRow = this.grid.getRowByIndex(rowIndex);
            if (prevRow && prevRow.cells) {
                this._focusCell(upperElementColumn.cells.find((c) => c.rowIndex === prevRow.index).nativeElement);
            }
            else if (prevRow) {
                prevRow.nativeElement.focus({ preventScroll: true });
            }
        };
        if (this.shouldPerformVerticalScroll(rowIndex, upperElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.performVerticalScrollToCell(rowIndex, upperElementColumn.visibleIndex, cb);
        }
        else {
            cb();
        }
    }
    /**
     * @private
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    focusCellDownFromLayout(rowElement, selectedNode) {
        /** @type {?} */
        const isGroupRow = rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row';
        /** @type {?} */
        const parentIndex = selectedNode.column;
        /** @type {?} */
        const columnLayout = this.grid.columns.find(x => x.columnLayout && x.visibleIndex === parentIndex);
        /** @type {?} */
        const currentRowEnd = selectedNode.layout ? selectedNode.layout.rowEnd || selectedNode.layout.rowStart + 1 : 2;
        /** @type {?} */
        const currentColStart = this.applyNavigationCell(selectedNode.layout ? selectedNode.layout.colStart : 1, selectedNode.layout ? selectedNode.layout.rowStart : 1, NavigationDirection.vertical);
        /** @type {?} */
        let moveNext;
        // check if element down is from the same layout
        /** @type {?} */
        let nextElementColumn = columnLayout.children.find(c => c.rowStart === currentRowEnd &&
            c.colStart <= currentColStart &&
            (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan));
        if (isGroupRow || !nextElementColumn) {
            // no next row in current row layout, go to next row first rowstart
            nextElementColumn = columnLayout.children.find(c => c.rowStart === 1 &&
                c.colStart <= currentColStart &&
                (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan));
            moveNext = true;
        }
        /** @type {?} */
        const rowIndex = moveNext ? selectedNode.row + 1 : selectedNode.row;
        if (rowIndex > this.grid.dataView.length - 1) {
            // end of rows reached.
            return;
        }
        /** @type {?} */
        let nextRow;
        /** @type {?} */
        const cb = () => {
            nextRow = this.grid.getRowByIndex(rowIndex);
            if (nextRow && nextRow.cells) {
                this._focusCell(nextElementColumn.cells.find((c) => c.rowIndex === nextRow.index).nativeElement);
            }
            else if (nextRow) {
                nextRow.nativeElement.focus({ preventScroll: true });
            }
        };
        if (this.shouldPerformVerticalScroll(rowIndex, nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.performVerticalScrollToCell(rowIndex, nextElementColumn.visibleIndex, cb);
        }
        else {
            cb();
        }
    }
    /**
     * @private
     * @param {?} cellElement
     * @param {?} selectedNode
     * @return {?}
     */
    focusNextCellFromLayout(cellElement, selectedNode) {
        /** @type {?} */
        const parentIndex = selectedNode.column;
        /** @type {?} */
        let columnLayout = this.grid.columns.find(x => x.columnLayout && x.visibleIndex === parentIndex);
        /** @type {?} */
        const currentColEnd = selectedNode.layout.colEnd || selectedNode.layout.colStart + 1;
        /** @type {?} */
        const currentRowStart = this.applyNavigationCell(selectedNode.layout.colStart, selectedNode.layout.rowStart, NavigationDirection.horizontal);
        /** @type {?} */
        const rowIndex = selectedNode.row;
        // check if next element is from the same layout
        /** @type {?} */
        let nextElementColumn = columnLayout.children.find(c => c.colStart === currentColEnd &&
            c.rowStart <= currentRowStart &&
            (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan));
        if (!nextElementColumn) {
            // no next column in current layout, search for next layout
            columnLayout = this.grid.columns.find(c => c.columnLayout && !c.hidden && c.visibleIndex === columnLayout.visibleIndex + 1);
            if (!columnLayout) {
                // reached the end
                return null;
            }
            // next element is from the next layout
            nextElementColumn = columnLayout.children.find(c => c.colStart === 1 &&
                c.rowStart <= currentRowStart &&
                (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan));
        }
        /** @type {?} */
        const cb = () => {
            /** @type {?} */
            const nextElement = nextElementColumn.cells.find((c) => c.rowIndex === rowIndex).nativeElement;
            this._focusCell(nextElement);
        };
        if (!this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
        }
        else {
            cb();
        }
    }
    /**
     * @private
     * @param {?} cellElement
     * @param {?} selectedNode
     * @return {?}
     */
    focusPrevCellFromLayout(cellElement, selectedNode) {
        /** @type {?} */
        const parentIndex = selectedNode.column;
        /** @type {?} */
        let columnLayout = this.grid.columns.find(x => x.columnLayout && x.visibleIndex === parentIndex);
        /** @type {?} */
        const currentColStart = selectedNode.layout.colStart;
        /** @type {?} */
        const currentRowStart = this.applyNavigationCell(currentColStart, selectedNode.layout.rowStart, NavigationDirection.horizontal);
        /** @type {?} */
        const rowIndex = selectedNode.row;
        // check previous element is from the same layout
        /** @type {?} */
        let prevElementColumn = columnLayout.children
            .find(c => (c.colEnd === currentColStart || c.colStart + c.gridColumnSpan === currentColStart) &&
            c.rowStart <= currentRowStart &&
            (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan));
        if (!prevElementColumn) {
            // no prev column in current layout, seacrh for prev layout
            columnLayout = this.grid.columns.find(c => c.columnLayout && !c.hidden && c.visibleIndex === columnLayout.visibleIndex - 1);
            if (!columnLayout) {
                // reached the end
                return null;
            }
            /** @type {?} */
            const layoutSize = columnLayout.getInitialChildColumnSizes(columnLayout.children).length;
            // first element is from the next layout
            prevElementColumn = columnLayout.children
                .find(c => (c.colEnd === layoutSize + 1 || c.colStart + c.gridColumnSpan === layoutSize + 1) &&
                c.rowStart <= currentRowStart &&
                (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan));
        }
        /** @type {?} */
        const cb = () => {
            /** @type {?} */
            const prevElement = prevElementColumn.cells.find((c) => c.rowIndex === rowIndex).nativeElement;
            this._focusCell(prevElement);
        };
        if (!this.isColumnLeftEdgeVisible(prevElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.performHorizontalScrollToCell(rowIndex, prevElementColumn.visibleIndex, false, cb);
        }
        else {
            cb();
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @param {?=} cellRowStart
     * @return {?}
     */
    onKeydownEnd(rowIndex, isSummary = false, cellRowStart) {
        /** @type {?} */
        const layouts = this.grid.columns.filter(c => c.columnLayout && !c.hidden).sort((a, b) => a.visibleIndex - b.visibleIndex);
        /** @type {?} */
        const lastLayout = layouts[layouts.length - 1];
        /** @type {?} */
        const lastLayoutChildren = lastLayout.children;
        /** @type {?} */
        const layoutSize = lastLayout.getInitialChildColumnSizes(lastLayoutChildren).length;
        /** @type {?} */
        const currentRowStart = this.applyNavigationCell(this.startNavigationCell ? this.startNavigationCell.colStart : 1, cellRowStart || this.grid.multiRowLayoutRowSize, NavigationDirection.horizontal);
        /** @type {?} */
        const nextElementColumn = lastLayout.children.find(c => (c.colEnd === layoutSize + 1 || c.colStart + c.gridColumnSpan === layoutSize + 1) &&
            c.rowStart <= currentRowStart &&
            (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan));
        /** @type {?} */
        const indexInLayout = lastLayoutChildren.toArray().indexOf(nextElementColumn);
        /** @type {?} */
        const rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
        /** @type {?} */
        let rowElement = rowList.find((row) => row.index === rowIndex);
        if (!rowElement) {
            return;
        }
        rowElement = rowElement.nativeElement;
        if (!this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            /** @type {?} */
            const cb = () => {
                /** @type {?} */
                const allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
                /** @type {?} */
                const cell = allBlocks[allBlocks.length - 1].children[indexInLayout];
                this._focusCell(cell);
            };
            this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
            return;
        }
        else {
            /** @type {?} */
            const allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
            /** @type {?} */
            const cell = allBlocks[allBlocks.length - 1].children[indexInLayout];
            this._focusCell(cell);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @param {?=} cellRowStart
     * @return {?}
     */
    onKeydownHome(rowIndex, isSummary = false, cellRowStart = 1) {
        /** @type {?} */
        const firstLayout = this.grid.columns.filter(c => c.columnLayout && !c.hidden)[0];
        /** @type {?} */
        const lastLayoutChildren = firstLayout.children.toArray();
        /** @type {?} */
        const currentRowStart = this.applyNavigationCell(this.startNavigationCell ? this.startNavigationCell.colStart : 1, cellRowStart, NavigationDirection.horizontal);
        /** @type {?} */
        const nextElementColumn = firstLayout.children.find(c => c.colStart === 1 &&
            c.rowStart <= currentRowStart &&
            (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan));
        /** @type {?} */
        const indexInLayout = lastLayoutChildren.indexOf(nextElementColumn);
        /** @type {?} */
        const rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
        /** @type {?} */
        let rowElement = rowList.find((row) => row.index === rowIndex);
        if (!rowElement) {
            return;
        }
        rowElement = rowElement.nativeElement;
        if (!this.isColumnLeftEdgeVisible(nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            /** @type {?} */
            const cb = () => {
                /** @type {?} */
                const allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
                /** @type {?} */
                const cell = allBlocks[0].children[indexInLayout];
                this._focusCell(cell);
            };
            this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
            return;
        }
        else {
            /** @type {?} */
            const allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
            /** @type {?} */
            const cell = allBlocks[0].children[indexInLayout];
            this._focusCell(cell);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    getColumnLayoutSelector() {
        return '.igx-grid__mrl-block';
    }
    /**
     * @protected
     * @param {?} visibleColIndex
     * @return {?}
     */
    getChildColumnScrollPositions(visibleColIndex) {
        /** @type {?} */
        const forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
        /** @type {?} */
        const targetCol = this.getColunmByVisibleIndex(visibleColIndex);
        /** @type {?} */
        const parent = targetCol.parent;
        /** @type {?} */
        const parentVIndex = forOfDir.igxForOf.indexOf(parent);
        /** @type {?} */
        let leftScroll = forOfDir.getColumnScrollLeft(parentVIndex);
        /** @type {?} */
        let rightScroll = 0;
        // caculate offset from parent based on target column colStart and colEnd and the resolved child column sizes.
        /** @type {?} */
        const childSizes = parent.getFilledChildColumnSizes(parent.children);
        /** @type {?} */
        const colStart = targetCol.colStart || 1;
        /** @type {?} */
        const colEnd = targetCol.colEnd || colStart + 1;
        for (let i = 1; i < colStart; i++) {
            leftScroll += parseInt(childSizes[i - 1], 10);
        }
        rightScroll += leftScroll;
        for (let j = colStart; j < colEnd; j++) {
            rightScroll += parseInt(childSizes[j - 1], 10);
        }
        return { leftScroll, rightScroll };
    }
    /**
     * @protected
     * @param {?} visibleColIndex
     * @return {?}
     */
    getColunmByVisibleIndex(visibleColIndex) {
        visibleColIndex = visibleColIndex < 0 ? 0 : visibleColIndex;
        return this.grid.columnList.find((col) => !col.columnLayout && col.visibleIndex === visibleColIndex);
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    shouldPerformVerticalScroll(rowIndex, visibleColumnIndex) {
        if (this._isGroupRecordAt(rowIndex)) {
            return super.shouldPerformVerticalScroll(rowIndex, visibleColumnIndex);
        }
        if (!super.shouldPerformVerticalScroll(rowIndex, visibleColumnIndex)) {
            return false;
        }
        /** @type {?} */
        const targetRow = this.grid.summariesRowList.filter(s => s.index !== 0)
            .concat(this.grid.rowList.toArray()).find(r => r.index === rowIndex);
        /** @type {?} */
        const scrollTop = Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
        /** @type {?} */
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        /** @type {?} */
        const scrollPos = this.getVerticalScrollPositions(rowIndex, visibleColumnIndex);
        if (!targetRow || targetRow.nativeElement.offsetTop + scrollPos.topOffset < Math.abs(this.verticalDCTopOffset)
            || containerHeight && containerHeight < scrollPos.rowBottom - scrollTop) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    get verticalDCTopOffset() {
        return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
    }
    /**
     * @private
     * @param {?} rowIndex
     * @return {?}
     */
    _isGroupRecordAt(rowIndex) {
        /** @type {?} */
        const record = this.grid.dataView[rowIndex];
        return record.records && record.records.length;
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} cb
     * @return {?}
     */
    performVerticalScrollToCell(rowIndex, visibleColumnIndex, cb) {
        if (this._isGroupRecordAt(rowIndex)) {
            return super.performVerticalScrollToCell(rowIndex, visibleColumnIndex, cb);
        }
        /** @type {?} */
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        /** @type {?} */
        const scrollTop = Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
        /** @type {?} */
        const scrollPos = this.getVerticalScrollPositions(rowIndex, visibleColumnIndex);
        /** @type {?} */
        const targetRow = this.grid.summariesRowList.filter(s => s.index !== 0)
            .concat(this.grid.rowList.toArray()).find(r => r.index === rowIndex);
        /** @type {?} */
        const isPrevious = (scrollTop > scrollPos.rowTop) && (!targetRow ||
            targetRow.nativeElement.offsetTop + scrollPos.topOffset < Math.abs(this.verticalDCTopOffset));
        /** @type {?} */
        const scrollAmount = isPrevious ? scrollPos.rowTop : Math.abs(scrollTop + containerHeight - scrollPos.rowBottom);
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
            cb();
        });
        if (isPrevious) {
            this.grid.verticalScrollContainer.scrollPosition = scrollAmount;
        }
        else {
            this.grid.verticalScrollContainer.addScrollTop(scrollAmount);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColIndex
     * @return {?}
     */
    getVerticalScrollPositions(rowIndex, visibleColIndex) {
        /** @type {?} */
        const targetCol = this.getColunmByVisibleIndex(visibleColIndex);
        /** @type {?} */
        const topOffset = (targetCol.rowStart - 1) * this.grid.defaultRowHeight;
        /** @type {?} */
        const rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
        /** @type {?} */
        const rowBottom = rowTop + (this.grid.defaultRowHeight * targetCol.gridRowSpan);
        return { rowTop, rowBottom, topOffset };
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @param {?=} cb
     * @return {?}
     */
    performHorizontalScrollToCell(rowIndex, visibleColumnIndex, isSummary = false, cb) {
        /** @type {?} */
        const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
        /** @type {?} */
        const hScroll = this.horizontalScroll(rowIndex);
        this.grid.parentVirtDir.onChunkLoad
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
            .subscribe(() => {
            if (cb) {
                cb();
            }
            else {
                this._focusCell(this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary));
            }
        });
        /** @type {?} */
        const isPrevItem = hScroll.getScroll().scrollLeft > scrollPos.leftScroll;
        /** @type {?} */
        const containerSize = parseInt(hScroll.igxForContainerSize, 10);
        /** @type {?} */
        const nextScroll = isPrevItem ? scrollPos.leftScroll : scrollPos.rightScroll - containerSize;
        hScroll.scrollPosition = nextScroll;
    }
    /**
     * @protected
     * @param {?} cellElem
     * @return {?}
     */
    _focusCell(cellElem) {
        // in case of variable row heights in mrl grid make sure cell is really in view after it has been rendered.
        /** @type {?} */
        const gridBoundingClientRect = this.grid.tbody.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const diffTop = cellElem.getBoundingClientRect().top - gridBoundingClientRect.top;
        /** @type {?} */
        const diffBottom = cellElem.getBoundingClientRect().bottom - gridBoundingClientRect.bottom;
        if (diffTop < 0) {
            // cell is above grid top - not visible
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(() => {
                cellElem.focus({ preventScroll: true });
            });
            this.grid.verticalScrollContainer.addScrollTop(diffTop);
        }
        else if (diffBottom > 0) {
            // cell is below grid bottom - not visible
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(() => {
                cellElem.focus({ preventScroll: true });
            });
            this.grid.verticalScrollContainer.addScrollTop(diffBottom);
        }
        else {
            // cell is visible
            cellElem.focus({ preventScroll: true });
        }
    }
    /**
     * @return {?}
     */
    goToFirstCell() {
        this.startNavigationCell = null;
        super.goToFirstCell();
    }
    /**
     * @return {?}
     */
    goToLastCell() {
        this.startNavigationCell = null;
        super.goToLastCell();
    }
}
IgxGridMRLNavigationService.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$m = 0;
/**
 * **Ignite UI for Angular Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 *
 * Example:
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
class IgxGridComponent extends IgxGridBaseComponent {
    constructor() {
        super(...arguments);
        this._id = `igx-grid-${NEXT_ID$m++}`;
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._filteredData = null;
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.groupingExpansionStateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */
        this.groupsRecords = [];
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.onGroupingDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        this.dragIndicatorIconTemplate = null;
    }
    /**
     * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
    }
    /**
     * An \@Input property that lets you fill the `IgxGridComponent` with an array of data.
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.notifyChanges(true);
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Returns the state of the grid virtualization, including the start index and how many records are rendered.
     * ```typescript
     * const gridVirtState = this.grid1.virtualizationState;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get virtualizationState() {
        return this.verticalScrollContainer.state;
    }
    /**
     * @hidden
     * @param {?} state
     * @return {?}
     */
    set virtualizationState(state) {
        this.verticalScrollContainer.state = state;
    }
    /**
     * Sets the total number of records in the data source.
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * ```typescript
     * this.grid1.totalItemCount = 55;
     * ```
     * \@memberof IgxGridComponent
     * @param {?} count
     * @return {?}
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    /**
     * Returns the total number of records in the data source.
     * Works only with remote grid virtualization.
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    /**
     * @private
     * @return {?}
     */
    get _gridAPI() {
        return (/** @type {?} */ (this.gridAPI));
    }
    /**
     * Returns the group by state of the `IgxGridComponent`.
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    /**
     * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
     * event with the appropriate arguments.
     * ```typescript
     * this.grid.groupingExpressions = [{
     *     fieldName: "ID",
     *     dir: SortingDirection.Asc,
     *     ignoreCase: false
     * }];
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set groupingExpressions(value) {
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        /** @type {?} */
        const oldExpressions = this.groupingExpressions;
        /** @type {?} */
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();
            this._gridAPI.arrange_sorting_expressions();
            this.notifyChanges();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            /** @type {?} */
            const groupedCols = [];
            /** @type {?} */
            const ungroupedCols = [];
            /** @type {?} */
            const groupedColsArr = newExpressions.filter((obj) => {
                return !oldExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            /** @type {?} */
            const ungroupedColsArr = oldExpressions.filter((obj) => {
                return !newExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            /** @type {?} */
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Returns a list of expansion states for group rows.
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * ```typescript
     * const groupExpState = this.grid.groupingExpansionState;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    /**
     * Sets a list of expansion states for group rows.
     * ```typescript
     *      this.grid.groupingExpansionState = [{
     *      expanded: false,
     *      hierarchy: [{ fieldName: 'ID', value: 1 }]
     *   }];
     * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * An \@Input property that sets whether the grouped columns should be hidden as well.
     * The default value is "false"
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    /**
     * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
     * @return {?}
     */
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * A list of all group rows.
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupsRowList() {
        /** @type {?} */
        const res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        if (!this._groupsRowList) {
            return res;
        }
        /** @type {?} */
        const rList = this._groupsRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        });
        res.reset(rList);
        return res;
    }
    /**
     * @hidden
     * @return {?}
     */
    get groupAreaHostClass() {
        return this.getComponentDensityClass('igx-drop-area');
    }
    /**
     * Returns the template reference of the `IgxGridComponent`'s group row.
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    /**
     * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
     * ```typescript
     * this.grid.groupRowTemplate = myRowTemplate.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} template
     * @return {?}
     */
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Returns the template reference of the `IgxGridComponent`'s group area.
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    /**
     * Sets the template reference of the `IgxGridComponent`'s group area.
     * ```typescript
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} template
     * @return {?}
     */
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} expression
     * @return {?}
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.endEdit(true);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.notifyChanges(true);
    }
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    isExpandedGroup(group) {
        /** @type {?} */
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setGroupColsVisibility(value) {
        if (this.columnList && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                /** @type {?} */
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    /**
     * Returns if the grid's group by drop area is visible.
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    }
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    getContext(rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    chipsOrderChanged(event) {
        /** @type {?} */
        const newGrouping = [];
        for (let i = 0; i < event.chipsArray.length; i++) {
            /** @type {?} */
            const expr = this.groupingExpressions.filter((item) => {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.notifyChanges();
    }
    /**
     * @hidden
     * @return {?}
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.notifyChanges();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipClicked(event) {
        /** @type {?} */
        const sortingExpr = this.sortingExpressions;
        /** @type {?} */
        const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.notifyChanges();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            /** @type {?} */
            const sortingExpr = this.sortingExpressions;
            /** @type {?} */
            const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get defaultTargetBodyHeight() {
        /** @type {?} */
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    }
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    getFeatureColumnsWidth() {
        /** @type {?} */
        let width = super.getFeatureColumnsWidth();
        if (this.groupingExpressions.length && this.headerGroupContainer) {
            width += this.headerGroupContainer.nativeElement.offsetWidth;
        }
        return width;
    }
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            /** @type {?} */
            const rowIndex = this.groupingResult.indexOf(row);
            /** @type {?} */
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden
     * @return {?}
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    getGroupByChipTitle(expression) {
        /** @type {?} */
        const column = this.getColumnByName(expression.fieldName);
        return (column && column.header) || expression.fieldName;
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    getColumnGroupable(fieldName) {
        /** @type {?} */
        const column = this.getColumnByName(fieldName);
        return column && column.groupable;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
            this.endEdit(true);
            this.summaryService.updateSummaryCache(args);
        });
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            /** @type {?} */
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList) {
                changes.forEachAddedItem((rec) => {
                    /** @type {?} */
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    /** @type {?} */
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * \@inheritdoc
     * @param {?=} formatters
     * @param {?=} headers
     * @return {?}
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length) {
            /** @type {?} */
            const source = [];
            /** @type {?} */
            const process = (record) => {
                if (record.expression || record.summaries) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
        }
    }
    /**
     * @private
     * @param {?} expression
     * @return {?}
     */
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
}
IgxGridComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                providers: [
                    IgxGridNavigationService,
                    IgxGridSummaryService,
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxGridComponent) },
                    IgxFilteringService,
                    IgxColumnResizingService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ],
                selector: 'igx-grid',
                template: "<igx-grid-toolbar [style.flex-basis.px]=\"outerWidth\" role=\"rowgroup\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\"\n    [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n                </igx-grid-row>\n            </ng-template>\n            <ng-template #group_template>\n                <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n                </igx-grid-groupby-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n            <ng-template\n                [igxTemplateOutlet]='isGroupByRecord(rowData) ? group_template : isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n"
            }] }
];
IgxGridComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupingExpressions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupingExpressionsChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    groupingExpansionState: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    groupingExpansionStateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    groupsExpanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hideGroupedColumns: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropAreaMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropAreaTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onGroupingDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    groupTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective, static: false },] }],
    dragIndicatorIconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxDragIndicatorIconDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    _groupsRowList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
    defaultDropAreaTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultDropArea', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    groupArea: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['groupArea', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridSortingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expressions, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection), expressions);
        }
        grid.filteredSortedData = result;
        return result;
    }
}
IgxGridSortingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridSort',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridGroupingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} groupsRecords
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        /** @type {?} */
        const state = { expressions: [], expansion: [], defaultExpanded };
        /** @type {?} */
        const grid = this.gridAPI.grid;
        state.expressions = grid.groupingExpressions;
        /** @type {?} */
        let result;
        /** @type {?} */
        const fullResult = { data: [], metadata: [] };
        if (!state.expressions.length) {
            // empty the array without changing reference
            groupsRecords.splice(0, groupsRecords.length);
            result = {
                data: collection,
                metadata: collection
            };
        }
        else {
            state.expansion = grid.groupingExpansionState;
            state.defaultExpanded = grid.groupsExpanded;
            result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
        }
        grid.groupingFlatResult = result.data;
        grid.groupingResult = fullResult.data;
        grid.groupingMetadata = fullResult.metadata;
        return result;
    }
}
IgxGridGroupingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridGroupBy',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridGroupingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridPagingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging) {
            return collection;
        }
        /** @type {?} */
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        DataUtil.correctPagingState(state, collection.data.length);
        /** @type {?} */
        const result = {
            data: DataUtil.page(cloneArray(collection.data), state),
            metadata: DataUtil.page(cloneArray(collection.metadata), state)
        };
        if (this.gridAPI.grid.page !== state.index) {
            this.gridAPI.grid.page = state.index;
        }
        this.gridAPI.grid.pagingState = state;
        return result;
    }
}
IgxGridPagingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridPaging',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridFilteringPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} expressionsTree
     * @param {?} filterStrategy
     * @param {?} advancedExpressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const state = {
            expressionsTree: expressionsTree,
            strategy: filterStrategy,
            advancedExpressionsTree: advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        /** @type {?} */
        const result = DataUtil.filter(cloneArray(collection), state);
        grid.filteredData = result;
        return result;
    }
}
IgxGridFilteringPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridFiltering',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxGridRowComponent extends IgxRowComponent {
    // R.K. TODO: Remove
    /**
     * @param {?} gridAPI
     * @param {?} crudService
     * @param {?} selectionService
     * @param {?} element
     * @param {?} cdr
     */
    constructor(gridAPI, crudService, selectionService, element, cdr) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(gridAPI, crudService, selectionService, element, cdr);
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
    }
    /**
     * @return {?}
     */
    get hasColumnLayouts() {
        return this.grid.hasColumnLayouts;
    }
}
IgxGridRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-row',
                template: "<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"this.showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n         <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\">\n        </igx-grid-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\">\n        </igx-grid-cell>\n    </ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n        [ngClass]=\"{'igx-grid__td--pinned-last': col.hasLastPinnedChildColumn}\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyleClasses:rowData[child.field]:rowData:child.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\"></igx-grid-cell>\n        </div>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n     'grid-template-columns':col.getGridTemplate(false, false),\n     '-ms-grid-rows':col.getGridTemplate(true, true),\n     '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyleClasses:rowData[child.field]:rowData:child.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\"></igx-grid-cell>\n        </div>\n    </ng-template>\n</ng-container>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
                providers: [{ provide: IgxRowComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxGridRowComponent) }]
            }] }
];
/** @nocollapse */
IgxGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridCRUDService },
    { type: IgxGridSelectionService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxGridRowComponent.propDecorators = {
    hasColumnLayouts: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__tr--mrl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridSummaryPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} hasSummary
     * @param {?} summaryCalculationMode
     * @param {?} summaryPosition
     * @param {?} id
     * @param {?} pipeTrigger
     * @param {?} summaryPipeTrigger
     * @return {?}
     */
    transform(collection, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
        if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return collection.data;
        }
        return this.addSummaryRows(id, collection, summaryPosition);
    }
    /**
     * @private
     * @param {?} gridId
     * @param {?} collection
     * @param {?} summaryPosition
     * @return {?}
     */
    addSummaryRows(gridId, collection, summaryPosition) {
        /** @type {?} */
        const recordsWithSummary = [];
        /** @type {?} */
        const lastChildMap = new Map();
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) &&
            grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {
            /** @type {?} */
            const groups = [];
            groups.push(collection.metadata[0]);
            while (groups[groups.length - 1].groupParent) {
                groups.push(groups[groups.length - 1].groupParent);
            }
            groups.reverse();
            groups.forEach(g => g.skip = true);
            collection.data.splice(0, 0, ...groups);
        }
        for (let i = 0; i < collection.data.length; i++) {
            /** @type {?} */
            const record = collection.data[i];
            /** @type {?} */
            let skipAdd = false;
            /** @type {?} */
            let recordId;
            /** @type {?} */
            let groupByRecord = null;
            if (grid.isGroupByRecord(record)) {
                skipAdd = !!record.skip;
                record.skip = null;
                groupByRecord = (/** @type {?} */ (record));
                recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
            }
            else {
                recordId = this.gridAPI.get_row_id(record);
            }
            if (!skipAdd) {
                recordsWithSummary.push(record);
            }
            if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                /** @type {?} */
                const groupRecords = lastChildMap.get(recordId);
                for (let j = 0; j < groupRecords.length; j++) {
                    /** @type {?} */
                    const groupRecord = groupRecords[j];
                    /** @type {?} */
                    const groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                    /** @type {?} */
                    const records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                    /** @type {?} */
                    const summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                    /** @type {?} */
                    const summaryRecord = {
                        summaries: summaries,
                        max: maxSummaryHeight
                    };
                    recordsWithSummary.push(summaryRecord);
                }
            }
            if (groupByRecord === null || !grid.isExpandedGroup(groupByRecord)) {
                continue;
            }
            if (summaryPosition === GridSummaryPosition.top) {
                /** @type {?} */
                const records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                /** @type {?} */
                const summaries = grid.summaryService.calculateSummaries(recordId, records);
                /** @type {?} */
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            else if (summaryPosition === GridSummaryPosition.bottom) {
                /** @type {?} */
                let lastChild = groupByRecord;
                while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                    lastChild = lastChild.groups[lastChild.groups.length - 1];
                }
                /** @type {?} */
                let lastChildId;
                if (grid.isExpandedGroup(lastChild)) {
                    lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                }
                else {
                    lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                }
                /** @type {?} */
                let groupRecords = lastChildMap.get(lastChildId);
                if (!groupRecords) {
                    groupRecords = [];
                    lastChildMap.set(lastChildId, groupRecords);
                }
                groupRecords.unshift(groupByRecord);
            }
        }
        return recordsWithSummary;
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} data
     * @return {?}
     */
    removeDeletedRecord(grid, data) {
        if (!grid.transactions.enabled) {
            return data;
        }
        /** @type {?} */
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        deletedRows.forEach(rowID => {
            /** @type {?} */
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            /** @type {?} */
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
}
IgxGridSummaryPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridSummary',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: IgxGridModule
        };
    }
}
IgxGridModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxGridComponent,
                    IgxGridRowComponent,
                    IgxGridGroupByRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe
                ],
                exports: [
                    IgxGridComponent,
                    IgxGridGroupByRowComponent,
                    IgxGridRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridCommonModule,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                    IgxChipsModule,
                    IgxGridCommonModule,
                    IgxSelectModule
                ]
            },] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateMethod('IgxGridModule.forRoot method is deprecated. Use IgxGridModule instead.'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", []),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:returntype", void 0)
], IgxGridModule, "forRoot", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTreeGridAPIService extends GridBaseAPIService {
    /**
     * @param {?=} transactions
     * @return {?}
     */
    get_all_data(transactions) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const data = transactions ? grid.dataWithAddedInTransactionRows : grid.flatData;
        return data ? data : [];
    }
    /**
     * @return {?}
     */
    get_summary_data() {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const data = grid.processedRootRecords.filter(row => row.isFilteredOutParent === undefined || row.isFilteredOutParent === false)
            .map(rec => rec.data);
        if (grid.transactions.enabled) {
            /** @type {?} */
            const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
            deletedRows.forEach(rowID => {
                /** @type {?} */
                const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                /** @type {?} */
                const index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
        }
        return data;
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    expand_row(rowID) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const expandedStates = grid.expansionStates;
        expandedStates.set(rowID, true);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    collapse_row(rowID) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const expandedStates = grid.expansionStates;
        expandedStates.set(rowID, false);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    toggle_row_expansion(rowID) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const expandedStates = grid.expansionStates;
        /** @type {?} */
        const treeRecord = grid.records.get(rowID);
        if (treeRecord) {
            /** @type {?} */
            const isExpanded = this.get_row_expansion_state(treeRecord);
            expandedStates.set(rowID, !isExpanded);
            grid.expansionStates = expandedStates;
        }
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    // TODO: Maybe move the focus logic in the tree cell ?
    /**
     * @param {?} row
     * @param {?} expanded
     * @param {?=} event
     * @param {?=} visibleColumnIndex
     * @return {?}
     */
    trigger_row_expansion_toggle(row, expanded, event, visibleColumnIndex) {
        /** @type {?} */
        const grid = this.grid;
        if (row.expanded === expanded ||
            ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
            return;
        }
        /** @type {?} */
        const args = {
            rowID: row.rowID,
            expanded: expanded,
            event: event,
            cancel: false
        };
        grid.onRowToggle.emit(args);
        if (args.cancel) {
            return;
        }
        /** @type {?} */
        const expandedStates = grid.expansionStates;
        expandedStates.set(row.rowID, expanded);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
        // TODO: Leave it to grid observer
        requestAnimationFrame(() => {
            /** @type {?} */
            const el = this.grid.selectionService.activeElement;
            if (el) {
                /** @type {?} */
                const cell = this.get_cell_by_visible_index(el.row, el.column);
                if (cell) {
                    cell.nativeElement.focus();
                }
            }
        });
    }
    /**
     * @param {?} record
     * @return {?}
     */
    expand_path_to_record(record) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const expandedStates = grid.expansionStates;
        while (record.parent) {
            record = record.parent;
            /** @type {?} */
            const expanded = this.get_row_expansion_state(record);
            if (!expanded) {
                expandedStates.set(record.rowID, true);
            }
        }
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    /**
     * @param {?} record
     * @return {?}
     */
    get_row_expansion_state(record) {
        /** @type {?} */
        const grid = this.grid;
        /** @type {?} */
        const states = grid.expansionStates;
        /** @type {?} */
        const expanded = states.get(record.rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return record.children && record.children.length && record.level < grid.expansionDepth;
        }
    }
    /**
     * @protected
     * @param {?} value
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    update_row_in_array(value, rowID, index) {
        /** @type {?} */
        const grid = this.grid;
        if (grid.primaryKey && grid.foreignKey) {
            super.update_row_in_array(value, rowID, index);
        }
        else {
            /** @type {?} */
            const record = grid.records.get(rowID);
            /** @type {?} */
            const childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
            index = grid.primaryKey ? childData.map(c => c[grid.primaryKey]).indexOf(rowID) :
                childData.indexOf(rowID);
            childData[index] = value;
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    should_apply_number_style(column) {
        return column.dataType === DataType.Number && column.visibleIndex !== 0;
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    deleteRowById(rowID) {
        /** @type {?} */
        const treeGrid = this.grid;
        /** @type {?} */
        const flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
            treeGrid.foreignKey &&
            treeGrid.cascadeOnDelete &&
            treeGrid.transactions.enabled;
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.startPending();
        }
        super.deleteRowById(rowID);
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.endPending(true);
        }
    }
    /**
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    deleteRowFromData(rowID, index) {
        /** @type {?} */
        const treeGrid = this.grid;
        /** @type {?} */
        const record = treeGrid.records.get(rowID);
        if (treeGrid.primaryKey && treeGrid.foreignKey) {
            index = treeGrid.primaryKey ?
                treeGrid.data.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                treeGrid.data.indexOf(rowID);
            super.deleteRowFromData(rowID, index);
            if (treeGrid.cascadeOnDelete) {
                if (record && record.children && record.children.length > 0) {
                    for (let i = 0; i < record.children.length; i++) {
                        /** @type {?} */
                        const child = record.children[i];
                        super.deleteRowById(child.rowID);
                    }
                }
            }
        }
        else {
            /** @type {?} */
            const collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
            index = treeGrid.primaryKey ?
                collection.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                collection.indexOf(rowID);
            /** @type {?} */
            const selectedChildren = [];
            this.get_selected_children(record, selectedChildren);
            if (selectedChildren.length > 0) {
                treeGrid.deselectRows(selectedChildren);
            }
            if (treeGrid.transactions.enabled) {
                /** @type {?} */
                const path = treeGrid.generateRowPath(rowID);
                treeGrid.transactions.add({
                    id: rowID,
                    type: TransactionType.DELETE,
                    newValue: null,
                    path: path
                }, collection[index]);
            }
            else {
                collection.splice(index, 1);
            }
        }
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @protected
     * @param {?} grid Grid to update data for
     * @param {?} rowID ID of the row to update
     * @param {?} rowValueInDataSource Initial value of the row as it is in data source
     * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param {?} rowNewValue New value of the row
     * @return {?}
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            /** @type {?} */
            const path = grid.generateRowPath(rowID);
            /** @type {?} */
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue,
                path: path
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    /**
     * @param {?} record
     * @param {?} selectedRowIDs
     * @return {?}
     */
    get_selected_children(record, selectedRowIDs) {
        /** @type {?} */
        const grid = this.grid;
        if (!record.children || record.children.length === 0) {
            return;
        }
        for (const child of record.children) {
            if (grid.selectionService.isRowSelected(child.rowID)) {
                selectedRowIDs.push(child.rowID);
            }
            this.get_selected_children(child, selectedRowIDs);
        }
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    row_deleted_transaction(rowID) {
        return this.row_deleted_parent(rowID) || super.row_deleted_transaction(rowID);
    }
    /**
     * @private
     * @param {?} rowID
     * @return {?}
     */
    row_deleted_parent(rowID) {
        /** @type {?} */
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
            /** @type {?} */
            let node = grid.records.get(rowID);
            while (node) {
                /** @type {?} */
                const state = grid.transactions.getState(node.rowID);
                if (state && state.type === TransactionType.DELETE) {
                    return true;
                }
                node = node.parent;
            }
        }
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTreeGridNavigationService extends IgxGridNavigationService {
    /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    getCellSelector(visibleIndex, isSummary = false) {
        if (isSummary) {
            return 'igx-grid-summary-cell';
        }
        if (visibleIndex === 0) {
            return 'igx-tree-grid-cell';
        }
        return 'igx-grid-cell';
    }
    /**
     * @protected
     * @return {?}
     */
    getRowSelector() {
        return 'igx-tree-grid-row';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxRowLoadingIndicatorTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxRowLoadingIndicatorTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRowLoadingIndicator]'
            },] }
];
/** @nocollapse */
IgxRowLoadingIndicatorTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$n = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
class IgxTreeGridComponent extends IgxGridBaseComponent {
    constructor() {
        super(...arguments);
        this._id = `igx-tree-grid-${NEXT_ID$n++}`;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        this._expansionDepth = Infinity;
        this._expansionStates = new Map();
        /**
         * @hidden
         */
        this.expansionStatesChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        this.dragIndicatorIconTemplate = null;
        /**
         * Emitted when the expanded state of a row gets changed.
         * ```typescript
         * rowToggle(event: IRowToggleEventArgs){
         *  // the id of the row
         *  const rowID = event.rowID;
         *  // the new expansion state
         *  const newExpandedState = event.expanded;
         *  // the original event that triggered onRowToggle
         *  const originalEvent = event.event;
         *  // whether the event should be cancelled
         *  event.cancel = true;
         * }
         * ```
         * ```html
         * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.onRowToggle = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._filteredData = null;
    }
    /**
     * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
    }
    /**
     * An \@Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.notifyChanges(true);
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} value
     * @return {?}
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Get transactions service for the grid.
     * \@experimental \@hidden
     * @return {?}
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * An \@Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * Returns a list of key-value pairs [row ID, expansion state]. Includes only states that differ from the default one.
     * ```typescript
     * const expansionStates = this.grid.expansionStates;
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get expansionStates() {
        return this._expansionStates;
    }
    /**
     * Sets a list of key-value pairs [row ID, expansion state].
     * ```typescript
     * const states = new Map<any, boolean>();
     * states.set(1, true);
     * this.grid.expansionStates = states;
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" [(expansionStates)]="model.expansionStates">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} value
     * @return {?}
     */
    set expansionStates(value) {
        this._expansionStates = this.cloneMap(value);
        this.expansionStatesChange.emit(this._expansionStates);
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * An \@Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon fontSet="material">loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    // Kind of stupid
    /**
     * @private
     * @return {?}
     */
    get _gridAPI() {
        return (/** @type {?} */ (this.gridAPI));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.onRowToggle.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    /**
     * @private
     * @param {?} args
     * @return {?}
     */
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            /** @type {?} */
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                    requestAnimationFrame(() => {
                        /** @type {?} */
                        const cellID = this.selectionService.activeElement;
                        if (cellID) {
                            /** @type {?} */
                            const cell = this._gridAPI.get_cell_by_index(cellID.row, cellID.column);
                            if (cell) {
                                cell.nativeElement.focus();
                            }
                        }
                    });
                });
            }
        }
    }
    /**
     * @private
     * @param {?} children
     * @param {?} parentID
     * @return {?}
     */
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            /** @type {?} */
            let parent = this.records.get(parentID);
            /** @type {?} */
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                /** @type {?} */
                const path = [];
                while (parent) {
                    path.push(parent.rowID);
                    parent = parent.parent;
                }
                /** @type {?} */
                let collection = this.data;
                /** @type {?} */
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    /** @type {?} */
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this._pipeTrigger++;
    }
    /**
     * @private
     * @param {?} mapIn
     * @return {?}
     */
    cloneMap(mapIn) {
        /** @type {?} */
        const mapCloned = new Map();
        mapIn.forEach((value, key, mapObj) => {
            mapCloned.set(key, value);
        });
        return mapCloned;
    }
    /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @return {?}
     */
    expandRow(rowID) {
        this._gridAPI.expand_row(rowID);
    }
    /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @return {?}
     */
    collapseRow(rowID) {
        this._gridAPI.collapse_row(rowID);
    }
    /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @return {?}
     */
    toggleRow(rowID) {
        this._gridAPI.toggle_row_expansion(rowID);
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} data
     * @param {?=} parentRowID
     * @return {?}
     */
    addRow(data, parentRowID) {
        if (parentRowID !== undefined && parentRowID !== null) {
            super.endEdit(true);
            /** @type {?} */
            const state = this.transactions.getState(parentRowID);
            // we should not allow adding of rows as child of deleted row
            if (state && state.type === TransactionType.DELETE) {
                throw Error(`Cannot add child row to deleted parent row`);
            }
            /** @type {?} */
            const parentRecord = this.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.primaryKey && this.foreignKey) {
                data[this.foreignKey] = parentRowID;
                super.addRow(data);
            }
            else {
                /** @type {?} */
                const parentData = parentRecord.data;
                /** @type {?} */
                const childKey = this.childDataKey;
                if (this.transactions.enabled) {
                    /** @type {?} */
                    const rowId = this.primaryKey ? data[this.primaryKey] : data;
                    /** @type {?} */
                    const path = [];
                    path.push(...this.generateRowPath(parentRowID));
                    path.push(parentRowID);
                    this.transactions.add((/** @type {?} */ ({
                        id: rowId,
                        path: path,
                        newValue: data,
                        type: TransactionType.ADD
                    })), null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
                this.onRowAdded.emit({ data });
                this._pipeTrigger++;
                this.notifyChanges();
            }
        }
        else {
            if (this.primaryKey && this.foreignKey) {
                /** @type {?} */
                const rowID = data[this.foreignKey];
                this.summaryService.clearSummaryCache({ rowID: rowID });
            }
            super.addRow(data);
        }
    }
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    }
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    generateRowPath(rowId) {
        /** @type {?} */
        const path = [];
        /** @type {?} */
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    }
    /**
     * @hidden \@internal
     * @protected
     * @return {?}
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    scrollTo(row, column) {
        /** @type {?} */
        let delayScrolling = false;
        /** @type {?} */
        let record;
        if (typeof (row) !== 'number') {
            /** @type {?} */
            const rowData = row;
            /** @type {?} */
            const rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                /** @type {?} */
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                /** @type {?} */
                const page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    getContext(rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    }
    /**
     * \@inheritdoc
     * @param {?=} formatters
     * @param {?=} headers
     * @return {?}
     */
    getSelectedData(formatters = false, headers = false) {
        /** @type {?} */
        const source = [];
        /** @type {?} */
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.dataView.forEach(process);
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            /** @type {?} */
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
}
IgxTreeGridComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-tree-grid',
                template: "<igx-grid-toolbar role=\"rowgroup\" [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'\n        (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData\n            [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger\n        | treeGridSorting:sortingExpressions:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row>\n                </igx-tree-grid-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                    [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"processedExpandedFlatData.length\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    IgxGridSummaryService,
                    { provide: IgxGridNavigationService, useClass: IgxTreeGridNavigationService },
                    { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                    { provide: IgxGridBaseComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTreeGridComponent) },
                    IgxFilteringService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ]
            }] }
];
IgxTreeGridComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    childDataKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    foreignKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hasChildrenKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cascadeOnDelete: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expansionDepth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expansionStates: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expansionStatesChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    rowLoadingTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective, static: false },] }],
    dragIndicatorIconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxDragIndicatorIconDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    rowLoadingIndicatorTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    loadChildrenOnDemand: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onRowToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    dragIndicatorIconBase: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dragIndicatorIconBase', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTreeGridRowComponent extends IgxRowComponent {
    /**
     * The `ITreeGridRecord` passed to the row component.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const treeRow = row.treeRow;
     * ```
     * @return {?}
     */
    get treeRow() {
        return this._treeRow;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set treeRow(value) {
        if (this._treeRow !== value) {
            this._treeRow = value;
            this.rowData = this._treeRow.data;
        }
    }
    /**
     * Returns a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const expanded = row.expanded;
     * ```
     * @return {?}
     */
    get expanded() {
        return this._treeRow.expanded;
    }
    /**
     * Sets a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * row.expanded = true;
     * ```
     * @param {?} value
     * @return {?}
     */
    set expanded(value) {
        ((/** @type {?} */ (this.gridAPI))).trigger_row_expansion_toggle(this._treeRow, value);
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     * @return {?}
     */
    get showIndicator() {
        return this.grid.loadChildrenOnDemand ?
            this.grid.expansionStates.has(this.rowID) ?
                this.treeRow.children && this.treeRow.children.length :
                this.grid.hasChildrenKey ?
                    this.rowData[this.grid.hasChildrenKey] :
                    true :
            this.treeRow.children && this.treeRow.children.length;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    resolveClasses() {
        /** @type {?} */
        const classes = super.resolveClasses();
        /** @type {?} */
        const filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
        return `${classes} ${filteredClass}`;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
        this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
        super.ngDoCheck();
    }
}
IgxTreeGridRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                selector: 'igx-tree-grid-row',
                template: "<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width.px]=\"col.width\"\n                [style.flex-basis.px]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\" #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width.px]=\"col.width\"\n                [style.flex-basis.px]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
                providers: [{ provide: IgxRowComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTreeGridRowComponent) }]
            }] }
];
IgxTreeGridRowComponent.propDecorators = {
    cells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: ['treeCell',] }],
    treeRow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-expanded',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxTreeGridHierarchizingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} foreignKey
     * @param {?} childDataKey
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, primaryKey, foreignKey, childDataKey, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        let hierarchicalRecords = [];
        /** @type {?} */
        const treeGridRecordsMap = new Map();
        /** @type {?} */
        const flatData = [];
        if (primaryKey && foreignKey) {
            hierarchicalRecords = this.hierarchizeFlatData(id, collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
        }
        else if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(id, collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
        }
        grid.flatData = flatData;
        grid.records = treeGridRecordsMap;
        grid.rootRecords = hierarchicalRecords;
        return hierarchicalRecords;
    }
    /**
     * @private
     * @param {?} primaryKey
     * @param {?} rowData
     * @return {?}
     */
    getRowID(primaryKey, rowData) {
        return primaryKey ? rowData[primaryKey] : rowData;
    }
    /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} foreignKey
     * @param {?} map
     * @param {?} flatData
     * @return {?}
     */
    hierarchizeFlatData(id, collection, primaryKey, foreignKey, map, flatData) {
        /** @type {?} */
        const result = [];
        /** @type {?} */
        const missingParentRecords = [];
        collection.forEach(row => {
            /** @type {?} */
            const record = {
                rowID: this.getRowID(primaryKey, row),
                data: row,
                children: []
            };
            /** @type {?} */
            const parent = map.get(row[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                missingParentRecords.push(record);
            }
            map.set(row[primaryKey], record);
        });
        missingParentRecords.forEach(record => {
            /** @type {?} */
            const parent = map.get(record.data[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                result.push(record);
            }
        });
        this.setIndentationLevels(id, result, 0, flatData);
        return result;
    }
    /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} indentationLevel
     * @param {?} flatData
     * @return {?}
     */
    setIndentationLevels(id, collection, indentationLevel, flatData) {
        for (let i = 0; i < collection.length; i++) {
            /** @type {?} */
            const record = collection[i];
            record.level = indentationLevel;
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);
            if (record.children && record.children.length > 0) {
                this.setIndentationLevels(id, record.children, indentationLevel + 1, flatData);
            }
        }
    }
    /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} parent
     * @param {?} flatData
     * @param {?} indentationLevel
     * @param {?} map
     * @return {?}
     */
    hierarchizeRecursive(id, collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
        /** @type {?} */
        const result = [];
        for (let i = 0; i < collection.length; i++) {
            /** @type {?} */
            const item = collection[i];
            /** @type {?} */
            const record = {
                rowID: this.getRowID(primaryKey, item),
                data: item,
                parent: parent,
                level: indentationLevel
            };
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map.set(record.rowID, record);
            record.children = item[childDataKey] ?
                this.hierarchizeRecursive(id, item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                undefined;
            result.push(record);
        }
        return result;
    }
}
IgxTreeGridHierarchizingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridHierarchizing',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridHierarchizingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxTreeGridFlatteningPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} id
     * @param {?} expandedLevels
     * @param {?} expandedStates
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, id, expandedLevels, expandedStates, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const data = [];
        grid.processedRootRecords = collection;
        grid.processedRecords = new Map();
        this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, id, true);
        grid.processedExpandedFlatData = data.map(r => r.data);
        return data;
    }
    /**
     * @private
     * @param {?} collection
     * @param {?} data
     * @param {?} expandedLevels
     * @param {?} expandedStates
     * @param {?} gridID
     * @param {?} parentExpanded
     * @return {?}
     */
    getFlatDataRecursive(collection, data, expandedLevels, expandedStates, gridID, parentExpanded) {
        if (!collection || !collection.length) {
            return;
        }
        /** @type {?} */
        const grid = this.gridAPI.grid;
        for (let i = 0; i < collection.length; i++) {
            /** @type {?} */
            const hierarchicalRecord = collection[i];
            if (parentExpanded) {
                data.push(hierarchicalRecord);
            }
            hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
            grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, gridID, parentExpanded && hierarchicalRecord.expanded);
        }
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} record
     * @return {?}
     */
    updateNonProcessedRecordExpansion(grid, record) {
        /** @type {?} */
        const rec = grid.records.get(record.rowID);
        rec.expanded = record.expanded;
    }
}
IgxTreeGridFlatteningPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridFlattening',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridFlatteningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxTreeGridSortingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(hierarchicalData, expressions, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        let result;
        if (!expressions.length) {
            result = hierarchicalData;
        }
        else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions);
        }
        /** @type {?} */
        const filteredSortedData = [];
        this.flattenTreeGridRecords(result, filteredSortedData);
        grid.filteredSortedData = filteredSortedData;
        return result;
    }
    /**
     * @private
     * @param {?} records
     * @param {?} flatData
     * @return {?}
     */
    flattenTreeGridRecords(records, flatData) {
        if (records && records.length) {
            for (const record of records) {
                flatData.push(record.data);
                this.flattenTreeGridRecords(record.children, flatData);
            }
        }
    }
}
IgxTreeGridSortingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridSorting',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxTreeGridPagingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        if (!grid.paging) {
            return collection;
        }
        /** @type {?} */
        const len = collection.length;
        /** @type {?} */
        const totalPages = Math.ceil(len / perPage);
        /** @type {?} */
        const state = {
            index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
            recordsPerPage: perPage
        };
        /** @type {?} */
        const result = DataUtil.page(cloneArray(collection), state);
        grid.pagingState = state;
        ((/** @type {?} */ (grid)))._page = state.index;
        return result;
    }
}
IgxTreeGridPagingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridPaging',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxTreeGridTransactionPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, id, pipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            /** @type {?} */
            const aggregatedChanges = grid.transactions.getAggregatedChanges(true);
            if (aggregatedChanges.length > 0) {
                /** @type {?} */
                const primaryKey = grid.primaryKey;
                if (!primaryKey) {
                    return collection;
                }
                /** @type {?} */
                const foreignKey = grid.foreignKey;
                /** @type {?} */
                const childDataKey = grid.childDataKey;
                if (foreignKey) {
                    /** @type {?} */
                    const flatDataClone = cloneArray(collection);
                    return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                }
                else if (childDataKey) {
                    /** @type {?} */
                    const hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                    return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                }
            }
        }
        return collection;
    }
}
IgxTreeGridTransactionPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridTransaction',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTreeGridCellComponent extends IgxGridCellComponent {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} gridAPI
     * @param {?} cdr
     * @param {?} element
     * @param {?} zone
     * @param {?} touchManager
     * @param {?} document
     * @param {?} platformUtil
     */
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.expanded = false;
        /**
         * @hidden
         */
        this.level = 0;
        /**
         * @hidden
         */
        this.showIndicator = false;
        this.treeGridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.stopPropagation();
        this.treeGridAPI.trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
    }
    /**
     * @hidden
     * @return {?}
     */
    onIndicatorFocus() {
        this.gridAPI.submit_value();
        this.nativeElement.focus();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onLoadingDblClick(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    calculateSizeToFit(range) {
        /** @type {?} */
        const indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        const indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        /** @type {?} */
        const indicatorMargin = parseFloat(indicatorStyle.marginRight);
        /** @type {?} */
        let leftPadding = 0;
        if (this.indentationDiv) {
            /** @type {?} */
            const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        /** @type {?} */
        const largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
}
IgxTreeGridCellComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                selector: 'igx-tree-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{level}}\"></div>\n    </ng-container>\n    <div #indicator\n         *ngIf=\"!isLoading\"\n         class=\"igx-grid__tree-grouping-indicator\"\n         [ngStyle]=\"{'visibility': showIndicator ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n    <div *ngIf=\"isLoading\"\n         (dblclick)=\"onLoadingDblClick($event)\"\n         class=\"igx-grid__tree-loading-indicator\">\n        <ng-container *ngTemplateOutlet=\"grid.rowLoadingIndicatorTemplate ? grid.rowLoadingIndicatorTemplate : defaultLoadingIndicatorTemplate\">\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }] }
];
/** @nocollapse */
IgxTreeGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: PlatformUtil }
];
IgxTreeGridCellComponent.propDecorators = {
    expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    level: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    showIndicator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    indicator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['indicator', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    indentationDiv: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['indentationDiv', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    defaultContentElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultContentElement', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    defaultExpandedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExpandedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultCollapsedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultCollapsedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    isLoading: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxTreeGridSummaryPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} flatData
     * @param {?} hasSummary
     * @param {?} summaryCalculationMode
     * @param {?} summaryPosition
     * @param {?} id
     * @param {?} pipeTrigger
     * @param {?} summaryPipeTrigger
     * @return {?}
     */
    transform(flatData, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
        /** @type {?} */
        const grid = this.gridAPI.grid;
        if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
        }
        return this.addSummaryRows(grid, flatData, summaryPosition);
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} collection
     * @param {?} summaryPosition
     * @return {?}
     */
    addSummaryRows(grid, collection, summaryPosition) {
        /** @type {?} */
        const recordsWithSummary = [];
        /** @type {?} */
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        for (let i = 0; i < collection.length; i++) {
            /** @type {?} */
            const record = collection[i];
            recordsWithSummary.push(record);
            /** @type {?} */
            const isExpanded = record.children && record.children.length > 0 && record.expanded;
            if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
                /** @type {?} */
                let childRecord = record;
                /** @type {?} */
                let parent = record.parent;
                while (parent) {
                    /** @type {?} */
                    const children = parent.children;
                    if (children[children.length - 1] === childRecord) {
                        /** @type {?} */
                        let childData = children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                        childData = this.removeDeletedRecord(grid, parent.rowID, childData);
                        /** @type {?} */
                        const summaries = grid.summaryService.calculateSummaries(parent.rowID, childData);
                        /** @type {?} */
                        const summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight,
                            cellIndentation: parent.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                        childRecord = parent;
                        parent = childRecord.parent;
                    }
                    else {
                        break;
                    }
                }
            }
            else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
                /** @type {?} */
                let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                /** @type {?} */
                const summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                /** @type {?} */
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
        }
        return recordsWithSummary;
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} rowId
     * @param {?} data
     * @return {?}
     */
    removeDeletedRecord(grid, rowId, data) {
        if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
            return data;
        }
        /** @type {?} */
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        /** @type {?} */
        let row = grid.records.get(rowId);
        if (!row && deletedRows.lenght === 0) {
            return [];
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowId = row.rowID;
            if (deletedRows.indexOf(rowId) !== -1) {
                return [];
            }
            row = row.parent;
        }
        deletedRows.forEach(rowID => {
            /** @type {?} */
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            /** @type {?} */
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
}
IgxTreeGridSummaryPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'treeGridSummary',
                pure: true
            },] }
];
/** @nocollapse */
IgxTreeGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxTreeGridModule {
}
IgxTreeGridModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxTreeGridHierarchizingPipe,
                    IgxTreeGridFlatteningPipe,
                    IgxTreeGridSortingPipe,
                    IgxTreeGridFilteringPipe,
                    IgxTreeGridPagingPipe,
                    IgxTreeGridTransactionPipe,
                    IgxTreeGridSummaryPipe,
                    IgxRowLoadingIndicatorTemplateDirective
                ],
                exports: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxGridCommonModule
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                    IgxChipsModule,
                    IgxGridCommonModule,
                    IgxSelectModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    getCellSelector(visibleIndex, isSummary = false) {
        return isSummary ? 'igx-grid-summary-cell' : 'igx-hierarchical-grid-cell';
    }
    /**
     * @protected
     * @return {?}
     */
    getRowSelector() {
        return 'igx-hierarchical-grid-row';
    }
    /**
     * @protected
     * @param {?} index
     * @return {?}
     */
    getRowByIndex(index) {
        /** @type {?} */
        const selector = this.getRowSelector();
        /** @type {?} */
        const rows = Array.from(this.grid.nativeElement.querySelectorAll(`${selector}[data-rowindex="${index}"]`));
        /** @type {?} */
        let row;
        rows.forEach((r) => {
            /** @type {?} */
            const parentGrid = this.getClosestElemByTag(r, 'igx-hierarchical-grid');
            if (parentGrid && parentGrid.getAttribute('id') === this.grid.id) {
                row = r;
            }
        });
        return row;
    }
    /**
     * @private
     * @param {?=} grid
     * @return {?}
     */
    getChildContainer(grid) {
        /** @type {?} */
        const currGrid = grid || this.grid;
        return currGrid.nativeElement.parentNode.parentNode.parentNode;
    }
    /**
     * @private
     * @param {?=} grid
     * @return {?}
     */
    getChildGridRowContainer(grid) {
        /** @type {?} */
        const currGrid = grid || this.grid;
        return currGrid.nativeElement.parentNode.parentNode;
    }
    /**
     * @private
     * @param {?} childGridID
     * @param {?} grid
     * @return {?}
     */
    getChildGrid(childGridID, grid) {
        /** @type {?} */
        const cgrid = grid.hgridAPI.getChildGrids(true).filter((g) => g.id === childGridID)[0];
        return cgrid;
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    _isScrolledToBottom(grid) {
        /** @type {?} */
        const scrollTop = grid.verticalScrollContainer.scrollPosition;
        /** @type {?} */
        const scrollHeight = grid.verticalScrollContainer.getScroll().scrollHeight;
        return scrollHeight === 0 || Math.round(scrollTop + grid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    getIsChildAtIndex(index) {
        return this.grid.isChildGridRecord(this.grid.dataView[index]);
    }
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary = false) {
        /** @type {?} */
        const cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
        if (isSummary) {
            /** @type {?} */
            const summaryRow = this.grid.summariesRowList.toArray()[0].nativeElement;
            return summaryRow.querySelector(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
        }
        /** @type {?} */
        const row = this.getRowByIndex(rowIndex);
        return row.querySelector(`${cellSelector}[data-rowindex="${rowIndex}"][data-visibleIndex="${visibleColumnIndex}"]`);
    }
    /**
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    navigateUp(rowElement, selectedNode) {
        if (selectedNode.isSummaryRow) {
            return;
        }
        /** @type {?} */
        const prevElem = rowElement.previousElementSibling;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const currentRowIndex = selectedNode.row;
        if (prevElem) {
            /** @type {?} */
            const nodeName = prevElem.children[0].nodeName.toLowerCase();
            /** @type {?} */
            const isElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';
            if (isElemChildGrid) {
                this.focusPrevChild(prevElem, visibleColumnIndex, this.grid);
            }
            else {
                if (this.grid.parent !== null) {
                    // currently navigating in child grid
                    this._navigateUpInChild(rowElement, currentRowIndex, visibleColumnIndex);
                }
                else {
                    super.navigateUp(rowElement, selectedNode);
                }
            }
        }
        else if (currentRowIndex !== 0) {
            // handle scenario when prev item is child grid but is not yet in view
            /** @type {?} */
            const isPrevChildGrid = this.getIsChildAtIndex(currentRowIndex - 1);
            if (!isPrevChildGrid) {
                super.navigateUp(rowElement, selectedNode);
            }
            else {
                this.scrollGrid(this.grid, -rowElement.offsetHeight, () => {
                    rowElement = this.getRowByIndex(currentRowIndex);
                    this.navigateUp(rowElement, selectedNode);
                });
            }
        }
        else if (this.grid.parent !== null &&
            currentRowIndex === 0) {
            // move to prev row in sibling layout or parent
            this.focusPrev(visibleColumnIndex);
        }
    }
    /**
     * @param {?} rowElement
     * @param {?} selectedNode
     * @return {?}
     */
    navigateDown(rowElement, selectedNode) {
        if (selectedNode.isSummaryRow) {
            return;
        }
        /** @type {?} */
        const nextElem = rowElement.nextElementSibling;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const currentRowIndex = selectedNode.row;
        if (nextElem) {
            // next elem is in DOM
            /** @type {?} */
            const nodeName = nextElem.children[0].nodeName.toLowerCase();
            /** @type {?} */
            const isNextElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';
            if (isNextElemChildGrid) {
                this.focusNextChild(nextElem, visibleColumnIndex, this.grid);
            }
            else {
                if (this.grid.parent !== null) {
                    // currently navigating in child grid
                    this._navigateDownInChild(rowElement, currentRowIndex, visibleColumnIndex);
                }
                else {
                    super.navigateDown(rowElement, selectedNode);
                }
            }
        }
        else if (currentRowIndex !== this.grid.dataView.length - 1) {
            // scroll next in view
            super.navigateDown(rowElement, selectedNode);
        }
        else if (this.grid.parent !== null &&
            currentRowIndex === this.grid.dataView.length - 1) {
            // move to next row in sibling layout or in parent
            this.focusNext(visibleColumnIndex);
        }
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    navigateTop(visibleColumnIndex) {
        if (this.grid.parent !== null) {
            // navigating in child
            /** @type {?} */
            const childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */
            const diff = childContainer.getBoundingClientRect().top - this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top;
            /** @type {?} */
            const topIsVisible = diff >= 0;
            /** @type {?} */
            const scrollable = this.getNextScrollable(this.grid);
            if (!topIsVisible) {
                this.scrollGrid(scrollable.grid, diff, () => super.navigateTop(visibleColumnIndex));
            }
            else {
                super.navigateTop(visibleColumnIndex);
            }
        }
        else {
            super.navigateTop(visibleColumnIndex);
        }
    }
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    navigateBottom(visibleColumnIndex) {
        // handle scenario where last index is child grid
        // in that case focus cell in last data row
        /** @type {?} */
        const lastIndex = this.grid.dataView.length - 1;
        if (this.getIsChildAtIndex(lastIndex)) {
            /** @type {?} */
            const targetIndex = lastIndex - 1;
            /** @type {?} */
            const scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
            /** @type {?} */
            const verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
            /** @type {?} */
            const cellSelector = this.getCellSelector(visibleColumnIndex);
            if (verticalScrollTop === scrTopPosition) {
                /** @type {?} */
                const cells = this.getRowByIndex(targetIndex).querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
                cells[cells.length - 1].focus();
            }
            else {
                this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, () => {
                    /** @type {?} */
                    const cells = this.getRowByIndex(targetIndex).querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
                    if (cells.length > 0) {
                        cells[cells.length - 1].focus();
                    }
                });
            }
        }
        else if (this.grid.parent !== null) {
            /** @type {?} */
            const childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */
            const diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            const endIsVisible = diff < 0;
            /** @type {?} */
            const scrollable = this.getNextScrollableDown(this.grid);
            if (!endIsVisible) {
                this.scrollGrid(scrollable.grid, diff, () => super.navigateBottom(visibleColumnIndex));
            }
            else {
                super.navigateBottom(visibleColumnIndex);
            }
        }
        else {
            super.navigateBottom(visibleColumnIndex);
        }
    }
    /**
     * @return {?}
     */
    goToLastCell() {
        // handle scenario where last index is child grid
        // in that case focus last cell in last data row
        /** @type {?} */
        const lastIndex = this.grid.dataView.length - 1;
        if (this.getIsChildAtIndex(lastIndex)) {
            /** @type {?} */
            const targetIndex = lastIndex - 1;
            /** @type {?} */
            const scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
            /** @type {?} */
            const verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
            if (verticalScrollTop === scrTopPosition) {
                this.onKeydownEnd(targetIndex);
            }
            else {
                this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, () => {
                    this.onKeydownEnd(targetIndex);
                });
            }
        }
        else {
            super.goToLastCell();
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    onKeydownEnd(rowIndex, isSummary = false) {
        if (this.grid.parent && !isSummary) {
            // handle scenario where last child row might not be in view
            // parent should scroll to child grid end
            /** @type {?} */
            const childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */
            const diffBottom = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            const row = this.grid.getRowByIndex(rowIndex).element.nativeElement;
            /** @type {?} */
            const rowBottom = row.getBoundingClientRect().bottom;
            /** @type {?} */
            const rowIsVisible = rowBottom <= this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            const gridTop = this._getMaxTop(this.grid);
            /** @type {?} */
            const diffTop = row.getBoundingClientRect().bottom -
                row.offsetHeight - gridTop;
            /** @type {?} */
            const endIsVisible = diffBottom <= 0;
            /** @type {?} */
            const topVisible = diffTop >= 0;
            if (!endIsVisible && !rowIsVisible) {
                this.scrollGrid(this.grid.parent, diffBottom, () => super.onKeydownEnd(rowIndex));
            }
            else if (!topVisible) {
                /** @type {?} */
                const scrGrid = this.grid.verticalScrollContainer.scrollPosition !== 0 ? this.grid :
                    this.getNextScrollable(this.grid).grid;
                /** @type {?} */
                const topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top >
                    this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : this.grid.rootGrid;
                this.scrollGrid(topGrid, diffTop, () => super.onKeydownEnd(rowIndex));
            }
            else {
                super.onKeydownEnd(rowIndex, isSummary);
            }
        }
        else {
            super.onKeydownEnd(rowIndex, isSummary);
        }
    }
    /**
     * @return {?}
     */
    goToFirstCell() {
        /** @type {?} */
        const verticalScroll = this.grid.verticalScrollContainer.getScroll();
        /** @type {?} */
        const horizontalScroll = this.grid.dataRowList.first.virtDirRow.getScroll();
        if (verticalScroll.scrollTop === 0 && this.grid.parent) {
            // scroll parent so that current child is in view
            if (!horizontalScroll.clientWidth || parseInt(horizontalScroll.scrollLeft, 10) <= 1 || this.grid.pinnedColumns.length) {
                this.navigateTop(0);
            }
            else {
                this.horizontalScroll(this.grid.dataRowList.first.index).scrollTo(0);
                this.grid.parentVirtDir.onChunkLoad
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                    .subscribe(() => {
                    this.navigateTop(0);
                });
            }
        }
        else {
            super.goToFirstCell();
        }
    }
    /**
     * @param {?} currentRowEl
     * @param {?} selectedNode
     * @return {?}
     */
    performTab(currentRowEl, selectedNode) {
        if (this.grid.rowInEditMode) {
            super.performTab(currentRowEl, selectedNode);
            return;
        }
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const isSummaryRow = selectedNode.isSummaryRow;
        /** @type {?} */
        const summaryRows = this.grid.summariesRowList.toArray();
        /** @type {?} */
        const hasSummaries = summaryRows.length > 0;
        /** @type {?} */
        const isLastDataRow = rowIndex === this.grid.dataView.length - 1;
        /** @type {?} */
        const nextIsDataRow = this.grid.dataRowList.find(row => row.index === rowIndex + 1);
        /** @type {?} */
        const isLastColumn = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex;
        /** @type {?} */
        const isLastSummaryRow = hasSummaries && isSummaryRow;
        /** @type {?} */
        const nextIndex = rowIndex + 1;
        /** @type {?} */
        const virt = this.grid.verticalScrollContainer;
        /** @type {?} */
        const isNextChild = nextIndex <= virt.igxForOf.length - 1 &&
            this.grid.isChildGridRecord(virt.igxForOf[nextIndex]);
        if (!nextIsDataRow && !(isLastDataRow && hasSummaries) && isLastColumn && !isSummaryRow) {
            // navigating in child, next is not summary
            /** @type {?} */
            const childContainer = this.getChildGridRowContainer();
            /** @type {?} */
            const nextIsSiblingChild = this.grid.parent ? !!childContainer.nextElementSibling : false;
            if (nextIsSiblingChild) {
                this.focusNextChildDOMElem(childContainer, this.grid.parent);
            }
            else if (isNextChild) {
                /** @type {?} */
                const isInView = virt.state.startIndex + virt.state.chunkSize > nextIndex;
                if (!isInView) {
                    this.scrollGrid(this.grid, 'next', () => {
                        this.focusNextChildDOMElem(currentRowEl, this.grid);
                    });
                }
                else {
                    this.focusNextChildDOMElem(currentRowEl, this.grid);
                }
            }
            else if (this.grid.parent && this.grid.parent.summariesRowList.length > 0) {
                this._navigateToNextParentRow(currentRowEl);
            }
            else {
                this.navigateDown(currentRowEl, { row: rowIndex, column: 0 });
            }
        }
        else if (isLastSummaryRow && isLastColumn && this.grid.parent) {
            this._navigateToNextParentRow(currentRowEl);
        }
        else if (isLastDataRow && hasSummaries && isLastColumn && this.grid.parent) {
            // navigating in child rows, next is child grid's summary row
            this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid.parent, true);
        }
        else {
            super.performTab(currentRowEl, selectedNode);
        }
    }
    /**
     * @private
     * @param {?} currentRowEl
     * @return {?}
     */
    _navigateToNextParentRow(currentRowEl) {
        // next is parent summary or next parent row
        /** @type {?} */
        const parent = this.grid.parent;
        /** @type {?} */
        const parentHasSummary = parent.summariesRowList.length > 0;
        /** @type {?} */
        const parentRowIndex = parseInt(this.getClosestElemByTag(currentRowEl, 'igx-child-grid-row').parentNode.getAttribute('data-rowindex'), 10);
        /** @type {?} */
        const isLastRowInParent = parent.dataView.length - 1 === parentRowIndex;
        // check if next is sibling
        /** @type {?} */
        const childRowContainer = this.getChildGridRowContainer(this.grid);
        /** @type {?} */
        const nextIsSiblingChild = !!childRowContainer.nextElementSibling;
        if (isLastRowInParent && parentHasSummary && !nextIsSiblingChild) {
            // next is parent summary
            /** @type {?} */
            const parentSummary = parent.summariesRowList.first.nativeElement;
            parent.navigation.focusNextRow(parentSummary, 0, parent, true);
        }
        else {
            // next is sibling or parent
            this.focusNext(0);
        }
    }
    /**
     * @private
     * @param {?} currentRowEl
     * @param {?} grid
     * @return {?}
     */
    focusNextChildDOMElem(currentRowEl, grid) {
        /** @type {?} */
        const gridElem = currentRowEl.nextElementSibling.querySelector('igx-hierarchical-grid');
        /** @type {?} */
        const childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        const childGrid = this.getChildGrid(childGridID, grid);
        if (childGrid.allowFiltering && childGrid.filterMode === FilterMode.quickFilter) {
            childGrid.navigation.moveFocusToFilterCell(true);
            return;
        }
        this.focusNextChild(currentRowEl.nextElementSibling, 0, grid);
    }
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    navigatePrevFilterCell(column, eventArgs) {
        if (column.visibleIndex === 0 && this.grid.parent) {
            eventArgs.preventDefault();
            /** @type {?} */
            let targetGrid = this.grid.parent;
            /** @type {?} */
            const prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;
            if (prevSiblingChild) {
                /** @type {?} */
                const gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                targetGrid = this.getChildGrid(gridElem.getAttribute('id'), this.grid.parent);
            }
            this.focusPrev(targetGrid.unpinnedColumns[targetGrid.unpinnedColumns.length - 1].visibleIndex);
        }
        else {
            super.navigatePrevFilterCell(column, eventArgs);
        }
    }
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    navigateNextFilterCell(column, eventArgs) {
        /** @type {?} */
        const cols = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        const nextFilterableIndex = cols.indexOf(column) + 1;
        if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
            // next is not filter cell
            /** @type {?} */
            const dataRows = this.grid.rowList.toArray();
            /** @type {?} */
            const hasRows = dataRows.length !== 0;
            /** @type {?} */
            const summaryRows = this.grid.summariesRowList.toArray();
            /** @type {?} */
            const hasSummaries = summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0;
            if (hasRows) {
                this.focusNextRow(dataRows[0].nativeElement, 0, this.grid, false);
            }
            else if (hasSummaries) {
                this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid, true);
            }
            else {
                this.focusNext(0);
            }
            eventArgs.preventDefault();
        }
        else {
            super.navigateNextFilterCell(column, eventArgs);
        }
    }
    /**
     * @param {?} currentRowEl
     * @param {?} selectedNode
     * @return {?}
     */
    performShiftTabKey(currentRowEl, selectedNode) {
        if (this.grid.rowInEditMode) {
            super.performShiftTabKey(currentRowEl, selectedNode);
            return;
        }
        /** @type {?} */
        const rowIndex = selectedNode.row;
        /** @type {?} */
        const visibleColumnIndex = selectedNode.column;
        /** @type {?} */
        const isSummary = selectedNode.isSummaryRow;
        if (visibleColumnIndex === 0 && rowIndex === 0 && this.grid.parent && !isSummary) {
            if (this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                this.moveFocusToFilterCell();
            }
            else {
                /** @type {?} */
                const prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;
                if (prevSiblingChild) {
                    /** @type {?} */
                    const gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                    this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
                }
                else {
                    /** @type {?} */
                    const selNode = {
                        row: rowIndex,
                        column: this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex
                    };
                    this.navigateUp(currentRowEl, selNode);
                }
            }
        }
        else if (visibleColumnIndex === 0 && currentRowEl.previousElementSibling &&
            currentRowEl.previousElementSibling.children[0].tagName.toLowerCase() === 'igx-child-grid-row') {
            /** @type {?} */
            const gridElem = this.getLastGridElem(currentRowEl.previousElementSibling);
            this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
        }
        else if (visibleColumnIndex === 0 && isSummary) {
            /** @type {?} */
            const lastRowIndex = this.grid.dataView.length - 1;
            if (lastRowIndex === -1) {
                // no child data
                if (this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                    this.moveFocusToFilterCell();
                }
                else {
                    /** @type {?} */
                    const selNode = {
                        row: rowIndex,
                        column: this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex
                    };
                    this.navigateUp(currentRowEl, selNode);
                }
            }
            else if (!this.getIsChildAtIndex(lastRowIndex)) {
                super.goToLastCell();
            }
            else {
                /** @type {?} */
                const scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(lastRowIndex, true);
                /** @type {?} */
                const verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
                if (verticalScrollTop === scrTopPosition || isNaN(scrTopPosition)) {
                    /** @type {?} */
                    const closestChild = this.getLastGridElem(this.grid.getRowByIndex(lastRowIndex).nativeElement.parentElement);
                    this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                }
                else {
                    this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, () => {
                        /** @type {?} */
                        const closestChild = this.getLastGridElem(this.grid.getRowByIndex(lastRowIndex).nativeElement.parentElement);
                        this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                    });
                }
            }
        }
        else {
            super.performShiftTabKey(currentRowEl, selectedNode);
        }
    }
    /**
     * @return {?}
     */
    getFocusableGrid() {
        return (isIE() && this.grid.rootGrid) ? this.grid.rootGrid : this.grid;
    }
    /**
     * @private
     * @param {?} trContainer
     * @return {?}
     */
    getLastGridElem(trContainer) {
        /** @type {?} */
        const children = trContainer.children;
        /** @type {?} */
        const closestChild = children[children.length - 1].children[0].children[0];
        return closestChild;
    }
    /**
     * @private
     * @param {?} gridElem
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @return {?}
     */
    performShiftTabIntoChild(gridElem, currentRowEl, rowIndex) {
        /** @type {?} */
        const childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        const childGrid = this.getChildGrid(childGridID, this.grid) || this.getChildGrid(childGridID, this.grid.parent);
        /** @type {?} */
        const lastIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
        /** @type {?} */
        const summaryRows = childGrid.summariesRowList.toArray();
        if (summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0) {
            // move focus to last summary row cell
            /** @type {?} */
            const summaryRow = summaryRows[0].nativeElement;
            this.focusPrevRow(summaryRow, lastIndex, childGrid, true, true);
        }
        else if (childGrid.rowList.toArray().length === 0 &&
            childGrid.allowFiltering && childGrid.filterMode === FilterMode.quickFilter) {
            // move to filter cell
            childGrid.navigation.moveFocusToFilterCell();
        }
        else if (childGrid.rowList.length === 0) {
            // move to prev child or parent row
            /** @type {?} */
            const prevChild = this.getSibling(childGrid);
            if (prevChild) {
                this.performShiftTabIntoChild(prevChild, currentRowEl, rowIndex);
            }
            else {
                /** @type {?} */
                const selNode = {
                    row: rowIndex,
                    column: this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex
                };
                this.navigateUp(currentRowEl, selNode);
            }
        }
        else {
            // move to prev cell
            childGrid.navigation.goToLastCell();
        }
    }
    /**
     * @private
     * @param {?} childGrid
     * @return {?}
     */
    getSibling(childGrid) {
        /** @type {?} */
        const prevChildRow = childGrid.childRow.nativeElement.previousElementSibling;
        if (prevChildRow) {
            return prevChildRow.children[0].children[0];
        }
        return null;
    }
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @return {?}
     */
    focusNextChild(elem, visibleColumnIndex, grid) {
        /** @type {?} */
        const gridElem = elem.querySelector('igx-hierarchical-grid');
        /** @type {?} */
        const childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        const childGrid = this.getChildGrid(childGridID, grid);
        if (childGrid.rowList.toArray().length === 0) {
            this.focusNext(visibleColumnIndex, childGrid);
            return;
        }
        // Update column index since the next child can have in general less columns than visibleColumnIndex value.
        /** @type {?} */
        const lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
        visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
        if (childGrid.verticalScrollContainer.state.startIndex !== 0) {
            // scroll to top
            this.scrollGrid(childGrid, 'top', () => this.focusNextRow(elem, visibleColumnIndex, childGrid));
        }
        else {
            this.focusNextRow(elem, visibleColumnIndex, childGrid);
        }
    }
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @return {?}
     */
    focusPrevChild(elem, visibleColumnIndex, grid) {
        /** @type {?} */
        const grids = [];
        /** @type {?} */
        const gridElems = Array.from(elem.querySelectorAll('igx-hierarchical-grid'));
        /** @type {?} */
        const childLevel = grid.childLayoutList.first.level;
        gridElems.forEach((hg) => {
            /** @type {?} */
            const parentRow = this.getClosestElemByTag(hg, 'igx-child-grid-row');
            if (parentRow && parseInt(parentRow.getAttribute('data-level'), 10) === childLevel) {
                grids.push(hg);
            }
        });
        /** @type {?} */
        const gridElem = grids[grids.length - 1];
        /** @type {?} */
        const childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        const childGrid = this.getChildGrid(childGridID, grid);
        if (childGrid.rowList.toArray().length === 0) {
            this.focusPrev(visibleColumnIndex, childGrid);
            return;
        }
        // Update column index since the previous child can have in general less columns than visibleColumnIndex value.
        /** @type {?} */
        const lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
        visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
        /** @type {?} */
        const isScrolledToBottom = this._isScrolledToBottom(childGrid);
        /** @type {?} */
        const lastIndex = childGrid.dataView.length - 1;
        if (!isScrolledToBottom) {
            // scroll to end
            this.scrollGrid(childGrid, 'bottom', () => this.focusPrevChild(elem, visibleColumnIndex, grid));
        }
        else {
            /** @type {?} */
            const lastRowInChild = childGrid.getRowByIndex(lastIndex);
            /** @type {?} */
            const isChildGrid = lastRowInChild.nativeElement.nodeName.toLowerCase() === 'igx-child-grid-row';
            if (isChildGrid) {
                this.focusPrevChild(lastRowInChild.nativeElement.parentNode, visibleColumnIndex, childGrid);
            }
            else {
                this.focusPrevRow(lastRowInChild.nativeElement, visibleColumnIndex, childGrid, true);
            }
        }
    }
    /**
     * @private
     * @param {?} visibleColumnIndex
     * @param {?=} grid
     * @return {?}
     */
    focusPrev(visibleColumnIndex, grid) {
        /** @type {?} */
        const currGrid = grid || this.grid;
        /** @type {?} */
        let parentContainer = this.getChildContainer(currGrid);
        /** @type {?} */
        let childRowContainer = this.getChildGridRowContainer(currGrid);
        /** @type {?} */
        const prevIsSiblingChild = !!childRowContainer.previousElementSibling;
        /** @type {?} */
        let prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;
        if (prev) {
            if (prevIsSiblingChild) {
                this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
            }
            else {
                this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
            }
        }
        else {
            this.scrollGrid(currGrid.parent, 'prev', () => {
                parentContainer = this.getChildContainer(grid);
                childRowContainer = this.getChildGridRowContainer(grid);
                prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;
                if (prevIsSiblingChild) {
                    this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
                }
                else {
                    this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
                }
            });
        }
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    getNextParentInfo(grid) {
        // find next parent that is not at bottom
        /** @type {?} */
        let currGrid = grid.parent;
        /** @type {?} */
        let nextElem = this.getChildContainer(grid).nextElementSibling;
        while (!nextElem && currGrid.parent !== null) {
            nextElem = this.getChildContainer(currGrid).nextElementSibling;
            currGrid = currGrid.parent;
        }
        return { grid: currGrid, nextElement: nextElem };
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    getNextScrollable(grid) {
        /** @type {?} */
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        /** @type {?} */
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        /** @type {?} */
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev: prev };
    }
    /**
     * @private
     * @param {?} visibleColumnIndex
     * @param {?=} grid
     * @return {?}
     */
    focusNext(visibleColumnIndex, grid) {
        /** @type {?} */
        const currGrid = grid || this.grid;
        /** @type {?} */
        const parentInfo = this.getNextParentInfo(currGrid);
        /** @type {?} */
        const nextParentGrid = parentInfo.grid;
        /** @type {?} */
        let nextParentElem = parentInfo.nextElement;
        /** @type {?} */
        let childRowContainer = this.getChildGridRowContainer(currGrid);
        /** @type {?} */
        const nextIsSiblingChild = !!childRowContainer.nextElementSibling;
        /** @type {?} */
        let next = childRowContainer.nextElementSibling || nextParentElem;
        /** @type {?} */
        const verticalScroll = nextParentGrid.verticalScrollContainer.getScroll();
        /** @type {?} */
        const parentState = nextParentGrid.verticalScrollContainer.state;
        /** @type {?} */
        const atLastChunk = parentState.startIndex + parentState.chunkSize ===
            nextParentGrid.dataView.length;
        if (next) {
            if (nextIsSiblingChild) {
                this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
            }
            else {
                this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
            }
        }
        else if (verticalScroll.scrollTop !==
            verticalScroll.scrollHeight - nextParentGrid.verticalScrollContainer.igxForContainerSize && !atLastChunk) {
            this.scrollGrid(nextParentGrid, 'next', () => {
                nextParentElem = parentInfo.nextElement;
                childRowContainer = this.getChildGridRowContainer();
                next = childRowContainer.nextElementSibling || nextParentElem;
                if (next && nextIsSiblingChild) {
                    this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
                }
                else if (next) {
                    this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
                }
            });
        }
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    getNextScrollableDown(grid) {
        /** @type {?} */
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        /** @type {?} */
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        /** @type {?} */
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        /** @type {?} */
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        /** @type {?} */
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev: prev };
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    _getMinBottom(grid) {
        /** @type {?} */
        let currGrid = grid;
        /** @type {?} */
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom);
        }
        return bottom;
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    _getMaxTop(grid) {
        /** @type {?} */
        let currGrid = grid;
        /** @type {?} */
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top);
        }
        return top;
    }
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @param {?=} isSummary
     * @return {?}
     */
    focusNextRow(elem, visibleColumnIndex, grid, isSummary) {
        /** @type {?} */
        const cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
        if (grid.navigation.isColumnFullyVisible(visibleColumnIndex)) {
            /** @type {?} */
            const cell = elem.querySelector(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
            /** @type {?} */
            const closestScrollableGrid = this.getNextScrollableDown(grid).grid;
            // const diff = cell.getBoundingClientRect().bottom - grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            const gridBottom = this._getMinBottom(grid);
            /** @type {?} */
            const diff = cell.getBoundingClientRect().bottom - gridBottom;
            /** @type {?} */
            const inView = diff <= 0;
            /** @type {?} */
            const scrollTop = closestScrollableGrid.verticalScrollContainer.scrollPosition;
            /** @type {?} */
            const scrollHeight = closestScrollableGrid.verticalScrollContainer.getScroll().scrollHeight;
            /** @type {?} */
            const canScroll = !(scrollHeight === 0 ||
                Math.round(scrollTop + closestScrollableGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight);
            if (!inView && canScroll) {
                this.scrollGrid(closestScrollableGrid, diff, () => cell.focus({ preventScroll: true }));
            }
            else {
                cell.focus({ preventScroll: true });
            }
        }
        else {
            /** @type {?} */
            const cellElem = elem.querySelector(`${cellSelector}`);
            /** @type {?} */
            const rowIndex = parseInt(cellElem.getAttribute('data-rowindex'), 10);
            grid.navigation.performHorizontalScrollToCell(rowIndex, visibleColumnIndex);
        }
    }
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @param {?=} inChild
     * @param {?=} isSummary
     * @return {?}
     */
    focusPrevRow(elem, visibleColumnIndex, grid, inChild, isSummary) {
        if (grid.navigation.isColumnFullyVisible(visibleColumnIndex)) {
            /** @type {?} */
            const cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
            /** @type {?} */
            const cells = elem.querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`);
            /** @type {?} */
            let cell = cells[cells.length - 1];
            /** @type {?} */
            const rIndex = parseInt(elem.getAttribute('data-rowindex'), 10);
            /** @type {?} */
            const scrGrid = grid.verticalScrollContainer.scrollPosition !== 0 ? grid :
                this.getNextScrollable(grid).grid;
            /** @type {?} */
            const topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top >
                grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : grid.rootGrid;
            /** @type {?} */
            const gridTop = this._getMaxTop(grid);
            /** @type {?} */
            const scrTop = scrGrid.verticalScrollContainer.scrollPosition;
            /** @type {?} */
            const diff = cell.getBoundingClientRect().bottom -
                cell.offsetHeight - gridTop;
            if (scrTop !== 0 && diff < 0 && !inChild) {
                this.scrollGrid(scrGrid, diff, () => {
                    /** @type {?} */
                    const el = !isSummary ? grid.navigation.getRowByIndex(rIndex) : elem;
                    cell = el.querySelectorAll(`${cellSelector}[data-visibleIndex="${visibleColumnIndex}"]`)[0];
                    cell.focus({ preventScroll: true });
                });
            }
            else if (diff < 0 && inChild) {
                this.scrollGrid(topGrid, diff, () => {
                    cell.focus({ preventScroll: true });
                });
            }
            else {
                cell.focus({ preventScroll: true });
            }
        }
        else {
            this.horizontalScrollGridToIndex(grid, visibleColumnIndex, () => {
                this.focusPrevRow(elem, visibleColumnIndex, grid, inChild, isSummary);
            });
        }
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} visibleColumnIndex
     * @param {?} callBackFunc
     * @return {?}
     */
    horizontalScrollGridToIndex(grid, visibleColumnIndex, callBackFunc) {
        /** @type {?} */
        const unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex);
        grid.parentVirtDir.onChunkLoad
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
            .subscribe(callBackFunc);
        if (grid.dataRowList.length > 0) {
            grid.dataRowList.first.virtDirRow.scrollTo(unpinnedIndex);
        }
        else {
            grid.headerContainer.scrollTo(unpinnedIndex);
        }
    }
    /**
     * @private
     * @param {?} grid
     * @param {?} target
     * @param {?} callBackFunc
     * @return {?}
     */
    scrollGrid(grid, target, callBackFunc) {
        this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
        requestAnimationFrame(() => {
            if (typeof target === 'number') {
                grid.verticalScrollContainer.addScrollTop(target);
            }
            else {
                switch (target) {
                    case 'top':
                        grid.verticalScrollContainer.scrollTo(0);
                        break;
                    case 'bottom':
                        grid.verticalScrollContainer.scrollTo(grid.dataView.length - 1);
                        break;
                    case 'next':
                        grid.verticalScrollContainer.scrollNext();
                        break;
                    case 'prev':
                        grid.verticalScrollContainer.scrollPrev();
                        break;
                }
            }
            grid.verticalScrollContainer.onChunkLoad
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(callBackFunc);
        });
    }
    /**
     * @private
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    _navigateUpInChild(rowElement, currentRowIndex, visibleColumnIndex) {
        /** @type {?} */
        const prevElem = rowElement.previousElementSibling;
        /** @type {?} */
        const scrollable = this.getNextScrollable(this.grid);
        /** @type {?} */
        const grid = scrollable.grid;
        /** @type {?} */
        const scrTop = grid.verticalScrollContainer.scrollPosition;
        /** @type {?} */
        const containerTop = scrollable.prev.nativeElement.parentNode.parentNode.parentNode.parentNode;
        /** @type {?} */
        const top = parseInt(containerTop.style.top, 10);
        if (scrTop !== 0 && top < 0) {
            this.scrollGrid(grid, -prevElem.offsetHeight, () => super.navigateUp(rowElement, { row: currentRowIndex, column: visibleColumnIndex }));
        }
        else {
            super.navigateUp(rowElement, { row: currentRowIndex, column: visibleColumnIndex });
        }
    }
    /**
     * @private
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    _navigateDownInChild(rowElement, currentRowIndex, visibleColumnIndex) {
        /** @type {?} */
        const nextElem = rowElement.nextElementSibling;
        /** @type {?} */
        const childContainer = this.grid.nativeElement.parentNode.parentNode;
        /** @type {?} */
        const diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
        /** @type {?} */
        const endIsVisible = diff < 0;
        /** @type {?} */
        const scrollable = this.getNextScrollableDown(this.grid);
        /** @type {?} */
        const grid = scrollable.grid;
        if (!endIsVisible) {
            this.scrollGrid(grid, nextElem.offsetHeight, () => super.navigateDown(rowElement, { row: currentRowIndex, column: visibleColumnIndex }));
        }
        else {
            super.navigateDown(rowElement, { row: currentRowIndex, column: visibleColumnIndex });
        }
    }
    /**
     * @private
     * @param {?} sourceElem
     * @param {?} targetTag
     * @return {?}
     */
    getClosestElemByTag(sourceElem, targetTag) {
        /** @type {?} */
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    /**
     * @protected
     * @param {?} nextIndex
     * @return {?}
     */
    getNextRowByIndex(nextIndex) {
        return this.grid.dataRowList.find(element => element.index === nextIndex).element.nativeElement;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const IgxHierarchicalTransactionServiceFactory = {
    provide: IgxGridTransaction,
    useFactory: hierarchicalTransactionServiceFactory
};
/**
 * @return {?}
 */
function hierarchicalTransactionServiceFactory() {
    return () => new IgxHierarchicalTransactionService();
}
/**
 * @abstract
 */
class IgxHierarchicalGridBaseComponent extends IgxGridBaseComponent {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} colResizingService
     * @param {?} gridAPI
     * @param {?} transactionFactory
     * @param {?} elementRef
     * @param {?} zone
     * @param {?} document
     * @param {?} cdr
     * @param {?} resolver
     * @param {?} differs
     * @param {?} viewRef
     * @param {?} navigation
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} summaryService
     * @param {?} _displayDensityOptions
     */
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        super(selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.showExpandAll = false;
        this._expandChildren = false;
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        this.dragIndicatorIconTemplate = null;
        this.hgridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @hidden
     * @return {?}
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get outlet() {
        return this.rootGrid ? this.rootGrid.outletDirective : this.outletDirective;
    }
    /**
     * @hidden
     * @param {?} cols
     * @return {?}
     */
    createColumnsList(cols) {
        /** @type {?} */
        const columns = [];
        /** @type {?} */
        const topLevelCols = this.onlyTopLevel(cols);
        topLevelCols.forEach((col) => {
            /** @type {?} */
            const ref = this._createColumn(col);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        /** @type {?} */
        const result = flatten$1(columns);
        this.columnList.reset(result);
        this.columnList.notifyOnChanges();
        this.initPinning();
    }
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    _createColumn(col) {
        /** @type {?} */
        let ref;
        if (col instanceof IgxColumnGroupComponent) {
            ref = this._createColGroupComponent(col);
        }
        else {
            ref = this._createColComponent(col);
        }
        return ref;
    }
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    _createColGroupComponent(col) {
        /** @type {?} */
        const factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
        /** @type {?} */
        const ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
        ref.changeDetectorRef.detectChanges();
        factoryGroup.inputs.forEach((input) => {
            /** @type {?} */
            const propName = input.propName;
            ((/** @type {?} */ (ref.instance)))[propName] = ((/** @type {?} */ (col)))[propName];
        });
        if (col.children.length > 0) {
            /** @type {?} */
            const newChildren = [];
            col.children.forEach(child => {
                /** @type {?} */
                const newCol = this._createColumn(child).instance;
                newCol.parent = ref.instance;
                newChildren.push(newCol);
            });
            ((/** @type {?} */ (ref.instance))).children.reset(newChildren);
            ((/** @type {?} */ (ref.instance))).children.notifyOnChanges();
        }
        // (<IgxColumnGroupComponent>ref.instance).grid = this;
        return ref;
    }
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    _createColComponent(col) {
        /** @type {?} */
        const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
        /** @type {?} */
        const ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
        factoryColumn.inputs.forEach((input) => {
            /** @type {?} */
            const propName = input.propName;
            if (!(((/** @type {?} */ (col)))[propName] instanceof IgxSummaryOperand)) {
                ((/** @type {?} */ (ref.instance)))[propName] = ((/** @type {?} */ (col)))[propName];
            }
            else {
                ((/** @type {?} */ (ref.instance)))[propName] = col[propName].constructor;
            }
        });
        // (<IgxColumnComponent>ref.instance).grid = this;
        return ref;
    }
    /**
     * @protected
     * @param {?} rowIslandID
     * @return {?}
     */
    getGridsForIsland(rowIslandID) {
        return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
    }
    /**
     * @protected
     * @param {?} path
     * @return {?}
     */
    getChildGrid(path) {
        if (!path) {
            return;
        }
        return this.hgridAPI.getChildGrid(path);
    }
}
/** @nocollapse */
IgxHierarchicalGridBaseComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxGridTransaction,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxHierarchicalGridBaseComponent.propDecorators = {
    expandChildren: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hasChildrenKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    showExpandAll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dragIndicatorIconBase: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dragIndicatorIconBase', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }]
};
/**
 * @param {?} arr
 * @return {?}
 */
function flatten$1(arr) {
    /** @type {?} */
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            result = result.concat(flatten$1(el.children.toArray()));
        }
    });
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxHierarchicalGridAPIService extends GridBaseAPIService {
    constructor() {
        super(...arguments);
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    unsetChildRowIsland(rowIsland) {
        this.childGrids.delete(rowIsland.key);
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getChildRowIsland(key) {
        return this.childRowIslands.get(key);
    }
    /**
     * @param {?} path
     * @return {?}
     */
    getChildGrid(path) {
        /** @type {?} */
        const currPath = path;
        /** @type {?} */
        let grid;
        /** @type {?} */
        const pathElem = currPath.shift();
        /** @type {?} */
        const childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
        if (childrenForLayout) {
            /** @type {?} */
            const childGrid = childrenForLayout.get(pathElem.rowID);
            if (currPath.length === 0) {
                grid = childGrid;
            }
            else {
                grid = childGrid.hgridAPI.getChildGrid(currPath);
            }
        }
        return grid;
    }
    /**
     * @param {?=} inDepth
     * @return {?}
     */
    getChildGrids(inDepth) {
        /** @type {?} */
        const allChildren = [];
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid) => {
                allChildren.push(grid);
                if (inDepth) {
                    /** @type {?} */
                    const children = grid.hgridAPI.getChildGrids(inDepth);
                    children.forEach((item) => {
                        allChildren.push(item);
                    });
                }
            });
        });
        return allChildren;
    }
    /**
     * @param {?} childGrid
     * @return {?}
     */
    getParentRowId(childGrid) {
        /** @type {?} */
        let rowID;
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid, key) => {
                if (grid === childGrid) {
                    rowID = key;
                    return;
                }
            });
        });
        return rowID;
    }
    /**
     * @param {?} parentRowID
     * @param {?} rowIslandKey
     * @param {?} grid
     * @return {?}
     */
    registerChildGrid(parentRowID, rowIslandKey, grid) {
        /** @type {?} */
        let childrenForLayout = this.childGrids.get(rowIslandKey);
        if (!childrenForLayout) {
            this.childGrids.set(rowIslandKey, new Map());
            childrenForLayout = this.childGrids.get(rowIslandKey);
        }
        childrenForLayout.set(parentRowID, grid);
    }
    /**
     * @param {?} rowIslandKey
     * @return {?}
     */
    getChildGridsForRowIsland(rowIslandKey) {
        /** @type {?} */
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        /** @type {?} */
        const children = [];
        if (childrenForLayout) {
            childrenForLayout.forEach((child) => {
                children.push(child);
            });
        }
        return children;
    }
    /**
     * @param {?} rowIslandKey
     * @param {?} rowID
     * @return {?}
     */
    getChildGridByID(rowIslandKey, rowID) {
        /** @type {?} */
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        return childrenForLayout.get(rowID);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxRowIslandAPIService {
    constructor() {
        this.change = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.state = new Map();
        this.destroyMap = new Map();
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    register(rowIsland) {
        this.state.set(rowIsland.id, rowIsland);
        this.destroyMap.set(rowIsland.id, new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    unsubscribe(rowIsland) {
        this.state.delete(rowIsland.id);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    get(id) {
        return this.state.get(id);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    unset(id) {
        this.state.delete(id);
        this.destroyMap.delete(id);
    }
    /**
     * @param {?} oldId
     * @param {?} newId
     * @return {?}
     */
    reset(oldId, newId) {
        /** @type {?} */
        const destroy = this.destroyMap.get(oldId);
        /** @type {?} */
        const rowIsland = this.get(oldId);
        this.unset(oldId);
        if (rowIsland) {
            this.state.set(newId, rowIsland);
        }
        if (destroy) {
            this.destroyMap.set(newId, destroy);
        }
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    unsetChildRowIsland(rowIsland) {
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    /**
     * @param {?} rowIslandKey
     * @return {?}
     */
    getChildRowIsland(rowIslandKey) {
        return this.childRowIslands.get(rowIslandKey);
    }
    /**
     * @param {?} parentRowID
     * @param {?} grid
     * @return {?}
     */
    registerChildGrid(parentRowID, grid) {
        this.childGrids.set(parentRowID, grid);
    }
    /**
     * @param {?=} inDepth
     * @return {?}
     */
    getChildGrids(inDepth) {
        /** @type {?} */
        let allChildren = [];
        this.childGrids.forEach((grid) => {
            allChildren.push(grid);
        });
        if (inDepth) {
            this.childRowIslands.forEach((layout) => {
                allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
            });
        }
        return allChildren;
    }
    /**
     * @param {?} rowID
     * @return {?}
     */
    getChildGridByID(rowID) {
        return this.childGrids.get(rowID);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxRowIslandComponent extends IgxHierarchicalGridBaseComponent {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} colResizingService
     * @param {?} gridAPI
     * @param {?} transactionFactory
     * @param {?} elementRef
     * @param {?} zone
     * @param {?} document
     * @param {?} cdr
     * @param {?} resolver
     * @param {?} differs
     * @param {?} viewRef
     * @param {?} navigation
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} summaryService
     * @param {?} _displayDensityOptions
     * @param {?} rowIslandAPI
     */
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI) {
        super(selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.rowIslandAPI = rowIslandAPI;
        /**
         * @hidden
         */
        this.children = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */
        this.childColumns = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */
        this.onLayoutChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event emmited when a grid is being created based on this row island.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * \@memberof IgxRowIslandComponent
         */
        this.onGridCreated = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.initialChanges = [];
        /**
         * @hidden
         */
        this.rootGrid = null;
        this.layout_id = `igx-row-island-`;
        this.isInit = false;
        this.hgridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
     *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
     *          <!-- ... -->
     *      </igx-row-island>
     * </igx-hierarchical-grid>
     * ```
     * \@memberof IgxRowIslandComponent
     * @param {?} value
     * @return {?}
     */
    set expandChildren(value) {
        this._expandChildren = value;
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            if (document.body.contains(grid.nativeElement)) {
                // Detect changes right away if the grid is visible
                grid.expandChildren = value;
                grid.markForCheck();
            }
            else {
                // Else defer the detection on changes when the grid gets into view for performance.
                grid.updateOnRender = true;
            }
        });
    }
    /**
     * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
     * ```typescript
     * const expanded = this.rowIsland.expandChildren;
     * ```
     * \@memberof IgxRowIslandComponent
     * @return {?}
     */
    get expandChildren() {
        return this._expandChildren;
    }
    /**
     * @hidden
     * @return {?}
     */
    get id() {
        /** @type {?} */
        const pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
        return this.layout_id + pId + this.key;
    }
    /**
     * @hidden
     * @return {?}
     */
    get parentId() {
        return this.parentIsland ? this.parentIsland.id : null;
    }
    /**
     * @hidden
     * @return {?}
     */
    get level() {
        /** @type {?} */
        let ptr = this.parentIsland;
        /** @type {?} */
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parentIsland;
        }
        return lvl + 1;
    }
    /**
     * Get transactions service for the children grid components.
     * \@experimental \@hidden
     * @return {?}
     */
    get transactions() {
        /** @type {?} */
        const grids = this.rowIslandAPI.getChildGrids();
        return grids.length ? grids[0].transactions : this._transactions;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.rootGrid = this.hgridAPI.grid;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateChildren();
        this.children.notifyOnChanges();
        this.children.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$))
            .subscribe((change) => {
            this.updateChildren();
            // update existing grids since their child ri have been changed.
            this.getGridsForIsland(this.key).forEach(grid => {
                ((/** @type {?} */ (grid))).onRowIslandChange(this.children);
            });
        });
        /** @type {?} */
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        /** @type {?} */
        const colsArray = [].concat.apply([], nestedColumns);
        /** @type {?} */
        const topCols = this.columnList.filter((item) => {
            return colsArray.indexOf(item) === -1;
        });
        this.childColumns.reset(topCols);
        this.columnList.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => { this.updateColumnList(); });
    }
    /**
     * @protected
     * @return {?}
     */
    updateChildren() {
        this.children.reset(this.children.toArray().slice(1));
        this.children.forEach(child => {
            child.parentIsland = this;
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.rowIslandAPI.register(this);
        if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.registerChildRowIsland(this);
        }
        this._init = false;
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.onLayoutChange.emit(changes);
        if (!this.isInit) {
            this.initialChanges.push(changes);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        // Override the base destroy because we don't have rendered anything to use removeEventListener on
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        this.rowIslandAPI.unset(this.id);
        if (this.parentIsland) {
            this.getGridsForIsland(this.key).forEach(grid => {
                this.cleanGridState(grid);
                grid.hgridAPI.unsetChildRowIsland(this);
            });
            this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.unsetChildRowIsland(this);
            this.cleanGridState(this.rootGrid);
        }
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    cleanGridState(grid) {
        grid.childGridTemplates.forEach((tmpl) => {
            tmpl.owner.cleanView(tmpl.context.templateID);
        });
        grid.childGridTemplates.clear();
        grid.onRowIslandChange();
    }
    /**
     * @hidden
     * @return {?}
     */
    reflow() { }
    /**
     * @hidden
     * @return {?}
     */
    calculateGridHeight() { }
    /**
     * @protected
     * @return {?}
     */
    updateColumnList() {
        /** @type {?} */
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        /** @type {?} */
        const colsArray = [].concat.apply([], nestedColumns);
        /** @type {?} */
        const topCols = this.columnList.filter((item) => {
            if (colsArray.indexOf(item) === -1) {
                /* Reset the default width of the columns that come into this row island,
                because the root catches them first during the detectChanges() and sets their defaultWidth. */
                item.defaultWidth = undefined;
                return true;
            }
            return false;
        });
        this.childColumns.reset(topCols);
        if (this.parentIsland) {
            this.parentIsland.columnList.notifyOnChanges();
        }
        else {
            this.rootGrid.columnList.notifyOnChanges();
        }
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            grid.createColumnsList(this.childColumns.toArray());
            if (!document.body.contains(grid.nativeElement)) {
                grid.updateOnRender = true;
            }
        });
    }
}
IgxRowIslandComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                selector: 'igx-row-island',
                template: ``,
                providers: [IgxRowIslandAPIService]
            }] }
];
/** @nocollapse */
IgxRowIslandComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxGridTransaction,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] },
    { type: IgxRowIslandAPIService }
];
IgxRowIslandComponent.propDecorators = {
    key: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    expandChildren: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    children: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
    childColumns: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false },] }],
    onLayoutChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onGridCreated: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxChildGridRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} element
     * @param {?} resolver
     * @param {?} cdr
     */
    constructor(gridAPI, element, resolver, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.role = 'row';
        this.resolver = resolver;
    }
    /**
     * @hidden
     * @return {?}
     */
    get parentHasScroll() {
        return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     * @return {?}
     */
    // TODO: Refactor
    get parentGrid() {
        return this.gridAPI.grid;
    }
    /**
     * @return {?}
     */
    get level() {
        return this.layout.level;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.layout.onLayoutChange.subscribe((ch) => {
            this._handleLayoutChanges(ch);
        });
        /** @type {?} */
        const changes = this.layout.initialChanges;
        changes.forEach(change => {
            this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        // handler logic that re-emits hgrid events on the row island
        this.setupEventEmitters();
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.hGrid.childLayoutList = this.layout.children;
        if (this.layout.childColumns.length > 0 && !this.hGrid.autoGenerate) {
            this.hGrid.createColumnsList(this.layout.childColumns.toArray());
        }
        /** @type {?} */
        const layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach((l) => this.hGrid.hgridAPI.registerChildRowIsland(l));
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.hGrid.cdr.detectChanges();
    }
    /**
     * @private
     * @return {?}
     */
    setupEventEmitters() {
        /** @type {?} */
        const destructor = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.hGrid.destroy$);
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(IgxGridComponent);
        // exclude outputs related to two-way binding functionality
        /** @type {?} */
        const inputNames = factory.inputs.map(input => input.propName);
        /** @type {?} */
        const outputs = factory.outputs.filter(o => {
            /** @type {?} */
            const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
        });
        outputs.forEach(output => {
            if (this.hGrid[output.propName]) {
                this.hGrid[output.propName].pipe(destructor).subscribe((args) => {
                    args.owner = this.hGrid;
                    this.layout[output.propName].emit(args);
                });
            }
        });
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    _handleLayoutChanges(changes) {
        for (const change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    }
}
IgxChildGridRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-child-grid-row',
                template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxChildGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxChildGridRowComponent.propDecorators = {
    layout: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    parentGridID: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    rowData: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hGrid: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['hgrid', { static: true },] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    level: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.data-level',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$o = 0;
class IgxHierarchicalGridComponent extends IgxHierarchicalGridBaseComponent {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} colResizingService
     * @param {?} gridAPI
     * @param {?} transactionFactory
     * @param {?} elementRef
     * @param {?} zone
     * @param {?} document
     * @param {?} cdr
     * @param {?} resolver
     * @param {?} differs
     * @param {?} viewRef
     * @param {?} navigation
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} summaryService
     * @param {?} _displayDensityOptions
     */
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        super(selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         */
        this.hierarchicalStateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.childLayoutKeys = [];
        /**
         * @hidden
         */
        this.highlightedRowID = null;
        /**
         * @hidden
         */
        this.updateOnRender = false;
        /**
         * @hidden
         */
        this.parent = null;
        this._hierarchicalState = [];
        this._filteredData = null;
        this.h_id = `igx-hierarchical-grid-${NEXT_ID$o++}`;
        this.childGridTemplates = new Map();
        this.scrollTop = 0;
        this.scrollLeft = 0;
        this.hgridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * Sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    get id() {
        return this.h_id;
    }
    /**
     * An \@Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
            this.reflow();
        }
        this.cdr.markForCheck();
        if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
            // If the height will change based on how much data there is, recalculate sizes in igxForOf.
            this.notifyChanges(true);
        }
    }
    /**
     * Returns an array of data set to the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * Sets the state of the `IgxHierarchicalGridComponent` containing which rows are expanded.
     * ```typescript
     * this.gridState = [{ rowID: 1 }, { rowID: 4}];
     * ```
     * ```html
     * <igx-hierarchical-grid [primaryKey]="'ID'" [data]="Data" [autoGenerate]="false" [hierarchicalState]="hgridState">
     *      <igx-column field="ID"  [dataType]='number'></igx-column>
     *      <igx-column field="Product"  [dataType]='string'></igx-column>
     *      <igx-column field="Description"  [dataType]='string'></igx-column>
     * </igx-hierarchical-grid>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-hierarchical-grid [primaryKey]="'ID'" [data]="Data" [autoGenerate]="false" [(hierarchicalState)]="hgridState">
     *      <igx-column field="ID"  [dataType]='number'></igx-column>
     *      <igx-column field="Product"  [dataType]='string'></igx-column>
     *      <igx-column field="Description"  [dataType]='string'></igx-column>
     * </igx-hierarchical-grid>
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    get hierarchicalState() {
        return this._hierarchicalState;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set hierarchicalState(val) {
        if (this._hierarchicalState !== val) {
            this.hierarchicalStateChange.emit(val);
        }
        if (this.hasChildrenKey) {
            val = val.filter(item => {
                /** @type {?} */
                const rec = this.primaryKey ? this.data.find(x => x[this.primaryKey] === item.rowID) : item.rowID;
                return rec[this.hasChildrenKey];
            });
        }
        this._hierarchicalState = val;
        if (this.parent) {
            this.notifyChanges(true);
        }
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @param {?} value
     * @return {?}
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
     * Defult value is false.
     * ```html
     * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @param {?} value
     * @return {?}
     */
    set expandChildren(value) {
        this._expandChildren = value;
        if (value && this.data) {
            this.hierarchicalState = this.data.map((rec) => {
                return { rowID: this.primaryKey ? rec[this.primaryKey] : rec };
            });
        }
        else if (this.data) {
            this.hierarchicalState = [];
        }
    }
    /**
     * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
     * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
     * ```typescript
     * const expanded = this.grid.expandChildren;
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    get expandChildren() {
        return this._expandChildren;
    }
    /**
     * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
     * parent grid is set or an object reference of the parent record otherwise.
     * ```typescript
     * const foreignKey = this.grid.foreignKey;
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    get foreignKey() {
        if (!this.parent) {
            return null;
        }
        return this.parent.hgridAPI.getParentRowId(this);
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasExpandableChildren() {
        return !!this.childLayoutKeys.length;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._transactions = this.parentIsland ? this.parentIsland.transactions : this._transactions;
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._cdrRequestRepaint && !this._init) {
            this.updateSizes();
        }
        super.ngDoCheck();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
        this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
        if (this.expandChildren && this.data && this.hierarchicalState.length !== this.data.length) {
            this.hierarchicalState = this.data.map((rec) => {
                return { rowID: this.primaryKey ? rec[this.primaryKey] : rec };
            });
            this.cdr.detectChanges();
        }
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe((view) => {
            /** @type {?} */
            const rowData = view.context.$implicit;
            if (this.isChildGridRecord(rowData)) {
                /** @type {?} */
                const cachedData = this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    /** @type {?} */
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
        if (this.parent) {
            this._displayDensity = this.rootGrid._displayDensity;
            this.rootGrid.onDensityChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(() => {
                this._displayDensity = this.rootGrid._displayDensity;
                this.notifyChanges(true);
                this.cdr.markForCheck();
            });
            this.childLayoutKeys = this.parentIsland.children.map((item) => item.key);
        }
        this.toolbarCustomContentTemplates = this.parentIsland ?
            this.parentIsland.toolbarCustomContentTemplates :
            this.toolbarCustomContentTemplates;
        this.headSelectorsTemplates = this.parentIsland ?
            this.parentIsland.headSelectorsTemplates :
            this.headSelectorsTemplates;
        this.rowSelectorsTemplates = this.parentIsland ?
            this.parentIsland.rowSelectorsTemplates :
            this.rowSelectorsTemplates;
        this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
        this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
        this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
        this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
        this.hasChildrenKey = this.parentIsland ?
            this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey :
            this.rootGrid.hasChildrenKey;
        this.showExpandAll = this.parentIsland ?
            this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
    }
    /**
     * @private
     * @return {?}
     */
    updateSizes() {
        if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
            this.reflow();
            this.hgridAPI.getChildGrids(false).forEach((grid) => {
                grid.updateSizes();
            });
        }
    }
    /**
     * @protected
     * @param {?} renderedHeight
     * @return {?}
     */
    _shouldAutoSize(renderedHeight) {
        if (this.isPercentHeight && this.parent) {
            return true;
        }
        return super._shouldAutoSize(renderedHeight);
    }
    /**
     * @return {?}
     */
    get outletDirective() {
        return this.rootGrid._outletDirective;
    }
    /**
     * @hidden
     * @return {?}
     */
    get parentRowOutletDirective() {
        return this === this.rootGrid ? null : this.rootGrid.rowEditingOutletDirective;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateColumnList(false);
        this.childLayoutKeys = this.parent ?
            this.parentIsland.children.map((item) => item.key) :
            this.childLayoutKeys = this.childLayoutList.map((item) => item.key);
        this.childLayoutList.notifyOnChanges();
        this.childLayoutList.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$))
            .subscribe(() => this.onRowIslandChange());
        super.ngAfterContentInit();
    }
    /**
     * @hidden
     * @return {?}
     */
    onRowIslandChange() {
        if (this.parent) {
            this.childLayoutKeys = this.parentIsland.children.filter(item => !((/** @type {?} */ (item)))._destroyed).map((item) => item.key);
        }
        else {
            this.childLayoutKeys = this.childLayoutList.filter(item => !((/** @type {?} */ (item)))._destroyed).map((item) => item.key);
        }
        if (!((/** @type {?} */ (this.cdr))).destroyed) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @protected
     * @param {?} change
     * @return {?}
     */
    onColumnsChanged(change) {
        this.updateColumnList();
        /** @type {?} */
        const cols = change.filter(c => c.gridAPI.grid === this);
        if (cols.length > 0) {
            this.columnList.reset(cols);
            super.onColumnsChanged(this.columnList);
        }
    }
    /**
     * @private
     * @param {?=} recalcColSizes
     * @return {?}
     */
    updateColumnList(recalcColSizes = true) {
        /** @type {?} */
        const childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
        /** @type {?} */
        const nestedColumns = childLayouts.map((layout) => {
            return layout.columnList.toArray();
        });
        /** @type {?} */
        const colsArray = [].concat.apply([], nestedColumns);
        /** @type {?} */
        const colLength = this.columnList.length;
        if (colsArray.length > 0) {
            /** @type {?} */
            const topCols = this.columnList.filter((item) => {
                return colsArray.indexOf(item) === -1;
            });
            this.columnList.reset(topCols);
            if (recalcColSizes && this.columnList.length !== colLength) {
                this.calculateGridSizes();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (!this.parent) {
            this.hgridAPI.getChildGrids(true).forEach((grid) => {
                if (!grid.childRow.cdr.destroyed) {
                    grid.childRow.cdr.destroy();
                }
            });
        }
        if (this.parent && this.selectionService.activeElement) {
            // in case selection is in destroyed child grid, selection should be cleared.
            this._clearSeletionHighlights();
        }
        super.ngOnDestroy();
    }
    /**
     * @private
     * @return {?}
     */
    _clearSeletionHighlights() {
        [this.rootGrid, ...this.rootGrid.getChildGrids(true)].forEach(grid => {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    getFeatureColumnsWidth() {
        /** @type {?} */
        let width = super.getFeatureColumnsWidth();
        if (this.hasExpandableChildren) {
            width += this.headerHierarchyExpander.nativeElement.offsetWidth || this.getDefaultExpanderWidth();
        }
        return width;
    }
    /**
     * @private
     * @return {?}
     */
    getDefaultExpanderWidth() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 57;
            case DisplayDensity.compact:
                return 49;
            default:
                return 72;
        }
    }
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    isRowHighlighted(rowData) {
        return this.highlightedRowID === rowData.rowID;
    }
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    isHierarchicalRecord(record) {
        return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
    }
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    isChildGridRecord(record) {
        // Can be null when there is defined layout but no child data was found
        return record.childGridsData !== undefined;
    }
    /**
     * @hidden
     * @param {?} index
     * @param {?} rec
     * @return {?}
     */
    trackChanges(index, rec) {
        if (rec.childGridsData !== undefined) {
            // if is child rec
            return rec.rowID;
        }
        return rec;
    }
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    getContext(rowData) {
        if (this.isChildGridRecord(rowData)) {
            /** @type {?} */
            const cachedData = this.childGridTemplates.get(rowData.rowID);
            if (cachedData) {
                /** @type {?} */
                const view = cachedData.view;
                /** @type {?} */
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData)
                };
            }
            else {
                /** @type {?} */
                const rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData,
                    templateID: 'childRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        else {
            return {
                $implicit: rowData,
                templateID: 'dataRow',
                index: this.dataView.indexOf(rowData)
            };
        }
    }
    /**
     * @hidden
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    get rootGrid() {
        /** @type {?} */
        let currGrid = (/** @type {?} */ (this));
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconTemplate() {
        /** @type {?} */
        const expanded = this.hierarchicalState.length > 0 && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
        else {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - hierarchical grid should not allow column layouts
            // remove column layouts
            /** @type {?} */
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     * @return {?}
     */
    getVisibleContentHeight() {
        /** @type {?} */
        let height = super.getVisibleContentHeight();
        if (this.parent) {
            /** @type {?} */
            const rootHeight = this.rootGrid.getVisibleContentHeight();
            /** @type {?} */
            const topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
            height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
        }
        return height;
    }
    /**
     * @hidden
     * @return {?}
     */
    toggleAll() {
        /** @type {?} */
        const expanded = this.hierarchicalState.length > 0 && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            this.expandAll();
        }
        else {
            this.collapseAll();
        }
    }
    /**
     * Collapses all rows of the current hierarchical grid.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    collapseAll() {
        this.hierarchicalState = [];
    }
    /**
     * Expands all rows of the current hierarchical grid.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxHierarchicalGridComponent
     * @return {?}
     */
    expandAll() {
        if (this.data) {
            this.hierarchicalState = this.data.map((rec) => {
                return { rowID: this.primaryKey ? rec[this.primaryKey] : rec };
            });
        }
    }
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    isExpanded(record) {
        /** @type {?} */
        let inState;
        if (record.childGridsData !== undefined) {
            inState = !!this.hierarchicalState.find(v => v.rowID === record.rowID);
        }
        else {
            inState = !!this.hierarchicalState.find(v => {
                return this.primaryKey ? v.rowID === record[this.primaryKey] : v.rowID === record;
            });
        }
        return inState && this.childLayoutList.length !== 0;
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    viewCreatedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            /** @type {?} */
            const key = args.context.$implicit.rowID;
            this.childGridTemplates.set(key, args);
        }
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    viewMovedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            // view was moved, update owner in cache
            /** @type {?} */
            const key = args.context.$implicit.rowID;
            /** @type {?} */
            const cachedData = this.childGridTemplates.get(key);
            cachedData.owner = args.owner;
            this.childLayoutList.forEach((layout) => {
                /** @type {?} */
                const relatedGrid = this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                if (relatedGrid && relatedGrid.updateOnRender) {
                    // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                    relatedGrid.notifyChanges(true);
                    relatedGrid.updateOnRender = false;
                }
            });
            /** @type {?} */
            const childGrids = this.getChildGrids(true);
            childGrids.forEach((grid) => {
                if (grid.isPercentWidth) {
                    grid.notifyChanges(true);
                }
                grid.updateScrollPosition();
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    updateScrollPosition() {
        /** @type {?} */
        const vScr = this.verticalScrollContainer.getScroll();
        /** @type {?} */
        const hScr = this.headerContainer.getScroll();
        if (vScr) {
            vScr.scrollTop = this.scrollTop;
        }
        if (hScr) {
            hScr.scrollLeft = this.scrollLeft;
        }
    }
    /**
     * @protected
     * @param {?=} inDeph
     * @return {?}
     */
    getChildGrids(inDeph) {
        return this.hgridAPI.getChildGrids(inDeph);
    }
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    generateDataFields(data) {
        return super.generateDataFields(data).filter((field) => {
            /** @type {?} */
            const layoutsList = this.parentIsland ? this.parentIsland.children : this.childLayoutList;
            /** @type {?} */
            const keys = layoutsList.map((item) => item.key);
            return keys.indexOf(field) === -1;
        });
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    hg_verticalScrollHandler(event) {
        this.scrollTop = event.target.scrollTop;
    }
    /**
     * @return {?}
     */
    onContainerScroll() {
        this.hideOverlays();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    hg_horizontalScrollHandler(event) {
        this.scrollLeft = event.target.scrollLeft;
    }
}
IgxHierarchicalGridComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid',
                template: "<igx-grid-toolbar role=\"rowgroup\" [style.flex-basis.px]=\"outerWidth\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n                <div #headerHierarchyExpander (click)=\"toggleAll()\" [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                    'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header': hasExpandableChildren,\n                    'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                    'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n                }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" role=\"rowgroup\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:hierarchicalState:id:primaryKey:childLayoutKeys:pipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData)' (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)'></ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow:auto;width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                    [rowData]=\"rowData\" [layout]='layout' #row>\n                </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" fontSet=\"material\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [isActive]='hierarchicalState.length > 0 && hasExpandableChildren' [isActive]='true' fontSet=\"material\">unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                    { provide: IgxGridBaseComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxHierarchicalGridComponent) },
                    IgxGridSummaryService,
                    IgxFilteringService,
                    IgxHierarchicalGridNavigationService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ]
            }] }
];
/** @nocollapse */
IgxHierarchicalGridComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxGridTransaction,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"],] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [DisplayDensityToken,] }] }
];
IgxHierarchicalGridComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hierarchicalState: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    hierarchicalStateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    expandChildren: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    childLayoutList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
    allLayoutList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true },] }],
    hierarchicalRecordTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['hierarchical_record_template', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    childTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['child_record_template', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    headerHierarchyExpander: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['headerHierarchyExpander', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: true },] }],
    templateOutlets: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
    hierarchicalRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxHierarchicalGridCellComponent extends IgxGridCellComponent {
    /**
     * @param {?} selectionService
     * @param {?} crudService
     * @param {?} gridAPI
     * @param {?} cdr
     * @param {?} helement
     * @param {?} zone
     * @param {?} touchManager
     * @param {?} platformUtil
     */
    constructor(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.helement = helement;
        this.zone = zone;
        this.platformUtil = platformUtil;
        // this.hSelection = <IgxHierarchicalSelectionAPIService>selection;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this._rootGrid = this._getRootGrid();
    }
    /**
     * @private
     * @return {?}
     */
    _getRootGrid() {
        /** @type {?} */
        let currGrid = this.grid;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    // TODO: Extend the new selection service to avoid complete traversal
    /**
     * @return {?}
     */
    _clearAllHighlights() {
        [this._rootGrid, ...this._rootGrid.getChildGrids(true)].forEach(grid => {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this._clearAllHighlights();
        /** @type {?} */
        const currentElement = this.grid.nativeElement;
        /** @type {?} */
        let parentGrid = this.grid;
        /** @type {?} */
        let childGrid;
        // add highligh to the current grid
        if (this._rootGrid.id !== currentElement.id) {
            currentElement.classList.add('igx-grid__tr--highlighted');
        }
        // add highligh to the current grid
        while (this._rootGrid.id !== parentGrid.id) {
            childGrid = parentGrid;
            parentGrid = parentGrid.parent;
            /** @type {?} */
            const parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
            parentGrid.highlightedRowID = parentRowID;
        }
        super.onFocus(event);
    }
    // TODO: Refactor
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    dispatchEvent(event) {
        /** @type {?} */
        const key = event.key.toLowerCase();
        if (event.altKey && !this.row.added) {
            /** @type {?} */
            const grid = this.gridAPI.grid;
            /** @type {?} */
            const state = this.gridAPI.grid.hierarchicalState;
            /** @type {?} */
            const collapse = this.row.expanded && (key === 'left' || key === 'arrowleft' || key === 'up' || key === 'arrowup');
            /** @type {?} */
            const expand = !this.row.expanded && (key === 'right' || key === 'arrowright' || key === 'down' || key === 'arrowdown');
            if (collapse) {
                grid.hierarchicalState = state.filter(v => {
                    return v.rowID !== this.row.rowID;
                });
            }
            else if (expand) {
                state.push({ rowID: this.row.rowID });
                grid.hierarchicalState = [...state];
            }
            if (expand || collapse) {
                /** @type {?} */
                const rowID = this.cellID.rowID;
                grid.cdr.detectChanges();
                this.persistFocusedCell(rowID);
            }
            return;
        }
        super.dispatchEvent(event);
    }
    /**
     * @protected
     * @param {?} rowID
     * @return {?}
     */
    persistFocusedCell(rowID) {
        requestAnimationFrame(() => {
            // TODO: Test it out
            /** @type {?} */
            const cell = this.gridAPI.get_cell_by_key(rowID, this.column.field);
            if (cell) {
                cell.nativeElement.focus();
            }
        });
    }
}
IgxHierarchicalGridCellComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
                providers: [HammerGesturesManager]
            }] }
];
/** @nocollapse */
IgxHierarchicalGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxHierarchicalGridCellComponent.propDecorators = {
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus', ['$event'],] }],
    dispatchEvent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxHierarchicalRowComponent extends IgxRowComponent {
    constructor() {
        super(...arguments);
        /**
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         * \@internal
         */
        this.select = () => {
            this.grid.selectRows([this.rowID]);
        };
        /**
         * @hidden
         * \@internal
         */
        this.deselect = () => {
            this.grid.deselectRows([this.rowID]);
        };
    }
    /**
     * @return {?}
     */
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * Returns whether the row is expanded.
     * ```typescript
     * const RowExpanded = this.grid1.rowList.first.expanded;
     * ```
     * @return {?}
     */
    get expanded() {
        return this.grid.isExpanded(this.rowData);
    }
    /**
     * @return {?}
     */
    get hasChildren() {
        return !!this.grid.childLayoutKeys.length;
    }
    /**
     * @hidden
     * @return {?}
     */
    get highlighted() {
        return this.grid && this.grid.highlightedRowID === this.rowID;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    expanderClick(event) {
        event.stopPropagation();
        this.toggle();
    }
    /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    toggle() {
        if (this.added) {
            return;
        }
        /** @type {?} */
        const grid = this.gridAPI.grid;
        this.endEdit(grid.rootGrid);
        /** @type {?} */
        const state = this.gridAPI.grid.hierarchicalState;
        if (!this.expanded) {
            state.push({ rowID: this.rowID });
            grid.hierarchicalState = [...state];
        }
        else {
            grid.hierarchicalState = state.filter(v => {
                return v.rowID !== this.rowID;
            });
        }
        grid.cdr.detectChanges();
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconTemplate() {
        /** @type {?} */
        let expandable = true;
        if (this.grid.hasChildrenKey) {
            expandable = this.rowData[this.grid.hasChildrenKey];
        }
        if (!expandable) {
            return this.defaultEmptyTemplate;
        }
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    endEdit(grid) {
        if (grid.crudService.inEditMode) {
            grid.endEdit();
        }
        grid.hgridAPI.getChildGrids(true).forEach(g => {
            if (g.crudService.inEditMode) {
                g.endEdit();
            }
        });
    }
}
IgxHierarchicalRowComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid-row',
                template: "<div (click)=\"expanderClick($event)\" class=\"igx-grid__hierarchical-expander\" [tabIndex]=\"tabindex\" *ngIf=\"hasChildren\" #expander>\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n</div>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">chevron_right</igx-icon>\n </ng-template>\n\n <ng-template #defaultEmptyTemplate>\n    <igx-icon fontSet=\"material\"></igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: {\n                            index: viewIndex,\n                            rowID: rowID,\n                            selected: selected,\n                            select: select,\n                            deselect: deselect }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width.px]=\"col.width\"\n        [style.flex-basis.px]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [cellSelectionMode]=\"grid.cellSelection\">\n    </igx-hierarchical-grid-cell>\n</ng-container>\n\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-hierarchical-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width.px]=\"col.width\"\n        [style.flex-basis.px]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [cellSelectionMode]=\"grid.cellSelection\">\n    </igx-hierarchical-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            disableRipple=\"true\"\n            [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
                providers: [{ provide: IgxRowComponent, useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxHierarchicalRowComponent) }]
            }] }
];
IgxHierarchicalRowComponent.propDecorators = {
    cells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxHierarchicalGridCellComponent), { read: IgxHierarchicalGridCellComponent },] }],
    expander: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['expander', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    defaultExpandedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultExpandedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultEmptyTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultEmptyTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    defaultCollapsedTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultCollapsedTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__tr--expanded',] }],
    highlighted: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-grid__tr--highlighted',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxGridHierarchicalPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} state
     * @param {?=} id
     * @param {?=} primaryKey
     * @param {?=} childKeys
     * @param {?=} pipeTrigger
     * @return {?}
     */
    transform(collection, state = [], id, primaryKey, childKeys, pipeTrigger) {
        if (childKeys.length === 0) {
            return collection;
        }
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
        return result;
    }
    /**
     * @template T
     * @param {?} grid
     * @param {?} data
     * @param {?} state
     * @param {?} primaryKey
     * @param {?} childKeys
     * @return {?}
     */
    addHierarchy(grid, data, state, primaryKey, childKeys) {
        /** @type {?} */
        const result = [];
        data.forEach((v) => {
            result.push(v);
            /** @type {?} */
            const childGridsData = {};
            childKeys.forEach((childKey) => {
                /** @type {?} */
                const childData = v[childKey] ? v[childKey] : null;
                childGridsData[childKey] = childData;
            });
            if (grid.isExpanded(v)) {
                result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData: childGridsData });
            }
        });
        return result;
    }
}
IgxGridHierarchicalPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridHierarchical',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridHierarchicalPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridHierarchicalPagingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging) {
            return collection;
        }
        /** @type {?} */
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        /** @type {?} */
        const result = DataUtil.page(cloneArray(collection), state);
        this.gridAPI.grid.pagingState = state;
        return result;
    }
}
IgxGridHierarchicalPagingPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{
                name: 'gridHierarchicalPaging',
                pure: true
            },] }
];
/** @nocollapse */
IgxGridHierarchicalPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxHierarchicalGridModule {
}
IgxHierarchicalGridModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxGridHierarchicalPipe,
                    IgxGridHierarchicalPagingPipe
                ],
                exports: [
                    IgxGridModule,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                    IgxChipsModule,
                    IgxGridModule,
                    IgxSelectModule
                ],
                providers: [
                    IgxRowIslandAPIService
                ],
                entryComponents: [
                    IgxGridComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
 */
class IgxActionIconDirective {
}
IgxActionIconDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-action-icon'
            },] }
];
/** @type {?} */
let NEXT_ID$p = 0;
/**
 * **Ignite UI for Angular Navbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
 *
 * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
 * state such as a "Go Back" button. It also supports other actions represented by icons.
 *
 * Example:
 * ```html
 * <igx-navbar title="Sample App" actionButtonIcon="menu">
 *   <igx-icon>search</igx-icon>
 *   <igx-icon>favorite</igx-icon>
 *   <igx-icon>more_vert</igx-icon>
 * </igx-navbar>
 * ```
 */
class IgxNavbarComponent {
    constructor() {
        this.isVisible = true;
        /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.id = `igx-navbar-${NEXT_ID$p++}`;
        /**
         * The event that will be thrown when the action is executed,
         * provides reference to the `IgxNavbar` component as argument
         * ```typescript
         * public actionExc(event){
         *    alert("Action Execute!");
         * }
         * //..
         * ```
         * ```html
         * <igx-navbar (onAction)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.onAction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
         * ```html
         * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.titleId = `igx-navbar-${IgxNavbarComponent.NEXT_ID++}`;
    }
    /**
     * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
     * ```typescript
     * \@ViewChild("MyChild")
     * public navBar: IgxNavbarComponent;
     * ngAfterViewInit(){
     *    let actionButtonVisibile = this.navBar.isActionButtonVisible;
     * }
     * ```
     * @return {?}
     */
    get isActionButtonVisible() {
        if (this.actionIconTemplate || !this.actionButtonIcon) {
            return false;
        }
        return this.isVisible;
    }
    /**
     * Sets whether the action button of the `IgxNavbarComponent` is visible.
     * ```html
     * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
     * ```
     * @param {?} value
     * @return {?}
     */
    set isActionButtonVisible(value) {
        this.isVisible = value;
    }
    /**
     * @hidden
     * @return {?}
     */
    _triggerAction() {
        this.onAction.emit(this);
    }
}
IgxNavbarComponent.NEXT_ID = 1;
IgxNavbarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-navbar',
                template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon (click)=\"_triggerAction()\" fontSet=\"material\" *ngIf=\"isActionButtonVisible\">{{actionButtonIcon}}</igx-icon>\n        <ng-content select=\"igx-action-icon\"></ng-content>\n        <h1 class=\"igx-navbar__title\" [attr.id]=\"titleId\">{{ title }}</h1>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
IgxNavbarComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isActionButtonVisible: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    actionButtonIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    title: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onAction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    titleId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    actionIconTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxActionIconDirective, { read: IgxActionIconDirective, static: false },] }]
};
/**
 * @hidden
 */
class IgxNavbarModule {
}
IgxNavbarModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxNavbarComponent, IgxActionIconDirective],
                exports: [IgxNavbarComponent, IgxActionIconDirective],
                imports: [IgxButtonModule, IgxIconModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxNavDrawerItemDirective {
    constructor() {
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.isHeader = false;
        /**
         * @hidden
         */
        this.activeClass = 'igx-nav-drawer__item--active';
    }
    /**
     * @hidden
     * @return {?}
     */
    get defaultCSS() {
        return !this.active && !this.isHeader;
    }
    /**
     * @hidden
     * @return {?}
     */
    get currentCSS() {
        return this.active && !this.isHeader;
    }
    /**
     * @hidden
     * @return {?}
     */
    get headerCSS() {
        return this.isHeader;
    }
}
IgxNavDrawerItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDrawerItem]',
                exportAs: 'igxDrawerItem'
            },] }
];
IgxNavDrawerItemDirective.propDecorators = {
    active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['active',] }],
    isHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['isHeader',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-nav-drawer__item',] }],
    currentCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-nav-drawer__item--active',] }],
    headerCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-nav-drawer__item--header',] }]
};
class IgxNavDrawerTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxNavDrawerTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDrawer]'
            },] }
];
/** @nocollapse */
IgxNavDrawerTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
class IgxNavDrawerMiniTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxNavDrawerMiniTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxDrawerMini]'
            },] }
];
/** @nocollapse */
IgxNavDrawerMiniTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$q = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
class IgxNavigationDrawerComponent {
    /**
     * @param {?} elementRef
     * @param {?} _state
     * @param {?} renderer
     * @param {?} _touchManager
     * @param {?} platformUtil
     */
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        this.cssClass = 'igx-nav-drawer';
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID$q++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"](true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            /** @type {?} */
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            /** @type {?} */
            let deltaX;
            /** @type {?} */
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            /** @type {?} */
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.setElementClass(this.overlay, 'panning', true);
                this.renderer.setElementClass(this.drawer, 'panning', true);
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            /** @type {?} */
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            /** @type {?} */
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            /** @type {?} */
            let visibleWidth;
            /** @type {?} */
            let newX;
            /** @type {?} */
            let percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                /** @type {?} */
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                /** @type {?} */
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     * @param {?} v
     * @return {?}
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     * @return {?}
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /**
     * @hidden
     * @return {?}
     */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     * @return {?}
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     * @return {?}
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     * @return {?}
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     * @return {?}
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @return {?}
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     * @return {?}
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     * @return {?}
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     * @protected
     * @param {?} value
     * @return {?}
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @protected
     * @param {?=} mini
     * @return {?}
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, true);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, false);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                }
                return this._widthCache.width;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     * @private
     * @param {?} width
     * @return {?}
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setElementStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setElementStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     * @private
     * @return {?}
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    /**
     * @private
     * @return {?}
     */
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(window, 'resize').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateEdgeZone() {
        /** @type {?} */
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, 'panning', false);
        this.renderer.setElementClass(this.drawer, 'panning', false);
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @private
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setElementStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                /** @type {?} */
                const transform = x ? 'translate3d(' + x + 'px,0,0)' : '';
                this.renderer.setElementStyle(this.drawer, 'transform', transform);
                this.renderer.setElementStyle(this.drawer, '-webkit-transform', transform);
            }
            if (opacity !== undefined) {
                this.renderer.setElementStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            }] }
];
/** @nocollapse */
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],] }] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer"] },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxNavigationDrawerComponent.propDecorators = {
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    enableGestures: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isOpenChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    pin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pinThreshold: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    miniWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    pinChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    opening: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    closing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    miniTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective, static: false },] }],
    contentTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective, static: false },] }],
    flexWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.flexBasis',] }],
    isPinnedRight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['style.order',] }],
    _drawer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['aside', { static: true },] }],
    _overlay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['overlay', { static: true },] }],
    _styleDummy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dummy', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxNavigationDrawerModule {
}
IgxNavigationDrawerModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                exports: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Template directive that allows you to set a custom template representing the lower label value of the {\@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * \@context {\@link IgxSliderComponent.context}
 */
class IgxThumbFromTemplateDirective {
}
IgxThumbFromTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxSliderThumbFrom]'
            },] }
];
/**
 * Template directive that allows you to set a custom template representing the upper label value of the {\@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * \@context {\@link IgxSliderComponent.context}
 */
class IgxThumbToTemplateDirective {
}
IgxThumbToTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxSliderThumbTo]'
            },] }
];
/** @enum {number} */
const SliderType = {
    /**
     * Slider with single thumb.
     */
    SLIDER: 0,
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    RANGE: 1,
};
SliderType[SliderType.SLIDER] = 'SLIDER';
SliderType[SliderType.RANGE] = 'RANGE';
/** @enum {number} */
const SliderHandle = {
    FROM: 0,
    TO: 1,
};
SliderHandle[SliderHandle.FROM] = 'FROM';
SliderHandle[SliderHandle.TO] = 'TO';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxSliderThumbComponent {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._isActive = false;
        this._isPressed = false;
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.isActive = false;
        this.onThumbValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onHoverChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.tabindex = 0;
        this.zIndex = 0;
    }
    /**
     * @private
     * @return {?}
     */
    get thumbPositionX() {
        /** @type {?} */
        const thumbBounderies = this.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
        return thumbBounderies.left + thumbCenter;
    }
    /**
     * @return {?}
     */
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    /**
     * @return {?}
     */
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    /**
     * @return {?}
     */
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this._isActive;
    }
    /**
     * @return {?}
     */
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this._isActive;
    }
    /**
     * @return {?}
     */
    get thumbPressedClass() {
        return this.isActive && this._isPressed;
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get destroy() {
        return this._destroy$;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.onPan
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$))
            .subscribe(mouseX => this.updateThumbValue(mouseX));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * @return {?}
     */
    onPinterEnter() {
        this.onHoverChange.emit(true);
    }
    /**
     * @return {?}
     */
    onPointerLeave() {
        this.onHoverChange.emit(false);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (this.disabled) {
            return;
        }
        /** @type {?} */
        let increment = 0;
        if (event.key.endsWith('Left')) {
            increment = this.step * -1;
        }
        else if (event.key.endsWith('Right')) {
            increment = this.step;
        }
        else {
            return;
        }
        this.onChange.emit();
        this.onThumbValueChange.emit(increment);
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.isActive = false;
        this.zIndex = 0;
    }
    /**
     * @return {?}
     */
    onFocusListener() {
        this.isActive = true;
        this.zIndex = 1;
    }
    /**
     * Show thumb label and ripple.
     * @return {?}
     */
    showThumbIndicators() {
        this.toggleThumbIndicators(true);
    }
    /**
     * Hide thumb label and ripple.
     * @return {?}
     */
    hideThumbIndicators() {
        this.toggleThumbIndicators(false);
    }
    /**
     * @private
     * @param {?} mouseX
     * @return {?}
     */
    updateThumbValue(mouseX) {
        /** @type {?} */
        const updateValue = this.calculateTrackUpdate(mouseX);
        if (this.isActive && updateValue !== 0) {
            this.onThumbValueChange.emit(updateValue);
        }
    }
    /**
     * @private
     * @param {?} mouseX
     * @return {?}
     */
    calculateTrackUpdate(mouseX) {
        /** @type {?} */
        const scaleX = mouseX - this.thumbPositionX;
        /** @type {?} */
        const stepDistanceCenter = this.stepDistance / 2;
        // If the thumb scale range (slider update) is less thàn a half step,
        // the position stays the same.
        /** @type {?} */
        const scaleXPositive = Math.abs(scaleX);
        if (scaleXPositive < stepDistanceCenter) {
            return 0;
        }
        return this.stepToProceed(scaleX, this.stepDistance);
    }
    /**
     * @private
     * @param {?} scaleX
     * @param {?} stepDist
     * @return {?}
     */
    stepToProceed(scaleX, stepDist) {
        return Math.round(scaleX / stepDist) * this.step;
    }
    /**
     * @private
     * @param {?} visible
     * @return {?}
     */
    toggleThumbIndicators(visible) {
        this._isPressed = visible;
        if (!this.continuous) {
            this._isActive = visible;
        }
    }
}
IgxSliderThumbComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-thumb',
                template: "<div class=\"dot\"></div>\n"
            }] }
];
/** @nocollapse */
IgxSliderThumbComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxSliderThumbComponent.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    continuous: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    thumbLabelVisibilityDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onPan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    stepDistance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    templateRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    context: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onThumbValueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onHoverChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    zIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.z-index',] }],
    thumbFromClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__thumb-from',] }],
    thumbToClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__thumb-to',] }],
    thumbFromActiveClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__thumb-from--active',] }],
    thumbToActiveClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__thumb-to--active',] }],
    thumbPressedClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__thumb--pressed',] }],
    onPinterEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['pointerenter',] }],
    onPointerLeave: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['pointerleave',] }],
    onKeyDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown', ['$event'],] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur',] }],
    onFocusListener: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxThumbLabelComponent {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    /**
     * @return {?}
     */
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    /**
     * @return {?}
     */
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    /**
     * @return {?}
     */
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this.active;
    }
    /**
     * @return {?}
     */
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this.active;
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set active(val) {
        if (this.continuous) {
            return;
        }
        this._active = val;
    }
}
IgxThumbLabelComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-thumb-label',
                template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
            }] }
];
/** @nocollapse */
IgxThumbLabelComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxThumbLabelComponent.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    templateRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    context: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    continuous: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    thumbFromClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__label-from',] }],
    thumbToClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__label-to',] }],
    thumbFromActiveClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__label-from--active',] }],
    thumbToActiveClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider__label-to--active',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const noop$6 = () => {
};
/** @type {?} */
let NEXT_ID$r = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
class IgxSliderComponent {
    /**
     * @param {?} renderer
     * @param {?} _el
     * @param {?} _cdr
     */
    constructor(renderer, _el, _cdr) {
        this.renderer = renderer;
        this._el = _el;
        this._cdr = _cdr;
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._continuous = false;
        this._disabled = false;
        this._step = 1;
        this._labels = new Array();
        this._type = SliderType.SLIDER;
        this._destroyer$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._indicatorsDestroyer$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._onChangeCallback = noop$6;
        this._onTouchedCallback = noop$6;
        /**
         * @hidden
         */
        this.thumbs = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */
        this.labelRefs = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */
        this.stepDistance = this._step;
        /**
         * @hidden
         */
        this.onPan = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = `igx-slider-${NEXT_ID$r++}`;
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @private
     * @return {?}
     */
    get thumbFrom() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.FROM);
    }
    /**
     * @private
     * @return {?}
     */
    get thumbTo() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.TO);
    }
    /**
     * @private
     * @return {?}
     */
    get labelFrom() {
        return this.labelRefs.find(label => label.type === SliderHandle.FROM);
    }
    /**
     * @private
     * @return {?}
     */
    get labelTo() {
        return this.labelRefs.find(label => label.type === SliderHandle.TO);
    }
    /**
     * @hidden
     * @return {?}
     */
    get valuemin() {
        return this.minValue;
    }
    /**
     * @hidden
     * @return {?}
     */
    get valuemax() {
        return this.maxValue;
    }
    /**
     * @hidden
     * @return {?}
     */
    get readonly() {
        return this.disabled;
    }
    /**
     * @hidden
     * @return {?}
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * An \@Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
     * ```typescript
     * sliderType: SliderType = SliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     * @param {?} type
     * @return {?}
     */
    set type(type) {
        this._type = type;
        if (type === SliderType.SLIDER) {
            this.lowerValue = 0;
        }
        if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
            this.upperValue = this.labels.length - 1;
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {\@link maxValue}, {\@link minValue}, {\@link step}.
     * This means that the manipulation for those properties won't be allowed.
     * @return {?}
     */
    get labels() {
        return this._labels;
    }
    /**
     * @param {?} labels
     * @return {?}
     */
    set labels(labels) {
        this._labels = labels;
        this._pMax = 1;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(labels);
        }
    }
    /**
     * Returns the template context corresponding
     * to {\@link IgxThumbFromTemplateDirective} and {\@link IgxThumbToTemplateDirective} templates.
     *
     * return {
     *  $implicit: {\@link value},
     *  labels: {\@link labels}
     * }
     * ```
     * @return {?}
     */
    get context() {
        return {
            $implicit: this.value,
            labels: this.labels
        };
    }
    /**
     * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @param {?} step
     * @return {?}
     */
    set step(step) {
        this._step = step;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.normalizeByStep(this.value);
            this.setTickInterval(this.labels);
        }
    }
    /**
     * Returns the incremental/decremental dragging step of the {\@link IgxSliderComponent}.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     * @return {?}
     */
    get step() {
        return this.labelsViewEnabled ? 1 : this._step;
    }
    /**
     * Returns if the {\@link IgxSliderComponent} is disabled.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * An \@Input property that disables or enables UI interaction.
     * ```html
     * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @param {?} disable
     * @return {?}
     */
    set disabled(disable) {
        this._disabled = disable;
        if (this._hasViewInit) {
            this.changeThumbFocusableState(disable);
        }
    }
    /**
     * Returns if the {\@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     * @return {?}
     */
    get continuous() {
        return this._continuous;
    }
    /**
     * An \@Input property that marks the {\@link IgxSliderComponent} as continuous.
     * By default is considered that the {\@link IgxSliderComponent} is discrete.
     * Discrete {\@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @param {?} continuous
     * @return {?}
     */
    set continuous(continuous) {
        this._continuous = continuous;
        this.setTickInterval(null);
    }
    /**
     * Returns if the {\@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     * @return {?}
     */
    get isContinuous() {
        return this.continuous;
    }
    /**
     * @hidden
     * \@internal
     * @param {?} continuous
     * @return {?}
     */
    set isContinuous(continuous) {
        this.continuous = continuous;
    }
    /**
     * Returns the maximum value for the {\@link IgxSliderComponent}.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderMax = this.slider.maxValue;
     * }
     * ```
     * @return {?}
     */
    get maxValue() {
        return this.labelsViewEnabled ?
            this.labels.length - 1 :
            this._maxValue;
    }
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     * @param {?} value
     * @return {?}
     */
    set maxValue(value) {
        if (value <= this._minValue) {
            this._maxValue = this._minValue + 1;
        }
        else {
            this._maxValue = value;
        }
        if (value < this.lowerBound) {
            this.updateLowerBoundAndMinTravelZone();
            this.upperBound = value;
        }
        // refresh max travel zone limits.
        this._pMax = 1;
        // recalculate step distance.
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(null);
    }
    /**
     * Returns the minimal value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderMin = this.slider.minValue;
     * }
     * ```
     * @return {?}
     */
    get minValue() {
        if (this.labelsViewEnabled) {
            return 0;
        }
        return this._minValue;
    }
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     * @param {?} value
     * @return {?}
     */
    set minValue(value) {
        if (value >= this.maxValue) {
            this._minValue = this.maxValue - 1;
        }
        else {
            this._minValue = value;
        }
        if (value > this.upperBound) {
            this.updateUpperBoundAndMaxTravelZone();
            this.lowerBound = value;
        }
        // Refresh min travel zone limit.
        this._pMin = 0;
        // Recalculate step distance.
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(null);
    }
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderLowBound = this.slider.lowerBound;
     * }
     * ```
     * @return {?}
     */
    get lowerBound() {
        if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
            return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
        }
        return this.minValue;
    }
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     * @param {?} value
     * @return {?}
     */
    set lowerBound(value) {
        if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
            return;
        }
        this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMin = this.valueToFraction(this._lowerBound) || 0;
        this.positionHandlesAndUpdateTrack();
    }
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     * }
     * ```
     * @return {?}
     */
    get upperBound() {
        if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
            return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
        }
        return this.maxValue;
    }
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     * @param {?} value
     * @return {?}
     */
    set upperBound(value) {
        if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
            return;
        }
        this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMax = this.valueToFraction(this._upperBound) || 1;
        this.positionHandlesAndUpdateTrack();
    }
    /**
     * Returns the slider value. If the slider is of type {\@link SliderType.SLIDER} the returned value is number.
     * If the slider type is {\@link SliderType.RANGE} the returned value represents an object of {\@link lowerValue} and {\@link upperValue}.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public sliderValue(event){
     *    let sliderVal = this.slider.value;
     * }
     * ```
     * @return {?}
     */
    get value() {
        if (this.isRange) {
            return {
                lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
            };
        }
        else {
            return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
        }
    }
    /**
     * Sets the slider value.
     * If the slider is of type {\@link SliderType.SLIDER} the argument is number. By default the {\@link value} gets the {\@link lowerBound}.
     * If the slider type is {\@link SliderType.RANGE} the argument
     * represents an object of {\@link lowerValue} and {\@link upperValue} properties.
     * By default the object is associated with the {\@link lowerBound} and {\@link upperBound} property values.
     * ```typescript
     * rangeValue = {
     *   lower: 30,
     *   upper: 60
     * };
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!this.isRange) {
            this.upperValue = (/** @type {?} */ (value));
        }
        else {
            value = this.validateInitialValue((/** @type {?} */ (value)));
            this.upperValue = ((/** @type {?} */ (value))).upper;
            this.lowerValue = ((/** @type {?} */ (value))).lower;
        }
        this._onChangeCallback(this.value);
        if (this._hasViewInit) {
            this.positionHandlesAndUpdateTrack();
        }
    }
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPointerDown($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        /** @type {?} */
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
        activeThumb.nativeElement.setPointerCapture($event.pointerId);
        this.showSliderIndicators();
        $event.preventDefault();
    }
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPointerUp($event) {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        /** @type {?} */
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
        activeThumb.nativeElement.releasePointerCapture($event.pointerId);
        this.hideSliderIndicators();
    }
    /**
     * @hidden
     * @return {?}
     */
    onFocus() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPanListener($event) {
        this.update($event.srcEvent.clientX);
    }
    /**
     * @return {?}
     */
    onPanStart() {
        this.showSliderIndicators();
    }
    /**
     * @return {?}
     */
    onPanEnd() {
        this.hideSliderIndicators();
    }
    /**
     * Returns whether the `IgxSliderComponent` type is RANGE.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderRange = this.slider.isRange;
     * }
     * ```
     * @return {?}
     */
    get isRange() {
        return this.type === SliderType.RANGE;
    }
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     * }
     * ```
     * @return {?}
     */
    get lowerValue() {
        if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
            return this._lowerValue;
        }
        return this.lowerBound;
    }
    /**
     * Sets the lower value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    this.slider.lowerValue = 120;
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set lowerValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._lowerValue = value;
    }
    /**
     * Returns the upper value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *    let upperValue = this.slider.upperValue;
     * }
     * ```
     * @return {?}
     */
    get upperValue() {
        if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
            return this._upperValue;
        }
        return this.upperBound;
    }
    /**
     * Sets the upper value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *    this.slider.upperValue = 120;
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set upperValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._upperValue = value;
    }
    /**
     * Returns the value corresponding the lower label.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     * ```
     * @return {?}
     */
    get lowerLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.lowerValue] :
            this.lowerValue;
    }
    /**
     * Returns the value corresponding the upper label.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     * ```
     * @return {?}
     */
    get upperLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.upperValue] :
            this.upperValue;
    }
    /**
     * Returns if label view is enabled.
     * If the {\@link labels} is set, the view is automatically activated.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     * ```
     * @return {?}
     */
    get labelsViewEnabled() {
        return !!(this.labels && this.labels.length > 1);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this._hasViewInit = true;
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(this.labels);
        this.changeThumbFocusableState(this.disabled);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroyer$)).subscribe(change => {
            /** @type {?} */
            const thumbFrom = change.find((thumb) => thumb.type === SliderHandle.FROM);
            /** @type {?} */
            const labelFrom = this.labelRefs.find((label) => label.type === SliderHandle.FROM);
            this.positionHandle(thumbFrom, labelFrom, this.lowerValue);
            this.subscribeTo(thumbFrom, this.thumbChanged.bind(this));
            this.changeThumbFocusableState(this.disabled);
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentChecked() {
        // Calculates the distance between every step in pixels.
        this.stepDistance = this.calculateStepDistance();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyer$.next(true);
        this._destroyer$.complete();
        this._indicatorsDestroyer$.next(true);
        this._indicatorsDestroyer$.complete();
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!value) {
            return;
        }
        this.normalizeByStep(value);
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    }
    /**
     *
     * @hidden
     * @param {?} mouseX
     * @return {?}
     */
    update(mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlesAndUpdateTrack the DOM
        // based on data values
        this.positionHandlesAndUpdateTrack();
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @param {?} value
     * @param {?} thumbType
     * @return {?}
     */
    thumbChanged(value, thumbType) {
        /** @type {?} */
        const oldValue = this.value;
        /** @type {?} */
        let newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower + value,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            else {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: ((/** @type {?} */ (this.value))).upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = (/** @type {?} */ (this.value)) + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onThumbChange() {
        this.toggleSliderIndicators();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    onHoverChange(state) {
        return state ? this.showSliderIndicators() : this.hideSliderIndicators();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    swapThumb(value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    findClosestThumb(event) {
        if (this.isRange) {
            this.closestHandle(event);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
    }
    /**
     * @private
     * @return {?}
     */
    updateLowerBoundAndMinTravelZone() {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    }
    /**
     * @private
     * @return {?}
     */
    updateUpperBoundAndMaxTravelZone() {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    }
    /**
     * @private
     * @return {?}
     */
    sliderSetup() {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this.value === this.upperBound) {
            this.value = this.lowerBound;
        }
    }
    /**
     * @private
     * @return {?}
     */
    calculateStepDistance() {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    }
    /**
     * @private
     * @return {?}
     */
    toggleThumb() {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    generateTickMarks(color, interval) {
        return interval !== null ? `repeating-linear-gradient(
            ${'to left'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        ), repeating-linear-gradient(
            ${'to right'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        )` : interval;
    }
    /**
     * @private
     * @param {?} thumbHandle
     * @param {?} labelHandle
     * @param {?} position
     * @return {?}
     */
    positionHandle(thumbHandle, labelHandle, position) {
        /** @type {?} */
        const positionLeft = `${this.valueToFraction(position) * 100}%`;
        if (thumbHandle) {
            thumbHandle.nativeElement.style.left = positionLeft;
        }
        if (labelHandle) {
            labelHandle.nativeElement.style.left = positionLeft;
        }
    }
    /**
     * @private
     * @return {?}
     */
    positionHandlesAndUpdateTrack() {
        if (!this.isRange) {
            this.positionHandle(this.thumbTo, this.labelTo, (/** @type {?} */ (this.value)));
        }
        else {
            this.positionHandle(this.thumbTo, this.labelTo, ((/** @type {?} */ (this.value))).upper);
            this.positionHandle(this.thumbFrom, this.labelFrom, ((/** @type {?} */ (this.value))).lower);
        }
        this.updateTrack();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    closestHandle(event) {
        /** @type {?} */
        const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        /** @type {?} */
        const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        /** @type {?} */
        const xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            this.thumbTo.nativeElement.focus();
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
    }
    /**
     * @private
     * @param {?} labels
     * @return {?}
     */
    setTickInterval(labels) {
        /** @type {?} */
        let interval;
        /** @type {?} */
        const trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            /** @type {?} */
            const trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        /** @type {?} */
        const renderCallbackExecution = !this.continuous ? this.generateTickMarks('white', interval) : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
    }
    /**
     * @private
     * @return {?}
     */
    showSliderIndicators() {
        if (this.disabled) {
            return;
        }
        if (this._indicatorsTimer) {
            this._indicatorsDestroyer$.next(true);
            this._indicatorsTimer = null;
        }
        this.thumbTo.showThumbIndicators();
        this.labelTo.active = true;
        if (this.thumbFrom) {
            this.thumbFrom.showThumbIndicators();
        }
        if (this.labelFrom) {
            this.labelFrom.active = true;
        }
    }
    /**
     * @private
     * @return {?}
     */
    hideSliderIndicators() {
        if (this.disabled) {
            return;
        }
        this._indicatorsTimer = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["timer"])(this.thumbLabelVisibilityDuration);
        this._indicatorsTimer.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._indicatorsDestroyer$)).subscribe(() => {
            this.thumbTo.hideThumbIndicators();
            this.labelTo.active = false;
            if (this.thumbFrom) {
                this.thumbFrom.hideThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = false;
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    toggleSliderIndicators() {
        this.showSliderIndicators();
        this.hideSliderIndicators();
    }
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    changeThumbFocusableState(state) {
        /** @type {?} */
        const value = state ? -1 : 1;
        if (this.isRange) {
            this.thumbFrom.tabindex = value;
        }
        this.thumbTo.tabindex = value;
        this._cdr.detectChanges();
    }
    /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} pMin
     * @param {?=} pMax
     * @return {?}
     */
    valueToFraction(value, pMin = this._pMin, pMax = this._pMax) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    }
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {\@link this.step} is set.
     * @private
     * @param {?} value
     * @return {?}
     */
    normalizeByStep(value) {
        if (this.isRange) {
            this.value = {
                lower: ((/** @type {?} */ (value))).lower - (((/** @type {?} */ (value))).lower % this.step),
                upper: ((/** @type {?} */ (value))).upper - (((/** @type {?} */ (value))).upper % this.step)
            };
        }
        else {
            this.value = ((/** @type {?} */ (value))) - (((/** @type {?} */ (value))) % this.step);
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateTrack() {
        /** @type {?} */
        const fromPosition = this.valueToFraction(this.lowerValue);
        /** @type {?} */
        const toPosition = this.valueToFraction(this.upperValue);
        /** @type {?} */
        const positionGap = toPosition - fromPosition;
        /** @type {?} */
        let trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            this.renderer.setStyle(this.track.nativeElement, 'transform', `scaleX(${positionGap}) translateX(${trackLeftIndention}%)`);
        }
        else {
            this.renderer.setStyle(this.track.nativeElement, 'transform', `scaleX(${toPosition})`);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    validateInitialValue(value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    }
    /**
     * @private
     * @param {?} thumb
     * @param {?} callback
     * @return {?}
     */
    subscribeTo(thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.unsubscriber(thumb)))
            .subscribe(value => callback(value, thumb.type));
    }
    /**
     * @private
     * @param {?} thumb
     * @return {?}
     */
    unsubscriber(thumb) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(this._destroyer$, thumb.destroy);
    }
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    hasValueChanged(oldValue) {
        /** @type {?} */
        const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        /** @type {?} */
        const isRangeWithOneDifferentValue = this.isRange &&
            (((/** @type {?} */ (oldValue))).lower !== ((/** @type {?} */ (this.value))).lower ||
                ((/** @type {?} */ (oldValue))).upper !== ((/** @type {?} */ (this.value))).upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    }
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    emitValueChanged(oldValue) {
        this.onValueChange.emit({ oldValue, value: this.value });
    }
}
IgxSliderComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxSliderComponent, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider__track\">\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-ticks\"></div>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"></igx-thumb-label>\n\n    <igx-thumb *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        [type]=\"1\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxSliderComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }
];
IgxSliderComponent.propDecorators = {
    track: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['track', { static: true },] }],
    ticks: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['ticks', { static: true },] }],
    thumbs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxSliderThumbComponent,] }],
    labelRefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [IgxThumbLabelComponent,] }],
    thumbFromTemplateRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxThumbFromTemplateDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    thumbToTemplateRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxThumbToTemplateDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.role`,] }],
    valuemin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.aria-valuemin`,] }],
    valuemax: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.aria-valuemax`,] }],
    readonly: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: [`attr.aria-readonly`,] }],
    slierClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider',] }],
    disabledClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-slider--disabled',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    thumbLabelVisibilityDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labels: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    continuous: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isContinuous: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    maxValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    minValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    lowerBound: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    upperBound: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onValueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onPointerDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['pointerdown', ['$event'],] }],
    onPointerUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['pointerup', ['$event'],] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus',] }],
    onPanListener: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['pan', ['$event'],] }],
    onPanStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['panstart',] }],
    onPanEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['panend',] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`IgxSliderComponent \`isContinuous\` property is deprecated.\nUse \`continuous\` instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])
], IgxSliderComponent.prototype, "isContinuous", null);
/**
 * @hidden
 */
class IgxSliderModule {
}
IgxSliderModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent
                ],
                exports: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent
                ],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$s = 0;
/**
 * **Ignite UI for Angular Snackbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
 *
 * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
 * include a link to an action such as Undo.
 *
 * Example:
 * ```html
 * <button (click)="snackbar.show()">Send message</button>
 * <div>
 *   <igx-snackbar #snackbar message="Message sent">
 *   </igx-snackbar>
 * </div>
 * ```
 */
class IgxSnackbarComponent {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * Sets/gets the `id` of the snackbar.
         * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
         * ```html
         * <igx-snackbar id = "Snackbar1"></igx-snackbar>
         * ```
         * ```typescript
         * let snackbarId = this.snackbar.id;
         * ```
         * \@memberof IgxSnackbarComponent
         */
        this.id = `igx-snackbar-${NEXT_ID$s++}`;
        /**
         * Enables/Disables the visibility of the snackbar.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-snackbar [isVisible] = "true"></igx-snackbar>
         * ```
         * ```typescript
         * let isVisible =  this.snackbar.isVisible;
         * ```
         */
        this.isVisible = false;
        /**
         * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-snackbar [autoHide] = "false"></igx-snackbar>
         * ```
         * ```typescript
         * let autoHide =  this.snackbar.autoHide;
         * ```
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
         * Default value is 4000.
         * ```html
         * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
         * ```
         * ```typescript
         * let displayTime = this.snackbar.displayTime;
         * ```
         */
        this.displayTime = 4000;
        /**
         * An event that will be emitted when the action is executed.
         * Provides reference to the `IgxSnackbarComponent` as an argument.
         * ```html
         * <igx-snackbar (onAction) = "onAction($event)"></igx-snackbar>
         * ```
         */
        this.onAction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that will be emitted when the snackbar animation starts.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
         * ```
         */
        this.animationStarted = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that will be emitted when the snackbar animation ends.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
         * ```
         */
        this.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     * @return {?}
     */
    show() {
        clearTimeout(this.timeoutId);
        setTimeout(this.timeoutId);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(() => {
                this.hide();
            }, this.displayTime);
        }
    }
    /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     * @return {?}
     */
    hide() {
        this.isVisible = false;
        clearTimeout(this.timeoutId);
    }
    /**
     * @hidden
     * @return {?}
     */
    triggerAction() {
        this.onAction.emit(this);
    }
    /**
     * @hidden
     * \@memberof IgxSnackbarComponent
     * @param {?} evt
     * @return {?}
     */
    snackbarAnimationStarted(evt) {
        if (evt.fromState === 'void') {
            this.animationStarted.emit(evt);
        }
    }
    /**
     * @hidden
     * \@memberof IgxSnackbarComponent
     * @param {?} evt
     * @return {?}
     */
    snackbarAnimationDone(evt) {
        if (evt.fromState === 'show') {
            this.animationDone.emit(evt);
        }
    }
}
IgxSnackbarComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                animations: [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('slideInOut', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', [
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInBottom, {
                                params: {
                                    duration: '.35s',
                                    easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                    fromPosition: 'translateY(100%)',
                                    toPosition: 'translateY(0)'
                                }
                            })
                        ]),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', [
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideOutBottom, {
                                params: {
                                    duration: '.2s',
                                    easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                    fromPosition: 'translateY(0)',
                                    toOpacity: 1,
                                    toPosition: 'translateY(100%)'
                                }
                            })
                        ])
                    ]),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('fadeInOut', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', [
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn, {
                                params: {
                                    duration: '.35s',
                                    easing: 'ease-out'
                                }
                            })
                        ]),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', [
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeOut, {
                                params: {
                                    duration: '.2s',
                                    easing: 'ease-out'
                                }
                            })
                        ])
                    ])
                ],
                selector: 'igx-snackbar',
                template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ message }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxSnackbarComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxSnackbarComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    message: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isVisible: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    autoHide: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayTime: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    actionText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onAction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    animationStarted: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    animationDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
};
/**
 * @hidden
 */
class IgxSnackbarModule {
}
IgxSnackbarModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxSnackbarComponent],
                exports: [IgxSnackbarComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const SwitchLabelPosition = {
    BEFORE: 'before',
    AFTER: 'after',
};
/** @type {?} */
const noop$7 = () => { };
/** @type {?} */
let nextId$3 = 0;
/**
 * **Ignite UI for Angular Switch** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/switch.html)
 *
 * The Ignite UI Switch lets the user toggle between on/off or true/false states.
 *
 * Example:
 * ```html
 * <igx-switch [checked]="true">
 *   Simple switch
 * </igx-switch>
 * ```
 */
class IgxSwitchComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the switch component.
         * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
         * ```html
         * <igx-switch id="my-first-switch"></igx-switch>
         * ```
         * ```typescript
         * let switchId =  this.switch.id;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.id = `igx-switch-${nextId$3++}`;
        /**
         * Sets/gets the id of the `label` element in the switch component.
         * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
         * ```html
         * <igx-switch labelId="Label1"></igx-switch>
         * ```
         * ```typescript
         * let labelId =  this.switch.labelId;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         * ```html
         * <igx-switch [tabindex]="1"></igx-switch>
         * ```
         * ```typescript
         * let tabIndex =  this.switch.tabindex;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.tabindex = null;
        /**
         * Sets/gets the position of the `label` in the switch component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-switch labelPosition="before"></igx-switch>
         * ```
         * ```typescript
         * let labelPosition =  this.switch.labelPosition;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.labelPosition = 'after';
        /**
         * Enables/Disables the ripple effect
         * If not set, `disableRipple` will have value `false`.
         * ```html
         * <igx-switch [disableRipple]="true"></igx-switch>
         * ```
         * ```typescript
         * let isRippleDisabled = this.switch.disableRipple;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether switch is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-switch [required]="true"></igx-switch>
         * ```
         * ```typescript
         * let isRequired = this.switch.required;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledBy` attribute.
         * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-switch aria-labelledby = "Label1"></igx-switch>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.switch.ariaLabelledBy;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         * ```html
         * <igx-switch aria-label="Label1"></igx-switch>
         * ```
         * ```typescript
         * let ariaLabel =  this.switch.ariaLabel;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the switch state is changed.
         * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
         * \@memberof IgxSwitchComponent
         */
        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         * \@memberof IgxSwitchComponent
         */
        this._onTouchedCallback = noop$7;
        /**
         * @hidden
         * \@memberof IgxSwitchComponent
         */
        this._onChangeCallback = noop$7;
        /**
         * Returns the class of the switch component.
         * ```typescript
         * let switchClass = this.switch.cssClass;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.cssClass = 'igx-switch';
        /**
         * Sets/gets whether the switch is on or off.
         * Default value is 'false'.
         * ```html
         *  <igx-switch [checked] = "true"></igx-switch>
         * ```
         * ```typescript
         * let isChecked =  this.switch.checked;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.checked = false;
        /**
         * Sets/gets the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-switch [disabled] = "true"><igx-switch>
         * ```
         * ```typescript
         * let isDisabled =  this.switch.disabled;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the switch component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.switch.focused = true;
         * ```
         * ```typescript
         * let isFocused =  this.switch.focused;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = `${this.id}-input`;
    }
    /**
     * Toggles the checked state of the switch.
     * ```typescript
     * this.switch.toggle();
     * ```
     * \@memberof IgxSwitchComponent
     * @return {?}
     */
    toggle() {
        if (this.disabled) {
            return;
        }
        this.checked = !this.checked;
        this.focused = false;
        this.change.emit({ checked: this.checked, switch: this });
        this._onChangeCallback(this.checked);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onSwitchChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onSwitchClick(event) {
        event.stopPropagation();
        this.toggle();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    _onLabelClick(event) {
        this.toggle();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.focused = true;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get labelClass() {
        switch (this.labelPosition) {
            case SwitchLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case SwitchLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
}
IgxSwitchComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"], useExisting: IgxSwitchComponent, multi: true }],
                selector: 'igx-switch',
                template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            }] }
];
IgxSwitchComponent.propDecorators = {
    nativeCheckbox: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['checkbox', { static: true },] }],
    nativeLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['label', { static: true },] }],
    placeholderLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['placeholderLabel', { static: true },] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelId: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    ariaLabelledBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-labelledby',] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-label',] }],
    change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-switch',] }],
    checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-switch--checked',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-switch--disabled',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    focused: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-switch--focused',] }]
};
/** @type {?} */
const IGX_SWITCH_REQUIRED_VALIDATOR = {
    provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALIDATORS"],
    useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxSwitchRequiredDirective),
    multi: true
};
/* tslint:disable directive-selector */
class IgxSwitchRequiredDirective extends _angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxRequiredValidator"] {
}
IgxSwitchRequiredDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: `igx-switch[required][formControlName],
    igx-switch[required][formControl],
    igx-switch[required][ngModel]`,
                providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
            },] }
];
/**
 * @hidden
 */
class IgxSwitchModule {
}
IgxSwitchModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                imports: [IgxRippleModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$t = 0;
class IgxTabTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxTabTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxTab]'
            },] }
];
/** @nocollapse */
IgxTabTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * **Ignite UI for Angular Tab Bar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar.html)
 *
 * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
 *
 * Example:
 * ```html
 * <igx-bottom-nav>
 *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
 * </igx-bottom-nav>
 * ```
 */
class IgxBottomNavComponent {
    /**
     * @param {?} _element
     */
    constructor(_element) {
        this._element = _element;
        /**
         * Sets/gets the `id` of the tab bar.
         * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
         * ```html
         * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
         * ```
         * ```typescript
         * let tabBarId =  this.tabBar.id;
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.id = `igx-bottom-nav-${NEXT_ID$t++}`;
        /**
         * Emits an event when a new tab is selected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.onTabSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when a tab is deselected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.onTabDeselected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets the `index` of selected tab/panel in the respective collection.
         * ```typescript
         * let index =  this.tabBar.selectedIndex;
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.selectedIndex = -1;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-bottom-nav';
    }
    /**
     * Gets the `IgxTabComponent` elements for this bottom navigation component.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
     * ```
     * \@memberof IgxBottomNavComponent
     * @return {?}
     */
    get tabs() {
        return this.hasContentTabs ? this.contentTabs : this.viewTabs;
    }
    /**
     * Gets the `itemStyle` of the tab bar.
     * ```typescript
     * let itemStyle =  this.tabBar.itemStyle;
     * ```
     * \@memberof IgxBottomNavComponent
     * @return {?}
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * Gets the selected tab in the tab bar.
     * ```typescript
     * let tab =  this.tabBar.selectedTab;
     * ```
     * \@memberof IgxBottomNavComponent
     * @return {?}
     */
    get selectedTab() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        // initial selection
        setTimeout(() => {
            if (this.selectedIndex === -1) {
                /** @type {?} */
                const selectablePanels = this.panels.filter((p) => !p.disabled);
                /** @type {?} */
                const panel = selectablePanels[0];
                if (panel) {
                    panel.select();
                }
            }
        }, 0);
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    _selectedPanelHandler(args) {
        if (this.hasContentTabs) {
            this.selectedIndex = args.tab.index;
            this.contentTabs.forEach((t) => {
                if (t !== args.tab) {
                    this._deselectTab(t);
                }
            });
        }
        else {
            if (args.panel) {
                this.selectedIndex = args.panel.index;
                this.panels.forEach((p) => {
                    if (p.index !== this.selectedIndex) {
                        this._deselectPanel(p);
                    }
                });
            }
        }
    }
    /**
     * @hidden
     * @private
     * @param {?} panel
     * @return {?}
     */
    _deselectPanel(panel) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (panel.disabled || this.selectedTab.index === panel.index) {
            return;
        }
        panel.isSelected = false;
        this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel });
    }
    /**
     * @private
     * @param {?} aTab
     * @return {?}
     */
    _deselectTab(aTab) {
        aTab.isSelected = false;
        this.onTabDeselected.emit({ tab: aTab, panel: null });
    }
}
IgxBottomNavComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-bottom-nav',
                template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">    \n        <igx-tab *ngFor=\"let panel of panels\" [relatedPanel]=\"panel\">\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxBottomNavComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxBottomNavComponent.propDecorators = {
    viewTabs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTabComponent),] }],
    contentTabs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTabComponent),] }],
    panels: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTabPanelComponent),] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onTabSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onTabDeselected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    _selectedPanelHandler: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['onTabSelected', ['$event'],] }]
};
// ================================= IgxTabPanelComponent ======================================
class IgxTabPanelComponent {
    /**
     * @param {?} _tabBar
     * @param {?} _element
     */
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-tab-panel';
        /**
         * @hidden
         */
        this._isSelected = false;
        /**
         * Gets the role of the tab panel.
         * ```typescript
         * let tabPanelRole = this.tabPanel.role;
         * ```
         * \@memberof IgxTabPanelComponent
         */
        this.role = 'tabpanel';
    }
    /**
     * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
     * ```typescript
     * let styleClass = this.tabPanel.styleClass;
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    get styleClass() {
        return (!this.isSelected);
    }
    /**
     * Sets/gets whether a tab panel is selected.
     * ```typescript
     * this.tabPanel.isSelected = true;
     * ```
     * ```typescript
     * let isSelected =  this.tabPanel.isSelected;
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set isSelected(newValue) {
        if (this._isSelected !== newValue) {
            if (newValue) {
                this.select();
            }
            else {
                this._isSelected = newValue;
            }
        }
    }
    /**
     * Gets the `itemStyle` of the tab panel.
     * ```typescript
     * let itemStyle = this.tabPanel.itemStyle;
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * Gets the tab associated with the panel.
     * ```typescript
     * let tab = this.tabPanel.relatedTab;
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    get relatedTab() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray()[this.index];
        }
    }
    /**
     * Gets the changes and updates accordingly applied to the tab/panel.
     *
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get changesCount() {
        return this.relatedTab ? this.relatedTab.changesCount : 0;
    }
    /**
     * Gets the index of a panel in the panels collection.
     * ```typescript
     * let panelIndex =  this.tabPanel.index
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    get index() {
        if (this._tabBar.panels) {
            return this._tabBar.panels.toArray().indexOf(this);
        }
    }
    /**
     * Gets the tab template.
     * ```typescript
     * let tabTemplate = this.tabPanel.customTabTemplate
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * Sets the tab template.
     * ```typescript
     * this.tabPanel.customTabTemplate(tabTemplate);
     * ```
     * \@memberof IgxTabPanelComponent
     * @param {?} template
     * @return {?}
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewChecked() {
        this._element.nativeElement.setAttribute('aria-labelledby', `igx-tab-${this.index}`);
        this._element.nativeElement.setAttribute('id', `igx-bottom-nav__panel-${this.index}`);
    }
    /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    select() {
        if (this.disabled || this._tabBar.selectedIndex === this.index) {
            return;
        }
        this._isSelected = true;
        this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
    }
}
IgxTabPanelComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-tab-panel',
                template: "<ng-content></ng-content>\n"
            }] }
];
/** @nocollapse */
IgxTabPanelComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxTabPanelComponent.propDecorators = {
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-bottom-nav__panel',] }],
    isSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-bottom-nav__panel--selected',] }],
    tabTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective, static: false },] }]
};
// ======================================= IgxTabComponent ==========================================
class IgxTabComponent {
    /**
     * @param {?} _tabBar
     * @param {?} _element
     */
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let tabRole = this.tab.role;
         * ```
         * \@memberof IgxTabComponent
         */
        this.role = 'tab';
        /**
         * @hidden \@internal
         */
        this.id = 'igx-tab-' + this.index;
        /**
         * @hidden \@internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden \@internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden \@internal
         */
        this.ariaSelected = this.isSelected;
        /**
         * @hidden \@internal
         */
        this.ariaControls = 'igx-tab-panel-' + this.index;
        /**
         * @hidden
         */
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._disabled = false;
        this._selected = false;
    }
    /**
     * Sets/gets the `label` of the tab panel.
     * ```html
     * <igx-tab [label] = "'Tab label'"><igx-tab>
     * ```
     * ```typescript
     * let tabLabel = this.tab.label;
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get label() {
        return this.relatedPanel ? this.relatedPanel.label : this._label;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set label(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.label = newValue;
        }
        this._label = newValue;
    }
    /**
     * Sets/gets  the `icon` of the tab panel.
     * ```html
     * <igx-tab [icon] = "tab_icon"><igx-tab>
     * ```
     * ```typescript
     * let tabIcon =  this.tab.icon;
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get icon() {
        return this.relatedPanel ? this.relatedPanel.icon : this._icon;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set icon(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.icon = newValue;
        }
        this._icon = newValue;
    }
    // changes and updates accordingly applied to the tab.
    /**
     * Gets the changes and updates accordingly applied to the tab.
     *
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * Gets whether the tab is disabled.
     * ```typescript
     * let isDisabled = this.tab.disabled;
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get disabled() {
        return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set disabled(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * let isSelected  = this.tab.isSelected;
     * ```
     * \@memberof IgxTabComponent
     * @param {?} newValue
     * @return {?}
     */
    set isSelected(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.isSelected = newValue;
        }
        else if (this._selected !== newValue) {
            this._selected = newValue;
            if (this._selected) {
                this._tabBar.onTabSelected.emit({ tab: this, panel: null });
            }
        }
    }
    /**
     * @return {?}
     */
    get isSelected() {
        return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
    }
    /**
     * @return {?}
     */
    get cssClassSelected() {
        return this.isSelected;
    }
    /**
     * @return {?}
     */
    get cssClassDisabled() {
        return this.disabled;
    }
    /**
     * @return {?}
     */
    get cssClass() {
        return (!this.disabled && !this.isSelected);
    }
    /**
     * Gets the `index` of the tab.
     * ```typescript
     * let tabIndex = this.tab.index;
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get index() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray().indexOf(this);
        }
    }
    /**
     * Returns the `template` for this IgxTabComponent.
     * ```typescript
     * let tabItemTemplate = this.tabItem.template;
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    get template() {
        if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
            return this.relatedPanel.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * Returns the `context` object for the template of this `IgxTabComponent`.
     * ```typescript
     * let tabItemContext = this.tabItem.context;
     * ```
     * @return {?}
     */
    get context() {
        return this.relatedPanel ? this.relatedPanel : this;
    }
    /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    select() {
        if (this.relatedPanel) {
            this.relatedPanel.select();
        }
        else {
            this._selected = true;
            this._tabBar.onTabSelected.emit({ tab: this, panel: null });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onClick() {
        this.select();
    }
    /**
     * @return {?}
     */
    elementRef() {
        return this._element;
    }
}
IgxTabComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-tab',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            }] }
];
/** @nocollapse */
IgxTabComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxTabComponent.propDecorators = {
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-label',] }],
    ariaDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-disabled',] }],
    ariaSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-selected',] }],
    ariaControls: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-controls',] }],
    relatedPanel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cssClassSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-bottom-nav__menu-item--selected',] }],
    cssClassDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-bottom-nav__menu-item--disabled',] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-bottom-nav__menu-item',] }],
    defaultTabTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultTabTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    customTabTemplateDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective, static: false },] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click',] }]
};
/**
 * @hidden
 */
class IgxBottomNavModule {
}
IgxBottomNavModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxBadgeModule, IgxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
class IgxTabsBase {
    /**
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    scrollElement(element, scrollRight) { }
    /**
     * @param {?} newTab
     * @return {?}
     */
    performSelectionChange(newTab) { }
    /**
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    transformContentAnimation(tab, duration) { }
    /**
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    transformIndicatorAnimation(element, duration) { }
}
/**
 * @hidden
 * @abstract
 */
class IgxTabItemBase {
    /**
     * @return {?}
     */
    get index() { return 0; }
    /**
     * @return {?}
     */
    select() { }
    /**
     * @param {?} newValue
     * @return {?}
     */
    setSelectedInternal(newValue) { }
}
/**
 * @hidden
 * @abstract
 */
class IgxTabsGroupBase {
    /**
     * @return {?}
     */
    select() { }
    /**
     * @param {?} newValue
     * @return {?}
     */
    setSelectedInternal(newValue) { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ButtonStyle = {
    VISIBLE: 'visible',
    HIDDEN: 'hidden',
    NOT_DISPLAYED: 'not_displayed',
};
class IgxRightButtonStyleDirective {
    /**
     * @param {?} tabs
     */
    constructor(tabs) {
        this.tabs = tabs;
    }
    /**
     * @return {?}
     */
    get visibleCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
    }
    /**
     * @return {?}
     */
    get hiddenCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
    }
    /**
     * @return {?}
     */
    get notDisplayedCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
    }
    /**
     * @private
     * @return {?}
     */
    getRightButtonStyle() {
        /** @type {?} */
        const viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        /** @type {?} */
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        /** @type {?} */
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            /** @type {?} */
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        /** @type {?} */
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        /** @type {?} */
        const offset = this.tabs.offset;
        /** @type {?} */
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return ButtonStyle.NOT_DISPLAYED;
        }
        if (itemsContainerWidth > total) {
            return ButtonStyle.VISIBLE;
        }
        else {
            return ButtonStyle.HIDDEN;
        }
    }
}
IgxRightButtonStyleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxRightButtonStyle]'
            },] }
];
/** @nocollapse */
IgxRightButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxRightButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-button--none',] }]
};
class IgxLeftButtonStyleDirective {
    /**
     * @param {?} tabs
     */
    constructor(tabs) {
        this.tabs = tabs;
    }
    /**
     * @return {?}
     */
    get visibleCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
    }
    /**
     * @return {?}
     */
    get hiddenCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
    }
    /**
     * @return {?}
     */
    get notDisplayedCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
    }
    /**
     * @private
     * @return {?}
     */
    getLeftButtonStyle() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        /** @type {?} */
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        /** @type {?} */
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            /** @type {?} */
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        /** @type {?} */
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        /** @type {?} */
        const offset = this.tabs.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return ButtonStyle.NOT_DISPLAYED;
            }
            return ButtonStyle.HIDDEN;
        }
        else {
            return ButtonStyle.VISIBLE;
        }
    }
}
IgxLeftButtonStyleDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxLeftButtonStyle]'
            },] }
];
/** @nocollapse */
IgxLeftButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxLeftButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-button--none',] }]
};
class IgxTabItemTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxTabItemTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxTab]'
            },] }
];
/** @nocollapse */
IgxTabItemTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTabsGroupComponent extends IgxTabsGroupBase {
    /**
     * @param {?} _tabs
     * @param {?} _element
     */
    constructor(_tabs, _element) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        /**
         * An \@Input property that allows you to enable/disable the `IgxTabGroupComponent`.
         * ```html
         * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
         * ```
         */
        this.disabled = false;
        this._isSelected = false;
        /**
         * @hidden
         */
        this.role = 'tabpanel';
        /**
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * Sets/gets whether a tab group is selected.
     * ```typescript
     * this.tabGroup.isSelected = true;
     * ```
     * ```typescript
     * let isSelected = this.tabGroup.isSelected;
     * ```
     * \@memberof IgxTabsGroupComponent
     * @return {?}
     */
    get isSelected() {
        return this._isSelected;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
        }
    }
    /**
     * An accessor that returns the `IgxTabItemComponent` component.
     * ```typescript
     * \@ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabComponent = this.tab.relatedTab;
     * }
     * ```
     * @return {?}
     */
    get relatedTab() {
        if (this._tabs.tabs) {
            return (/** @type {?} */ (this._tabs.tabs.toArray()[this.index]));
        }
    }
    /**
     * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
     * ```typescript
     * \@ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabIndex = this.tab.index;
     * }
     * ```
     * @return {?}
     */
    get index() {
        if (this._tabs.groups) {
            return this._tabs.groups.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     * @return {?}
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * @hidden
     * @param {?} template
     * @return {?}
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewChecked() {
        this._element.nativeElement.setAttribute('aria-labelledby', `igx-tab-item-${this.index}`);
        this._element.nativeElement.setAttribute('id', `igx-tabs__group-${this.index}`);
    }
    /**
     * A method that sets the focus on a tab.
     * \@memberof {\@link IgxTabsGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * public tab : IgxTabsGroupComponent;
     * ngAfterViewInit(){
     *    this.tab.select();
     * }
     * ```
     * @return {?}
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this.relatedTab);
        }
    }
    /**
     * @hidden
     * @param {?} newValue
     * @return {?}
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
    }
}
IgxTabsGroupComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-tabs-group',
                template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
            }] }
];
/** @nocollapse */
IgxTabsGroupComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxTabsGroupComponent.propDecorators = {
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    tabTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective, static: false },] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    styleClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__group',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgxTabItemComponent extends IgxTabItemBase {
    /**
     * @param {?} _tabs
     * @param {?} _element
     * @param {?} _ngZone
     */
    constructor(_tabs, _element, _ngZone) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        this._ngZone = _ngZone;
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        // changes and updates accordingly applied to the tab.
        this._isSelected = false;
        this._disabled = false;
        /**
         * @hidden \@internal
         */
        this.role = 'tab';
        /**
         * @hidden \@internal
         */
        this.id = 'igx-tab-item-' + this.index;
        /**
         * @hidden \@internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden \@internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden \@internal
         */
        this.ariaSelected = this.isSelected;
        /**
         * @hidden \@internal
         */
        this.ariaControls = 'igx-tab-item-group-' + this.index;
        this._nativeTabItem = _element;
    }
    /**
     * An \@Input property that sets the value of the `icon`.
     * The value should be valid icon name from {\@link https://material.io/tools/icons/?style=baseline}.
     * ```html
     * <igx-tab-item label="Tab 1" icon="home">
     * ```
     * @return {?}
     */
    get icon() {
        return this.relatedGroup ? this.relatedGroup.icon : this._icon;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set icon(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * An \@Input property that sets the value of the `label`.
     * ```html
     * <igx-tabs-item label="Tab 2" icon="folder">
     * ```
     * @return {?}
     */
    get label() {
        return this.relatedGroup ? this.relatedGroup.label : this._label;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set label(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.label = newValue;
        }
        this._label = newValue;
    }
    /**
     * @return {?}
     */
    get provideCssClassSelected() {
        return this.isSelected;
    }
    /**
     * @return {?}
     */
    get provideCssClassDisabled() {
        return this.disabled;
    }
    /**
     * @return {?}
     */
    get provideCssClass() {
        return (!this.disabled && !this.isSelected);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](() => {
                this._tabs.transformIndicatorAnimation(this._nativeTabItem.nativeElement, 0);
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver.disconnect();
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        this.select();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowRight(event) {
        this.onKeyDown(false);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowLeft(event) {
        this.onKeyDown(true);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownHome(event) {
        event.preventDefault();
        this.onKeyDown(false, 0);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnd(event) {
        event.preventDefault();
        this.onKeyDown(false, this._tabs.tabs.toArray().length - 1);
    }
    /**
     * @hidden
     * @return {?}
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * @hidden
     * @return {?}
     */
    get nativeTabItem() {
        return this._nativeTabItem;
    }
    /**
     * 	Gets whether the tab is disabled.
     * ```
     * const disabledItem = this.myTabComponent.tabs.first.disabled;
     * ```
     * @return {?}
     */
    get disabled() {
        return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set disabled(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * const selectedItem = this.myTabComponent.tabs.first.isSelected;
     * ```
     * @return {?}
     */
    get isSelected() {
        return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this : null);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get index() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     * @param {?} newValue
     * @return {?}
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
        this._ngZone.runOutsideAngular(() => {
            if (this._resizeObserver) {
                if (this._isSelected) {
                    this._resizeObserver.observe(this._element.nativeElement);
                }
                else {
                    this._resizeObserver.disconnect();
                }
            }
        });
        this.tabindex = newValue ? 0 : -1;
    }
    /**
     * @private
     * @param {?} isLeftArrow
     * @param {?=} index
     * @return {?}
     */
    onKeyDown(isLeftArrow, index = null) {
        /** @type {?} */
        const tabsArray = this._tabs.tabs.toArray();
        if (index === null) {
            index = (isLeftArrow)
                ? (this._tabs.selectedIndex === 0) ? tabsArray.length - 1 : this._tabs.selectedIndex - 1
                : (this._tabs.selectedIndex === tabsArray.length - 1) ? 0 : this._tabs.selectedIndex + 1;
        }
        /** @type {?} */
        const tab = tabsArray[index];
        tab.select();
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
            return this.relatedGroup.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * @hidden
     * @return {?}
     */
    get context() {
        return this.relatedGroup ? this.relatedGroup : this;
    }
}
IgxTabItemComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-tab-item',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            }] }
];
/** @nocollapse */
IgxTabItemComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxTabItemComponent.propDecorators = {
    relatedGroup: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    defaultTabTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultTabTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    customTabTemplateDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective, static: false },] }],
    provideCssClassSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-menu-item--selected',] }],
    provideCssClassDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-menu-item--disabled',] }],
    provideCssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-tabs__header-menu-item',] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.role',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }],
    ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-label',] }],
    ariaDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-disabled',] }],
    ariaSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-selected',] }],
    ariaControls: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.aria-controls',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['$event'],] }],
    onKeydownArrowRight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownHome: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.end', ['$event'],] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const TabsType = {
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit',
};
class IgxTabsComponent {
    /**
     * @param {?} _element
     * @param {?} _ngZone
     */
    constructor(_element, _ngZone) {
        this._element = _element;
        this._ngZone = _ngZone;
        /**
         * @hidden
         */
        this.selectedIndexChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.tabsType = 'contentfit';
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    /**
     * An \@Input property that sets the value of the `selectedIndex`.
     * Default value is 0.
     * ```html
     * <igx-tabs selectedIndex="1">
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tabs [(selectedIndex)]="model.selectedIndex">
     * ```
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set selectedIndex(index) {
        /** @type {?} */
        const newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
        if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
                /** @type {?} */
                const newTab = this.tabs.toArray()[newIndex];
                if (newTab) {
                    this.performSelectionChange(newTab);
                }
            }
            else {
                this._selectedIndex = newIndex;
            }
        }
    }
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     * @return {?}
     */
    get tabs() {
        if (this.hasContentTabs) {
            return this.contentTabs;
        }
        return this.viewTabs;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClass() {
        /** @type {?} */
        const defaultStyle = `igx-tabs`;
        /** @type {?} */
        const fixedStyle = `igx-tabs--fixed`;
        /** @type {?} */
        const iconStyle = `igx-tabs--icons`;
        /** @type {?} */
        const iconLabelFoundInGroups = this.groups.find((group) => group.icon != null && group.label != null);
        /** @type {?} */
        const iconLabelFoundInTabs = this.contentTabs.find((tab) => tab.icon != null && tab.label != null);
        /** @type {?} */
        let css;
        switch (TabsType[this.tabsType.toUpperCase()]) {
            case TabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return `${css} ${this.class}`;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scrollLeft(event) {
        this.scroll(false);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scrollRight(event) {
        this.scroll(true);
    }
    /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    scrollElement(element, scrollRight) {
        /** @type {?} */
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     * @return {?}
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._selectedIndex === -1) {
            this.tabs.forEach((t) => {
                if (t.isSelected) {
                    this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        requestAnimationFrame(() => {
            /** @type {?} */
            const newTab = this.tabs.toArray()[this._selectedIndex];
            if (newTab) {
                this.performSelection(newTab);
            }
            else {
                this.hideIndicator();
            }
        });
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.resetSelectionOnCollectionChanged();
        });
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](() => {
                if (!this.hasContentTabs && this._selectedIndex >= 0 && this._selectedIndex < this.tabs.length) {
                    /** @type {?} */
                    const newTab = this.tabs.toArray()[this._selectedIndex];
                    this.transformContentAnimation(newTab, 0);
                }
            });
            this._resizeObserver.observe(this.tabsContainer.nativeElement);
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver.disconnect();
        });
    }
    /**
     * @private
     * @return {?}
     */
    resetSelectionOnCollectionChanged() {
        requestAnimationFrame(() => {
            /** @type {?} */
            const currentTab = this.tabs.toArray()[this.selectedIndex];
            if (currentTab) {
                this.performSelectionChange(currentTab);
            }
            else if (this.selectedIndex >= this.tabs.length) {
                this.performSelectionChange(this.tabs.last);
            }
            else {
                this.hideIndicator();
            }
        });
    }
    /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    scroll(scrollRight) {
        /** @type {?} */
        const tabsArray = this.tabs.toArray();
        for (const tab of tabsArray) {
            /** @type {?} */
            const element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    /**
     * @hidden
     * @param {?} newTab
     * @return {?}
     */
    performSelectionChange(newTab) {
        /** @type {?} */
        const oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    }
    /**
     * @private
     * @param {?} oldTab
     * @return {?}
     */
    performDeselection(oldTab) {
        oldTab.setSelectedInternal(false);
        /** @type {?} */
        const oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    }
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    performSelection(newTab) {
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        /** @type {?} */
        let newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(() => {
            // bring the new selected tab into view if it is not
            this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!this.hasContentTabs) {
                this.transformContentAnimation(newTab, 0.2);
            }
        });
    }
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    bringNewTabIntoView(newTab) {
        /** @type {?} */
        const tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        /** @type {?} */
        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        /** @type {?} */
        const delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    }
    /**
     * @hidden
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    // animation for the new panel/group (not needed for tab only mode)
    transformContentAnimation(tab, duration) {
        /** @type {?} */
        const contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
        this.contentsContainer.nativeElement.style.transform = `translate(${-contentOffset}px)`;
    }
    /**
     * @hidden
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    transformIndicatorAnimation(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    /**
     * @return {?}
     */
    hideIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
}
IgxTabsComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'igx-tabs',
                template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple *ngFor=\"let group of groups\" [relatedGroup]=\"group\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
            }] }
];
/** @nocollapse */
IgxTabsComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
];
IgxTabsComponent.propDecorators = {
    groups: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTabsGroupComponent),] }],
    contentTabs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTabItemComponent),] }],
    selectedIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    selectedIndexChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    tabsType: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['tabsType',] }],
    class: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onTabItemDeselected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onTabItemSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    contentsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['contentsContainer', { static: true },] }],
    headerContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['headerContainer', { static: true },] }],
    itemsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['itemsContainer', { static: true },] }],
    selectedIndicator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['selectedIndicator', { static: false },] }],
    tabsContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['tabsContainer', { static: true },] }],
    viewPort: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['viewPort', { static: true },] }],
    viewTabs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => IgxTabItemComponent),] }],
    cssClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.class',] }]
};
/**
 * @hidden
 */
class IgxTabsModule {
}
IgxTabsModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxBadgeModule, IgxIconModule, IgxRippleModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
const IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
class IgxItemListDirective {
    /**
     * @param {?} timePicker
     * @param {?} elementRef
     */
    constructor(timePicker, elementRef) {
        this.timePicker = timePicker;
        this.elementRef = elementRef;
        this.tabindex = 0;
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return true;
    }
    /**
     * @return {?}
     */
    get hourCSS() {
        return this.type === 'hourList';
    }
    /**
     * @return {?}
     */
    get minuteCSS() {
        return this.type === 'minuteList';
    }
    /**
     * @return {?}
     */
    get ampmCSS() {
        return this.type === 'ampmList';
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.isActive = true;
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.isActive = false;
    }
    /**
     * @private
     * @return {?}
     */
    nextItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.nextHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.nextMinute();
                break;
            }
            case 'ampmList': {
                this.timePicker.nextAmPm();
                break;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    prevItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.prevHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.prevMinute();
                break;
            }
            case 'ampmList': {
                this.timePicker.prevAmPm();
                break;
            }
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        this.nextItem();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        this.prevItem();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        /** @type {?} */
        const listName = ((/** @type {?} */ (event.target))).className;
        if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.ampmList) {
            this.timePicker.ampmList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        /** @type {?} */
        const listName = ((/** @type {?} */ (event.target))).className;
        if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
            this.timePicker.hourList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEnter(event) {
        event.preventDefault();
        if (this.timePicker.mode === InteractionMode.DropDown) {
            this.timePicker.close();
            return;
        }
        this.timePicker.okButtonClick();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownEscape(event) {
        event.preventDefault();
        this.timePicker.cancelButtonClick();
    }
    /**
     * @hidden
     * @return {?}
     */
    onHover() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.nextItem();
        }
        else if (event.deltaY < 0) {
            this.prevItem();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onPanMove(event) {
        if (event.deltaY < 0) {
            this.nextItem();
        }
        else if (event.deltaY > 0) {
            this.prevItem();
        }
    }
}
IgxItemListDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxItemList]'
            },] }
];
/** @nocollapse */
IgxItemListDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
IgxItemListDirective.propDecorators = {
    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxItemList',] }],
    tabindex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.tabindex',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__column',] }],
    hourCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__hourList',] }],
    minuteCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__minuteList',] }],
    ampmCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__ampmList',] }],
    onFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['focus',] }],
    onBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['blur',] }],
    onKeydownArrowDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowup', ['$event'],] }],
    onKeydownArrowRight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.enter', ['$event'],] }],
    onKeydownEscape: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.escape', ['$event'],] }],
    onHover: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['mouseover',] }],
    onScroll: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['wheel', ['$event'],] }],
    onPanMove: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['panmove', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxHourItemDirective {
    /**
     * @param {?} timePicker
     * @param {?} itemList
     */
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return true;
    }
    /**
     * @return {?}
     */
    get selectedCSS() {
        return this.isSelectedHour;
    }
    /**
     * @return {?}
     */
    get activeCSS() {
        return this.isSelectedHour && this.itemList.isActive;
    }
    /**
     * @return {?}
     */
    get isSelectedHour() {
        return this.timePicker.selectedHour === this.value;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollHourIntoView(item);
        }
    }
}
IgxHourItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxHourItem]'
            },] }
];
/** @nocollapse */
IgxHourItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxHourItemDirective.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxHourItem',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxMinuteItemDirective {
    /**
     * @param {?} timePicker
     * @param {?} itemList
     */
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return true;
    }
    /**
     * @return {?}
     */
    get selectedCSS() {
        return this.isSelectedMinute;
    }
    /**
     * @return {?}
     */
    get activeCSS() {
        return this.isSelectedMinute && this.itemList.isActive;
    }
    /**
     * @return {?}
     */
    get isSelectedMinute() {
        return this.timePicker.selectedMinute === this.value;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollMinuteIntoView(item);
        }
    }
}
IgxMinuteItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxMinuteItem]'
            },] }
];
/** @nocollapse */
IgxMinuteItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxMinuteItemDirective.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxMinuteItem',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxAmPmItemDirective {
    /**
     * @param {?} timePicker
     * @param {?} itemList
     */
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return true;
    }
    /**
     * @return {?}
     */
    get selectedCSS() {
        return this.isSelectedAmPm;
    }
    /**
     * @return {?}
     */
    get activeCSS() {
        return this.isSelectedAmPm && this.itemList.isActive;
    }
    /**
     * @return {?}
     */
    get isSelectedAmPm() {
        return this.timePicker.selectedAmPm === this.value;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollAmPmIntoView(item);
        }
    }
}
IgxAmPmItemDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxAmPmItem]'
            },] }
];
/** @nocollapse */
IgxAmPmItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxAmPmItemDirective.propDecorators = {
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['igxAmPmItem',] }],
    defaultCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['click', ['value'],] }]
};
/**
 * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
 */
class IgxTimePickerTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxTimePickerTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxTimePickerTemplate]'
            },] }
];
/** @nocollapse */
IgxTimePickerTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];
/**
 * This directive can be used to add custom action buttons to the dropdownb/dialog.
 */
class IgxTimePickerActionsDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxTimePickerActionsDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                selector: '[igxTimePickerActions]'
            },] }
];
/** @nocollapse */
IgxTimePickerActionsDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element loses focus.
 *
 */
class TimeDisplayFormatPipe {
    /**
     * @param {?} timePicker
     */
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        /** @type {?} */
        let hour;
        /** @type {?} */
        let minutes;
        /** @type {?} */
        let amPM;
        /** @type {?} */
        const maskAmPM = this.timePicker.parseMask();
        /** @type {?} */
        const mask = this.timePicker.parseMask(false);
        if (!value || value === mask || value === maskAmPM) {
            return '';
        }
        /** @type {?} */
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        /** @type {?} */
        const format = this.timePicker.format;
        /** @type {?} */
        const prompt = this.timePicker.promptChar;
        /** @type {?} */
        const regExp = new RegExp(this.timePicker.promptChar, 'g');
        if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
            hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
        }
        if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
            minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
        }
        if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
            hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
            /** @type {?} */
            const hourVal = parseInt(hour, 10);
            hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
        }
        if (format.indexOf('mm') === -1 && minutes !== undefined) {
            minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
            /** @type {?} */
            const minutesVal = parseInt(minutes, 10);
            minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
        }
        if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
            amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
        }
        /** @type {?} */
        let result = amPM ? `${hour}:${minutes} ${amPM}` : `${hour}:${minutes}`;
        if (!hour) {
            result = result.slice(result.indexOf(':') + 1, result.length);
        }
        if (!minutes) {
            result = result.slice(0, result.indexOf(':'));
            if (amPM) {
                result = result + ' ' + amPM;
            }
        }
        return result;
    }
}
TimeDisplayFormatPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{ name: 'displayFormat' },] }
];
/** @nocollapse */
TimeDisplayFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_TIME_PICKER_COMPONENT,] }] }
];
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element gets focus.
 *
 */
class TimeInputFormatPipe {
    /**
     * @param {?} timePicker
     */
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        /** @type {?} */
        const prompt = this.timePicker.promptChar;
        /** @type {?} */
        const regExp = new RegExp(prompt, 'g');
        /** @type {?} */
        let mask;
        /** @type {?} */
        let hour;
        /** @type {?} */
        let minutes;
        /** @type {?} */
        let amPM;
        if (this.timePicker.cleared) {
            this.timePicker.cleared = false;
            mask = this.timePicker.parseMask(false);
        }
        else {
            mask = this.timePicker.parseMask();
        }
        if (!value || value === mask) {
            return mask;
        }
        /** @type {?} */
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
            hour = hour.replace(regExp, '');
            /** @type {?} */
            const leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
            hour = leadZeroHour ? '0' + hour : hour;
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            minutes = minutes.replace(regExp, '');
            /** @type {?} */
            const leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
            minutes = leadZeroMinutes ? '0' + minutes : minutes;
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        /** @type {?} */
        let result = amPM ? `${hour}:${minutes} ${amPM}` : `${hour}:${minutes}`;
        if (!hour) {
            result = result.slice(result.indexOf(':') + 1, result.length);
        }
        if (!minutes) {
            result = result.slice(0, result.indexOf(':'));
            if (amPM) {
                result = result + ' ' + amPM;
            }
        }
        return result;
    }
}
TimeInputFormatPipe.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"], args: [{ name: 'inputFormat' },] }
];
/** @nocollapse */
TimeInputFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [IGX_TIME_PICKER_COMPONENT,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$u = 0;
/** @type {?} */
const HOURS_POS = [0, 1, 2];
/** @type {?} */
const MINUTES_POS = [3, 4, 5];
/** @type {?} */
const AMPM_POS = [6, 7, 8];
/** @type {?} */
const ITEMS_COUNT = 7;
class TimePickerHammerConfig extends _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HammerGestureConfig"] {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
}
TimePickerHammerConfig.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] }
];
class IgxTimePickerComponent {
    constructor() {
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.id = `igx-time-picker-${NEXT_ID$u++}`;
        /**
         * An \@Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
         * ```html
         * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.disabled = false;
        /**
         * An \@Input property that gets/sets the delta by which hour and minute items would be changed <br>
         * when the user presses the Up/Down keys.
         * By default `itemsDelta` is set to `{hours: 1, minutes:1}`
         * ```html
         * <igx-time-picker [itemsDelta]="{hours:3, minutes:5}" id="time-picker"></igx-time-picker>
         * ```
         */
        this.itemsDelta = { hours: 1, minutes: 1 };
        /**
         * An \@Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
         * The minutes and hour spinning will wrap around by default.
         * ```html
         * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An \@Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
         * ```html
         * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Sets the character used to prompt the user for input.
         * Default value is "'-'".
         * ```html
         * <igx-time-picker [promptChar] = "'_'">
         * ```
         * \@memberof IgxTimePickerComponent
         */
        this.promptChar = '-';
        /**
         * An \@Input property that allows you to switch the interaction mode between
         * a dialog picker or dropdown with editable masked input.
         * Deafult is dialog picker.
         * ```html
         * public mode = InteractionMode.DROPDOWN;
         *  //..
         * <igx-time-picker [mode]="mode"></igx-time-picker>
         * ```
         * \@memberof IgxTimePickerComponent
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValueChanged(timepicker){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
         * <igx-toast #toast message="The value has been changed!"></igx-toast>
         * ```
         */
        this.onValueChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
         * ```typescript
         * public min: string = "09:00";
         * public max: string = "18:00";
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValidationFailed(timepicker){
         *    this.toast.show();
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
         * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
         * ```
         */
        this.onValidationFailed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a timePicker is opened.
         */
        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a timePicker is closed.
         */
        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a timePicker is being closed.
         */
        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */
        this._hourItems = [];
        /**
         * @hidden
         */
        this._minuteItems = [];
        /**
         * @hidden
         */
        this._ampmItems = [];
        /**
         * @hidden
         */
        this.cleared = false;
        /**
         * @hidden
         */
        this.isNotEmpty = false;
        /**
         * @hidden
         */
        this.displayFormat = new TimeDisplayFormatPipe(this);
        /**
         * @hidden
         */
        this.inputFormat = new TimeInputFormatPipe(this);
        this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
        this._okButtonLabel = null;
        this._cancelButtonLabel = null;
        this._isHourListLoop = this.isSpinLoop;
        this._isMinuteListLoop = this.isSpinLoop;
        this._hourView = [];
        this._minuteView = [];
        this._ampmView = [];
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._onOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._onTouchedCallback = () => { };
        this._onChangeCallback = () => { };
    }
    /**
     * An accessor that allows you to set a time using the `value` input.
     * ```html
     * public date: Date = new Date(Date.now());
     *  //...
     * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (this._isValueValid(value)) {
            /** @type {?} */
            const oldVal = this._value;
            this._value = value;
            this._onChangeCallback(value);
            /** @type {?} */
            const dispVal = this._formatTime(this.value, this.format);
            if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
                this.displayValue = dispVal;
            }
            /** @type {?} */
            const args = {
                oldValue: oldVal,
                newValue: value
            };
            this.onValueChanged.emit(args);
        }
        else {
            /** @type {?} */
            const args = {
                timePicker: this,
                currentValue: value,
                setThroughUI: false
            };
            this.onValidationFailed.emit(args);
        }
    }
    /**
     * An accessor that returns the value of `igx-time-picker` component.
     * ```html
     * \@ViewChild("MyPick")
     * public pick: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let pickSelect = this.pick.value;
     * }
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     * @param {?} value
     * @return {?}
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     * @return {?}
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * An \@Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
     * ```html
     * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     * @param {?} value
     * @return {?}
     */
    set okButtonLabel(value) {
        this._okButtonLabel = value;
    }
    /**
     * An accessor that returns the label of ok button.
     * @return {?}
     */
    get okButtonLabel() {
        if (this._okButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_ok;
        }
        return this._okButtonLabel;
    }
    /**
     * An \@Input property that renders cancel button with custom text.
     * By default `cancelButtonLabel` is set to Cancel.
     * ```html
     * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     * @param {?} value
     * @return {?}
     */
    set cancelButtonLabel(value) {
        this._cancelButtonLabel = value;
    }
    /**
     * An accessor that returns the label of cancel button.
     * @return {?}
     */
    get cancelButtonLabel() {
        if (this._cancelButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_cancel;
        }
        return this._cancelButtonLabel;
    }
    /**
     * An \@Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
     * By default `format` is set to hh:mm tt. <br>
     * List of time-flags: <br>
     * `h` : hours field in 12-hours format without leading zero <br>
     * `hh` : hours field in 12-hours format with leading zero <br>
     * `H` : hours field in 24-hours format without leading zero <br>
     * `HH` : hours field in 24-hours format with leading zero <br>
     * `m` : minutes field without leading zero <br>
     * `mm` : minutes field with leading zero <br>
     * `tt` : 2 character string which represents AM/PM field <br>
     * ```html
     * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
     * ```
     * @return {?}
     */
    get format() {
        return this._format || 'hh:mm tt';
    }
    /**
     * @param {?} formatValue
     * @return {?}
     */
    set format(formatValue) {
        this._format = formatValue;
        this.mask = this._format.indexOf('tt') !== -1 ? '00:00 LL' : '00:00';
        if (!this.showHoursList || !this.showMinutesList) {
            this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
        }
        if (this.displayValue) {
            this.displayValue = this._formatTime(this.value, this._format);
        }
    }
    /**
     * An \@Input property that allows you to modify overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: true,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
     * ```
     * \@memberof IgxTimePickerComponent
     * @param {?} value
     * @return {?}
     */
    set overlaySettings(value) {
        this._overlaySettings = value;
    }
    /**
     * @return {?}
     */
    get overlaySettings() {
        return this._overlaySettings ? this._overlaySettings :
            (this.mode === InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings);
    }
    /**
     * @deprecated Use 'onOpened' instead.
     * Emitted when a timePicker is being opened.
     * ```html
     * \@ViewChild("toast")
     * private toast: IgxToastComponent;
     * public onOpen(timepicker){
     *    this.toast.show();
     * }
     * //...
     * ```
     * ```html
     * <igx-time-picker [minValue]="min" [maxValue]="max" (onOpen)="onOpen($event)"></igx-time-picker>
     * <igx-toast #toast message="The time picker has been opened!"></igx-toast>
     * ```
     * @return {?}
     */
    get onOpen() {
        return this._onOpen;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set onOpen(val) {
        this._onOpen = val;
    }
    /**
     * @deprecated Use 'onClosed' instead.
     * Emitted when a timePicker is being closed.
     * @return {?}
     */
    get onClose() {
        return this._onClose;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set onClose(val) {
        this._onClose = val;
    }
    /**
     * @hidden
     * @return {?}
     */
    get mask() {
        return this._mask || '00:00 LL';
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set mask(val) {
        this._mask = val;
    }
    /**
     * @hidden
     * @return {?}
     */
    get displayValue() {
        if (this._displayValue === undefined) {
            return this._formatTime(this.value, this.format);
        }
        return this._displayValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set displayValue(value) {
        this._displayValue = value;
    }
    /**
     * Returns the current time formatted as string using the `format` option.
     * If there is no set time the return is an empty string.
     * ```typescript
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let time = this.picker.displayTime;
     * }
     * ```
     * @return {?}
     */
    get displayTime() {
        if (this.value) {
            return this._formatTime(this.value, this.format);
        }
        return '';
    }
    /**
     * @hidden
     * @return {?}
     */
    get hourView() {
        return this._hourView;
    }
    /**
     * @hidden
     * @return {?}
     */
    get minuteView() {
        return this._minuteView;
    }
    /**
     * @hidden
     * @return {?}
     */
    get ampmView() {
        return this._ampmView;
    }
    /**
     * @hidden
     * @return {?}
     */
    get showClearButton() {
        return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
    }
    /**
     * @hidden
     * @return {?}
     */
    get showHoursList() {
        return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
    }
    /**
     * @hidden
     * @return {?}
     */
    get showMinutesList() {
        return this.format.indexOf('m') !== -1;
    }
    /**
     * @hidden
     * @return {?}
     */
    get showAmPmList() {
        return this.format.indexOf('t') !== -1;
    }
    /**
     * @hidden
     * @return {?}
     */
    get validMinuteEntries() {
        /** @type {?} */
        const minuteEntries = [];
        for (let i = 0; i < 60; i++) {
            minuteEntries.push(i);
        }
        return minuteEntries;
    }
    /**
     * @hidden
     * @return {?}
     */
    get validHourEntries() {
        /** @type {?} */
        const hourEntries = [];
        /** @type {?} */
        const index = this.format.indexOf('h') !== -1 ? 13 : 24;
        for (let i = 0; i < index; i++) {
            hourEntries.push(i);
        }
        return hourEntries;
    }
    /**
     * Gets the input group template.
     * ```typescript
     * let template = this.template();
     * ```
     * \@memberof IgxTimePickerComponent
     * @return {?}
     */
    get template() {
        if (this.timePickerTemplateDirective) {
            return this.timePickerTemplateDirective.template;
        }
        return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     * \@memberof IgxTimePickerComponent
     * @return {?}
     */
    get context() {
        return {
            value: this.value,
            displayTime: this.displayTime,
            displayValue: this.displayValue,
            openDialog: (target) => this.openDialog(target)
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._generateHours();
        this._generateMinutes();
        if (this.format.indexOf('tt') !== -1) {
            this._generateAmPm();
        }
        this._dropDownOverlaySettings = {
            modal: false,
            closeOnOutsideClick: true,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy()
        };
        this._dialogOverlaySettings = {};
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this.input) {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.input.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"])), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((event) => {
                if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                    event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                    this.spinOnEdit(event);
                }
            });
        }
        if (this.toggleRef && this.group) {
            this.toggleRef.element.style.width = this.group.element.nativeElement.getBoundingClientRect().width + 'px';
        }
        if (this.toggleRef) {
            this.toggleRef.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => {
                if (this._input) {
                    this._input.nativeElement.focus();
                }
                if (this.mode === InteractionMode.DropDown) {
                    this._onDropDownClosed();
                }
                this.onClosed.emit(this);
                // TODO: remove this line after deprecating 'onClose'
                this._onClose.emit(this);
            });
            this.toggleRef.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(() => {
                this.onOpened.emit(this);
                // TODO: remove this line after deprecating 'onOpen'
                this._onOpen.emit(this);
            });
            this.toggleRef.onClosing.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe((event) => {
                this.onClosing.emit(event);
            });
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydownSpace(event) {
        this.openDialog(this.getInputGroupElement());
        event.preventDefault();
    }
    /**
     * @hidden
     * @return {?}
     */
    onAltArrowDown() {
        this.openDialog(this.getInputGroupElement());
    }
    /**
     * @private
     * @param {?} item
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    _scrollItemIntoView(item, items, selectedItem, isListLoop, viewType) {
        /** @type {?} */
        let itemIntoView;
        if (items) {
            /** @type {?} */
            const index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
            /** @type {?} */
            let view;
            if (index !== -1) {
                if (isListLoop) {
                    if (index > 0) {
                        selectedItem = this._itemToString(items[index - 1], viewType);
                        itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                    }
                    else {
                        selectedItem = this._itemToString(items[1], viewType);
                        itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                    }
                }
                else {
                    view = items.slice(index - 3, index + 4);
                    selectedItem = this._itemToString(items[index], viewType);
                    itemIntoView = { selectedItem, view };
                }
                itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
            }
        }
        return itemIntoView;
    }
    /**
     * @private
     * @param {?} view
     * @param {?} viewType
     * @return {?}
     */
    _viewToString(view, viewType) {
        for (let i = 0; i < view.length; i++) {
            if (typeof (view[i]) !== 'string') {
                view[i] = this._itemToString(view[i], viewType);
            }
        }
        return view;
    }
    /**
     * @private
     * @param {?} item
     * @param {?} viewType
     * @return {?}
     */
    _itemToString(item, viewType) {
        if (item === null) {
            item = '';
        }
        else if (viewType && typeof (item) !== 'string') {
            /** @type {?} */
            const leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
            /** @type {?} */
            const leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
            /** @type {?} */
            const leadZero = (viewType === 'hour') ? leadZeroHour : leadZeroMinute;
            item = (leadZero) ? '0' + item : `${item}`;
        }
        return item;
    }
    /**
     * @private
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    _prevItem(items, selectedItem, isListLoop, viewType) {
        /** @type {?} */
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        /** @type {?} */
        const itemsCount = items.length;
        /** @type {?} */
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex - 4 < 0) {
                view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3));
            }
            else if (selectedIndex + 4 > itemsCount) {
                view = items.slice(selectedIndex - 4, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
            }
            selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
        }
        else if (selectedIndex > 3) {
            view = items.slice(selectedIndex - 4, selectedIndex + 3);
            selectedItem = items[selectedIndex - 1];
        }
        else if (selectedIndex === 3) {
            view = items.slice(0, 7);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    /**
     * @private
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    _nextItem(items, selectedItem, isListLoop, viewType) {
        /** @type {?} */
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        /** @type {?} */
        const itemsCount = items.length;
        /** @type {?} */
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex < 2) {
                view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5));
            }
            else if (selectedIndex + 4 >= itemsCount) {
                view = items.slice(selectedIndex - 2, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
            }
            selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
        }
        else if (selectedIndex + 1 < itemsCount - 3) {
            view = items.slice(selectedIndex - 2, selectedIndex + 5);
            selectedItem = items[selectedIndex + 1];
        }
        else if (selectedIndex === itemsCount - 4) {
            view = items.slice(selectedIndex - 3, itemsCount);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    /**
     * @private
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    _formatTime(value, format) {
        if (!value) {
            return '';
        }
        else {
            /** @type {?} */
            let hour = value.getHours();
            /** @type {?} */
            let formattedMinute;
            /** @type {?} */
            let formattedHour;
            /** @type {?} */
            const minute = value.getMinutes();
            /** @type {?} */
            const amPM = (hour > 11) ? 'PM' : 'AM';
            if (format.indexOf('h') !== -1) {
                if (hour > 12) {
                    hour -= 12;
                    formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : `${hour}`;
                }
                else if (hour === 0) {
                    formattedHour = '12';
                }
                else if (hour < 10 && format.indexOf('hh') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            else {
                if (hour < 10 && format.indexOf('HH') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : `${minute}`;
            return format.replace('hh', formattedHour).replace('h', formattedHour)
                .replace('HH', formattedHour).replace('H', formattedHour)
                .replace('mm', formattedMinute).replace('m', formattedMinute)
                .replace('tt', amPM);
        }
    }
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    _updateHourView(start, end) {
        this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
    }
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    _updateMinuteView(start, end) {
        this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
    }
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    _updateAmPmView(start, end) {
        this._ampmView = this._ampmItems.slice(start, end);
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    _addEmptyItems(items) {
        for (let i = 0; i < 3; i++) {
            items.push(null);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _generateHours() {
        /** @type {?} */
        let hourItemsCount = 24;
        if (this.format.indexOf('h') !== -1) {
            hourItemsCount = 13;
        }
        hourItemsCount /= this.itemsDelta.hours;
        /** @type {?} */
        let i = this.format.indexOf('H') !== -1 ? 0 : 1;
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
            this._isHourListLoop = false;
        }
        if (hourItemsCount > 1) {
            for (i; i < hourItemsCount; i++) {
                this._hourItems.push(i * this.itemsDelta.hours);
            }
        }
        else {
            this._hourItems.push(0);
        }
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _generateMinutes() {
        /** @type {?} */
        const minuteItemsCount = 60 / this.itemsDelta.minutes;
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
            this._isMinuteListLoop = false;
        }
        for (let i = 0; i < minuteItemsCount; i++) {
            this._minuteItems.push(i * this.itemsDelta.minutes);
        }
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _generateAmPm() {
        this._addEmptyItems(this._ampmItems);
        this._ampmItems.push('AM');
        this._ampmItems.push('PM');
        this._addEmptyItems(this._ampmItems);
    }
    /**
     * @private
     * @return {?}
     */
    _getSelectedTime() {
        /** @type {?} */
        const date = this.value ? new Date(this.value) : new Date();
        if (this.selectedHour) {
            date.setHours(parseInt(this.selectedHour, 10));
        }
        if (this.selectedMinute) {
            date.setMinutes(parseInt(this.selectedMinute, 10));
        }
        date.setSeconds(0);
        if (((this.showHoursList && this.selectedHour !== '12') || (!this.showHoursList && this.selectedHour <= '11')) &&
            this.selectedAmPm === 'PM') {
            date.setHours(date.getHours() + 12);
        }
        if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
            date.setHours(date.getHours() - 12);
        }
        if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
            date.setHours(0);
        }
        return date;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _convertMinMaxValue(value) {
        /** @type {?} */
        const date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
        /** @type {?} */
        const sections = value.split(/[\s:]+/);
        /** @type {?} */
        let hour;
        /** @type {?} */
        let minutes;
        /** @type {?} */
        let amPM;
        date.setSeconds(0);
        if (this.showHoursList) {
            hour = sections[0];
            date.setHours(parseInt(hour, 10));
        }
        if (this.showMinutesList) {
            minutes = this.showHoursList ? sections[1] : sections[0];
            date.setMinutes(parseInt(minutes, 10));
        }
        if (this.showAmPmList) {
            amPM = sections[sections.length - 1];
            if (((this.showHoursList && date.getHours().toString() !== '12') ||
                (!this.showHoursList && date.getHours().toString() <= '11')) && amPM === 'PM') {
                date.setHours(date.getHours() + 12);
            }
            if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
                date.setHours(date.getHours() - 12);
            }
            if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
                date.setHours(0);
            }
        }
        return date;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _isValueValid(value) {
        if (this.maxValue && value > this._convertMinMaxValue(this.maxValue)) {
            return false;
        }
        else if (this.minValue && value < this._convertMinMaxValue(this.minValue)) {
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * @private
     * @param {?} val
     * @return {?}
     */
    _isEntryValid(val) {
        /** @type {?} */
        let validH = true;
        /** @type {?} */
        let validM = true;
        /** @type {?} */
        const sections = val.split(/[\s:]+/);
        /** @type {?} */
        const re = new RegExp(this.promptChar, 'g');
        if (this.showHoursList) {
            validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
        }
        if (this.showMinutesList) {
            /** @type {?} */
            const minutes = this.showHoursList ? sections[1] : sections[0];
            validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
        }
        return validH && validM;
    }
    /**
     * @private
     * @return {?}
     */
    _getCursorPosition() {
        return this.input.nativeElement.selectionStart;
    }
    /**
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    _setCursorPosition(start, end = start) {
        this.input.nativeElement.setSelectionRange(start, end);
    }
    /**
     * @private
     * @return {?}
     */
    _updateEditableInput() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
        }
    }
    /**
     * @private
     * @param {?} currentVal
     * @param {?} minVal
     * @param {?} maxVal
     * @param {?} hDelta
     * @param {?} sign
     * @return {?}
     */
    _spinHours(currentVal, minVal, maxVal, hDelta, sign) {
        /** @type {?} */
        const oldVal = new Date(currentVal);
        currentVal.setMinutes(sign * hDelta);
        if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
            currentVal.setDate(oldVal.getDate());
        }
        /** @type {?} */
        let minutes = currentVal.getMinutes();
        if (currentVal.getTime() > maxVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                minVal.setMinutes(sign * minutes);
                return minVal;
            }
            else {
                return oldVal;
            }
        }
        else if (currentVal.getTime() < minVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                maxVal.setMinutes(minutes);
                return maxVal;
            }
            else {
                return oldVal;
            }
        }
        else {
            return currentVal;
        }
    }
    /**
     * @private
     * @param {?} currentVal
     * @param {?} mDelta
     * @param {?} sign
     * @return {?}
     */
    _spinMinutes(currentVal, mDelta, sign) {
        /** @type {?} */
        let minutes = currentVal.getMinutes() + (sign * mDelta);
        if (minutes < 0 || minutes >= 60) {
            minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
        }
        currentVal.setMinutes(minutes);
        return currentVal;
    }
    /**
     * @private
     * @return {?}
     */
    _initializeContainer() {
        if (this.value) {
            /** @type {?} */
            const formttedTime = this._formatTime(this.value, this.format);
            /** @type {?} */
            const sections = formttedTime.split(/[\s:]+/);
            if (this.showHoursList) {
                this.selectedHour = sections[0];
            }
            if (this.showMinutesList) {
                this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
            }
            if (this.showAmPmList && this._ampmItems !== null) {
                this.selectedAmPm = sections[sections.length - 1];
            }
        }
        if (this.selectedHour === undefined) {
            this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() :
                this.showHoursList ? `${this._hourItems[3]}` : '0';
        }
        if (this.selectedMinute === undefined) {
            this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
        }
        if (this.selectedAmPm === undefined && this._ampmItems !== null) {
            this.selectedAmPm = this._ampmItems[3];
        }
        this._prevSelectedHour = this.selectedHour;
        this._prevSelectedMinute = this.selectedMinute;
        this._prevSelectedAmPm = this.selectedAmPm;
        this._onTouchedCallback();
        this._updateHourView(0, ITEMS_COUNT);
        this._updateMinuteView(0, ITEMS_COUNT);
        this._updateAmPmView(0, ITEMS_COUNT);
        if (this.selectedHour) {
            this.scrollHourIntoView(this.selectedHour);
        }
        if (this.selectedMinute) {
            this.scrollMinuteIntoView(this.selectedMinute);
        }
        if (this.selectedAmPm) {
            this.scrollAmPmIntoView(this.selectedAmPm);
        }
        requestAnimationFrame(() => {
            if (this.hourList) {
                this.hourList.nativeElement.focus();
            }
            else if (this.minuteList) {
                this.minuteList.nativeElement.focus();
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    _onDropDownClosed() {
        /** @type {?} */
        const oldValue = this.value;
        /** @type {?} */
        const newVal = this._convertMinMaxValue(this.displayValue);
        if (this._isValueValid(newVal)) {
            if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                this.value = newVal;
            }
        }
        else {
            this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
            /** @type {?} */
            const args = {
                timePicker: this,
                currentValue: newVal,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this._input ? this._input.nativeElement : null;
    }
    /**
     * @hidden
     * @return {?}
     */
    getInputGroupElement() {
        return this.group ? this.group.element.nativeElement : null;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
        // against the real value when initializing the component and value is bound via ngModel
        this._dateFromModel = value;
        this.value = value;
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
        }
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /**
     * opens the dialog.
     * @param {?=} target HTMLElement - the target element to use for positioning the drop down container according to
     * ```html
     * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
     *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
     *                let-displayTime="displayTime">
     *     <igx-input-group>
     *       <input #dropDownTarget igxInput [value]="displayTime" />
     *       <igx-suffix (click)="openDialog(dropDownTarget)">
     *         <igx-icon>alarm</igx-icon>
     *       </igx-suffix>
     *     </igx-input-group>
     *   </ng-template>
     * </igx-time-picker>
     * ```
     * @return {?}
     */
    openDialog(target) {
        if (!this.toggleRef.collapsed) {
            return this._onDropDownClosed();
        }
        /** @type {?} */
        const settings = this.overlaySettings;
        if (target && settings && settings.positionStrategy) {
            settings.positionStrategy.settings.target = target;
        }
        if (this.outlet) {
            settings.outlet = this.outlet;
        }
        this.toggleRef.open(settings);
        this._initializeContainer();
    }
    /**
     * Scrolls a hour item into view.
     * ```typescript
     * scrhintoView(picker) {
     * picker.scrollHourIntoView('2');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrhintoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    scrollHourIntoView(item) {
        if (this.showHoursList) {
            /** @type {?} */
            const hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            if (hourIntoView) {
                this._hourView = hourIntoView.view;
                this.selectedHour = hourIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a minute item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollMinuteIntoView('3');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    scrollMinuteIntoView(item) {
        if (this.showMinutesList) {
            /** @type {?} */
            const minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            if (minuteIntoView) {
                this._minuteView = minuteIntoView.view;
                this.selectedMinute = minuteIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls an ampm item into view.
     * ```typescript
     * scrAmPmIntoView(picker) {
     * picker.scrollAmPmIntoView('PM');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrAmPmIntoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    scrollAmPmIntoView(item) {
        if (this.showAmPmList) {
            /** @type {?} */
            const ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
            if (ampmIntoView) {
                this._ampmView = ampmIntoView.view;
                this.selectedAmPm = ampmIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    nextHour() {
        /** @type {?} */
        const nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = nextHour.view;
        this.selectedHour = nextHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     * @return {?}
     */
    prevHour() {
        /** @type {?} */
        const prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = prevHour.view;
        this.selectedHour = prevHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     * @return {?}
     */
    nextMinute() {
        /** @type {?} */
        const nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = nextMinute.view;
        this.selectedMinute = nextMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     * @return {?}
     */
    prevMinute() {
        /** @type {?} */
        const prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = prevMinute.view;
        this.selectedMinute = prevMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     * @return {?}
     */
    nextAmPm() {
        /** @type {?} */
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex + 1 < this._ampmItems.length - 3) {
            this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
            this.selectedAmPm = this._ampmItems[selectedIndex + 1];
            this._updateEditableInput();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    prevAmPm() {
        /** @type {?} */
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex > 3) {
            this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
            this.selectedAmPm = this._ampmItems[selectedIndex - 1];
            this._updateEditableInput();
        }
    }
    /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     * @return {?}
     */
    okButtonClick() {
        /** @type {?} */
        const time = this._getSelectedTime();
        if (this._isValueValid(time)) {
            this.close();
            this.value = time;
            return true;
        }
        else {
            /** @type {?} */
            const args = {
                timePicker: this,
                currentValue: time,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
            return false;
        }
    }
    /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     * @return {?}
     */
    cancelButtonClick() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
        }
        this.close();
        this.selectedHour = this._prevSelectedHour;
        this.selectedMinute = this._prevSelectedMinute;
        this.selectedAmPm = this._prevSelectedAmPm;
    }
    /**
     * Returns an array of the hours currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let hInView = this.picker.hoursInView;
     * }
     * ```
     * @return {?}
     */
    hoursInView() {
        return this._hourView.filter((hour) => hour !== '');
    }
    /**
     * Returns an array of the minutes currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let minInView = this.picker.minutesInView;
     * }
     * ```
     * @return {?}
     */
    minutesInView() {
        return this._minuteView.filter((minute) => minute !== '');
    }
    /**
     * Returns an array of the AM/PM currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let ApInView = this.picker.ampmInView;
     * }
     * ```
     * @return {?}
     */
    ampmInView() {
        return this._ampmView.filter((ampm) => ampm !== '');
    }
    /**
     * Closes the dropdown/dialog.
     * ```html
     * <igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * \@ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.close();
     * ```
     * @return {?}
     */
    close() {
        this.toggleRef.close();
    }
    /**
     * @hidden
     * @param {?=} preserveAmPm
     * @return {?}
     */
    parseMask(preserveAmPm = true) {
        /** @type {?} */
        const maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
        /** @type {?} */
        const pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
        return preserveAmPm ? maskWithAmPm : pureMask;
    }
    /**
     * @hidden
     * @return {?}
     */
    clear() {
        if (this.toggleRef.collapsed) {
            this.cleared = true;
            this.isNotEmpty = false;
            /** @type {?} */
            const oldVal = new Date(this.value);
            this.displayValue = '';
            this.value.setHours(0, 0);
            if (oldVal.getTime() !== this.value.getTime()) {
                /** @type {?} */
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onInput(event) {
        /** @type {?} */
        const val = event.target.value;
        /** @type {?} */
        const oldVal = new Date(this.value);
        this.isNotEmpty = val !== this.parseMask(false);
        // handle cases where all empty positions (promts) are filled and we want to update
        // timepicker own value property if it is a valid Date
        if (val.indexOf(this.promptChar) === -1) {
            if (this._isEntryValid(val)) {
                /** @type {?} */
                const newVal = this._convertMinMaxValue(val);
                if (oldVal.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                /** @type {?} */
                const args = {
                    timePicker: this,
                    currentValue: val,
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
            // handle cases where the user deletes the display value (when pressing backspace or delete)
        }
        else if (!this.value || !val || val === this.parseMask(false)) {
            this.isNotEmpty = false;
            this.value.setHours(0, 0);
            this.displayValue = val;
            if (oldVal.getTime() !== this.value.getTime()) {
                /** @type {?} */
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.isNotEmpty = event.target.value !== this.parseMask(false);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        /** @type {?} */
        const value = event.target.value;
        this.isNotEmpty = value !== '';
        this.displayValue = value;
        if (value && value !== this.parseMask()) {
            if (this._isEntryValid(value)) {
                /** @type {?} */
                const newVal = this._convertMinMaxValue(value);
                if (!this.value || this.value.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                /** @type {?} */
                const args = {
                    timePicker: this,
                    currentValue: value,
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    spinOnEdit(event) {
        event.preventDefault();
        /** @type {?} */
        let sign;
        /** @type {?} */
        let displayVal;
        /** @type {?} */
        const currentVal = new Date(this.value);
        /** @type {?} */
        const min = this.minValue ? this._convertMinMaxValue(this.minValue) : this._convertMinMaxValue('00:00');
        /** @type {?} */
        const max = this.maxValue ? this._convertMinMaxValue(this.maxValue) : this._convertMinMaxValue('24:00');
        /** @type {?} */
        const cursor = this._getCursorPosition();
        if (event.key) {
            /** @type {?} */
            const key = event.key;
            sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
        }
        if (event.deltaY) {
            sign = event.deltaY < 0 ? 1 : -1;
        }
        if (!this.displayValue) {
            this.value = min;
            displayVal = this._formatTime(this.value, this.format);
        }
        else {
            /** @type {?} */
            const hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
            /** @type {?} */
            const mDelta = this.itemsDelta.minutes;
            if (this.showHoursList && HOURS_POS.indexOf(cursor) !== -1) {
                this.value = this._spinHours(currentVal, min, max, hDelta, sign);
            }
            if (this.showMinutesList &&
                ((this.showHoursList && MINUTES_POS.indexOf(cursor) !== -1) || (!this.showHoursList && HOURS_POS.indexOf(cursor) !== -1))) {
                this.value = this._spinMinutes(currentVal, mDelta, sign);
            }
            if (this.showAmPmList) {
                if (((!this.showHoursList || !this.showMinutesList) && MINUTES_POS.indexOf(cursor) !== -1) ||
                    (this.showHoursList && this.showMinutesList && AMPM_POS.indexOf(cursor) !== -1)) {
                    /** @type {?} */
                    const sections = this.displayValue.split(/[\s:]+/);
                    sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                    currentVal.setHours(currentVal.getHours() + (sign * 12));
                    this.value = currentVal;
                }
            }
            displayVal = this._formatTime(this.value, this.format);
        }
        // minor hack for preventing cursor jumping in IE
        this._displayValue = this.inputFormat.transform(displayVal);
        this.input.nativeElement.value = this._displayValue;
        this._setCursorPosition(cursor);
        requestAnimationFrame(() => {
            this._setCursorPosition(cursor);
        });
    }
}
IgxTimePickerComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                providers: [
                    {
                        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
                        useExisting: IgxTimePickerComponent,
                        multi: true
                    },
                    {
                        provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_GESTURE_CONFIG"],
                        useClass: TimePickerHammerConfig
                    },
                    {
                        provide: IGX_TIME_PICKER_COMPONENT,
                        useExisting: IgxTimePickerComponent
                    }
                ],
                selector: 'igx-time-picker',
                template: "<ng-template #dropdownInputTemplate>\n    <igx-input-group #group>\n        <label igxLabel>Time</label>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input #input type=\"text\" [igxMask]=\"mask\" igxInput [includeLiterals]=\"false\" [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\" [focusedValuePipe]=\"inputFormat\" [promptChar]=\"promptChar\"\n            [value]=\"displayValue\" (input)=\"onInput($event)\" (blur)=\"onBlur($event)\" (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\" [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon fontSet=\"material\">clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel>Time</label>\n        <input igxInput [value]=\"displayTime || ''\" [disabled]=\"disabled\" tabindex=\"0\" readonly />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\" *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\" *ngFor=\"let minute of minuteView\">{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\" *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\"></ng-container>\n    </div>\n</div>",
                styles: [`:host {
            display: block;
        }`]
            }] }
];
IgxTimePickerComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    resourceStrings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    okButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    cancelButtonLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    itemsDelta: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    minValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    maxValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isSpinLoop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    format: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    promptChar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    mode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    outlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    overlaySettings: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onValueChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onValidationFailed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onClosing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    hourList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['hourList', { static: false },] }],
    minuteList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['minuteList', { static: false },] }],
    ampmList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['ampmList', { static: false },] }],
    defaultTimePickerTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['defaultTimePickerTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    timePickerTemplateDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective, static: false },] }],
    timePickerActionsDirective: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective, static: false },] }],
    _input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxInputDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    toggleRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [IgxToggleDirective, { static: true },] }],
    input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['input', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], static: false },] }],
    group: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['group', { read: IgxInputGroupComponent, static: false },] }],
    dropdownInputTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['dropdownInputTemplate', { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: true },] }],
    onKeydownSpace: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.spacebar', ['$event'],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.space', ['$event'],] }],
    onAltArrowDown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"], args: ['keydown.Alt.ArrowDown',] }]
};
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'onOpen' @Output property is deprecated. Use 'onOpened' instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])
], IgxTimePickerComponent.prototype, "onOpen", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([
    DeprecateProperty(`'onClose' @Output property is deprecated. Use 'onClosed' instead.`),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])
], IgxTimePickerComponent.prototype, "onClose", null);
/**
 * @hidden
 */
class IgxTimePickerModule {
}
IgxTimePickerModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    IgxTimePickerComponent,
                    IgxHourItemDirective,
                    IgxItemListDirective,
                    IgxMinuteItemDirective,
                    IgxAmPmItemDirective,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                exports: [
                    IgxTimePickerComponent,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
                    IgxInputGroupModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxMaskModule,
                    IgxToggleModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let NEXT_ID$v = 0;
/**
 * **Ignite UI for Angular Toast** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast.html)
 *
 * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
 * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
 *
 * Example:
 * ```html
 * <button (click)="toast.show()">Show notification</button>
 * <igx-toast #toast
 *           message="Notification displayed"
 *           displayTime="1000">
 * </igx-toast>
 * ```
 */
class IgxToastComponent {
    /**
     * @param {?} elementRef
     * @param {?} navService
     */
    constructor(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        this._isVisible = false;
        /**
         * Returns a list of available CSS classes.
         * ```typescript
         * let toastClasses =  this.toast.CSS_CLASSES;
         * ```
         * \@memberof IgxToastComponent
         */
        this.CSS_CLASSES = {
            IGX_TOAST_BOTTOM: 'igx-toast--bottom',
            IGX_TOAST_MIDDLE: 'igx-toast--middle',
            IGX_TOAST_TOP: 'igx-toast--top'
        };
        /**
         * Sets/gets the `id` of the toast.
         * If not set, the `id` will have value `"igx-toast-0"`.
         * ```html
         * <igx-toast id = "my-first-toast"></igx-toast>
         * ```
         * ```typescript
         * let toastId = this.toast.id;
         * ```
         */
        this.id = `igx-toast-${NEXT_ID$v++}`;
        /**
         * Emits an event prior the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShowing) = "onShowing($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onShowing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShown) = "onShown($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onShown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event prior the toast is hidden.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHiding) = "onHiding($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onHiding = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         *  Emits an event when the toast is hidden.
         *  Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHidden) = "onHidden($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onHidden = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets the `role` attribute.
         * If not set, `role` will have value `"alert"`.
         * ```html
         * <igx-toast [role] = "'notify'"></igx-toast>
         * ```
         * ```typescript
         * let toastRole = this.toast.role;
         * ```
         * \@memberof IgxToastComponent
         */
        this.role = 'alert';
        /**
         * Sets/gets whether the toast will be hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-toast [autoHide] = "false"></igx-toast>
         * ```
         * ```typescript
         * let autoHide = this.toast.autoHide;
         * ```
         * \@memberof IgxToastComponent
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
         * after it is being shown.
         * Default value is `4000`.
         * ```html
         * <igx-toast [displayTime] = "2500"></igx-toast>
         * ```
         * ```typescript
         * let displayTime = this.toast.displayTime;
         * ```
         * \@memberof IgxToastComponent
         */
        this.displayTime = 4000;
        /**
         * @hidden
         */
        this.isVisibleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets the position of the toast.
         * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
         * ```html
         * <igx-toast [position] = "top"></igx-toast>
         * ```
         * ```typescript
         * let toastPosition = this.toast.position;
         * ```
         * \@memberof IgxToastComponent
         */
        this.position = IgxToastPosition.Bottom;
    }
    /**
     * Enables/Disables the visibility of the toast.
     * If not set, the `isVisible` attribute will have value `false`.
     * ```html
     * <igx-toast [isVisible] = "true"></igx-toast>
     * ```
     * ```typescript
     * let isVisible = this.toast.isVisible;
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-toast [(isVisible)] = "model.isVisible"></igx-toast>
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    get isVisible() {
        return this._isVisible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isVisible(value) {
        this._isVisible = value;
        this.isVisibleChange.emit(this._isVisible);
    }
    /**
     * Gets the nativeElement of the toast.
     * ```typescript
     * let nativeElement = this.toast.element;
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     * ```typescript
     * this.toast.show();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    show() {
        clearInterval(this.timeoutId);
        this.onShowing.emit(this);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(() => {
                this.hide();
            }, this.displayTime);
        }
        this.onShown.emit(this);
    }
    /**
     * Hides the toast.
     * ```typescript
     * this.toast.hide();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    hide() {
        this.onHiding.emit(this);
        this.isVisible = false;
        this.onHidden.emit(this);
        clearInterval(this.timeoutId);
    }
    /**
     * Wraps \@show() method due \@IToggleView interface implementation.
     * @hidden
     * @return {?}
     */
    open() {
        this.show();
    }
    /**
     * Wraps \@hide() method due \@IToggleView interface implementation.
     * @hidden
     * @return {?}
     */
    close() {
        this.hide();
    }
    /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    toggle() {
        this.isVisible ? this.close() : this.open();
    }
    /**
     * Sets/gets the class name of the toast based on the `position` value.
     * ```typescript
     * let className =  this.toast.mapPositionToClassName();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    mapPositionToClassName() {
        if (this.position === IgxToastPosition.Top) {
            return this.CSS_CLASSES.IGX_TOAST_TOP;
        }
        if (this.position === IgxToastPosition.Middle) {
            return this.CSS_CLASSES.IGX_TOAST_MIDDLE;
        }
        if (this.position === IgxToastPosition.Bottom) {
            return this.CSS_CLASSES.IGX_TOAST_BOTTOM;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    }
}
IgxToastComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                animations: [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animate', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('show', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                            opacity: 1
                        })),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => show', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('.20s ease')),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('show => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('.40s ease-out'))
                    ])
                ],
                selector: 'igx-toast',
                template: "<div [ngClass]=\"mapPositionToClassName()\" *ngIf=\"this.isVisible\" [@animate]=\"'show'\">\n    {{ message }}\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxToastComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: IgxNavigationService, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
];
IgxToastComponent.propDecorators = {
    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"], args: ['attr.id',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onShowing: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onShown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onHiding: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onHidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    autoHide: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    displayTime: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isVisible: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    isVisibleChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    message: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
};
/** @enum {number} */
const IgxToastPosition = {
    Bottom: 0,
    Middle: 1,
    Top: 2,
};
IgxToastPosition[IgxToastPosition.Bottom] = 'Bottom';
IgxToastPosition[IgxToastPosition.Middle] = 'Middle';
IgxToastPosition[IgxToastPosition.Top] = 'Top';
/**
 * @hidden
 */
class IgxToastModule {
}
IgxToastModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [IgxToastComponent],
                exports: [IgxToastComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */


//# sourceMappingURL=igniteui-angular.js.map


/***/ }),

/***/ "./node_modules/jszip/dist/jszip.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/dist/jszip.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/*!

JSZip v3.2.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":30,"./utils":32}],2:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":7,"./stream/GenericWorker":28}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};

},{"./utils":32}],5:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],6:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)
var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":37}],7:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":28,"./utils":32,"pako":38}],8:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":3,"./ZipFileWorker":8}],10:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.2.0";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":28,"../utils":32}],13:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}


NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":32,"readable-stream":16}],14:[function(require,module,exports){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(data, encoding);
        } else {
            if (typeof data === "number") {
                // Safeguard for old Node.js versions. On newer versions,
                // Buffer.from(number) / Buffer(number, encoding) already throw.
                throw new Error("The \"data\" argument must not be a number");
            }
            return new Buffer(data, encoding);
        }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function (size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

},{}],15:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is prefered but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              opts.platform === 'darwin' ||
              opts.platform === 'freebsd' ||
              opts.platform === 'linux' ||
              opts.platform === 'sunos'
          ) {
              opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
              opts.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(require,module,exports){
/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":undefined}],17:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":32,"./DataReader":18}],18:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":32}],19:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":32,"./DataReader":18}],21:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":32,"./ArrayReader":17}],22:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],24:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":32,"./GenericWorker":28}],25:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":32,"./GenericWorker":28}],27:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":32,"./GenericWorker":28}],28:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],29:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch(e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch(type) {
        case "blob" :
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64" :
            return base64.encode(content);
        default :
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(require,module,exports){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch(e) {
    exports.nodestream = false;
}

},{"readable-stream":16}],31:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('set-immediate-shim');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {
        
        
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("Can't read the data of '" + name + "'. Is it " +
                          "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var result = null, outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],37:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["finally"] = function (callback) {
  if (typeof callback !== 'function') {
    return this;
  }
  var p = this.constructor;
  return this.then(resolve, reject);

  function resolve(value) {
    function yes () {
      return value;
    }
    return p.resolve(callback()).then(yes);
  }
  function reject(reason) {
    function no () {
      throw reason;
    }
    return p.resolve(callback()).then(no);
  }
};
Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":36}],38:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],42:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":41}],43:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],44:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],45:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],46:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],48:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],49:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":41}],51:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],52:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":41}],53:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],54:[function(require,module,exports){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

},{}]},{},[10])(10)
});

/***/ }),

/***/ "./node_modules/ng2-material-dropdown/fesm2015/ng2-material-dropdown.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ng2-material-dropdown/fesm2015/ng2-material-dropdown.js ***!
  \******************************************************************************/
/*! exports provided: DropdownStateService, Ng2Dropdown, Ng2DropdownButton, Ng2DropdownMenu, Ng2DropdownModule, Ng2MenuItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropdownStateService", function() { return DropdownStateService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ng2Dropdown", function() { return Ng2Dropdown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ng2DropdownButton", function() { return Ng2DropdownButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ng2DropdownMenu", function() { return Ng2DropdownMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ng2DropdownModule", function() { return Ng2DropdownModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ng2MenuItem", function() { return Ng2MenuItem; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");





let Ng2DropdownButton = class Ng2DropdownButton {
    constructor(element) {
        this.element = element;
        this.onMenuToggled = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.showCaret = true;
    }
    /**
     * @name toggleMenu
     * @desc emits event to toggle menu
     */
    toggleMenu() {
        this.onMenuToggled.emit(true);
    }
    /**
     * @name getPosition
     * @desc returns position of the button
     */
    getPosition() {
        return this.element.nativeElement.getBoundingClientRect();
    }
};
Ng2DropdownButton.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()
], Ng2DropdownButton.prototype, "onMenuToggled", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2DropdownButton.prototype, "showCaret", void 0);
Ng2DropdownButton = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'ng2-dropdown-button',
        template: "<button class='ng2-dropdown-button' type=\"button\" (click)=\"toggleMenu()\" tabindex=\"0s\">\n    <span class=\"ng2-dropdown-button__label\">\n        <ng-content></ng-content>\n    </span>\n\n    <span class=\"ng2-dropdown-button__caret\" *ngIf=\"showCaret\">\n        <svg enable-background=\"new 0 0 32 32\" height=\"16px\" id=\"\u0421\u043B\u043E\u0439_1\" version=\"1.1\" viewBox=\"0 0 32 32\" width=\"16px\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"M24.285,11.284L16,19.571l-8.285-8.288c-0.395-0.395-1.034-0.395-1.429,0  c-0.394,0.395-0.394,1.035,0,1.43l8.999,9.002l0,0l0,0c0.394,0.395,1.034,0.395,1.428,0l8.999-9.002  c0.394-0.395,0.394-1.036,0-1.431C25.319,10.889,24.679,10.889,24.285,11.284z\" fill=\"#121313\" id=\"Expand_More\"/><g/><g/><g/><g/><g/><g/></svg>\n    </span>\n</button>\n",
        styles: [".ng2-dropdown-button{font-family:Roboto,\"Helvetica Neue\",Helvetica,Arial;background:#fff;padding:.45rem .25rem;font-size:14px;letter-spacing:.08rem;color:#444;outline:0;cursor:pointer;font-weight:400;border:none;border-bottom:1px solid #efefef;text-align:left;min-width:100px;width:100%;display:flex;flex-direction:row;max-width:150px}.ng2-dropdown-button:hover{color:#222}.ng2-dropdown-button:active,.ng2-dropdown-button:focus{color:#222;border-bottom:2px solid #2196f3}.ng2-dropdown-button__label{flex:1 1 95%}.ng2-dropdown-button__caret{width:12px;height:12px;display:flex;flex:1 1 6%}:host-context(.ng2-dropdown-button--icon) .ng2-dropdown-button{border:none;min-width:40px;width:40px;border-radius:100%;transition:.2s;text-align:center;height:40px;padding:.5em}:host-context(.ng2-dropdown-button--icon) .ng2-dropdown-button:active{background:rgba(0,0,0,.2)}"]
    })
], Ng2DropdownButton);

const KEYS = {
    BACKSPACE: 9,
    PREV: 38,
    NEXT: 40,
    ENTER: 13,
    ESCAPE: 27
};
/**
 * @name onSwitchNext
 * @param index
 * @param items
 * @param state
 */
const onSwitchNext = (index, items, state) => {
    if (index < items.length - 1) {
        state.select(items[index + 1], true);
    }
};
const ɵ0 = onSwitchNext;
/**
 * @name onSwitchPrev
 * @param index
 * @param items
 * @param state
 */
const onSwitchPrev = (index, items, state) => {
    if (index > 0) {
        state.select(items[index - 1], true);
    }
};
const ɵ1 = onSwitchPrev;
/**
 * @name onBackspace
 * @param index
 * @param items
 * @param state
 */
const onBackspace = (index, items, state) => {
    if (index < items.length - 1) {
        state.select(items[index + 1], true);
    }
    else {
        state.select(items[0], true);
    }
};
const ɵ2 = onBackspace;
function onEscape() {
    this.hide();
}
;
/**
 * @name onItemClicked
 * @param index
 * @param items
 * @param state
 */
const onItemClicked = (index, items, state) => {
    return state.selectedItem ? state.selectedItem.click() : undefined;
};
const ɵ3 = onItemClicked;
const ACTIONS = {
    [KEYS.BACKSPACE]: onBackspace,
    [KEYS.PREV]: onSwitchPrev,
    [KEYS.NEXT]: onSwitchNext,
    [KEYS.ENTER]: onItemClicked,
    [KEYS.ESCAPE]: onEscape
};
function arrowKeysHandler(event) {
    if ([38, 40].indexOf(event.keyCode) > -1) {
        event.preventDefault();
    }
}

class Ng2DropdownState {
    constructor() {
        this.onItemSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onItemClicked = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onItemDestroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    /**
     * @name selectedItem
     * @desc getter for _selectedItem
     */
    get selectedItem() {
        return this._selectedItem;
    }
    /**
     * @name selects a menu item and emits event
     * @param item
     */
    select(item, dispatchEvent = true) {
        this._selectedItem = item;
        if (!dispatchEvent || !item) {
            return;
        }
        item.focus();
        this.onItemSelected.emit(item);
    }
    /**
     * @name unselect
     * @desc sets _selectedItem as undefined
     */
    unselect() {
        this._selectedItem = undefined;
    }
}

let DropdownStateService = class DropdownStateService {
    constructor() {
        this.menuState = {
            isVisible: false,
            toString() {
                return this.isVisible === true ? 'visible' : 'hidden';
            }
        };
        this.dropdownState = new Ng2DropdownState();
    }
};
DropdownStateService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])()
], DropdownStateService);

let Ng2MenuItem = class Ng2MenuItem {
    constructor(state, element) {
        this.state = state;
        this.element = element;
        /**
         * @preventClose
         * @desc if true, clicking on the item won't close the dropdown
         */
        this.preventClose = false;
    }
    ngOnDestroy() {
        this.state.dropdownState.onItemDestroyed.emit(this);
    }
    /**
     * @name isSelected
     * @desc returns current selected item
     */
    get isSelected() {
        return this === this.state.dropdownState.selectedItem;
    }
    /**
     * @name click
     * @desc emits select event
     */
    select($event) {
        this.state.dropdownState.select(this, true);
        if ($event) {
            $event.stopPropagation();
            $event.preventDefault();
        }
    }
    /**
     * @name click
     * @desc emits click event
     */
    click() {
        this.state.dropdownState.onItemClicked.emit(this);
    }
    /**
     * @name focus
     */
    focus() {
        this.element.nativeElement.children[0].focus();
    }
};
Ng2MenuItem.ctorParameters = () => [
    { type: DropdownStateService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2MenuItem.prototype, "preventClose", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2MenuItem.prototype, "value", void 0);
Ng2MenuItem = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'ng2-menu-item',
        template: `
        <div
            class="ng2-menu-item"
            role="button"
            tabindex="0"
            [class.ng2-menu-item--selected]="isSelected"
            (keydown.enter)="click()"
            (click)="click()"
            (mouseover)="select()"
        >
            <ng-content></ng-content>
        </div>
    `,
        styles: [".ng2-menu-item{font-family:Roboto,\"Helvetica Neue\",Helvetica,Arial;background:#fff;color:rgba(0,0,0,.87);cursor:pointer;font-size:.9em;text-transform:none;font-weight:400;letter-spacing:.03em;height:48px;line-height:48px;padding:.3em 1.25rem;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;transition:background .25s}.ng2-menu-item--selected{background:rgba(158,158,158,.2);outline:0}.ng2-menu-item:focus{outline:0}.ng2-menu-item:active{background:rgba(158,158,158,.4)}:host(ng2-menu-item) ::ng-deep [ng2-menu-item-icon]{vertical-align:middle;font-size:28px;width:1.5em;height:30px;color:rgba(0,0,0,.44)}"]
    })
], Ng2MenuItem);

let Ng2DropdownMenu = class Ng2DropdownMenu {
    constructor(dropdownState, element, renderer) {
        this.dropdownState = dropdownState;
        this.element = element;
        this.renderer = renderer;
        /**
         * @name width
         */
        this.width = 4;
        /**
         * @description if set to true, the first element of the dropdown will be automatically focused
         * @name focusFirstElement
         */
        this.focusFirstElement = true;
        /**
         * @name appendToBody
         */
        this.appendToBody = true;
        /**
         * @name zIndex
         */
        this.zIndex = 1000;
        this.listeners = {
            arrowHandler: undefined,
            handleKeypress: undefined
        };
    }
    /**
     * @name show
     * @shows menu and selects first item
     */
    show(position, dynamic = true) {
        const dc = typeof document !== 'undefined' ? document : undefined;
        const wd = typeof window !== 'undefined' ? window : undefined;
        if (!this.dropdownState.menuState.isVisible) {
            // setting handlers
            this.listeners.handleKeypress = this.renderer.listen(dc.body, 'keydown', this.handleKeypress.bind(this));
            this.listeners.arrowHandler = this.renderer.listen(wd, 'keydown', arrowKeysHandler);
        }
        // update state
        this.dropdownState.menuState.isVisible = true;
        if (position) {
            this.updatePosition(position, dynamic);
        }
    }
    /**
     * @name hide
     * @desc hides menu
     */
    hide() {
        this.dropdownState.menuState.isVisible = false;
        // reset selected item state
        this.dropdownState.dropdownState.unselect();
        // call function to unlisten
        this.listeners.arrowHandler && this.listeners.arrowHandler();
        this.listeners.handleKeypress && this.listeners.handleKeypress();
    }
    /**
     * @name updatePosition
     * @desc updates the menu position every time it is toggled
     * @param position {ClientRect}
     * @param dynamic {boolean}
     */
    updatePosition(position, dynamic) {
        this.position = position;
        this.updateOnChange(dynamic);
    }
    /**
     * @name handleKeypress
     * @desc executes functions on keyPress based on the key pressed
     * @param $event
     */
    handleKeypress($event) {
        const key = $event.keyCode;
        const items = this.items.toArray();
        const index = items.indexOf(this.dropdownState.dropdownState.selectedItem);
        if (!ACTIONS.hasOwnProperty(key)) {
            return;
        }
        ACTIONS[key].call(this, index, items, this.dropdownState.dropdownState);
    }
    /**
     * @name getMenuElement
     */
    getMenuElement() {
        return this.element.nativeElement.children[0];
    }
    /**
     * @name calcPositionOffset
     * @param position
     */
    calcPositionOffset(position) {
        const wd = typeof window !== 'undefined' ? window : undefined;
        const dc = typeof document !== 'undefined' ? document : undefined;
        if (!wd || !dc || !position) {
            return;
        }
        const element = this.getMenuElement();
        const supportPageOffset = wd.pageXOffset !== undefined;
        const isCSS1Compat = (dc.compatMode || '') === 'CSS1Compat';
        const x = supportPageOffset
            ? wd.pageXOffset
            : isCSS1Compat
                ? dc.documentElement.scrollLeft
                : dc.body.scrollLeft;
        const y = supportPageOffset
            ? wd.pageYOffset
            : isCSS1Compat
                ? dc.documentElement.scrollTop
                : dc.body.scrollTop;
        let { top, left } = this.applyOffset(`${position.top + (this.appendToBody ? y - 15 : 0)}px`, `${position.left + x - 5}px`);
        const clientWidth = element.clientWidth;
        const clientHeight = element.clientHeight;
        const marginFromBottom = parseInt(top) + clientHeight + (this.appendToBody ? 0 : y - 15);
        const marginFromRight = parseInt(left) + clientWidth;
        const windowScrollHeight = wd.innerHeight + wd.scrollY;
        const windowScrollWidth = wd.innerWidth + wd.scrollX;
        if (marginFromBottom >= windowScrollHeight) {
            top = `${parseInt(top.replace('px', '')) - clientHeight}px`;
        }
        if (marginFromRight >= windowScrollWidth) {
            const marginRight = marginFromRight - windowScrollWidth + 30;
            left = `${parseInt(left.replace('px', '')) - marginRight}px`;
        }
        return { top, left };
    }
    applyOffset(top, left) {
        if (!this.offset) {
            return { top, left };
        }
        const offset = this.offset.split(' ');
        if (!offset[1]) {
            offset[1] = '0';
        }
        top = `${parseInt(top.replace('px', '')) + parseInt(offset[0])}px`;
        left = `${parseInt(left.replace('px', '')) + parseInt(offset[1])}px`;
        return { top, left };
    }
    ngOnInit() {
        const dc = typeof document !== 'undefined' ? document : undefined;
        if (this.appendToBody) {
            // append menu element to the body
            dc.body.appendChild(this.element.nativeElement);
        }
    }
    updateOnChange(dynamic = true) {
        const element = this.getMenuElement();
        const position = this.calcPositionOffset(this.position);
        if (position) {
            this.renderer.setStyle(element, 'top', position.top.toString());
            this.renderer.setStyle(element, 'left', position.left.toString());
        }
        // select first item unless user disabled this option
        if (this.focusFirstElement &&
            this.items.first &&
            !this.dropdownState.dropdownState.selectedItem) {
            this.dropdownState.dropdownState.select(this.items.first, false);
        }
    }
    ngOnDestroy() {
        const elem = this.element.nativeElement;
        elem.parentNode.removeChild(elem);
        if (this.listeners.handleKeypress) {
            this.listeners.handleKeypress();
        }
    }
};
Ng2DropdownMenu.ctorParameters = () => [
    { type: DropdownStateService },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2DropdownMenu.prototype, "width", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2DropdownMenu.prototype, "focusFirstElement", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2DropdownMenu.prototype, "offset", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2DropdownMenu.prototype, "appendToBody", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2DropdownMenu.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"])(Ng2MenuItem, { descendants: true })
], Ng2DropdownMenu.prototype, "items", void 0);
Ng2DropdownMenu = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'ng2-dropdown-menu',
        template: `
        <!-- MENU -->
        <div
            class="ng2-dropdown-menu ng2-dropdown-menu---width--{{ width }}"
            [class.ng2-dropdown-menu--inside-element]="!appendToBody"
            [class.ng2-dropdown-menu--open]="dropdownState.menuState.isVisible"
            [style.z-index]="zIndex"
            [@fade]="dropdownState.menuState.toString()"
        >
            <div
                class="ng2-dropdown-menu__options-container"
                [@opacity]="dropdownState.menuState.toString()"
            >
                <ng-content></ng-content>
            </div>
        </div>

        <!-- BACKDROP -->
        <div
            class="ng2-dropdown-backdrop"
            *ngIf="dropdownState.menuState.isVisible"
            (click)="hide()"
        ></div>
    `,
        animations: [
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])('fade', [
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 1, height: '*', width: '*' })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 0, overflow: 'hidden', height: 0, width: 0 })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('hidden => visible', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('250ms ease-in', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 1, height: '*', width: '*' }))
                ]),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('visible => hidden', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('350ms ease-out', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 0, width: 0, height: 0 }))
                ])
            ]),
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])('opacity', [
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('hidden => visible', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('450ms ease-in', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 0, offset: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 1, offset: 1 })
                    ]))
                ]),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('visible => hidden', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('250ms ease-out', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 1, offset: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 0.5, offset: 0.3 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({ opacity: 0, offset: 1 })
                    ]))
                ])
            ])
        ],
        styles: [":host{display:block}.ng2-dropdown-menu{overflow-y:auto;box-shadow:0 1px 2px 0 rgba(0,0,0,.3);position:absolute;padding:.5em 0;background:#fff;border-radius:1px;max-height:400px;width:260px;min-height:0;display:block}.ng2-dropdown-menu.ng2-dropdown-menu--inside-element{position:fixed}.ng2-dropdown-menu.ng2-dropdown-menu--width--2{width:200px}.ng2-dropdown-menu.ng2-dropdown-menu--width--4{width:260px}.ng2-dropdown-menu.ng2-dropdown-menu--width--6{width:320px}.ng2-dropdown-backdrop{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1;overflow:hidden}:host ::ng-deep .ng2-menu-divider{height:1px;min-height:1px;max-height:1px;width:100%;display:block;background:#f9f9f9}"]
    })
], Ng2DropdownMenu);

let Ng2Dropdown = class Ng2Dropdown {
    constructor(state) {
        this.state = state;
        this.dynamicUpdate = true;
        // outputs
        this.onItemClicked = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onItemSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onShow = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onHide = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    ngOnInit() {
        this.state.dropdownState.onItemClicked.subscribe(item => {
            this.onItemClicked.emit(item);
            if (item.preventClose) {
                return;
            }
            this.hide.call(this);
        });
        if (this.button) {
            this.button.onMenuToggled.subscribe(() => {
                this.toggleMenu();
            });
        }
        this.state.dropdownState.onItemSelected.subscribe(item => {
            this.onItemSelected.emit(item);
        });
        this.state.dropdownState.onItemDestroyed.subscribe((item) => {
            let newSelectedItem;
            const items = this.menu.items.toArray();
            if (item !== this.state.dropdownState.selectedItem) {
                return;
            }
            if (this.menu.focusFirstElement) {
                newSelectedItem =
                    item === items[0] && items.length > 1
                        ? items[1]
                        : items[0];
            }
            this.state.dropdownState.select(newSelectedItem);
        });
    }
    /**
     * @name toggleMenu
     * @desc toggles menu visibility
     */
    toggleMenu(position = this.button.getPosition()) {
        this.state.menuState.isVisible ? this.hide() : this.show(position);
    }
    /**
     * - hides dropdown
     * @name hide
     */
    hide() {
        this.menu.hide();
        this.onHide.emit(this);
    }
    /**
     * - shows dropdown
     * @name show
     * @param position
     */
    show(position = this.button.getPosition()) {
        this.menu.show(position, this.dynamicUpdate);
        this.onShow.emit(this);
    }
    /**
     * @name scrollListener
     */
    scrollListener() {
        if (this.button && this.dynamicUpdate) {
            this.menu.updatePosition(this.button.getPosition(), true);
        }
    }
};
Ng2Dropdown.ctorParameters = () => [
    { type: DropdownStateService }
];
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"])(Ng2DropdownButton, { static: true })
], Ng2Dropdown.prototype, "button", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"])(Ng2DropdownMenu, { static: true })
], Ng2Dropdown.prototype, "menu", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()
], Ng2Dropdown.prototype, "dynamicUpdate", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()
], Ng2Dropdown.prototype, "onItemClicked", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()
], Ng2Dropdown.prototype, "onItemSelected", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()
], Ng2Dropdown.prototype, "onShow", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()
], Ng2Dropdown.prototype, "onHide", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('window:scroll')
], Ng2Dropdown.prototype, "scrollListener", null);
Ng2Dropdown = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'ng2-dropdown',
        template: `
        <div class="ng2-dropdown-container">
            <ng-content select="ng2-dropdown-button"></ng-content>
            <ng-content select="ng2-dropdown-menu"></ng-content>
        </div>
    `,
        providers: [DropdownStateService]
    })
], Ng2Dropdown);

let Ng2DropdownModule = class Ng2DropdownModule {
};
Ng2DropdownModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
        exports: [
            Ng2MenuItem,
            Ng2DropdownButton,
            Ng2DropdownMenu,
            Ng2Dropdown
        ],
        declarations: [
            Ng2Dropdown,
            Ng2MenuItem,
            Ng2DropdownButton,
            Ng2DropdownMenu,
        ],
        imports: [
            _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]
        ]
    })
], Ng2DropdownModule);

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=ng2-material-dropdown.js.map


/***/ }),

/***/ "./node_modules/ngx-chips/fesm2015/ngx-chips.js":
/*!******************************************************!*\
  !*** ./node_modules/ngx-chips/fesm2015/ngx-chips.js ***!
  \******************************************************/
/*! exports provided: DeleteIconComponent, TagComponent, TagInputComponent, TagInputDropdown, TagInputForm, TagInputModule, TagRipple, ɵa, ɵb, ɵc, ɵd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeleteIconComponent", function() { return DeleteIconComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagComponent", function() { return TagComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagInputComponent", function() { return TagInputComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagInputDropdown", function() { return TagInputDropdown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagInputForm", function() { return TagInputForm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagInputModule", function() { return TagInputModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagRipple", function() { return TagRipple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return TagInputAccessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function() { return animations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function() { return DragProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function() { return HighlightPipe; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
/* harmony import */ var ng2_material_dropdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ng2-material-dropdown */ "./node_modules/ng2-material-dropdown/fesm2015/ng2-material-dropdown.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");








const escape = s => s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
let HighlightPipe = class HighlightPipe {
    /**
     * @name transform
     * @param value {string}
     * @param arg {string}
     */
    transform(value, arg) {
        if (!arg.trim()) {
            return value;
        }
        try {
            const regex = new RegExp(`(${escape(arg)})`, 'i');
            return value.replace(regex, '<b>$1</b>');
        }
        catch (e) {
            return value;
        }
    }
};
HighlightPipe = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"])({
        name: 'highlight'
    })
], HighlightPipe);

/*
** constants and default values for <tag-input>
 */
const PLACEHOLDER = '+ Tag';
const SECONDARY_PLACEHOLDER = 'Enter a new tag';
const KEYDOWN = 'keydown';
const KEYUP = 'keyup';
const MAX_ITEMS_WARNING = 'The number of items specified was greater than the property max-items.';
const ACTIONS_KEYS = {
    DELETE: 'DELETE',
    SWITCH_PREV: 'SWITCH_PREV',
    SWITCH_NEXT: 'SWITCH_NEXT',
    TAB: 'TAB'
};
const KEY_PRESS_ACTIONS = {
    8: ACTIONS_KEYS.DELETE,
    37: ACTIONS_KEYS.SWITCH_PREV,
    39: ACTIONS_KEYS.SWITCH_NEXT,
    9: ACTIONS_KEYS.TAB
};
const DRAG_AND_DROP_KEY = 'Text';
const NEXT = 'NEXT';
const PREV = 'PREV';

let DragProvider = class DragProvider {
    constructor() {
        this.state = {
            dragging: false,
            dropping: false,
            index: undefined
        };
    }
    /**
     * @name setDraggedItem
     * @param event
     * @param tag
     */
    setDraggedItem(event, tag) {
        if (event && event.dataTransfer) {
            event.dataTransfer.setData(DRAG_AND_DROP_KEY, JSON.stringify(tag));
        }
    }
    /**
     * @name getDraggedItem
     * @param event
     */
    getDraggedItem(event) {
        if (event && event.dataTransfer) {
            const data = event.dataTransfer.getData(DRAG_AND_DROP_KEY);
            try {
                return JSON.parse(data);
            }
            catch (_a) {
                return;
            }
        }
    }
    /**
     * @name setSender
     * @param sender
     */
    setSender(sender) {
        this.sender = sender;
    }
    /**
     * @name setReceiver
     * @param receiver
     */
    setReceiver(receiver) {
        this.receiver = receiver;
    }
    /**
     * @name onTagDropped
     * @param tag
     * @param indexDragged
     * @param indexDropped
     */
    onTagDropped(tag, indexDragged, indexDropped) {
        this.onDragEnd();
        this.sender.onRemoveRequested(tag, indexDragged);
        this.receiver.onAddingRequested(false, tag, indexDropped);
    }
    /**
     * @name setState
     * @param state
     */
    setState(state) {
        this.state = Object.assign({}, this.state, state);
    }
    /**
     * @name getState
     * @param key
     */
    getState(key) {
        return key ? this.state[key] : this.state;
    }
    /**
     * @name onDragEnd
     */
    onDragEnd() {
        this.setState({
            dragging: false,
            dropping: false,
            index: undefined
        });
    }
};
DragProvider = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])()
], DragProvider);

const defaults = {
    tagInput: {
        separatorKeys: [],
        separatorKeyCodes: [],
        maxItems: Infinity,
        placeholder: PLACEHOLDER,
        secondaryPlaceholder: SECONDARY_PLACEHOLDER,
        validators: [],
        asyncValidators: [],
        onlyFromAutocomplete: false,
        errorMessages: {},
        theme: '',
        onTextChangeDebounce: 250,
        inputId: null,
        inputClass: '',
        clearOnBlur: false,
        hideForm: false,
        addOnBlur: false,
        addOnPaste: false,
        pasteSplitPattern: ',',
        blinkIfDupe: true,
        removable: true,
        editable: false,
        allowDupes: false,
        modelAsStrings: false,
        trimTags: true,
        ripple: true,
        tabIndex: '',
        disable: false,
        dragZone: '',
        onRemoving: undefined,
        onAdding: undefined,
        displayBy: 'display',
        identifyBy: 'value',
        animationDuration: {
            enter: '250ms',
            leave: '150ms'
        }
    },
    dropdown: {
        displayBy: 'display',
        identifyBy: 'value',
        appendToBody: true,
        offset: '50 0',
        focusFirstElement: false,
        showDropdownIfEmpty: false,
        minimumTextLength: 1,
        limitItemsTo: Infinity,
        keepOpen: true,
        dynamicUpdate: true,
        zIndex: 1000,
        matchingFn
    }
};
/**
 * @name matchingFn
 * @param this
 * @param value
 * @param target
 */
function matchingFn(value, target) {
    const targetValue = target[this.displayBy].toString();
    return targetValue && targetValue
        .toLowerCase()
        .indexOf(value.toLowerCase()) >= 0;
}

class OptionsProvider {
    setOptions(options) {
        OptionsProvider.defaults.tagInput = Object.assign({}, defaults.tagInput, options.tagInput);
        OptionsProvider.defaults.dropdown = Object.assign({}, defaults.dropdown, options.dropdown);
    }
}
OptionsProvider.defaults = defaults;

function isObject(obj) {
    return obj === Object(obj);
}
class TagInputAccessor {
    constructor() {
        this._items = [];
        /**
         * @name displayBy
         */
        this.displayBy = OptionsProvider.defaults.tagInput.displayBy;
        /**
         * @name identifyBy
         */
        this.identifyBy = OptionsProvider.defaults.tagInput.identifyBy;
    }
    get items() {
        return this._items;
    }
    set items(items) {
        this._items = items;
        this._onChangeCallback(this._items);
    }
    onTouched() {
        this._onTouchedCallback();
    }
    writeValue(items) {
        this._items = items || [];
    }
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @name getItemValue
     * @param item
     * @param fromDropdown
     */
    getItemValue(item, fromDropdown = false) {
        const property = fromDropdown && this.dropdown ? this.dropdown.identifyBy : this.identifyBy;
        return isObject(item) ? item[property] : item;
    }
    /**
     * @name getItemDisplay
     * @param item
     * @param fromDropdown
     */
    getItemDisplay(item, fromDropdown = false) {
        const property = fromDropdown && this.dropdown ? this.dropdown.displayBy : this.displayBy;
        return isObject(item) ? item[property] : item;
    }
    /**
     * @name getItemsWithout
     * @param index
     */
    getItemsWithout(index) {
        return this.items.filter((item, position) => position !== index);
    }
}
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputAccessor.prototype, "displayBy", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputAccessor.prototype, "identifyBy", void 0);

/**
 * @name listen
 * @param listenerType
 * @param action
 * @param condition
 */
function listen(listenerType, action, condition = true) {
    // if the event provided does not exist, throw an error
    if (!this.listeners.hasOwnProperty(listenerType)) {
        throw new Error('The event entered may be wrong');
    }
    // if a condition is present and is false, exit early
    if (!condition) {
        return;
    }
    // fire listener
    this.listeners[listenerType].push(action);
}

let TagInputForm = class TagInputForm {
    constructor() {
        /**
         * @name onSubmit
         */
        this.onSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onBlur
         */
        this.onBlur = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onFocus
         */
        this.onFocus = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onKeyup
         */
        this.onKeyup = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onKeydown
         */
        this.onKeydown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name inputTextChange
         */
        this.inputTextChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name validators
         */
        this.validators = [];
        /**
         * @name asyncValidators
         * @desc array of AsyncValidator that are used to validate the tag before it gets appended to the list
         */
        this.asyncValidators = [];
        /**
         * @name tabindex
         * @desc pass through the specified tabindex to the input
         */
        this.tabindex = '';
        /**
         * @name disabled
         */
        this.disabled = false;
        this.item = new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"]({ value: '', disabled: this.disabled });
    }
    /**
     * @name inputText
     */
    get inputText() {
        return this.item.value;
    }
    /**
     * @name inputText
     * @param text {string}
     */
    set inputText(text) {
        this.item.setValue(text);
        this.inputTextChange.emit(text);
    }
    ngOnInit() {
        this.item.setValidators(this.validators);
        this.item.setAsyncValidators(this.asyncValidators);
        // creating form
        this.form = new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormGroup"]({
            item: this.item
        });
    }
    ngOnChanges(changes) {
        if (changes.disabled && !changes.disabled.firstChange) {
            if (changes.disabled.currentValue) {
                this.form.controls['item'].disable();
            }
            else {
                this.form.controls['item'].enable();
            }
        }
    }
    /**
     * @name value
     */
    get value() {
        return this.form.get('item');
    }
    /**
     * @name isInputFocused
     */
    isInputFocused() {
        const doc = typeof document !== 'undefined' ? document : undefined;
        return doc ? doc.activeElement === this.input.nativeElement : false;
    }
    /**
     * @name getErrorMessages
     * @param messages
     */
    getErrorMessages(messages) {
        return Object.keys(messages)
            .filter(err => this.value.hasError(err))
            .map(err => messages[err]);
    }
    /**
     * @name hasErrors
     */
    hasErrors() {
        const { dirty, value, valid } = this.form;
        return dirty && value.item && !valid;
    }
    /**
     * @name focus
     */
    focus() {
        this.input.nativeElement.focus();
    }
    /**
     * @name blur
     */
    blur() {
        this.input.nativeElement.blur();
    }
    /**
     * @name getElementPosition
     */
    getElementPosition() {
        return this.input.nativeElement.getBoundingClientRect();
    }
    /**
     * - removes input from the component
     * @name destroy
     */
    destroy() {
        const input = this.input.nativeElement;
        input.parentElement.removeChild(input);
    }
    /**
     * @name onKeyDown
     * @param $event
     */
    onKeyDown($event) {
        this.inputText = this.value.value;
        if ($event.key === 'Enter') {
            this.submit($event);
        }
        else {
            return this.onKeydown.emit($event);
        }
    }
    /**
     * @name onKeyUp
     * @param $event
     */
    onKeyUp($event) {
        this.inputText = this.value.value;
        return this.onKeyup.emit($event);
    }
    /**
     * @name submit
     */
    submit($event) {
        $event.preventDefault();
        this.onSubmit.emit($event);
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputForm.prototype, "onSubmit", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputForm.prototype, "onBlur", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputForm.prototype, "onFocus", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputForm.prototype, "onKeyup", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputForm.prototype, "onKeydown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputForm.prototype, "inputTextChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputForm.prototype, "placeholder", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], TagInputForm.prototype, "validators", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], TagInputForm.prototype, "asyncValidators", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputForm.prototype, "inputId", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputForm.prototype, "inputClass", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputForm.prototype, "tabindex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputForm.prototype, "disabled", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('input', { static: false }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputForm.prototype, "input", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [String])
], TagInputForm.prototype, "inputText", null);
TagInputForm = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'tag-input-form',
        template: "<!-- form -->\n<form (ngSubmit)=\"submit($event)\" [formGroup]=\"form\">\n    <input #input\n\n           type=\"text\"\n           class=\"ng2-tag-input__text-input\"\n           autocomplete=\"off\"\n           tabindex=\"{{ disabled ? -1 : tabindex ? tabindex : 0 }}\"\n           minlength=\"1\"\n           formControlName=\"item\"\n\n           [ngClass]=\"inputClass\"\n           [attr.id]=\"inputId\"\n           [attr.placeholder]=\"placeholder\"\n           [attr.aria-label]=\"placeholder\"\n           [attr.tabindex]=\"tabindex\"\n           [attr.disabled]=\"disabled ? disabled : null\"\n\n           (focus)=\"onFocus.emit($event)\"\n           (blur)=\"onBlur.emit($event)\"\n           (keydown)=\"onKeyDown($event)\"\n           (keyup)=\"onKeyUp($event)\"\n    />\n</form>\n",
        styles: [".dark tag:focus{box-shadow:0 0 0 1px #323232}.ng2-tag-input.bootstrap3-info{background-color:#fff;display:inline-block;color:#555;vertical-align:middle;max-width:100%;height:42px;line-height:44px}.ng2-tag-input.bootstrap3-info input{border:none;box-shadow:none;outline:0;background-color:transparent;padding:0 6px;margin:0;width:auto;max-width:inherit}.ng2-tag-input.bootstrap3-info .form-control input::-moz-placeholder{color:#777;opacity:1}.ng2-tag-input.bootstrap3-info .form-control input:-ms-input-placeholder{color:#777}.ng2-tag-input.bootstrap3-info .form-control input::-webkit-input-placeholder{color:#777}.ng2-tag-input.bootstrap3-info input:focus{border:none;box-shadow:none}.bootstrap3-info.ng2-tag-input.ng2-tag-input--focused{box-shadow:inset 0 1px 1px rgba(0,0,0,.4);border:1px solid #ccc}.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;transition:.25s;padding:.25rem 0;min-height:32px;cursor:text;border-bottom:2px solid #efefef}.ng2-tag-input:focus{outline:0}.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.ng2-tag-input.ng2-tag-input--focused{border-bottom:2px solid #2196f3}.ng2-tag-input.ng2-tag-input--invalid{border-bottom:2px solid #f44336}.ng2-tag-input.ng2-tag-input--loading{border:none}.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.ng2-tag-input form{margin:.1em 0}.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.minimal.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:1px solid transparent}.minimal.ng2-tag-input:focus{outline:0}.minimal.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.minimal.ng2-tag-input.ng2-tag-input--loading{border:none}.minimal.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.minimal.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.dark.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:2px solid #444}.dark.ng2-tag-input:focus{outline:0}.dark.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.dark.ng2-tag-input.ng2-tag-input--loading{border:none}.dark.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.dark.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.bootstrap.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:2px solid #efefef}.bootstrap.ng2-tag-input:focus{outline:0}.bootstrap.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.bootstrap.ng2-tag-input.ng2-tag-input--focused{border-bottom:2px solid #0275d8}.bootstrap.ng2-tag-input.ng2-tag-input--invalid{border-bottom:2px solid #d9534f}.bootstrap.ng2-tag-input.ng2-tag-input--loading{border:none}.bootstrap.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.bootstrap.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.bootstrap3-info.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;padding:4px;cursor:text;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);border-radius:4px}.bootstrap3-info.ng2-tag-input:focus{outline:0}.bootstrap3-info.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.bootstrap3-info.ng2-tag-input.ng2-tag-input--invalid{box-shadow:inset 0 1px 1px #d9534f;border-bottom:1px solid #d9534f}.bootstrap3-info.ng2-tag-input.ng2-tag-input--loading{border:none}.bootstrap3-info.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.bootstrap3-info.ng2-tag-input form{margin:.1em 0}.bootstrap3-info.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.error-message{font-size:.8em;color:#f44336;margin:.5em 0 0}.bootstrap .error-message{color:#d9534f}.ng2-tag-input__text-input{display:inline;vertical-align:middle;border:none;padding:0 .5rem;height:38px;font-size:1em;font-family:Roboto,\"Helvetica Neue\",sans-serif}.ng2-tag-input__text-input:focus{outline:0}.ng2-tag-input__text-input[disabled=true]{opacity:.5;background:#fff}"]
    })
], TagInputForm);

let TagRipple = class TagRipple {
    constructor() {
        this.state = 'none';
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagRipple.prototype, "state", void 0);
TagRipple = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'tag-ripple',
        template: `
        <div class="tag-ripple" [@ink]="state"></div>
    `,
        animations: [
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["trigger"])('ink', [
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["state"])('none', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ width: 0, opacity: 0 })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["transition"])('none => clicked', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["animate"])(300, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 1, offset: 0, width: '30%', borderRadius: '100%' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 1, offset: 0.5, width: '50%' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 0.5, offset: 1, width: '100%', borderRadius: '16px' })
                    ]))
                ])
            ])
        ],
        styles: [`
        :host {
            width: 100%;
            height: 100%;
            left: 0;
            overflow: hidden;
            position: absolute;
        }

        .tag-ripple {
            background: rgba(0, 0, 0, 0.1);
            top: 50%;
            left: 50%;
            height: 100%;
            transform: translate(-50%, -50%);
            position: absolute;
        }
    `]
    })
], TagRipple);

// mocking navigator
const navigator = typeof window !== 'undefined' ? window.navigator : {
    userAgent: 'Chrome',
    vendor: 'Google Inc'
};
const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
let TagComponent = class TagComponent {
    constructor(element, renderer, cdRef) {
        this.element = element;
        this.renderer = renderer;
        this.cdRef = cdRef;
        /**
         * @name disabled
         */
        this.disabled = false;
        /**
         * @name onSelect
         */
        this.onSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onRemove
         */
        this.onRemove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onBlur
         */
        this.onBlur = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onKeyDown
         */
        this.onKeyDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onTagEdited
         */
        this.onTagEdited = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name editing
         */
        this.editing = false;
        /**
         * @name rippleState
         */
        this.rippleState = 'none';
    }
    /**
     * @name readonly {boolean}
     */
    get readonly() {
        return typeof this.model !== 'string' && this.model.readonly === true;
    }
    /**
     * @name select
     */
    select($event) {
        if (this.readonly || this.disabled) {
            return;
        }
        if ($event) {
            $event.stopPropagation();
        }
        this.focus();
        this.onSelect.emit(this.model);
    }
    /**
     * @name remove
     */
    remove($event) {
        $event.stopPropagation();
        this.onRemove.emit(this);
    }
    /**
     * @name focus
     */
    focus() {
        this.element.nativeElement.focus();
    }
    move() {
        this.moving = true;
    }
    /**
     * @name keydown
     * @param event
     */
    keydown(event) {
        if (this.editing) {
            if (event.keyCode === 13) {
                return this.disableEditMode(event);
            }
        }
        else {
            this.onKeyDown.emit({ event, model: this.model });
        }
    }
    /**
     * @name blink
     */
    blink() {
        const classList = this.element.nativeElement.classList;
        classList.add('blink');
        setTimeout(() => classList.remove('blink'), 50);
    }
    /**
     * @name toggleEditMode
     */
    toggleEditMode() {
        if (this.editable) {
            return this.editing ? undefined : this.activateEditMode();
        }
    }
    /**
     * @name onBlurred
     * @param event
     */
    onBlurred(event) {
        // Checks if it is editable first before handeling the onBlurred event in order to prevent
        // a bug in IE where tags are still editable with onlyFromAutocomplete set to true
        if (!this.editable) {
            return;
        }
        this.disableEditMode();
        const value = event.target.innerText;
        const result = typeof this.model === 'string'
            ? value
            : Object.assign({}, this.model, { [this.displayBy]: value });
        this.onBlur.emit(result);
    }
    /**
     * @name getDisplayValue
     * @param item
     */
    getDisplayValue(item) {
        return typeof item === 'string' ? item : item[this.displayBy];
    }
    /**
     * @desc returns whether the ripple is visible or not
     * only works in Chrome
     * @name isRippleVisible
     */
    get isRippleVisible() {
        return !this.readonly && !this.editing && isChrome && this.hasRipple;
    }
    /**
     * @name disableEditMode
     * @param $event
     */
    disableEditMode($event) {
        const classList = this.element.nativeElement.classList;
        const input = this.getContentEditableText();
        this.editing = false;
        classList.remove('tag--editing');
        if (!input) {
            this.setContentEditableText(this.model);
            return;
        }
        this.storeNewValue(input);
        this.cdRef.detectChanges();
        if ($event) {
            $event.preventDefault();
        }
    }
    /**
     * @name isDeleteIconVisible
     */
    isDeleteIconVisible() {
        return (!this.readonly && !this.disabled && this.removable && !this.editing);
    }
    /**
     * @name getContentEditableText
     */
    getContentEditableText() {
        const input = this.getContentEditable();
        return input ? input.innerText.trim() : '';
    }
    /**
     * @name setContentEditableText
     * @param model
     */
    setContentEditableText(model) {
        const input = this.getContentEditable();
        const value = this.getDisplayValue(model);
        input.innerText = value;
    }
    /**
     * @name
     */
    activateEditMode() {
        const classList = this.element.nativeElement.classList;
        classList.add('tag--editing');
        this.editing = true;
    }
    /**
     * @name storeNewValue
     * @param input
     */
    storeNewValue(input) {
        const exists = (tag) => {
            return typeof tag === 'string'
                ? tag === input
                : tag[this.displayBy] === input;
        };
        const hasId = () => {
            return this.model[this.identifyBy] !== this.model[this.displayBy];
        };
        // if the value changed, replace the value in the model
        if (exists(this.model)) {
            return;
        }
        const model = typeof this.model === 'string'
            ? input
            : {
                index: this.index,
                [this.identifyBy]: hasId()
                    ? this.model[this.identifyBy]
                    : input,
                [this.displayBy]: input
            };
        if (this.canAddTag(model)) {
            this.onTagEdited.emit({ tag: model, index: this.index });
        }
        else {
            this.setContentEditableText(this.model);
        }
    }
    /**
     * @name getContentEditable
     */
    getContentEditable() {
        return this.element.nativeElement.querySelector('[contenteditable]');
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagComponent.prototype, "model", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagComponent.prototype, "removable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagComponent.prototype, "editable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"])
], TagComponent.prototype, "template", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagComponent.prototype, "displayBy", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagComponent.prototype, "identifyBy", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], TagComponent.prototype, "index", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagComponent.prototype, "hasRipple", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagComponent.prototype, "disabled", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function)
], TagComponent.prototype, "canAddTag", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagComponent.prototype, "onSelect", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagComponent.prototype, "onRemove", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagComponent.prototype, "onBlur", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagComponent.prototype, "onKeyDown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagComponent.prototype, "onTagEdited", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('class.moving'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagComponent.prototype, "moving", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])(TagRipple, { static: false }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", TagRipple)
], TagComponent.prototype, "ripple", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('keydown', ['$event']),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:returntype", void 0)
], TagComponent.prototype, "keydown", null);
TagComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'tag',
        template: "<div (click)=\"select($event)\"\n     (dblclick)=\"toggleEditMode()\"\n     (mousedown)=\"rippleState='clicked'\"\n     (mouseup)=\"rippleState='none'\"\n     [ngSwitch]=\"!!template\"\n     [class.disabled]=\"disabled\"\n     [attr.tabindex]=\"-1\"\n     [attr.aria-label]=\"getDisplayValue(model)\">\n\n    <div *ngSwitchCase=\"true\" [attr.contenteditable]=\"editing\">\n        <!-- CUSTOM TEMPLATE -->\n        <ng-template\n            [ngTemplateOutletContext]=\"{ item: model, index: index }\"\n            [ngTemplateOutlet]=\"template\">\n        </ng-template>\n    </div>\n\n    <div *ngSwitchCase=\"false\" class=\"tag-wrapper\">\n        <!-- TAG NAME -->\n        <div [attr.contenteditable]=\"editing\"\n             [attr.title]=\"getDisplayValue(model)\"\n             class=\"tag__text inline\"\n             spellcheck=\"false\"\n             (keydown.enter)=\"disableEditMode($event)\"\n             (keydown.escape)=\"disableEditMode($event)\"\n             (click)=\"editing ? $event.stopPropagation() : undefined\"\n             (blur)=\"onBlurred($event)\">\n            {{ getDisplayValue(model) }}\n        </div>\n\n        <!-- 'X' BUTTON -->\n        <delete-icon\n            aria-label=\"Remove tag\"\n            role=\"button\"\n            (click)=\"remove($event)\"\n            *ngIf=\"isDeleteIconVisible()\">\n        </delete-icon>\n    </div>\n</div>\n\n<tag-ripple [state]=\"rippleState\"\n            [attr.tabindex]=\"-1\"\n            *ngIf=\"isRippleVisible\">\n</tag-ripple>\n",
        styles: [":host,:host>div,:host>div:focus{outline:0;overflow:hidden;transition:opacity 1s;z-index:1}:host{max-width:400px}:host.blink{-webkit-animation:.3s ease-in-out forwards blink;animation:.3s ease-in-out forwards blink}@-webkit-keyframes blink{0%{opacity:.3}}@keyframes blink{0%{opacity:.3}}:host .disabled{cursor:not-allowed}:host [contenteditable=true]{outline:0}.tag-wrapper{flex-direction:row;display:flex}.tag__text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}"]
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"],
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]])
], TagComponent);

/**
 * @name animations
 */
const animations = [
    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["trigger"])('animation', [
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["state"])('in', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({
            opacity: 1
        })),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["state"])('out', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({
            opacity: 0
        })),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["transition"])(':enter', [
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["animate"])('{{ enter }}', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["keyframes"])([
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 0, offset: 0, transform: 'translate(0px, 20px)' }),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 0.3, offset: 0.3, transform: 'translate(0px, -10px)' }),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 0.5, offset: 0.5, transform: 'translate(0px, 0px)' }),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 0.75, offset: 0.75, transform: 'translate(0px, 5px)' }),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 1, offset: 1, transform: 'translate(0px, 0px)' })
            ]))
        ]),
        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["transition"])(':leave', [
            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["animate"])('{{ leave }}', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["keyframes"])([
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 1, transform: 'translateX(0)', offset: 0 }),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 1, transform: 'translateX(-15px)', offset: 0.7 }),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_6__["style"])({ opacity: 0, transform: 'translateX(100%)', offset: 1.0 })
            ]))
        ])
    ])
];

let TagInputDropdown = class TagInputDropdown {
    constructor(injector) {
        this.injector = injector;
        /**
         * @name offset
         */
        this.offset = defaults.dropdown.offset;
        /**
         * @name focusFirstElement
         */
        this.focusFirstElement = defaults.dropdown.focusFirstElement;
        /**
         * - show autocomplete dropdown if the value of input is empty
         * @name showDropdownIfEmpty
         */
        this.showDropdownIfEmpty = defaults.dropdown.showDropdownIfEmpty;
        /**
         * - desc minimum text length in order to display the autocomplete dropdown
         * @name minimumTextLength
         */
        this.minimumTextLength = defaults.dropdown.minimumTextLength;
        /**
         * - number of items to display in the autocomplete dropdown
         * @name limitItemsTo
         */
        this.limitItemsTo = defaults.dropdown.limitItemsTo;
        /**
         * @name displayBy
         */
        this.displayBy = defaults.dropdown.displayBy;
        /**
         * @name identifyBy
         */
        this.identifyBy = defaults.dropdown.identifyBy;
        /**
         * @description a function a developer can use to implement custom matching for the autocomplete
         * @name matchingFn
         */
        this.matchingFn = defaults.dropdown.matchingFn;
        /**
         * @name appendToBody
         */
        this.appendToBody = defaults.dropdown.appendToBody;
        /**
         * @name keepOpen
         * @description option to leave dropdown open when adding a new item
         */
        this.keepOpen = defaults.dropdown.keepOpen;
        /**
         * @name dynamicUpdate
         */
        this.dynamicUpdate = defaults.dropdown.dynamicUpdate;
        /**
         * @name zIndex
         */
        this.zIndex = defaults.dropdown.zIndex;
        /**
         * list of items that match the current value of the input (for autocomplete)
         * @name items
         */
        this.items = [];
        /**
         * @name tagInput
         */
        this.tagInput = this.injector.get(TagInputComponent);
        /**
         * @name _autocompleteItems
         */
        this._autocompleteItems = [];
        /**
         *
         * @name show
         */
        this.show = () => {
            const maxItemsReached = this.tagInput.items.length === this.tagInput.maxItems;
            const value = this.getFormValue();
            const hasMinimumText = value.trim().length >= this.minimumTextLength;
            const position = this.calculatePosition();
            const items = this.getMatchingItems(value);
            const hasItems = items.length > 0;
            const isHidden = this.isVisible === false;
            const showDropdownIfEmpty = this.showDropdownIfEmpty && hasItems && !value;
            const isDisabled = this.tagInput.disable;
            const shouldShow = isHidden && ((hasItems && hasMinimumText) || showDropdownIfEmpty);
            const shouldHide = this.isVisible && !hasItems;
            if (this.autocompleteObservable && hasMinimumText) {
                return this.getItemsFromObservable(value);
            }
            if ((!this.showDropdownIfEmpty && !value) ||
                maxItemsReached ||
                isDisabled) {
                return this.dropdown.hide();
            }
            this.setItems(items);
            if (shouldShow) {
                this.dropdown.show(position);
            }
            else if (shouldHide) {
                this.hide();
            }
        };
        /**
         * @name requestAdding
         * @param item {Ng2MenuItem}
         */
        this.requestAdding = (item) => Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const tag = this.createTagModel(item);
            yield this.tagInput.onAddingRequested(true, tag).catch(() => { });
        });
        /**
         * @name resetItems
         */
        this.resetItems = () => {
            this.items = [];
        };
        /**
         * @name getItemsFromObservable
         * @param text
         */
        this.getItemsFromObservable = (text) => {
            this.setLoadingState(true);
            const subscribeFn = (data) => {
                // hide loading animation
                this.setLoadingState(false)
                    // add items
                    .populateItems(data);
                this.setItems(this.getMatchingItems(text));
                if (this.items.length) {
                    this.dropdown.show(this.calculatePosition());
                }
                else {
                    this.dropdown.hide();
                }
            };
            this.autocompleteObservable(text)
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                .subscribe(subscribeFn, () => this.setLoadingState(false));
        };
    }
    /**
     * @name autocompleteItems
     * @param items
     */
    set autocompleteItems(items) {
        this._autocompleteItems = items;
    }
    /**
     * @name autocompleteItems
     * @desc array of items that will populate the autocomplete
     */
    get autocompleteItems() {
        const items = this._autocompleteItems;
        if (!items) {
            return [];
        }
        return items.map((item) => {
            return typeof item === 'string'
                ? {
                    [this.displayBy]: item,
                    [this.identifyBy]: item
                }
                : item;
        });
    }
    /**
     * @name ngAfterviewInit
     */
    ngAfterViewInit() {
        this.onItemClicked().subscribe((item) => {
            this.requestAdding(item);
        });
        // reset itemsMatching array when the dropdown is hidden
        this.onHide().subscribe(this.resetItems);
        const DEBOUNCE_TIME = 200;
        const KEEP_OPEN = this.keepOpen;
        this.tagInput.onTextChange
            .asObservable()
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(DEBOUNCE_TIME), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])((value) => {
            if (KEEP_OPEN === false) {
                return value.length > 0;
            }
            return true;
        }))
            .subscribe(this.show);
    }
    /**
     * @name updatePosition
     */
    updatePosition() {
        const position = this.tagInput.inputForm.getElementPosition();
        this.dropdown.menu.updatePosition(position, this.dynamicUpdate);
    }
    /**
     * @name isVisible
     */
    get isVisible() {
        return this.dropdown.menu.dropdownState.menuState.isVisible;
    }
    /**
     * @name onHide
     */
    onHide() {
        return this.dropdown.onHide;
    }
    /**
     * @name onItemClicked
     */
    onItemClicked() {
        return this.dropdown.onItemClicked;
    }
    /**
     * @name selectedItem
     */
    get selectedItem() {
        return this.dropdown.menu.dropdownState.dropdownState.selectedItem;
    }
    /**
     * @name state
     */
    get state() {
        return this.dropdown.menu.dropdownState;
    }
    /**
     * @name hide
     */
    hide() {
        this.resetItems();
        this.dropdown.hide();
    }
    /**
     * @name scrollListener
     */
    scrollListener() {
        if (!this.isVisible || !this.dynamicUpdate) {
            return;
        }
        this.updatePosition();
    }
    /**
     * @name onWindowBlur
     */
    onWindowBlur() {
        this.dropdown.hide();
    }
    /**
     * @name getFormValue
     */
    getFormValue() {
        const formValue = this.tagInput.formValue;
        return formValue ? formValue.toString().trim() : '';
    }
    /**
     * @name calculatePosition
     */
    calculatePosition() {
        return this.tagInput.inputForm.getElementPosition();
    }
    /**
     * @name createTagModel
     * @param item
     */
    createTagModel(item) {
        const display = typeof item.value === 'string' ? item.value : item.value[this.displayBy];
        const value = typeof item.value === 'string' ? item.value : item.value[this.identifyBy];
        return Object.assign({}, item.value, { [this.tagInput.displayBy]: display, [this.tagInput.identifyBy]: value });
    }
    /**
     *
     * @param value {string}
     */
    getMatchingItems(value) {
        if (!value && !this.showDropdownIfEmpty) {
            return [];
        }
        const dupesAllowed = this.tagInput.allowDupes;
        return this.autocompleteItems.filter((item) => {
            const hasValue = dupesAllowed
                ? false
                : this.tagInput.tags.some(tag => {
                    const identifyBy = this.tagInput.identifyBy;
                    const model = typeof tag.model === 'string' ? tag.model : tag.model[identifyBy];
                    return model === item[this.identifyBy];
                });
            return this.matchingFn(value, item) && hasValue === false;
        });
    }
    /**
     * @name setItems
     */
    setItems(items) {
        this.items = items.slice(0, this.limitItemsTo || items.length);
    }
    /**
     * @name populateItems
     * @param data
     */
    populateItems(data) {
        this.autocompleteItems = data.map(item => {
            return typeof item === 'string'
                ? {
                    [this.displayBy]: item,
                    [this.identifyBy]: item
                }
                : item;
        });
        return this;
    }
    /**
     * @name setLoadingState
     * @param state
     */
    setLoadingState(state) {
        this.tagInput.isLoading = state;
        return this;
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])(ng2_material_dropdown__WEBPACK_IMPORTED_MODULE_4__["Ng2Dropdown"], { static: false }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", ng2_material_dropdown__WEBPACK_IMPORTED_MODULE_4__["Ng2Dropdown"])
], TagInputDropdown.prototype, "dropdown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
], TagInputDropdown.prototype, "templates", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputDropdown.prototype, "offset", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "focusFirstElement", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "showDropdownIfEmpty", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function)
], TagInputDropdown.prototype, "autocompleteObservable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "minimumTextLength", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], TagInputDropdown.prototype, "limitItemsTo", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "displayBy", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "identifyBy", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function)
], TagInputDropdown.prototype, "matchingFn", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "appendToBody", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "keepOpen", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "dynamicUpdate", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputDropdown.prototype, "zIndex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Array])
], TagInputDropdown.prototype, "autocompleteItems", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('window:scroll'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", []),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:returntype", void 0)
], TagInputDropdown.prototype, "scrollListener", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('window:blur'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Function),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", []),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:returntype", void 0)
], TagInputDropdown.prototype, "onWindowBlur", null);
TagInputDropdown = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'tag-input-dropdown',
        template: "<ng2-dropdown [dynamicUpdate]=\"dynamicUpdate\">\n    <ng2-dropdown-menu [focusFirstElement]=\"focusFirstElement\"\n                       [zIndex]=\"zIndex\"\n                       [appendToBody]=\"appendToBody\"\n                       [offset]=\"offset\">\n        <ng2-menu-item *ngFor=\"let item of items; let index = index; let last = last\"\n                       [value]=\"item\"\n                       [ngSwitch]=\"!!templates.length\">\n\n            <span *ngSwitchCase=\"false\"\n                  [innerHTML]=\"item[displayBy] | highlight : tagInput.inputForm.value.value\">\n            </span>\n\n            <ng-template *ngSwitchDefault\n                      [ngTemplateOutlet]=\"templates.first\"\n                      [ngTemplateOutletContext]=\"{ item: item, index: index, last: last }\">\n            </ng-template>\n        </ng2-menu-item>\n    </ng2-dropdown-menu>\n</ng2-dropdown>\n"
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]])
], TagInputDropdown);

// angular universal hacks
/* tslint:disable-next-line */
const DragEvent = window.DragEvent;
const CUSTOM_ACCESSOR = {
    provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
    useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => TagInputComponent),
    multi: true
};
let TagInputComponent = class TagInputComponent extends TagInputAccessor {
    constructor(renderer, dragProvider) {
        super();
        this.renderer = renderer;
        this.dragProvider = dragProvider;
        /**
         * @name separatorKeys
         * @desc keyboard keys with which a user can separate items
         */
        this.separatorKeys = defaults.tagInput.separatorKeys;
        /**
         * @name separatorKeyCodes
         * @desc keyboard key codes with which a user can separate items
         */
        this.separatorKeyCodes = defaults.tagInput.separatorKeyCodes;
        /**
         * @name placeholder
         * @desc the placeholder of the input text
         */
        this.placeholder = defaults.tagInput.placeholder;
        /**
         * @name secondaryPlaceholder
         * @desc placeholder to appear when the input is empty
         */
        this.secondaryPlaceholder = defaults.tagInput.secondaryPlaceholder;
        /**
         * @name maxItems
         * @desc maximum number of items that can be added
         */
        this.maxItems = defaults.tagInput.maxItems;
        /**
         * @name validators
         * @desc array of Validators that are used to validate the tag before it gets appended to the list
         */
        this.validators = defaults.tagInput.validators;
        /**
         * @name asyncValidators
         * @desc array of AsyncValidator that are used to validate the tag before it gets appended to the list
         */
        this.asyncValidators = defaults.tagInput.asyncValidators;
        /**
        * - if set to true, it will only possible to add items from the autocomplete
        * @name onlyFromAutocomplete
        */
        this.onlyFromAutocomplete = defaults.tagInput.onlyFromAutocomplete;
        /**
         * @name errorMessages
         */
        this.errorMessages = defaults.tagInput.errorMessages;
        /**
         * @name theme
         */
        this.theme = defaults.tagInput.theme;
        /**
         * @name onTextChangeDebounce
         */
        this.onTextChangeDebounce = defaults.tagInput.onTextChangeDebounce;
        /**
         * - custom id assigned to the input
         * @name id
         */
        this.inputId = defaults.tagInput.inputId;
        /**
         * - custom class assigned to the input
         */
        this.inputClass = defaults.tagInput.inputClass;
        /**
         * - option to clear text input when the form is blurred
         * @name clearOnBlur
         */
        this.clearOnBlur = defaults.tagInput.clearOnBlur;
        /**
         * - hideForm
         * @name clearOnBlur
         */
        this.hideForm = defaults.tagInput.hideForm;
        /**
         * @name addOnBlur
         */
        this.addOnBlur = defaults.tagInput.addOnBlur;
        /**
         * @name addOnPaste
         */
        this.addOnPaste = defaults.tagInput.addOnPaste;
        /**
         * - pattern used with the native method split() to separate patterns in the string pasted
         * @name pasteSplitPattern
         */
        this.pasteSplitPattern = defaults.tagInput.pasteSplitPattern;
        /**
         * @name blinkIfDupe
         */
        this.blinkIfDupe = defaults.tagInput.blinkIfDupe;
        /**
         * @name removable
         */
        this.removable = defaults.tagInput.removable;
        /**
         * @name editable
         */
        this.editable = defaults.tagInput.editable;
        /**
         * @name allowDupes
         */
        this.allowDupes = defaults.tagInput.allowDupes;
        /**
         * @description if set to true, the newly added tags will be added as strings, and not objects
         * @name modelAsStrings
         */
        this.modelAsStrings = defaults.tagInput.modelAsStrings;
        /**
         * @name trimTags
         */
        this.trimTags = defaults.tagInput.trimTags;
        /**
         * @name ripple
         */
        this.ripple = defaults.tagInput.ripple;
        /**
         * @name tabindex
         * @desc pass through the specified tabindex to the input
         */
        this.tabindex = defaults.tagInput.tabIndex;
        /**
         * @name disable
         */
        this.disable = defaults.tagInput.disable;
        /**
         * @name dragZone
         */
        this.dragZone = defaults.tagInput.dragZone;
        /**
         * @name onRemoving
         */
        this.onRemoving = defaults.tagInput.onRemoving;
        /**
         * @name onAdding
         */
        this.onAdding = defaults.tagInput.onAdding;
        /**
         * @name animationDuration
         */
        this.animationDuration = defaults.tagInput.animationDuration;
        /**
         * @name onAdd
         * @desc event emitted when adding a new item
         */
        this.onAdd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onRemove
         * @desc event emitted when removing an existing item
         */
        this.onRemove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onSelect
         * @desc event emitted when selecting an item
         */
        this.onSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onFocus
         * @desc event emitted when the input is focused
         */
        this.onFocus = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onFocus
         * @desc event emitted when the input is blurred
         */
        this.onBlur = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name onTextChange
         * @desc event emitted when the input value changes
         */
        this.onTextChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * - output triggered when text is pasted in the form
         * @name onPaste
         */
        this.onPaste = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * - output triggered when tag entered is not valid
         * @name onValidationError
         */
        this.onValidationError = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * - output triggered when tag is edited
         * @name onTagEdited
         */
        this.onTagEdited = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @name isLoading
         */
        this.isLoading = false;
        /**
         * @name listeners
         * @desc array of events that get fired using @fireEvents
         */
        this.listeners = {
            [KEYDOWN]: [],
            [KEYUP]: []
        };
        /**
         * @description emitter for the 2-way data binding inputText value
         * @name inputTextChange
         */
        this.inputTextChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @description private variable to bind get/set
         * @name inputTextValue
         */
        this.inputTextValue = '';
        this.errors = [];
        /**
         * @name appendTag
         * @param tag {TagModel}
         */
        this.appendTag = (tag, index = this.items.length) => {
            const items = this.items;
            const model = this.modelAsStrings ? tag[this.identifyBy] : tag;
            this.items = [
                ...items.slice(0, index),
                model,
                ...items.slice(index, items.length)
            ];
        };
        /**
         * @name createTag
         * @param model
         */
        this.createTag = (model) => {
            const trim = (val, key) => {
                return typeof val === 'string' ? val.trim() : val[key];
            };
            return Object.assign({}, typeof model !== 'string' ? model : {}, { [this.displayBy]: this.trimTags ? trim(model, this.displayBy) : model, [this.identifyBy]: this.trimTags ? trim(model, this.identifyBy) : model });
        };
        /**
         *
         * @param tag
         * @param isFromAutocomplete
         */
        this.isTagValid = (tag, fromAutocomplete = false) => {
            const selectedItem = this.dropdown ? this.dropdown.selectedItem : undefined;
            const value = this.getItemDisplay(tag).trim();
            if (selectedItem && !fromAutocomplete || !value) {
                return false;
            }
            const dupe = this.findDupe(tag, fromAutocomplete);
            // if so, give a visual cue and return false
            if (!this.allowDupes && dupe && this.blinkIfDupe) {
                const model = this.tags.find(item => {
                    return this.getItemValue(item.model) === this.getItemValue(dupe);
                });
                if (model) {
                    model.blink();
                }
            }
            const isFromAutocomplete = fromAutocomplete && this.onlyFromAutocomplete;
            const assertions = [
                // 1. there must be no dupe OR dupes are allowed
                !dupe || this.allowDupes,
                // 2. check max items has not been reached
                !this.maxItemsReached,
                // 3. check item comes from autocomplete or onlyFromAutocomplete is false
                ((isFromAutocomplete) || !this.onlyFromAutocomplete)
            ];
            return assertions.filter(Boolean).length === assertions.length;
        };
        /**
         * @name onPasteCallback
         * @param data
         */
        this.onPasteCallback = (data) => Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const getText = () => {
                const isIE = Boolean(window.clipboardData);
                const clipboardData = isIE ? (window.clipboardData) : data.clipboardData;
                const type = isIE ? 'Text' : 'text/plain';
                return clipboardData === null ? '' : clipboardData.getData(type) || '';
            };
            const text = getText();
            const requests = text
                .split(this.pasteSplitPattern)
                .map(item => {
                const tag = this.createTag(item);
                this.setInputValue(tag[this.displayBy]);
                return this.onAddingRequested(false, tag);
            });
            const resetInput = () => setTimeout(() => this.setInputValue(''), 50);
            Promise.all(requests).then(() => {
                this.onPaste.emit(text);
                resetInput();
            })
                .catch(resetInput);
        });
    }
    /**
     * @name inputText
     */
    get inputText() {
        return this.inputTextValue;
    }
    /**
     * @name inputText
     * @param text
     */
    set inputText(text) {
        this.inputTextValue = text;
        this.inputTextChange.emit(text);
    }
    /**
     * @desc removes the tab index if it is set - it will be passed through to the input
     * @name tabindexAttr
     */
    get tabindexAttr() {
        return this.tabindex !== '' ? '-1' : '';
    }
    /**
     * @name ngAfterViewInit
     */
    ngAfterViewInit() {
        // set up listeners
        this.setUpKeypressListeners();
        this.setupSeparatorKeysListener();
        this.setUpInputKeydownListeners();
        if (this.onTextChange.observers.length) {
            this.setUpTextChangeSubscriber();
        }
        // if clear on blur is set to true, subscribe to the event and clear the text's form
        if (this.clearOnBlur || this.addOnBlur) {
            this.setUpOnBlurSubscriber();
        }
        // if addOnPaste is set to true, register the handler and add items
        if (this.addOnPaste) {
            this.setUpOnPasteListener();
        }
        const statusChanges$ = this.inputForm.form.statusChanges;
        statusChanges$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])((status) => status !== 'PENDING')).subscribe(() => {
            this.errors = this.inputForm.getErrorMessages(this.errorMessages);
        });
        this.isProgressBarVisible$ = statusChanges$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])((status) => {
            return status === 'PENDING' || this.isLoading;
        }));
        // if hideForm is set to true, remove the input
        if (this.hideForm) {
            this.inputForm.destroy();
        }
    }
    /**
     * @name ngOnInit
     */
    ngOnInit() {
        // if the number of items specified in the model is > of the value of maxItems
        // degrade gracefully and let the max number of items to be the number of items in the model
        // though, warn the user.
        const hasReachedMaxItems = this.maxItems !== undefined &&
            this.items &&
            this.items.length > this.maxItems;
        if (hasReachedMaxItems) {
            this.maxItems = this.items.length;
            console.warn(MAX_ITEMS_WARNING);
        }
        // Setting editable to false to fix problem with tags in IE still being editable when
        // onlyFromAutocomplete is true
        this.editable = this.onlyFromAutocomplete ? false : this.editable;
        this.setAnimationMetadata();
    }
    /**
     * @name onRemoveRequested
     * @param tag
     * @param index
     */
    onRemoveRequested(tag, index) {
        return new Promise(resolve => {
            const subscribeFn = (model) => {
                this.removeItem(model, index);
                resolve(tag);
            };
            this.onRemoving ?
                this.onRemoving(tag)
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                    .subscribe(subscribeFn) : subscribeFn(tag);
        });
    }
    /**
     * @name onAddingRequested
     * @param fromAutocomplete {boolean}
     * @param tag {TagModel}
     * @param index? {number}
     * @param giveupFocus? {boolean}
     */
    onAddingRequested(fromAutocomplete, tag, index, giveupFocus) {
        return new Promise((resolve, reject) => {
            const subscribeFn = (model) => {
                return this
                    .addItem(fromAutocomplete, model, index, giveupFocus)
                    .then(resolve)
                    .catch(reject);
            };
            return this.onAdding ?
                this.onAdding(tag)
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                    .subscribe(subscribeFn, reject) : subscribeFn(tag);
        });
    }
    /**
     * @name selectItem
     * @desc selects item passed as parameter as the selected tag
     * @param item
     * @param emit
     */
    selectItem(item, emit = true) {
        const isReadonly = item && typeof item !== 'string' && item.readonly;
        if (isReadonly || this.selectedTag === item) {
            return;
        }
        this.selectedTag = item;
        if (emit) {
            this.onSelect.emit(item);
        }
    }
    /**
     * @name fireEvents
     * @desc goes through the list of the events for a given eventName, and fires each of them
     * @param eventName
     * @param $event
     */
    fireEvents(eventName, $event) {
        this.listeners[eventName].forEach(listener => listener.call(this, $event));
    }
    /**
     * @name handleKeydown
     * @desc handles action when the user hits a keyboard key
     * @param data
     */
    handleKeydown(data) {
        const event = data.event;
        const key = event.keyCode || event.which;
        const shiftKey = event.shiftKey || false;
        switch (KEY_PRESS_ACTIONS[key]) {
            case ACTIONS_KEYS.DELETE:
                if (this.selectedTag && this.removable) {
                    const index = this.items.indexOf(this.selectedTag);
                    this.onRemoveRequested(this.selectedTag, index);
                }
                break;
            case ACTIONS_KEYS.SWITCH_PREV:
                this.moveToTag(data.model, PREV);
                break;
            case ACTIONS_KEYS.SWITCH_NEXT:
                this.moveToTag(data.model, NEXT);
                break;
            case ACTIONS_KEYS.TAB:
                if (shiftKey) {
                    if (this.isFirstTag(data.model)) {
                        return;
                    }
                    this.moveToTag(data.model, PREV);
                }
                else {
                    if (this.isLastTag(data.model) && (this.disable || this.maxItemsReached)) {
                        return;
                    }
                    this.moveToTag(data.model, NEXT);
                }
                break;
            default:
                return;
        }
        // prevent default behaviour
        event.preventDefault();
    }
    onFormSubmit() {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            try {
                yield this.onAddingRequested(false, this.formValue);
            }
            catch (_a) {
                return;
            }
        });
    }
    /**
     * @name setInputValue
     * @param value
     */
    setInputValue(value, emitEvent = true) {
        const control = this.getControl();
        // update form value with the transformed item
        control.setValue(value, { emitEvent });
    }
    /**
     * @name getControl
     */
    getControl() {
        return this.inputForm.value;
    }
    /**
     * @name focus
     * @param applyFocus
     * @param displayAutocomplete
     */
    focus(applyFocus = false, displayAutocomplete = false) {
        if (this.dragProvider.getState('dragging')) {
            return;
        }
        this.selectItem(undefined, false);
        if (applyFocus) {
            this.inputForm.focus();
            this.onFocus.emit(this.formValue);
        }
    }
    /**
     * @name blur
     */
    blur() {
        this.onTouched();
        this.onBlur.emit(this.formValue);
    }
    /**
     * @name hasErrors
     */
    hasErrors() {
        return !!this.inputForm && this.inputForm.hasErrors();
    }
    /**
     * @name isInputFocused
     */
    isInputFocused() {
        return !!this.inputForm && this.inputForm.isInputFocused();
    }
    /**
     * - this is the one way I found to tell if the template has been passed and it is not
     * the template for the menu item
     * @name hasCustomTemplate
     */
    hasCustomTemplate() {
        const template = this.templates ? this.templates.first : undefined;
        const menuTemplate = this.dropdown && this.dropdown.templates ?
            this.dropdown.templates.first : undefined;
        return Boolean(template && template !== menuTemplate);
    }
    /**
     * @name maxItemsReached
     */
    get maxItemsReached() {
        return this.maxItems !== undefined &&
            this.items.length >= this.maxItems;
    }
    /**
     * @name formValue
     */
    get formValue() {
        const form = this.inputForm.value;
        return form ? form.value : '';
    }
    /**3
     * @name onDragStarted
     * @param event
     * @param index
     */
    onDragStarted(event, tag, index) {
        event.stopPropagation();
        const item = { zone: this.dragZone, tag, index };
        this.dragProvider.setSender(this);
        this.dragProvider.setDraggedItem(event, item);
        this.dragProvider.setState({ dragging: true, index });
    }
    /**
     * @name onDragOver
     * @param event
     */
    onDragOver(event, index) {
        this.dragProvider.setState({ dropping: true });
        this.dragProvider.setReceiver(this);
        event.preventDefault();
    }
    /**
     * @name onTagDropped
     * @param event
     * @param index
     */
    onTagDropped(event, index) {
        const item = this.dragProvider.getDraggedItem(event);
        if (!item || item.zone !== this.dragZone) {
            return;
        }
        this.dragProvider.onTagDropped(item.tag, item.index, index);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * @name isDropping
     */
    isDropping() {
        const isReceiver = this.dragProvider.receiver === this;
        const isDropping = this.dragProvider.getState('dropping');
        return Boolean(isReceiver && isDropping);
    }
    /**
     * @name onTagBlurred
     * @param changedElement {TagModel}
     * @param index {number}
     */
    onTagBlurred(changedElement, index) {
        this.items[index] = changedElement;
        this.blur();
    }
    /**
     * @name trackBy
     * @param items
     */
    trackBy(index, item) {
        return item[this.identifyBy];
    }
    /**
     * @name updateEditedTag
     * @param tag
     */
    updateEditedTag({ tag, index }) {
        this.onTagEdited.emit(tag);
    }
    /**
     * @name moveToTag
     * @param item
     * @param direction
     */
    moveToTag(item, direction) {
        const isLast = this.isLastTag(item);
        const isFirst = this.isFirstTag(item);
        const stopSwitch = (direction === NEXT && isLast) ||
            (direction === PREV && isFirst);
        if (stopSwitch) {
            this.focus(true);
            return;
        }
        const offset = direction === NEXT ? 1 : -1;
        const index = this.getTagIndex(item) + offset;
        const tag = this.getTagAtIndex(index);
        return tag.select.call(tag);
    }
    /**
     * @name isFirstTag
     * @param item {TagModel}
     */
    isFirstTag(item) {
        return this.tags.first.model === item;
    }
    /**
     * @name isLastTag
     * @param item {TagModel}
     */
    isLastTag(item) {
        return this.tags.last.model === item;
    }
    /**
     * @name getTagIndex
     * @param item
     */
    getTagIndex(item) {
        const tags = this.tags.toArray();
        return tags.findIndex(tag => tag.model === item);
    }
    /**
     * @name getTagAtIndex
     * @param index
     */
    getTagAtIndex(index) {
        const tags = this.tags.toArray();
        return tags[index];
    }
    /**
     * @name removeItem
     * @desc removes an item from the array of the model
     * @param tag {TagModel}
     * @param index {number}
     */
    removeItem(tag, index) {
        this.items = this.getItemsWithout(index);
        // if the removed tag was selected, set it as undefined
        if (this.selectedTag === tag) {
            this.selectItem(undefined, false);
        }
        // focus input
        this.focus(true, false);
        // emit remove event
        this.onRemove.emit(tag);
    }
    /**
     * @name addItem
     * @desc adds the current text model to the items array
     * @param fromAutocomplete {boolean}
     * @param item {TagModel}
     * @param index? {number}
     * @param giveupFocus? {boolean}
     */
    addItem(fromAutocomplete = false, item, index, giveupFocus) {
        const display = this.getItemDisplay(item);
        const tag = this.createTag(item);
        if (fromAutocomplete) {
            this.setInputValue(this.getItemValue(item, true));
        }
        return new Promise((resolve, reject) => {
            /**
             * @name reset
             */
            const reset = () => {
                // reset control and focus input
                this.setInputValue('');
                if (giveupFocus) {
                    this.focus(false, false);
                }
                else {
                    // focus input
                    this.focus(true, false);
                }
                resolve(display);
            };
            const appendItem = () => {
                this.appendTag(tag, index);
                // emit event
                this.onAdd.emit(tag);
                if (!this.dropdown) {
                    return;
                }
                this.dropdown.hide();
                if (this.dropdown.showDropdownIfEmpty) {
                    this.dropdown.show();
                }
            };
            const status = this.inputForm.form.status;
            const isTagValid = this.isTagValid(tag, fromAutocomplete);
            const onValidationError = () => {
                this.onValidationError.emit(tag);
                return reject();
            };
            if (status === 'VALID' && isTagValid) {
                appendItem();
                return reset();
            }
            if (status === 'INVALID' || !isTagValid) {
                reset();
                return onValidationError();
            }
            if (status === 'PENDING') {
                const statusUpdate$ = this.inputForm.form.statusChanges;
                return statusUpdate$
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(statusUpdate => statusUpdate !== 'PENDING'), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                    .subscribe((statusUpdate) => {
                    if (statusUpdate === 'VALID' && isTagValid) {
                        appendItem();
                        return reset();
                    }
                    else {
                        reset();
                        return onValidationError();
                    }
                });
            }
        });
    }
    /**
     * @name setupSeparatorKeysListener
     */
    setupSeparatorKeysListener() {
        const useSeparatorKeys = this.separatorKeyCodes.length > 0 || this.separatorKeys.length > 0;
        const listener = ($event) => {
            const hasKeyCode = this.separatorKeyCodes.indexOf($event.keyCode) >= 0;
            const hasKey = this.separatorKeys.indexOf($event.key) >= 0;
            // the keyCode of keydown event is 229 when IME is processing the key event.
            const isIMEProcessing = $event.keyCode === 229;
            if (hasKeyCode || (hasKey && !isIMEProcessing)) {
                $event.preventDefault();
                this.onAddingRequested(false, this.formValue)
                    .catch(() => { });
            }
        };
        listen.call(this, KEYDOWN, listener, useSeparatorKeys);
    }
    /**
     * @name setUpKeypressListeners
     */
    setUpKeypressListeners() {
        const listener = ($event) => {
            const isCorrectKey = $event.keyCode === 37 || $event.keyCode === 8;
            if (isCorrectKey &&
                !this.formValue &&
                this.items.length) {
                this.tags.last.select.call(this.tags.last);
            }
        };
        // setting up the keypress listeners
        listen.call(this, KEYDOWN, listener);
    }
    /**
     * @name setUpKeydownListeners
     */
    setUpInputKeydownListeners() {
        this.inputForm.onKeydown.subscribe(event => {
            if (event.key === 'Backspace' && this.formValue.trim() === '') {
                event.preventDefault();
            }
        });
    }
    /**
     * @name setUpOnPasteListener
     */
    setUpOnPasteListener() {
        const input = this.inputForm.input.nativeElement;
        // attach listener to input
        this.renderer.listen(input, 'paste', (event) => {
            this.onPasteCallback(event);
            event.preventDefault();
            return true;
        });
    }
    /**
     * @name setUpTextChangeSubscriber
     */
    setUpTextChangeSubscriber() {
        this.inputForm.form
            .valueChanges
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(this.onTextChangeDebounce))
            .subscribe((value) => {
            this.onTextChange.emit(value.item);
        });
    }
    /**
     * @name setUpOnBlurSubscriber
     */
    setUpOnBlurSubscriber() {
        const filterFn = () => {
            const isVisible = this.dropdown && this.dropdown.isVisible;
            return !isVisible && !!this.formValue;
        };
        this.inputForm
            .onBlur
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(100), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(filterFn))
            .subscribe(() => {
            const reset = () => this.setInputValue('');
            if (this.addOnBlur) {
                return this
                    .onAddingRequested(false, this.formValue, undefined, true)
                    .then(reset)
                    .catch(reset);
            }
            reset();
        });
    }
    /**
     * @name findDupe
     * @param tag
     * @param isFromAutocomplete
     */
    findDupe(tag, isFromAutocomplete) {
        const identifyBy = isFromAutocomplete ? this.dropdown.identifyBy : this.identifyBy;
        const id = tag[identifyBy];
        return this.items.find(item => this.getItemValue(item) === id);
    }
    /**
     * @name setAnimationMetadata
     */
    setAnimationMetadata() {
        this.animationMetadata = {
            value: 'in',
            params: Object.assign({}, this.animationDuration)
        };
    }
};
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], TagInputComponent.prototype, "separatorKeys", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], TagInputComponent.prototype, "separatorKeyCodes", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputComponent.prototype, "placeholder", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputComponent.prototype, "secondaryPlaceholder", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)
], TagInputComponent.prototype, "maxItems", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], TagInputComponent.prototype, "validators", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
], TagInputComponent.prototype, "asyncValidators", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onlyFromAutocomplete", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "errorMessages", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputComponent.prototype, "theme", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onTextChangeDebounce", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "inputId", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputComponent.prototype, "inputClass", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "clearOnBlur", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "hideForm", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "addOnBlur", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "addOnPaste", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "pasteSplitPattern", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "blinkIfDupe", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "removable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "editable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "allowDupes", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "modelAsStrings", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "trimTags", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [String])
], TagInputComponent.prototype, "inputText", null);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "ripple", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputComponent.prototype, "tabindex", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
], TagInputComponent.prototype, "disable", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
], TagInputComponent.prototype, "dragZone", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onRemoving", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onAdding", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "animationDuration", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onAdd", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onRemove", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onSelect", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onFocus", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onBlur", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onTextChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onPaste", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onValidationError", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
], TagInputComponent.prototype, "onTagEdited", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"])(TagInputDropdown, { static: false }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", TagInputDropdown)
], TagInputComponent.prototype, "dropdown", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], { descendants: false }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
], TagInputComponent.prototype, "templates", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])(TagInputForm, { static: false }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", TagInputForm)
], TagInputComponent.prototype, "inputForm", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(TagComponent),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
], TagInputComponent.prototype, "tags", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"])
], TagInputComponent.prototype, "inputTextChange", void 0);
Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('attr.tabindex'),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [])
], TagInputComponent.prototype, "tabindexAttr", null);
TagInputComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'tag-input',
        providers: [CUSTOM_ACCESSOR],
        template: "<div\n    [ngClass]=\"theme\"\n    class=\"ng2-tag-input\"\n    (click)=\"focus(true, false)\"\n    [attr.tabindex]=\"-1\"\n    (drop)=\"dragZone ? onTagDropped($event, undefined) : undefined\"\n    (dragenter)=\"dragZone ? onDragOver($event) : undefined\"\n    (dragover)=\"dragZone ? onDragOver($event) : undefined\"\n    (dragend)=\"dragZone ? dragProvider.onDragEnd() : undefined\"\n    [class.ng2-tag-input--dropping]=\"isDropping()\"\n    [class.ng2-tag-input--disabled]=\"disable\"\n    [class.ng2-tag-input--loading]=\"isLoading\"\n    [class.ng2-tag-input--invalid]=\"hasErrors()\"\n    [class.ng2-tag-input--focused]=\"isInputFocused()\"\n>\n\n    <!-- TAGS -->\n    <div class=\"ng2-tags-container\">\n        <tag\n            *ngFor=\"let item of items; let i = index; trackBy: trackBy\"\n            (onSelect)=\"selectItem(item)\"\n            (onRemove)=\"onRemoveRequested(item, i)\"\n            (onKeyDown)=\"handleKeydown($event)\"\n            (onTagEdited)=\"updateEditedTag($event)\"\n            (onBlur)=\"onTagBlurred($event, i)\"\n            draggable=\"{{ editable }}\"\n            (dragstart)=\"dragZone ? onDragStarted($event, item, i) : undefined\"\n            (drop)=\"dragZone ? onTagDropped($event, i) : undefined\"\n            (dragenter)=\"dragZone ? onDragOver($event) : undefined\"\n            (dragover)=\"dragZone ? onDragOver($event, i) : undefined\"\n            (dragleave)=\"dragZone ? dragProvider.onDragEnd() : undefined\"\n            [canAddTag]=\"isTagValid\"\n            [attr.tabindex]=\"0\"\n            [disabled]=\"disable\"\n            [@animation]=\"animationMetadata\"\n            [hasRipple]=\"ripple\"\n            [index]=\"i\"\n            [removable]=\"removable\"\n            [editable]=\"editable\"\n            [displayBy]=\"displayBy\"\n            [identifyBy]=\"identifyBy\"\n            [template]=\"!!hasCustomTemplate() ? templates.first : undefined\"\n            [draggable]=\"dragZone\"\n            [model]=\"item\"\n        >\n        </tag>\n\n        <tag-input-form\n            (onSubmit)=\"onFormSubmit()\"\n            (onBlur)=\"blur()\"\n            (click)=\"dropdown ? dropdown.show() : undefined\"\n            (onKeydown)=\"fireEvents('keydown', $event)\"\n            (onKeyup)=\"fireEvents('keyup', $event)\"\n            [(inputText)]=\"inputText\"\n            [disabled]=\"disable\"\n            [validators]=\"validators\"\n            [asyncValidators]=\"asyncValidators\"\n            [hidden]=\"maxItemsReached\"\n            [placeholder]=\"items.length ? placeholder : secondaryPlaceholder\"\n            [inputClass]=\"inputClass\"\n            [inputId]=\"inputId\"\n            [tabindex]=\"tabindex\"\n        >\n        </tag-input-form>\n    </div>\n\n    <div\n        class=\"progress-bar\"\n        *ngIf=\"isProgressBarVisible$ | async\"\n    ></div>\n</div>\n\n<!-- ERRORS -->\n<div\n    *ngIf=\"hasErrors()\"\n    [ngClass]=\"theme\"\n    class=\"error-messages\"\n>\n    <p\n        *ngFor=\"let error of errors\"\n        class=\"error-message\"\n    >\n        <span>{{ error }}</span>\n    </p>\n</div>\n<ng-content></ng-content>",
        animations,
        styles: [".dark tag:focus{box-shadow:0 0 0 1px #323232}.ng2-tag-input.bootstrap3-info{background-color:#fff;display:inline-block;color:#555;vertical-align:middle;max-width:100%;height:42px;line-height:44px}.ng2-tag-input.bootstrap3-info input{border:none;box-shadow:none;outline:0;background-color:transparent;padding:0 6px;margin:0;width:auto;max-width:inherit}.ng2-tag-input.bootstrap3-info .form-control input::-moz-placeholder{color:#777;opacity:1}.ng2-tag-input.bootstrap3-info .form-control input:-ms-input-placeholder{color:#777}.ng2-tag-input.bootstrap3-info .form-control input::-webkit-input-placeholder{color:#777}.ng2-tag-input.bootstrap3-info input:focus{border:none;box-shadow:none}.bootstrap3-info.ng2-tag-input.ng2-tag-input--focused{box-shadow:inset 0 1px 1px rgba(0,0,0,.4);border:1px solid #ccc}.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;transition:.25s;padding:.25rem 0;min-height:32px;cursor:text;border-bottom:2px solid #efefef}.ng2-tag-input:focus{outline:0}.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.ng2-tag-input.ng2-tag-input--focused{border-bottom:2px solid #2196f3}.ng2-tag-input.ng2-tag-input--invalid{border-bottom:2px solid #f44336}.ng2-tag-input.ng2-tag-input--loading{border:none}.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.ng2-tag-input form{margin:.1em 0}.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.minimal.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:1px solid transparent}.minimal.ng2-tag-input:focus{outline:0}.minimal.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.minimal.ng2-tag-input.ng2-tag-input--loading{border:none}.minimal.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.minimal.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.dark.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:2px solid #444}.dark.ng2-tag-input:focus{outline:0}.dark.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.dark.ng2-tag-input.ng2-tag-input--loading{border:none}.dark.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.dark.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.bootstrap.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:2px solid #efefef}.bootstrap.ng2-tag-input:focus{outline:0}.bootstrap.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.bootstrap.ng2-tag-input.ng2-tag-input--focused{border-bottom:2px solid #0275d8}.bootstrap.ng2-tag-input.ng2-tag-input--invalid{border-bottom:2px solid #d9534f}.bootstrap.ng2-tag-input.ng2-tag-input--loading{border:none}.bootstrap.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.bootstrap.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.bootstrap3-info.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;padding:4px;cursor:text;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);border-radius:4px}.bootstrap3-info.ng2-tag-input:focus{outline:0}.bootstrap3-info.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.bootstrap3-info.ng2-tag-input.ng2-tag-input--invalid{box-shadow:inset 0 1px 1px #d9534f;border-bottom:1px solid #d9534f}.bootstrap3-info.ng2-tag-input.ng2-tag-input--loading{border:none}.bootstrap3-info.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.bootstrap3-info.ng2-tag-input form{margin:.1em 0}.bootstrap3-info.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.error-message{font-size:.8em;color:#f44336;margin:.5em 0 0}.bootstrap .error-message{color:#d9534f}.progress-bar,.progress-bar:before{height:2px;width:100%;margin:0}.progress-bar{background-color:#2196f3;display:flex;position:absolute;bottom:0}.progress-bar:before{background-color:#82c4f8;content:\"\";-webkit-animation:2s cubic-bezier(.4,0,.2,1) infinite running-progress;animation:2s cubic-bezier(.4,0,.2,1) infinite running-progress}@-webkit-keyframes running-progress{0%{margin-left:0;margin-right:100%}50%{margin-left:25%;margin-right:0}100%{margin-left:100%;margin-right:0}}@keyframes running-progress{0%{margin-left:0;margin-right:100%}50%{margin-left:25%;margin-right:0}100%{margin-left:100%;margin-right:0}}tag{display:flex;flex-direction:row;flex-wrap:wrap;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:400;font-size:1em;letter-spacing:.05rem;color:#444;border-radius:16px;transition:.3s;margin:.1rem .3rem .1rem 0;padding:.08rem .45rem;height:32px;line-height:34px;background:#efefef;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;outline:0;cursor:pointer;position:relative}tag:not(.readonly):not(.tag--editing):focus{background:#2196f3;color:#fff;box-shadow:0 2px 3px 1px #d4d1d1}tag:not(.readonly):not(.tag--editing):active{background:#0d8aee;color:#fff;box-shadow:0 2px 3px 1px #d4d1d1}tag:not(:focus):not(.tag--editing):not(:active):not(.readonly):hover{background:#e2e2e2;color:initial;box-shadow:0 2px 3px 1px #d4d1d1}tag.readonly{cursor:default}tag.readonly:focus,tag:focus{outline:0}tag.tag--editing{background-color:#fff;border:1px solid #ccc;cursor:text}.minimal tag{display:flex;flex-direction:row;flex-wrap:wrap;border-radius:0;background:#f9f9f9;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;outline:0;cursor:pointer;position:relative}.minimal tag:not(.readonly):not(.tag--editing):active,.minimal tag:not(.readonly):not(.tag--editing):focus{background:#d0d0d0;color:initial}.minimal tag:not(:focus):not(.tag--editing):not(:active):not(.readonly):hover{background:#ececec}.minimal tag.readonly{cursor:default}.minimal tag.readonly:focus,.minimal tag:focus{outline:0}.minimal tag.tag--editing{cursor:text}.dark tag{display:flex;flex-direction:row;flex-wrap:wrap;color:#f9f9f9;border-radius:3px;background:#444;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;outline:0;cursor:pointer;position:relative}.dark tag:not(.readonly):not(.tag--editing):focus{background:#efefef;color:#444}.dark tag:not(:focus):not(.tag--editing):not(:active):not(.readonly):hover{background:#2b2b2b;color:#f9f9f9}.dark tag.readonly{cursor:default}.dark tag.readonly:focus,.dark tag:focus{outline:0}.dark tag.tag--editing{cursor:text}.bootstrap tag{display:flex;flex-direction:row;flex-wrap:wrap;color:#f9f9f9;border-radius:.25rem;background:#0275d8;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;outline:0;cursor:pointer;position:relative}.bootstrap tag:not(.readonly):not(.tag--editing):active,.bootstrap tag:not(.readonly):not(.tag--editing):focus{background:#025aa5}.bootstrap tag:not(:focus):not(.tag--editing):not(:active):not(.readonly):hover{background:#0267bf;color:#f9f9f9}.bootstrap tag.readonly{cursor:default}.bootstrap tag.readonly:focus,.bootstrap tag:focus{outline:0}.bootstrap tag.tag--editing{cursor:text}.bootstrap3-info tag{display:flex;flex-direction:row;flex-wrap:wrap;font-family:inherit;font-weight:400;font-size:95%;color:#fff;border-radius:.25em;background:#5bc0de;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;outline:0;cursor:pointer;position:relative;padding:.25em .6em;text-align:center;white-space:nowrap}.bootstrap3-info tag:not(.readonly):not(.tag--editing):active,.bootstrap3-info tag:not(.readonly):not(.tag--editing):focus{background:#28a1c5}.bootstrap3-info tag:not(:focus):not(.tag--editing):not(:active):not(.readonly):hover{background:#46b8da;color:#fff}.bootstrap3-info tag.readonly{cursor:default}.bootstrap3-info tag.readonly:focus,.bootstrap3-info tag:focus{outline:0}.bootstrap3-info tag.tag--editing{cursor:text}:host{display:block}"]
    }),
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"],
        DragProvider])
], TagInputComponent);

let DeleteIconComponent = class DeleteIconComponent {
};
DeleteIconComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'delete-icon',
        template: "<span>\n    <svg\n        height=\"16px\"\n        viewBox=\"0 0 32 32\"\n        width=\"16px\"\n    >\n        <path\n            d=\"M17.459,16.014l8.239-8.194c0.395-0.391,0.395-1.024,0-1.414c-0.394-0.391-1.034-0.391-1.428,0  l-8.232,8.187L7.73,6.284c-0.394-0.395-1.034-0.395-1.428,0c-0.394,0.396-0.394,1.037,0,1.432l8.302,8.303l-8.332,8.286  c-0.394,0.391-0.394,1.024,0,1.414c0.394,0.391,1.034,0.391,1.428,0l8.325-8.279l8.275,8.276c0.394,0.395,1.034,0.395,1.428,0  c0.394-0.396,0.394-1.037,0-1.432L17.459,16.014z\"\n            fill=\"#121313\"\n        />\n    </svg>\n</span>",
        styles: [".dark tag:focus{box-shadow:0 0 0 1px #323232}.ng2-tag-input.bootstrap3-info{background-color:#fff;display:inline-block;color:#555;vertical-align:middle;max-width:100%;height:42px;line-height:44px}.ng2-tag-input.bootstrap3-info input{border:none;box-shadow:none;outline:0;background-color:transparent;padding:0 6px;margin:0;width:auto;max-width:inherit}.ng2-tag-input.bootstrap3-info .form-control input::-moz-placeholder{color:#777;opacity:1}.ng2-tag-input.bootstrap3-info .form-control input:-ms-input-placeholder{color:#777}.ng2-tag-input.bootstrap3-info .form-control input::-webkit-input-placeholder{color:#777}.ng2-tag-input.bootstrap3-info input:focus{border:none;box-shadow:none}.bootstrap3-info.ng2-tag-input.ng2-tag-input--focused{box-shadow:inset 0 1px 1px rgba(0,0,0,.4);border:1px solid #ccc}.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;transition:.25s;padding:.25rem 0;min-height:32px;cursor:text;border-bottom:2px solid #efefef}.ng2-tag-input:focus{outline:0}.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.ng2-tag-input.ng2-tag-input--focused{border-bottom:2px solid #2196f3}.ng2-tag-input.ng2-tag-input--invalid{border-bottom:2px solid #f44336}.ng2-tag-input.ng2-tag-input--loading{border:none}.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.ng2-tag-input form{margin:.1em 0}.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.minimal.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:1px solid transparent}.minimal.ng2-tag-input:focus{outline:0}.minimal.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.minimal.ng2-tag-input.ng2-tag-input--loading{border:none}.minimal.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.minimal.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.dark.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:2px solid #444}.dark.ng2-tag-input:focus{outline:0}.dark.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.dark.ng2-tag-input.ng2-tag-input--loading{border:none}.dark.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.dark.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.bootstrap.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;cursor:text;border-bottom:2px solid #efefef}.bootstrap.ng2-tag-input:focus{outline:0}.bootstrap.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.bootstrap.ng2-tag-input.ng2-tag-input--focused{border-bottom:2px solid #0275d8}.bootstrap.ng2-tag-input.ng2-tag-input--invalid{border-bottom:2px solid #d9534f}.bootstrap.ng2-tag-input.ng2-tag-input--loading{border:none}.bootstrap.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.bootstrap.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.bootstrap3-info.ng2-tag-input{display:block;flex-direction:row;flex-wrap:wrap;position:relative;padding:4px;cursor:text;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);border-radius:4px}.bootstrap3-info.ng2-tag-input:focus{outline:0}.bootstrap3-info.ng2-tag-input.ng2-tag-input--dropping{opacity:.7}.bootstrap3-info.ng2-tag-input.ng2-tag-input--invalid{box-shadow:inset 0 1px 1px #d9534f;border-bottom:1px solid #d9534f}.bootstrap3-info.ng2-tag-input.ng2-tag-input--loading{border:none}.bootstrap3-info.ng2-tag-input.ng2-tag-input--disabled{opacity:.5;cursor:not-allowed}.bootstrap3-info.ng2-tag-input form{margin:.1em 0}.bootstrap3-info.ng2-tag-input .ng2-tags-container{flex-wrap:wrap;display:flex}.error-message{font-size:.8em;color:#f44336;margin:.5em 0 0}.bootstrap .error-message{color:#d9534f}:host(delete-icon){width:20px;height:16px;transition:.15s;display:inline-block;text-align:right}:host(delete-icon) path{fill:#444}:host(delete-icon) svg{vertical-align:bottom;height:34px}:host(delete-icon):hover{-webkit-transform:scale(1.5) translateY(-3px);transform:scale(1.5) translateY(-3px)}:host-context(.dark){text-align:right}:host-context(.dark) path{fill:#fff}:host-context(.dark) svg{vertical-align:bottom;height:34px}:host-context(.minimal){text-align:right}:host-context(.minimal) path{fill:#444}:host-context(.minimal) svg{vertical-align:bottom;height:34px}:host-context(.bootstrap){text-align:right}:host-context(.bootstrap) path{fill:#fff}:host-context(.bootstrap) svg{vertical-align:bottom;height:34px}:host-context(tag:active) path,:host-context(tag:focus) path{fill:#fff}:host-context(.darktag:active) path,:host-context(.darktag:focus) path{fill:#000}:host-context(.minimaltag:active) path,:host-context(.minimaltag:focus) path{fill:#000}:host-context(.bootstraptag:active) path,:host-context(.bootstraptag:focus) path{fill:#fff}:host-context(.bootstrap3-info){height:inherit}:host-context(.bootstrap3-info) path{fill:#fff}"]
    })
], DeleteIconComponent);

const optionsProvider = new OptionsProvider();
let TagInputModule = class TagInputModule {
    /**
     * @name withDefaults
     * @param options {Options}
     */
    static withDefaults(options) {
        optionsProvider.setOptions(options);
    }
};
TagInputModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
        imports: [
            _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
            ng2_material_dropdown__WEBPACK_IMPORTED_MODULE_4__["Ng2DropdownModule"]
        ],
        declarations: [
            TagInputComponent,
            DeleteIconComponent,
            TagInputForm,
            TagComponent,
            HighlightPipe,
            TagInputDropdown,
            TagRipple
        ],
        exports: [
            TagInputComponent,
            DeleteIconComponent,
            TagInputForm,
            TagComponent,
            HighlightPipe,
            TagInputDropdown,
            TagRipple
        ],
        providers: [
            DragProvider,
            { provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["COMPOSITION_BUFFER_MODE"], useValue: false },
        ]
    })
], TagInputModule);

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=ngx-chips.js.map


/***/ }),

/***/ "./node_modules/ngx-file-drop/fesm2015/ngx-file-drop.js":
/*!**************************************************************!*\
  !*** ./node_modules/ngx-file-drop/fesm2015/ngx-file-drop.js ***!
  \**************************************************************/
/*! exports provided: NgxFileDropComponent, NgxFileDropModule, NgxFileDropEntry, ɵa */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NgxFileDropComponent", function() { return NgxFileDropComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NgxFileDropModule", function() { return NgxFileDropModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NgxFileDropEntry", function() { return NgxFileDropEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function() { return NgxFileDropContentTemplateDirective; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");




/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * fileEntry is an instance of {\@link FileSystemFileEntry} or {\@link FileSystemDirectoryEntry}.
 * Which one is it can be checked using {\@link FileSystemEntry.isFile} or {\@link FileSystemEntry.isDirectory}
 * properties of the given {\@link FileSystemEntry}.
 */
class NgxFileDropEntry {
    /**
     * @param {?} relativePath
     * @param {?} fileEntry
     */
    constructor(relativePath, fileEntry) {
        this.relativePath = relativePath;
        this.fileEntry = fileEntry;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxFileDropContentTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
NgxFileDropContentTemplateDirective.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[ngx-file-drop-content-tmp]' },] }
];
/** @nocollapse */
NgxFileDropContentTemplateDirective.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxFileDropComponent {
    /**
     * @param {?} zone
     * @param {?} renderer
     */
    constructor(zone, renderer) {
        this.zone = zone;
        this.renderer = renderer;
        this.accept = '*';
        this.directory = false;
        this.multiple = true;
        this.dropZoneLabel = '';
        this.dropZoneClassName = 'ngx-file-drop__drop-zone';
        this.contentClassName = 'ngx-file-drop__content';
        this.showBrowseBtn = false;
        this.browseBtnClassName = 'btn btn-primary btn-xs ngx-file-drop__browse-btn';
        this.browseBtnLabel = 'Browse files';
        this.onFileDrop = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onFileOver = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onFileLeave = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.isDraggingOverDropZone = false;
        this.globalDraggingInProgress = false;
        this.files = [];
        this.numOfActiveReadEntries = 0;
        this.helperFormEl = null;
        this.fileInputPlaceholderEl = null;
        this.dropEventTimerSubscription = null;
        this._disabled = false;
        this.openFileSelector = (/**
         * @param {?=} event
         * @return {?}
         */
        (event) => {
            if (this.fileSelector && this.fileSelector.nativeElement) {
                ((/** @type {?} */ (this.fileSelector.nativeElement))).click();
            }
        });
        this.globalDragStartListener = this.renderer.listen('document', 'dragstart', (/**
         * @param {?} evt
         * @return {?}
         */
        (evt) => {
            this.globalDraggingInProgress = true;
        }));
        this.globalDragEndListener = this.renderer.listen('document', 'dragend', (/**
         * @param {?} evt
         * @return {?}
         */
        (evt) => {
            this.globalDraggingInProgress = false;
        }));
    }
    /**
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = (value != null && `${value}` !== 'false');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.dropEventTimerSubscription) {
            this.dropEventTimerSubscription.unsubscribe();
            this.dropEventTimerSubscription = null;
        }
        this.globalDragStartListener();
        this.globalDragEndListener();
        this.files = [];
        this.helperFormEl = null;
        this.fileInputPlaceholderEl = null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        if (!this.isDropzoneDisabled()) {
            if (!this.isDraggingOverDropZone) {
                this.isDraggingOverDropZone = true;
                this.onFileOver.emit(event);
            }
            this.preventAndStop(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        if (!this.isDropzoneDisabled()) {
            if (this.isDraggingOverDropZone) {
                this.isDraggingOverDropZone = false;
                this.onFileLeave.emit(event);
            }
            this.preventAndStop(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropFiles(event) {
        if (!this.isDropzoneDisabled()) {
            this.isDraggingOverDropZone = false;
            if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'copy';
                /** @type {?} */
                let items;
                if (event.dataTransfer.items) {
                    items = event.dataTransfer.items;
                }
                else {
                    items = event.dataTransfer.files;
                }
                this.preventAndStop(event);
                this.checkFiles(items);
            }
        }
    }
    /**
     * Processes the change event of the file input and adds the given files.
     * @param {?} event
     * @return {?}
     */
    uploadFiles(event) {
        if (!this.isDropzoneDisabled()) {
            if (event.target) {
                /** @type {?} */
                const items = ((/** @type {?} */ (event.target))).files || ((/** @type {?} */ ([])));
                this.checkFiles(items);
                this.resetFileInput();
            }
        }
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    checkFiles(items) {
        for (let i = 0; i < items.length; i++) {
            /** @type {?} */
            const item = items[i];
            /** @type {?} */
            let entry = null;
            if (this.canGetAsEntry(item)) {
                entry = item.webkitGetAsEntry();
            }
            if (!entry) {
                if (item) {
                    /** @type {?} */
                    const fakeFileEntry = {
                        name: ((/** @type {?} */ (item))).name,
                        isDirectory: false,
                        isFile: true,
                        file: (/**
                         * @param {?} callback
                         * @return {?}
                         */
                        (callback) => {
                            callback((/** @type {?} */ (item)));
                        }),
                    };
                    /** @type {?} */
                    const toUpload = new NgxFileDropEntry(fakeFileEntry.name, fakeFileEntry);
                    this.addToQueue(toUpload);
                }
            }
            else {
                if (entry.isFile) {
                    /** @type {?} */
                    const toUpload = new NgxFileDropEntry(entry.name, entry);
                    this.addToQueue(toUpload);
                }
                else if (entry.isDirectory) {
                    this.traverseFileTree(entry, entry.name);
                }
            }
        }
        if (this.dropEventTimerSubscription) {
            this.dropEventTimerSubscription.unsubscribe();
        }
        this.dropEventTimerSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_0__["timer"])(200, 200)
            .subscribe((/**
         * @return {?}
         */
        () => {
            if (this.files.length > 0 && this.numOfActiveReadEntries === 0) {
                /** @type {?} */
                const files = this.files;
                this.files = [];
                this.onFileDrop.emit(files);
            }
        }));
    }
    /**
     * @private
     * @param {?} item
     * @param {?} path
     * @return {?}
     */
    traverseFileTree(item, path) {
        if (item.isFile) {
            /** @type {?} */
            const toUpload = new NgxFileDropEntry(path, item);
            this.files.push(toUpload);
        }
        else {
            path = path + '/';
            /** @type {?} */
            const dirReader = ((/** @type {?} */ (item))).createReader();
            /** @type {?} */
            let entries = [];
            /** @type {?} */
            const readEntries = (/**
             * @return {?}
             */
            () => {
                this.numOfActiveReadEntries++;
                dirReader.readEntries((/**
                 * @param {?} result
                 * @return {?}
                 */
                (result) => {
                    if (!result.length) {
                        // add empty folders
                        if (entries.length === 0) {
                            /** @type {?} */
                            const toUpload = new NgxFileDropEntry(path, item);
                            this.zone.run((/**
                             * @return {?}
                             */
                            () => {
                                this.addToQueue(toUpload);
                            }));
                        }
                        else {
                            for (let i = 0; i < entries.length; i++) {
                                this.zone.run((/**
                                 * @return {?}
                                 */
                                () => {
                                    this.traverseFileTree(entries[i], path + entries[i].name);
                                }));
                            }
                        }
                    }
                    else {
                        // continue with the reading
                        entries = entries.concat(result);
                        readEntries();
                    }
                    this.numOfActiveReadEntries--;
                }));
            });
            readEntries();
        }
    }
    /**
     * Clears any added files from the file input element so the same file can subsequently be added multiple times.
     * @private
     * @return {?}
     */
    resetFileInput() {
        if (this.fileSelector && this.fileSelector.nativeElement) {
            /** @type {?} */
            const fileInputEl = (/** @type {?} */ (this.fileSelector.nativeElement));
            /** @type {?} */
            const fileInputContainerEl = fileInputEl.parentElement;
            /** @type {?} */
            const helperFormEl = this.getHelperFormElement();
            /** @type {?} */
            const fileInputPlaceholderEl = this.getFileInputPlaceholderElement();
            // Just a quick check so we do not mess up the DOM (will never happen though).
            if (fileInputContainerEl !== helperFormEl) {
                // Insert the form input placeholder in the DOM before the form input element.
                this.renderer.insertBefore(fileInputContainerEl, fileInputPlaceholderEl, fileInputEl);
                // Add the form input as child of the temporary form element, removing the form input from the DOM.
                this.renderer.appendChild(helperFormEl, fileInputEl);
                // Reset the form, thus clearing the input element of any files.
                helperFormEl.reset();
                // Add the file input back to the DOM in place of the file input placeholder element.
                this.renderer.insertBefore(fileInputContainerEl, fileInputEl, fileInputPlaceholderEl);
                // Remove the input placeholder from the DOM
                this.renderer.removeChild(fileInputContainerEl, fileInputPlaceholderEl);
            }
        }
    }
    /**
     * Get a cached HTML form element as a helper element to clear the file input element.
     * @private
     * @return {?}
     */
    getHelperFormElement() {
        if (!this.helperFormEl) {
            this.helperFormEl = (/** @type {?} */ (this.renderer.createElement('form')));
        }
        return this.helperFormEl;
    }
    /**
     * Get a cached HTML div element to be used as placeholder for the file input element when clearing said element.
     * @private
     * @return {?}
     */
    getFileInputPlaceholderElement() {
        if (!this.fileInputPlaceholderEl) {
            this.fileInputPlaceholderEl = (/** @type {?} */ (this.renderer.createElement('div')));
        }
        return this.fileInputPlaceholderEl;
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    canGetAsEntry(item) {
        return !!item.webkitGetAsEntry;
    }
    /**
     * @private
     * @return {?}
     */
    isDropzoneDisabled() {
        return (this.globalDraggingInProgress || this.disabled);
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    addToQueue(item) {
        this.files.push(item);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    preventAndStop(event) {
        event.stopPropagation();
        event.preventDefault();
    }
}
NgxFileDropComponent.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{
                selector: 'ngx-file-drop',
                template: "<div [className]=\"dropZoneClassName\"\r\n     [class.ngx-file-drop__drop-zone--over]=\"isDraggingOverDropZone\"\r\n     (drop)=\"dropFiles($event)\"\r\n     (dragover)=\"onDragOver($event)\"\r\n     (dragleave)=\"onDragLeave($event)\">\r\n  <div [className]=\"contentClassName\">\r\n    <input \r\n      type=\"file\" \r\n      #fileSelector \r\n      [accept]=\"accept\" \r\n      [attr.directory]=\"directory || undefined\" \r\n      [attr.webkitdirectory]=\"directory || undefined\"\r\n      [attr.mozdirectory]=\"directory || undefined\"\r\n      [attr.msdirectory]=\"directory || undefined\"\r\n      [attr.odirectory]=\"directory || undefined\"\r\n      [multiple]=\"multiple\"\r\n      (change)=\"uploadFiles($event)\" \r\n      class=\"ngx-file-drop__file-input\" \r\n    />\r\n\r\n    <ng-template #defaultContentTemplate>\r\n      <div *ngIf=\"dropZoneLabel\" class=\"ngx-file-drop__drop-zone-label\">{{dropZoneLabel}}</div>\r\n      <div *ngIf=\"showBrowseBtn\">\r\n        <input type=\"button\" [className]=\"browseBtnClassName\" value=\"{{browseBtnLabel}}\" (click)=\"openFileSelector($event)\" />\r\n      </div>\r\n    </ng-template>\r\n\r\n    <ng-template\r\n      [ngTemplateOutlet]=\"contentTemplate || defaultContentTemplate\"\r\n      [ngTemplateOutletContext]=\"{ openFileSelector: openFileSelector }\">\r\n    </ng-template>\r\n  </div>\r\n</div>\r\n",
                styles: [".ngx-file-drop__drop-zone{height:100px;margin:auto;border:2px dotted #0782d0;border-radius:30px}.ngx-file-drop__drop-zone--over{background-color:rgba(147,147,147,.5)}.ngx-file-drop__content{display:flex;align-items:center;justify-content:center;height:100px;color:#0782d0}.ngx-file-drop__drop-zone-label{text-align:center}.ngx-file-drop__file-input{display:none}"]
            }] }
];
/** @nocollapse */
NgxFileDropComponent.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"] }
];
NgxFileDropComponent.propDecorators = {
    accept: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    directory: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropZoneLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    dropZoneClassName: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    contentClassName: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    showBrowseBtn: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    browseBtnClassName: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    browseBtnLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
    onFileDrop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onFileOver: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    onFileLeave: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
    contentTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [NgxFileDropContentTemplateDirective, { read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"], static: false },] }],
    fileSelector: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: ['fileSelector', { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxFileDropModule {
}
NgxFileDropModule.decorators = [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                declarations: [
                    NgxFileDropComponent,
                    NgxFileDropContentTemplateDirective,
                ],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"]
                ],
                exports: [
                    NgxFileDropComponent,
                    NgxFileDropContentTemplateDirective,
                ],
                providers: [],
                bootstrap: [
                    NgxFileDropComponent
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ngx-file-drop.js.map

/***/ }),

/***/ "./node_modules/ngx-google-places-autocomplete/bundles/ngx-google-places-autocomplete.umd.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ngx-google-places-autocomplete/bundles/ngx-google-places-autocomplete.umd.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports, __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js")) :
	undefined;
}(this, (function (exports,_angular_core) { 'use strict';

var Options = (function () {
    /**
     * @param {?=} opt
     */
    function Options(opt) {
        if (!opt)
            return;
        Object.assign(this, opt);
    }
    return Options;
}());

var GooglePlaceDirective = (function () {
    /**
     * @param {?} el
     * @param {?} ngZone
     */
    function GooglePlaceDirective(el, ngZone) {
        this.el = el;
        this.ngZone = ngZone;
        this.onAddressChange = new _angular_core.EventEmitter();
    }
    /**
     * @return {?}
     */
    GooglePlaceDirective.prototype.ngAfterViewInit = function () {
        if (!this.options)
            this.options = new Options();
        this.initialize();
    };
    /**
     * @return {?}
     */
    GooglePlaceDirective.prototype.isGoogleLibExists = function () {
        return !(!google || !google.maps || !google.maps.places);
    };
    /**
     * @return {?}
     */
    GooglePlaceDirective.prototype.initialize = function () {
        var _this = this;
        if (!this.isGoogleLibExists())
            throw new Error("Google maps library can not be found");
        this.autocomplete = new google.maps.places.Autocomplete(this.el.nativeElement, this.options);
        if (!this.autocomplete)
            throw new Error("Autocomplete is not initialized");
        if (!this.autocomplete.addListener != null) {
            this.eventListener = this.autocomplete.addListener('place_changed', function () {
                _this.handleChangeEvent();
            });
        }
        this.el.nativeElement.addEventListener('keydown', function (event) {
            if (!event.key) {
                return;
            }
            var /** @type {?} */ key = event.key.toLowerCase();
            if (key == 'enter' && event.target === _this.el.nativeElement) {
                event.preventDefault();
                event.stopPropagation();
            }
        });
        // according to https://gist.github.com/schoenobates/ef578a02ac8ab6726487
        if (window && window.navigator && window.navigator.userAgent && navigator.userAgent.match(/(iPad|iPhone|iPod)/g)) {
            setTimeout(function () {
                var /** @type {?} */ containers = document.getElementsByClassName('pac-container');
                if (containers) {
                    var /** @type {?} */ arr = Array.from(containers);
                    if (arr) {
                        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                            var container = arr_1[_i];
                            if (!container)
                                continue;
                            container.addEventListener('touchend', function (e) {
                                e.stopImmediatePropagation();
                            });
                        }
                    }
                }
            }, 500);
        }
    };
    /**
     * @return {?}
     */
    GooglePlaceDirective.prototype.reset = function () {
        this.autocomplete.setComponentRestrictions(this.options.componentRestrictions);
        this.autocomplete.setTypes(this.options.types);
    };
    /**
     * @return {?}
     */
    GooglePlaceDirective.prototype.handleChangeEvent = function () {
        var _this = this;
        this.ngZone.run(function () {
            _this.place = _this.autocomplete.getPlace();
            if (_this.place && _this.place.place_id) {
                _this.onAddressChange.emit(_this.place);
            }
        });
    };
    GooglePlaceDirective.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: '[ngx-google-places-autocomplete]',
                    exportAs: 'ngx-places'
                },] },
    ];
    /**
     * @nocollapse
     */
    GooglePlaceDirective.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.NgZone, },
    ]; };
    GooglePlaceDirective.propDecorators = {
        'options': [{ type: _angular_core.Input, args: ['options',] },],
        'onAddressChange': [{ type: _angular_core.Output },],
    };
    return GooglePlaceDirective;
}());

var GooglePlaceModule = (function () {
    function GooglePlaceModule() {
    }
    GooglePlaceModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    declarations: [GooglePlaceDirective],
                    exports: [GooglePlaceDirective]
                },] },
    ];
    /**
     * @nocollapse
     */
    GooglePlaceModule.ctorParameters = function () { return []; };
    return GooglePlaceModule;
}());

exports.GooglePlaceModule = GooglePlaceModule;
exports.GooglePlaceDirective = GooglePlaceDirective;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/assign-team-members/assign-team-members.component.html":
/*!********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/assign-team-members/assign-team-members.component.html ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Add Team Members</p>\n      </div>\n      <div class=\"card-body\">\n        <form [formGroup]=\"assignMemberForm\">\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Team Name</label>\n                <select class=form-control formControlName=\"teamName\">\n                  <option value=\"\">Select Team Name </option>\n                  <option *ngFor=\"let team of teamList\" value=\"{{team.teamId}}\"> {{team.teamName}} </option>\n              </select>\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">AD User Name</label>\n                <input type=\"text\" class=\"form-control\" formControlName=\"adName\">\n                <!-- <div *ngIf=\"submitted && formFileds.adName.errors\" class=\"invalid-feedback\">\n                  <div *ngIf=\"submitted && formFileds.adName.errors.required\">AD user name is required</div> -->\n              <!-- </div> -->\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1 pt-4\">\n              <button type=\"submit\" class=\"btn btn-default btn-round\">Retrieve User</button>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Name</label>\n                <input type=\"name\" class=\"form-control\" formControlName=\"name\">\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label>Email</label>\n                <input type=\"email\" class=\"form-control\"  formControlName=\"email\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n              <div class=\"col-md-3 pl-3 pt-4 mt-2\">\n                <div class=\"form-group\">\n                  <label style=\"margin-right: 10px;\">Lead</label>\n                  <label class=\"switch\">\n                    <input type=\"checkbox\" checked formControlName=\"isLead\" >\n                    <span class=\"slider round\"></span>\n                  </label>\n                </div>\n              </div>\n            </div>\n          <div class=\"row ml-auto mr-auto\">\n            <div class=\"flex-grow-1\"> </div>\n            <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n              <button type=\"submit\" class=\"btn btn-primary btn-round\"  style=\"width: 120px; margin-right: 40px\" (click)=\"saveTeamMember()\">Save</button>\n              <button type=\"submit\" (click)=\"clear()\" class=\"btn btn-default btn-round\" style=\"width: 120px\">Clear</button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\"> Team List</p>\n      </div>\n      <div class=\"card-body\" >\n        <div class=\"table-responsive\" style=\" overflow-y:hidden;\">\n          <table class=\"table\">\n            <thead class=\" text-primary\">\n              <th>\n                Name\n              </th>\n              <th>\n                Role\n              </th>\n              <th>\n               Team\n              </th>\n            </thead>\n            <tbody>\n              <tr *ngFor=\"let member of teamMemberList;\">\n                <td>{{ member.employee }}</td>\n                <td>{{ member.role }}</td>\n                <td>{{ member.team }}</td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/clusters/clusters.component.html":
/*!**********************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/clusters/clusters.component.html ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<!-- <div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Add Clusters</p>\n      </div>\n      <div class=\"card-body\">\n        <form [formGroup]=\"clusterForm\">\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Cluster Name</label>\n                <input type=\"text\" class=\"form-control\" formControlName=\"clusterName\"\n                  [ngClass]=\"{'is-invalid': submitted && formFileds.teamName.errors }\">\n                <div *ngIf=\"submitted && formFileds.clusterName.errors\" class=\"invalid-feedback\">\n                  <div *ngIf=\"submitted && formFileds.clusterName.errors.required\">Team name is required</div>\n                </div>\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Cluster Description</label>\n                <input type=\"text\" class=\"form-control\" formControlName=\"clusterdescription\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Location</label>\n                <select class=form-control>\n                  <option value=\"\">Select Location </option>\n                  <option *ngFor=\"let location of locations\" value=\"location\"> </option>\n                </select>\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Team Name</label>\n                <select class=form-control>\n                  <option value=\"\">Select Team Name </option>\n                  <option *ngFor=\"let team of teams\" value=\"team\"> </option>\n                </select>\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Dedicated Seats</label>\n                <input type=\"number\" NumberDirective class=\"form-control\" formControlName=\"dedicatedSeats\">\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Hot Seats</label>\n                <input type=\"number\" NumberDirective class=\"form-control\" formControlName=\"hotseats\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row ml-auto mr-auto\">\n            <div class=\"flex-grow-1\"> </div>\n            <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n              <button type=\"submit\" class=\"btn btn-primary btn-round\" style=\"width: 120px; margin-right: 40px\"\n                (click)=\"saveSeatsForTeam()\" >Save</button>\n              <button type=\"submit\" (click)=\"clear()\" class=\"btn btn-default btn-round\"\n                style=\"width: 120px\">Clear</button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\"> Team List</p>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"table-responsive\" style=\" overflow-y:hidden;\">\n          <table class=\"table\">\n            <thead class=\" text-primary\">\n              <th>\n                Cluster Name\n              </th>\n              <th>\n                Description\n              </th>\n              <th>\n                Location\n              </th>\n              <th>\n                Team Name\n              </th>\n              <th>\n                  No of dedicated seats\n              </th>\n              <th>\n                No of hot seats\n              </th>\n              <th>\n                Edit\n              </th>\n            </thead>\n            <tbody>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/dashboard/dashboard.component.html":
/*!************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/dashboard/dashboard.component.html ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<img src=\"../../../assets/img/dashboard_background.png\">\n<!-- <div class=\"row\">\n  <div class=\"col-lg-3 col-md-6 col-sm-6\">\n    <div class=\"card card-stats\">\n      <div class=\"card-body \">\n        <div class=\"row\">\n          <div class=\"col-5 col-md-4\">\n            <div class=\"icon-big text-center icon-warning\">\n              <i class=\"nc-icon nc-globe text-warning\"></i>\n            </div>\n          </div>\n          <div class=\"col-7 col-md-8\">\n            <div class=\"numbers\">\n              <p class=\"card-category\">Capacity</p>\n              <p class=\"card-title\">150GB\n                <p>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"card-footer \">\n        <hr>\n        <div class=\"stats\">\n          <i class=\"fa fa-refresh\"></i> Update Now\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"col-lg-3 col-md-6 col-sm-6\">\n    <div class=\"card card-stats\">\n      <div class=\"card-body \">\n        <div class=\"row\">\n          <div class=\"col-5 col-md-4\">\n            <div class=\"icon-big text-center icon-warning\">\n              <i class=\"nc-icon nc-money-coins text-success\"></i>\n            </div>\n          </div>\n          <div class=\"col-7 col-md-8\">\n            <div class=\"numbers\">\n              <p class=\"card-category\">Revenue</p>\n              <p class=\"card-title\">$ 1,345\n                <p>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"card-footer \">\n        <hr>\n        <div class=\"stats\">\n          <i class=\"fa fa-calendar-o\"></i> Last day\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"col-lg-3 col-md-6 col-sm-6\">\n    <div class=\"card card-stats\">\n      <div class=\"card-body \">\n        <div class=\"row\">\n          <div class=\"col-5 col-md-4\">\n            <div class=\"icon-big text-center icon-warning\">\n              <i class=\"nc-icon nc-vector text-danger\"></i>\n            </div>\n          </div>\n          <div class=\"col-7 col-md-8\">\n            <div class=\"numbers\">\n              <p class=\"card-category\">Errors</p>\n              <p class=\"card-title\">23\n                <p>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"card-footer \">\n        <hr>\n        <div class=\"stats\">\n          <i class=\"fa fa-clock-o\"></i> In the last hour\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"col-lg-3 col-md-6 col-sm-6\">\n    <div class=\"card card-stats\">\n      <div class=\"card-body \">\n        <div class=\"row\">\n          <div class=\"col-5 col-md-4\">\n            <div class=\"icon-big text-center icon-warning\">\n              <i class=\"nc-icon nc-favourite-28 text-primary\"></i>\n            </div>\n          </div>\n          <div class=\"col-7 col-md-8\">\n            <div class=\"numbers\">\n              <p class=\"card-category\">Followers</p>\n              <p class=\"card-title\">+45K\n                <p>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"card-footer \">\n        <hr>\n        <div class=\"stats\">\n          <i class=\"fa fa-refresh\"></i> Update now\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n<!-- <div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card \">\n      <div class=\"card-header \">\n        <h5 class=\"card-title\">Users Behavior</h5>\n        <p class=\"card-category\">24 Hours performance</p>\n      </div>\n      <div class=\"card-body \">\n        <canvas id=chartHours width=\"400\" height=\"100\"></canvas>\n      </div>\n      <div class=\"card-footer \">\n        <hr>\n        <div class=\"stats\">\n          <i class=\"fa fa-history\"></i> Updated 3 minutes ago\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n<!-- <div class=\"row\">\n  <div class=\"col-md-4\">\n    <div class=\"card \">\n      <div class=\"card-header \">\n        <h5 class=\"card-title\">Email Statistics</h5>\n        <p class=\"card-category\">Last Campaign Performance</p>\n      </div>\n      <div class=\"card-body \">\n        <canvas id=\"chartEmail\"></canvas>\n      </div>\n      <div class=\"card-footer \">\n        <div class=\"legend\">\n          <i class=\"fa fa-circle text-primary\"></i> Opened\n          <i class=\"fa fa-circle text-warning\"></i> Read\n          <i class=\"fa fa-circle text-danger\"></i> Deleted\n          <i class=\"fa fa-circle text-gray\"></i> Unopened\n        </div>\n        <hr>\n        <div class=\"stats\">\n          <i class=\"fa fa-calendar\"></i> Number of emails sent\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"col-md-8\">\n    <div class=\"card card-chart\">\n      <div class=\"card-header\">\n        <h5 class=\"card-title\">NASDAQ: AAPL</h5>\n        <p class=\"card-category\">Line Chart with Points</p>\n      </div>\n      <div class=\"card-body\">\n        <canvas id=\"speedChart\" width=\"400\" height=\"100\"></canvas>\n      </div>\n      <div class=\"card-footer\">\n        <div class=\"chart-legend\">\n          <i class=\"fa fa-circle text-info\"></i> Tesla Model S\n          <i class=\"fa fa-circle text-warning\"></i> BMW 5 Series\n        </div>\n        <hr/>\n        <div class=\"card-stats\">\n          <i class=\"fa fa-check\"></i> Data information certified\n        </div>\n      </div>\n    </div>\n  </div>\n</div> -->\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/employee-seat-booking/employee-seat-booking.component.html":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/employee-seat-booking/employee-seat-booking.component.html ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Hot Seats</p>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"row\">\n          <div class=\"col-md-6 pr-1\">\n              <form [formGroup]=\"seatBookingForm\">\n              <label >Location</label>\n              <select class=form-control formControlName=\"location\" (change)=\"getAllSeatsForLocation($event.target.value)\">\n                  <option value=\"\">Select location </option>\n                  <option *ngFor=\"let location of locationList\" value=\"{{location.locationId}}\"> {{location.locationId}} </option>\n                </select>\n              </form>\n            </div>\n            <div class=\"col-md-4 pr-1\" [hidden]=\"!locationSelected\">\n                <div class=\"form-group\" >\n                    <label style=\"margin-left: 10px;margin-right: 10px;\" >Booking Date</label>\n                  <ngb-datepicker #dp [(ngModel)]=\"model\" (navigate)=\"date = $event.next\" (click)=\"getSeats(model)\">\n                  </ngb-datepicker>\n                </div>\n              </div>\n        </div>\n        <div class=\"row\" style=\"margin-top: 30px;\">\n          <div class=\"col-md-6 pr-1\" >\n            <div class=\"row\">\n              <div class=\"col-md-2 pr-1\" *ngFor=\"let seat of seats\">\n                <!-- <button type=\"submit\" class=\"seat btn-round\" (click)=\"selectedSeat(seat)\" style=\"cursor: not-allowed;margin-top: 20px;\"\n                [ngStyle]=\"changeBackground(seat)\" >{{seat}}</button> -->\n                <a ng-class=\"{'disabled': true }\">\n                <img src=\"../../../assets/img/chair.png\" [ngStyle]=\"changeBackground(seat)\" (click)=\"selectedSeat(seat)\" style=\"width:48px; height:48px; cursor: not-allowed;margin-top: 20px;\">\n                <p [ngStyle]=\"yourSeat(seat)\" style=\"visibility: hidden; margin: 0px; color: red;font-weight: bold;\"  >Your Seat</p>\n                <p style=\" margin: 0px;font-weight: bold;\">{{seat}}</p>\n            </a>\n              </div>\n            </div>\n          </div>\n          <div class=\"col-md-4 pr-1\" [hidden]=\"!locationSelected\">\n            <label style=\"font-weight: bold;\">Selected seat ID :</label>\n            <input type=\"text\" class=\"form-control\" value=\"{{selectedSeatId}}\" disabled>\n          </div>\n        </div>\n        <div class=\"row\" style=\"margin-top: 30px;margin-top: 50px;\" [hidden]=\"!locationSelected\">\n          <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; color:red\" disable>\n            <!-- <button type=\"submit\" class=\"btn btn-round\" style=\"background-color: #9D9999; margin:20px;\" disabled></button> -->\n            <p style=\"color:#3393FF; margin-right:30px\">All seats</p>\n            <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid red;\" disable>\n            <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #9D9999; margin:20px; border: 3px solid red\" disabled></button> -->\n            <p style=\"color:red\">Seats for team</p>\n            <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid #53AA33;\" disable>\n            <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #53AA33; margin:20px;\" disabled></button> -->\n            <p style=\"color:#53AA33\">Available hot seats</p>\n            <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid #4FB0F9;\" disable>\n            <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #4FB0F9; margin:20px;\" disabled></button> -->\n            <p style=\"color:#4FB0F9\">Available dedicated seats</p>\n        </div>\n        <div class=\"row\">\n            <div class=\"flex-grow-1\"> </div>\n            <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n            <button type=\"submit\" class=\"btn btn-primary btn-round\" style=\"width: 120px; margin-right: 40px\"\n            (click)=\"bookHotSeat()\" [disabled]='isDisable'>Save</button>\n            </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n<!-- <div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Hot Seats</p>\n      </div>\n      <div class=\"card-body\">\n\n\n      </div>\n    </div>\n  </div>\n</div> -->\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/lead-seat-booking/lead-seat-booking.component.html":
/*!****************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/lead-seat-booking/lead-seat-booking.component.html ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Seat Booking</p>\n      </div>\n      <div class=\"card-body\">\n          <form [formGroup]=\"bookingForm\">\n        <div class=\"row\">\n            <div class=\"col-md-4 pr-1\">\n                <label >AD Name</label>\n                <select class=form-control formControlName=\"adName\">\n                    <option value=\"\">Select AD Name </option>\n                    <option *ngFor=\"let member of teamMemberList\" value=\"{{member.employee}}\"> {{member.employee}} </option>\n                  </select>\n              </div>\n              <div class=\"col-md-4 pr-1\">\n                  <label >Location</label>\n                  <select class=form-control formControlName=\"location\" (change)=\"getAllSeatsForLocation($event.target.value)\">\n                      <option value=\"\">Select location </option>\n                      <option *ngFor=\"let location of locationList\" value=\"{{location.locationId}}\"> {{location.locationId}} </option>\n                    </select>\n                </div>\n          <div class=\"col-md-4 pr-1\" [hidden]=\"!locationSelected\">\n            <div class=\"form-group\">\n              <label style=\"margin-right: 20px; font-size: 15px;\">Start Date</label>\n              <ngb-datepicker #dp [(ngModel)]=\"smodel\" (navigate)=\"sdate = $event.next\" (click)=\"getSeats(smodel)\" formControlName=\"bookingDate\">\n              </ngb-datepicker>\n            </div>\n          </div>\n\n        </div>\n      </form>\n        <div class=\"row\">\n          <div class=\"row\" style=\"margin-left: 40px;\">\n            <div class=\"col-md-2 pr-1\" *ngFor=\"let seat of seats\">\n                <!-- <button type=\"submit\" class=\"seat btn-round\" (click)=\"selectedSeat(seat)\" style=\"cursor: not-allowed;margin-top: 20px;\"\n                [ngStyle]=\"changeBackground(seat)\">{{seat}}</button> -->\n                <img src=\"../../../assets/img/chair.png\" [ngStyle]=\"changeBackground(seat)\"   (click)=\"selectedSeat(seat)\" style=\"width:48px; height:48px; cursor: not-allowed;margin-top: 40px;\">\n                <p style=\"margin-top: 0em; margin-bottom: 0em; \" [ngStyle]=\"seatOwner(seat)\" style=\"visibility: hidden; margin: 0px;font-weight: bold;\" >{{ownerName}}</p>\n                <p style=\"margin-top: 0em; margin-bottom: 0em;font-weight: bold;\">{{seat}}</p>\n                <p style=\"margin-top: 0em; margin-bottom: 0em; \" [ngStyle]=\"yourSeat(seat)\" style=\"visibility: hidden; margin: 0px; color: red;font-weight: bold;\"  >Your Seat</p>\n            </div>\n          </div>\n        </div>\n        <div class=\"row\" style=\"margin-top: 20px;\">\n            <div class=\"col-md-4 pr-1\" [hidden]=\"!locationSelected\">\n          <label style=\"font-weight: bold;\">Selected seat ID :</label>\n          <input type=\"text\" class=\"form-control\" value=\"{{selectedSeatId}}\" disabled>\n          </div>\n        </div>\n        <div class=\"row\" style=\"margin-left: 30px;margin-top: 50px;\"  [hidden]=\"!locationSelected\">\n          <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px;\" disable>\n          <!-- <button type=\"submit\" class=\"btn btn-round\" style=\"background-color: #9D9999; margin:20px;\" disabled></button> -->\n            <p style=\"color:#3393FF; margin-right:30px\">All seats</p>\n            <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid red;\" disable>\n            <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #9D9999; margin:20px; border: 3px solid red\" disabled></button> -->\n            <p style=\"color:red\">Seats for team</p>\n            <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid #53AA33\" disable>\n            <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #53AA33; margin:20px;\" disabled></button> -->\n            <p style=\"color:#53AA33\">Available hot seats</p>\n            <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid #4FB0F9\" disable>\n            <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #4FB0F9; margin:20px;\" disabled></button> -->\n            <p style=\"color:#4FB0F9\">Available dedicated seats</p>\n\n        </div>\n        <div class=\"row\">\n          <div class=\"flex-grow-1\"> </div>\n          <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n            <button type=\"submit\" class=\"btn btn-primary btn-round\" style=\"width: 120px; margin-right: 40px\"\n              (click)=\"bookDedicatedSeats()\" [disabled]='isDisable'>Save</button>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/locations/locations.component.html":
/*!************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/locations/locations.component.html ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n    <div class=\"col-md-12\">\n      <div class=\"card card-user\">\n        <div class=\"card-header\">\n          <p class=\"card-title\" style=\"font-size: 25px;\">Add seats</p>\n        </div>\n        <div class=\"card-body\">\n          <form [formGroup]=\"locationForm\">\n            <div class=\"row\">\n              <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                    <label for=\"exampleInputEmail1\">Location</label>\n                    <select class=form-control  formControlName=\"location\">\n                      <option value=\"\">Select location </option>\n                      <option *ngFor=\"let location of locationList\" value=\"{{location.locationId}}\">{{location.locationId}}  </option>\n                  </select>\n                </div>\n              </div>\n              <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                  <label for=\"exampleInputEmail1\">Seat Id</label>\n                  <input type=\"name\" class=\"form-control\" formControlName=\"seatId\">\n                </div>\n              </div>\n            </div>\n            <div class=\"row\">\n              <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                  <label for=\"exampleInputEmail1\">Description</label>\n                  <input type=\"name\" class=\"form-control\" formControlName=\"description\">\n                </div>\n              </div>\n            </div>\n            <div class=\"row ml-auto mr-auto\">\n              <div class=\"flex-grow-1\"> </div>\n              <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n                <button type=\"submit\" class=\"btn btn-primary btn-round\"  style=\"width: 120px; margin-right: 40px\" (click)=\"saveLocation()\">Save</button>\n                <button type=\"submit\" (click)=\"clear()\" class=\"btn btn-default btn-round\" style=\"width: 120px\">Clear</button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <div class=\"card\">\n        <div class=\"card-header\">\n          <p class=\"card-title\" style=\"font-size: 25px;\"> Seat List</p>\n        </div>\n        <div class=\"card-body\" >\n          <div class=\"table-responsive\" style=\" overflow-y:hidden;\">\n            <table class=\"table\">\n              <thead class=\" text-primary\">\n                <th>\n                  Location Id\n                </th>\n                <th>\n                  No of seats\n                </th>\n                <th>\n                 Description\n                </th>\n              </thead>\n              <tbody>\n                <tr  *ngFor=\"let location of locationList\">\n                  <td>{{ location.locationId }}</td>\n                  <td>{{ location.totSeatNumber }}</td>\n                  <td>{{ location.description }}</td>\n                </tr>\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/roles/roles.component.html":
/*!****************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/roles/roles.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n    <div class=\"col-md-12\">\n      <div class=\"card card-user\">\n        <div class=\"card-header\">\n          <p class=\"card-title\" style=\" font-size: 25px;\">Role Permissions</p>\n        </div>\n        <div class=\"card-body\">\n          <form>\n\n            <div class=\"row mb-4\">\n                <div class=\"col-md-12\">\n                    <select class=form-control (change)=\"onSelectChanged($event.target.value)\">\n                        <option value=\"\"> Select Role </option>\n                        <option value=\"adminPermissions\">Admin Permissions</option>\n                        <option value=\"superAdminPresmission\">Super Admin Permissions</option>\n                    </select>\n                </div>\n            </div>\n            <div class=\"row\">\n                <div class=\"col-md-12\">\n                    <div class=\"checkbox mb-1\" onclick=\"return false\">\n                        <label><input type=\"checkbox\" [checked]=\"permissions.indexOf('View User Role') != -1\"><p class=\"checkboxText\">User roles</p></label>\n                    </div>\n                    <div class=\"checkbox mb-1\" onclick=\"return false\">\n                        <label><input type=\"checkbox\" [checked]=\"permissions.indexOf('Add Users') != -1\"><p class=\"checkboxText\">User profile</p></label>\n                    </div>\n                    <div class=\"checkbox mb-1\" onclick=\"return false\">\n                        <label><input type=\"checkbox\" [checked]=\"permissions.indexOf('Trailers') != -1\"><p class=\"checkboxText\">Marketing content</p></label>\n                    </div>\n                    <div class=\"checkbox mb-1\" onclick=\"return false\">\n                        <label><input type=\"checkbox\" [checked]=\"permissions.indexOf('Promotions') != -1\"><p class=\"checkboxText\">Promotions</p></label>\n                    </div>\n                    <!-- <div class=\"checkbox mb-1\" onclick=\"return false\">\n                        <label><input type=\"checkbox\" [checked]=\"permissions.indexOf('ScratchCard') != -1\"><p class=\"checkboxText\">Scratch card</p></label>\n                    </div> -->\n                    <div class=\"checkbox mb-1\" onclick=\"return false\">\n                        <label><input type=\"checkbox\" [checked]=\"permissions.indexOf('Bundle') != -1\"><p class=\"checkboxText\">Data packages</p></label>\n                    </div>\n                </div>\n            </div>\n\n          </form>\n        </div>\n      </div>\n    </div>\n  </div>\n  "

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/team-mates/team-mates.component.html":
/*!**************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/team-mates/team-mates.component.html ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n<div class=\"row\">\n    <div class=\"col-md-12\">\n      <div class=\"card\">\n        <div class=\"card-header\">\n          <p class=\"card-title\" style=\"font-size: 25px;\"> Team Mate List</p>\n        </div>\n        <div class=\"card-body\" >\n          <div class=\"table-responsive\" style=\" overflow-y:hidden;\">\n            <table class=\"table\">\n              <thead class=\" text-primary\">\n                <th>\n                  Name\n                </th>\n                <th>\n                  Role\n                </th>\n                <th>\n                    Created Date\n                  </th>\n              </thead>\n              <tbody>\n                <tr *ngFor=\"let member of teamMemberList;\" >\n                  <td *ngIf=\"member.team==loggedUserTeam\">{{ member.employee }}</td>\n                  <td *ngIf=\"member.team==loggedUserTeam\">{{ member.role }}</td>\n                  <td *ngIf=\"member.team==loggedUserTeam\">{{member.createdDate|date:'yyyy-MM-dd '}}</td>\n                </tr>\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/teams/teams.component.html":
/*!****************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/teams/teams.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Add Teams</p>\n      </div>\n      <div class=\"card-body\">\n        <form [formGroup]=\"teamForm\">\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Team Name</label>\n                <input type=\"text\" class=\"form-control\" formControlName=\"teamName\">\n                <!-- <div *ngIf=\"submitted && formFileds.teamName.errors\" class=\"invalid-feedback\">\n                  <div *ngIf=\"submitted && formFileds.teamName.errors.required\">Team name is required</div>\n                </div> -->\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Description</label>\n                <input type=\"name\" class=\"form-control\" formControlName=\"description\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Location</label>\n                <select class=form-control formControlName=\"location\">\n                  <option value=\"\">Select location </option>\n                  <option *ngFor=\"let location of locationList\" value=\" {{location.locationId}}\"> {{location.locationId}} </option>\n                </select>\n              </div>\n            </div>\n          </div>\n          <div class=\"row ml-auto mr-auto\">\n            <div class=\"flex-grow-1\"> </div>\n            <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n              <button type=\"submit\" class=\"btn btn-primary btn-round\" style=\"width: 120px; margin-right: 40px\"\n                (click)=\"saveTeams()\">Save</button>\n              <button type=\"submit\" (click)=\"clear()\" class=\"btn btn-default btn-round\"\n                style=\"width: 120px\">Clear</button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Add Clusters</p>\n      </div>\n      <div class=\"card-body\">\n        <form [formGroup]=\"clusterForm\">\n          <!-- <div class=\"row\">\n              <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                  <label for=\"exampleInputEmail1\">Cluster Name</label>\n                  <input type=\"text\" class=\"form-control\" formControlName=\"clusterName\"\n                    [ngClass]=\"{'is-invalid': submitted && formFileds.teamName.errors }\">\n                  <div *ngIf=\"submitted && formFileds.clusterName.errors\" class=\"invalid-feedback\">\n                    <div *ngIf=\"submitted && formFileds.clusterName.errors.required\">Team name is required</div>\n                  </div>\n                </div>\n              </div>\n              <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                  <label for=\"exampleInputEmail1\">Cluster Description</label>\n                  <input type=\"text\" class=\"form-control\" formControlName=\"clusterdescription\">\n                </div>\n              </div>\n            </div> -->\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Location</label>\n                <select class=form-control formControlName=\"location\">\n                  <option value=\"\">Select Location </option>\n                  <option *ngFor=\"let location of locationList\" value=\"{{location.locationId}}\">\n                    {{location.locationId}} </option>\n                </select>\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Team Name</label>\n                <select class=form-control formControlName=\"teamName\">\n                  <option value=\"\">Select Team Name </option>\n                  <option *ngFor=\"let team of teamList\" value={{team.teamId}}>{{team.teamName}} </option>\n                </select>\n              </div>\n            </div>\n          </div>\n        </form>\n        <div class=\"row\">\n          <div class=\"col-md-6 pr-1\">\n            <div class=\"form-group\">\n              <label style=\"margin-right: 20px; font-size: 15px;\">Start Date</label>\n              <ngb-datepicker #dp [(ngModel)]=\"smodel\" (navigate)=\"sdate = $event.next\" (click)=\"addStartDate(smodel)\">\n              </ngb-datepicker>\n            </div>\n          </div>\n          <div class=\"col-md-6 pr-1\">\n            <label style=\"margin-right: 20px; font-size: 15px;\">End Date</label>\n            <ngb-datepicker #dp [(ngModel)]=\"emodel\" (navigate)=\"edate = $event.next\" (click)=\"getSeats(emodel)\"\n              [disabled]=\"!startDateSelected\">\n            </ngb-datepicker>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"col-md-6 pr-1\">\n            <div class=\"form-group\">\n              <label for=\"exampleInputEmail1\">Dedicated Seats</label>\n              <!-- <select class=form-control formControlName=\"dedicatedSeats\" multiple>\n                      <option value=\"\">Select Team Name </option>\n                      <option *ngFor=\"let team of teams\" value=\"team\"> </option>\n                    </select> -->\n              <tag-input class=\"form-control\" [ngModel]=\"[]\" (onAdd)=\"onItemAddedToDedicated($event)\"\n                (onRemove)=\"removeDedicatedSeats($event)\">\n                <tag-input-dropdown [autocompleteItems]=\"items\" [showDropdownIfEmpty]=\"true\" [dynamicUpdate]=\"false\">\n                </tag-input-dropdown>\n              </tag-input>\n            </div>\n          </div>\n          <div class=\"col-md-6 pr-1\">\n            <div class=\"form-group\">\n              <label for=\"exampleInputEmail1\">Hot Seats</label>\n              <!-- <select class=form-control formControlName=\"hotseats\" multiple>\n                      <option value=\"\">Select Team Name </option>\n                      <option *ngFor=\"let team of teams\" value=\"team\"> </option>\n                    </select> -->\n              <tag-input class=\"form-control\" [ngModel]=\"[]\" (onAdd)=\"onItemAddedToHot($event)\"\n                (onRemove)=\"removeHotSeats($event)\">\n                <tag-input-dropdown [autocompleteItems]=\"items\" [showDropdownIfEmpty]=\"true\" [dynamicUpdate]=\"false\">\n                </tag-input-dropdown>\n              </tag-input>\n              <div *ngIf=\"duplicates.length!=0\" class=\"error\">Selected seat already booked</div>\n            </div>\n          </div>\n        </div>\n        <div class=\"row ml-auto mr-auto\">\n          <div class=\"flex-grow-1\"> </div>\n          <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n            <button type=\"submit\" class=\"btn btn-primary btn-round\" style=\"width: 120px; margin-right: 40px\"\n              (click)=\"saveSeatsForTeam()\">Save</button>\n            <button type=\"submit\" (click)=\"clear()\" class=\"btn btn-default btn-round\"\n              style=\"width: 120px\">Clear</button>\n          </div>\n        </div>\n\n      </div>\n    </div>\n  </div>\n</div>\n\n\n<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\"> Team List</p>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"table-responsive\" style=\" overflow-y:hidden;\">\n          <table class=\"table\">\n            <thead class=\" text-primary\">\n              <th>\n                Team ID\n              </th>\n              <th>\n                Team Name\n              </th>\n              <th>\n                Description\n              </th>\n              <th>\n                Location\n              </th>\n              <th>\n                Edit\n              </th>\n            </thead>\n            <tbody>\n              <tr *ngFor=\"let team of teamList\">\n                <td>{{ team.teamId }}</td>\n                <td>{{ team.teamName }}</td>\n                <td>{{ team.description }}</td>\n                <td>{{ team.location }}</td>\n                <td>\n                    <label class=\"switch\">\n                        <button type=\"submit\" class=\"btn btn-default btn-round\"\n                        style=\"width: 80px\">Edit</button>\n                    </label>\n                  </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/user-profile/user-profile.component.html":
/*!******************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/user-profile/user-profile.component.html ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Add User</p>\n      </div>\n      <div class=\"card-body\">\n        <form [formGroup]=\"userForm\">\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">AD User Name</label>\n                <input type=\"text\" class=\"form-control\" formControlName=\"adName\">\n                <!-- <div *ngIf=\"submitted && formFileds.adName.errors\" class=\"invalid-feedback\">\n                  <div *ngIf=\"submitted && formFileds.adName.errors.required\">AD user name is required</div>\n              </div> -->\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1 pt-4\">\n              <button type=\"submit\" class=\"btn btn-default btn-round\">Retrieve User</button>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Name</label>\n                <input type=\"name\" class=\"form-control\" formControlName=\"name\"disabled>\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label>Email</label>\n                <input type=\"email\" class=\"form-control\"  disabled formControlName=\"email\">\n              </div>\n            </div>\n\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label>User Role</label>\n                <input type=\"text\" class=\"form-control\" formControlName=\"userRole\" disabled>\n              </div>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                    <label for=\"exampleInputEmail1\">Team Name</label>\n                    <select class=form-control >\n                      <option value=\"\">Select Team Name </option>\n                      <!-- <option *ngFor=\"let team of teams\" value=\"team\">  </option> -->\n                  </select>\n                </div>\n              </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-3 pl-3 pt-4 mt-2\">\n              <div class=\"form-group\">\n                <label style=\"margin-right: 10px;\">Status</label>\n                <label class=\"switch\">\n                  <input type=\"checkbox\" checked formControlName=\"isEnable\" >\n                  <span class=\"slider round\"></span>\n                </label>\n              </div>\n            </div>\n          </div>\n          <div class=\"row ml-auto mr-auto\">\n            <div class=\"flex-grow-1\"> </div>\n            <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n              <button type=\"submit\" class=\"btn btn-primary btn-round\"  style=\"width: 120px; margin-right: 40px\" (click)=\"save()\" [disabled]=\"!validateRequiredFeilds\">Save</button>\n              <button type=\"submit\" (click)=\"clear()\" class=\"btn btn-default btn-round\" style=\"width: 120px\">Clear</button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\"> User List</p>\n      </div>\n      <div class=\"card-body\" >\n        <div class=\"table-responsive\" style=\" overflow-y:hidden;\">\n          <table class=\"table\">\n            <thead class=\" text-primary\">\n              <th>\n                User Name\n              </th>\n              <th>\n                Display Name\n              </th>\n              <th>\n                Email\n              </th>\n              <th>\n                  Team name\n              </th>\n              <th>\n                User Role\n              </th>\n              <th>\n                Status\n              </th>\n            </thead>\n            <tbody>\n              <tr *ngFor=\"let user of userList;\">\n                <td>{{ user.adName }}</td>\n                <td>{{ user.adminName }}</td>\n                <td>{{ user.email }}</td>\n                <td>{{ user.email }}</td>\n                <td>{{ user.defaultRole }}</td>\n                <td>\n                  <label class=\"switch\">\n                    <input type=\"checkbox\" (change)=\"openConfirmation(user.adName,user.enabled,'Enable Confirmation')\"\n                     [checked]=\"user.enabled\" [disabled]=\"userName==user.adName\">\n                    <span class=\"slider round\"></span>\n                  </label>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/user-role-list/user-role-list.component.html":
/*!**********************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/user-role-list/user-role-list.component.html ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<!-- <div class=\"row\">\n    <div class=\"col-md-12\">\n      <div class=\"card\">\n        <div class=\"card-header\">\n          <h4 class=\"card-title\"> User Role List</h4>\n        </div>\n        <div class=\"card-body\">\n          <div class=\"table-responsive\">\n            <table class=\"table\">\n              <thead class=\" text-primary\">\n                <th>\n                  User role\n                </th>\n                <th>\n                  User Name\n                </th>\n                <th>\n                  Email\n                </th>\n                <th class=\"text-right\">\n                  Edit\n                </th>\n              </thead>\n              <tbody >\n                  <tr *ngFor=\"let country of countries; index as i\">\n                      <th scope=\"row\">{{ i + 1 }}</th>\n                      <td>\n                        <img [src]=\"'https://upload.wikimedia.org/wikipedia/commons/' + country.flag\" class=\"mr-2\" style=\"width: 20px\">\n                        {{ country.name }}\n                      </td>\n                      <td>{{ country.area | number }}</td>\n                      <td>{{ country.population | number }}</td>\n                    </tr>\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"row\">\n    <div class=\"col-md-12\">\n      <user-cmp></user-cmp>\n    </div>\n  </div>\n   -->"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/user/user.component.html":
/*!**************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/user/user.component.html ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <h5 class=\"card-title\">Edit Profile</h5>\n      </div>\n      <div class=\"card-body\">\n        <form>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                  <label for=\"exampleInputEmail1\">User Name</label>\n                <input type=\"text\" class=\"form-control\" placeholder=\"Username\" value=\"michael23\">\n              </div>\n            </div>\n            <div class=\"col-md-6 pl-1\">\n              <div class=\"form-group\">\n                <label for=\"exampleInputEmail1\">Email address</label>\n                <input type=\"email\" class=\"form-control\" placeholder=\"Email\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <div class=\"form-group\">\n                <label>First Name</label>\n                <input type=\"text\" class=\"form-control\" placeholder=\"Company\" value=\"Chet\">\n              </div>\n            </div>\n            <div class=\"col-md-6 pl-1\">\n              <div class=\"form-group\">\n                <label>Last Name</label>\n                <input type=\"text\" class=\"form-control\" placeholder=\"Last Name\" value=\"Faker\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-md-12\">\n              <div class=\"form-group\">\n                <label>Address</label>\n                <input type=\"text\" class=\"form-control\" placeholder=\"Home Address\" value=\"Melbourne, Australia\">\n              </div>\n            </div>\n          </div>\n          <div class=\"row\">\n              <div class=\"col-md-12\">\n                  <div class=\"form-group\">\n                      <label for=\"exampleFormControlSelect1\">Example select</label>\n                      <select class=\"form-control\" id=\"exampleFormControlSelect1\" multiple>\n                        <option>1</option>\n                        <option>2</option>\n                        <option>3</option>\n                        <option>4</option>\n                        <option>5</option>\n                      </select>\n                    </div>\n              </div>\n            </div>\n          <div class=\"row\">\n            <div class=\"update ml-auto mr-auto\">\n              <button type=\"submit\" class=\"btn btn-primary btn-round\">Update Profile</button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.html":
/*!********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.html ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <div class=\"card card-user\">\n      <div class=\"card-header\">\n        <p class=\"card-title\" style=\"font-size: 25px;\">Weekly Seat Booking</p>\n      </div>\n      <div class=\"card-body\">\n        <form [formGroup]=\"bookingForm\">\n          <div class=\"row\">\n            <div class=\"col-md-6 pr-1\">\n              <label>AD Name</label>\n              <select class=form-control formControlName=\"adName\">\n                <option value=\"\">Select AD Name </option>\n                <option *ngFor=\"let member of teamMemberList\" value=\"{{member.employee}}\"> {{member.employee}} </option>\n              </select>\n            </div>\n            <div class=\"col-md-6 pr-1\">\n              <label>Location</label>\n              <select class=form-control formControlName=\"location\"\n                (change)=\"getAllSeatsForLocation($event.target.value)\">\n                <option value=\"\">Select location </option>\n                <option *ngFor=\"let location of locationList\" value=\"{{location.locationId}}\"> {{location.locationId}}\n                </option>\n              </select>\n            </div>\n          </div>\n\n        </form>\n          <div class=\"row\" style=\"margin-top:40px\" [hidden]=\"!locationSelected\">\n            <div class=\"col-md-6 pr-1\">\n                <div class=\"form-group\">\n                  <label style=\"margin-right: 20px; font-size: 15px;\">Start Date</label>\n                  <ngb-datepicker #dp [(ngModel)]=\"smodel\" (navigate)=\"sdate = $event.next\" (click)=\"addStartDate(smodel)\">\n                  </ngb-datepicker>\n                </div>\n              </div>\n              <div class=\"col-md-6 pr-1\">\n                <label style=\"margin-right: 20px; font-size: 15px;\">End Date</label>\n                <ngb-datepicker #dp [(ngModel)]=\"emodel\" (navigate)=\"edate = $event.next\" (click)=\"getSeats(emodel)\"\n                  [disabled]=\"!startDateSelected\">\n                </ngb-datepicker>\n              </div>\n          </div>\n\n        <div class=\"row\">\n          <div class=\"row\" style=\"margin-left: 40px;\">\n            <div class=\"col-md-2 pr-1\" *ngFor=\"let seat of seats\">\n              <!-- <button type=\"submit\" class=\"seat btn-round\" (click)=\"selectedSeat(seat)\" style=\"cursor: not-allowed;margin-top: 20px;\"\n                [ngStyle]=\"changeBackground(seat)\">{{seat}}</button> -->\n              <img src=\"../../../assets/img/chair.png\" [ngStyle]=\"changeBackground(seat)\" (click)=\"selectedSeat(seat)\"\n                style=\"width:48px; height:48px; cursor: not-allowed;margin-top: 40px;\">\n              <p style=\"margin-top: 0em; margin-bottom: 0em;font-weight: bold;\">{{seat}}</p>\n              <p style=\"margin-top: 0em; margin-bottom: 0em; \" [ngStyle]=\"yourSeat(seat)\"\n                style=\"visibility: hidden; margin: 0px; color: red;font-weight: bold;\">Your Seat</p>\n            </div>\n          </div>\n        </div>\n        <div class=\"row\" style=\"margin-top: 20px;\">\n          <div class=\"col-md-4 pr-1\" [hidden]=\"!locationSelected\">\n            <label style=\"font-weight: bold;\">Selected seat ID :</label>\n            <input type=\"text\" class=\"form-control\" value=\"{{selectedSeatId}}\" disabled>\n          </div>\n        </div>\n        <div class=\"row\" style=\"margin-left: 30px;margin-top: 50px;\" [hidden]=\"!locationSelected\">\n          <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px;\" disable>\n          <!-- <button type=\"submit\" class=\"btn btn-round\" style=\"background-color: #9D9999; margin:20px;\" disabled></button> -->\n          <p style=\"color:#3393FF; margin-right:30px\">All seats</p>\n          <img src=\"../../../assets/img/chair.png\" style=\"margin:20px; width:48px; height:48px; border: 3px solid red;\"\n            disable>\n          <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #9D9999; margin:20px; border: 3px solid red\" disabled></button> -->\n          <p style=\"color:red\">Seats for team</p>\n          <img src=\"../../../assets/img/chair.png\"\n            style=\"margin:20px; width:48px; height:48px; border: 3px solid #53AA33\" disable>\n          <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #53AA33; margin:20px;\" disabled></button> -->\n          <p style=\"color:#53AA33\">Available hot seats</p>\n          <img src=\"../../../assets/img/chair.png\"\n            style=\"margin:20px; width:48px; height:48px; border: 3px solid #4FB0F9\" disable>\n          <!-- <button type=\"submit\" class=\"btn  btn-round\" style=\"background-color: #4FB0F9; margin:20px;\" disabled></button> -->\n          <p style=\"color:#4FB0F9\">Available dedicated seats</p>\n\n        </div>\n        <div class=\"row\">\n          <div class=\"flex-grow-1\"> </div>\n          <div class=\"update \" style=\"align-self: flex-end; margin-right: 3%;\">\n            <button type=\"submit\" class=\"btn btn-primary btn-round\" style=\"width: 120px; margin-right: 40px\"\n              (click)=\"bookDedicatedSeats()\" [disabled]='isDisable'>Save</button>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n"

/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);


/***/ }),

/***/ "./src/app/layouts/admin-layout/admin-layout.module.ts":
/*!*************************************************************!*\
  !*** ./src/app/layouts/admin-layout/admin-layout.module.ts ***!
  \*************************************************************/
/*! exports provided: AdminLayoutModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdminLayoutModule", function() { return AdminLayoutModule; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _admin_layout_routing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./admin-layout.routing */ "./src/app/layouts/admin-layout/admin-layout.routing.ts");
/* harmony import */ var _pages_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../pages/dashboard/dashboard.component */ "./src/app/pages/dashboard/dashboard.component.ts");
/* harmony import */ var _pages_user_user_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../pages/user/user.component */ "./src/app/pages/user/user.component.ts");
/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ng-bootstrap/ng-bootstrap */ "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
/* harmony import */ var app_pages_user_role_list_user_role_list_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/pages/user-role-list/user-role-list.component */ "./src/app/pages/user-role-list/user-role-list.component.ts");
/* harmony import */ var app_pages_roles_roles_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/pages/roles/roles.component */ "./src/app/pages/roles/roles.component.ts");
/* harmony import */ var ngx_file_drop__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ngx-file-drop */ "./node_modules/ngx-file-drop/fesm2015/ngx-file-drop.js");
/* harmony import */ var app_pages_user_profile_user_profile_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/pages/user-profile/user-profile.component */ "./src/app/pages/user-profile/user-profile.component.ts");
/* harmony import */ var igniteui_angular__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! igniteui-angular */ "./node_modules/igniteui-angular/fesm2015/igniteui-angular.js");
/* harmony import */ var app_pages_user_profile_services_useProfileResolver__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/pages/user-profile/services/useProfileResolver */ "./src/app/pages/user-profile/services/useProfileResolver.ts");
/* harmony import */ var _agm_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @agm/core */ "./node_modules/@agm/core/fesm2015/agm-core.js");
/* harmony import */ var ngx_google_places_autocomplete__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ngx-google-places-autocomplete */ "./node_modules/ngx-google-places-autocomplete/bundles/ngx-google-places-autocomplete.umd.js");
/* harmony import */ var ngx_google_places_autocomplete__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(ngx_google_places_autocomplete__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var app_shared_directives_numbers_only_directive__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/shared/directives/numbers-only.directive */ "./src/app/shared/directives/numbers-only.directive.ts");
/* harmony import */ var app_shared_directives_prices_directive__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/shared/directives/prices.directive */ "./src/app/shared/directives/prices.directive.ts");
/* harmony import */ var app_pages_teams_teams_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/pages/teams/teams.component */ "./src/app/pages/teams/teams.component.ts");
/* harmony import */ var app_pages_assign_team_members_assign_team_members_component__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! app/pages/assign-team-members/assign-team-members.component */ "./src/app/pages/assign-team-members/assign-team-members.component.ts");
/* harmony import */ var app_pages_clusters_clusters_component__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! app/pages/clusters/clusters.component */ "./src/app/pages/clusters/clusters.component.ts");
/* harmony import */ var app_pages_locations_locations_component__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! app/pages/locations/locations.component */ "./src/app/pages/locations/locations.component.ts");
/* harmony import */ var ngx_chips__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ngx-chips */ "./node_modules/ngx-chips/fesm2015/ngx-chips.js");
/* harmony import */ var app_pages_employee_seat_booking_employee_seat_booking_component__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! app/pages/employee-seat-booking/employee-seat-booking.component */ "./src/app/pages/employee-seat-booking/employee-seat-booking.component.ts");
/* harmony import */ var app_pages_lead_seat_booking_lead_seat_booking_component__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! app/pages/lead-seat-booking/lead-seat-booking.component */ "./src/app/pages/lead-seat-booking/lead-seat-booking.component.ts");
/* harmony import */ var app_pages_assign_team_members_assignTeamMember_service__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! app/pages/assign-team-members/assignTeamMember.service */ "./src/app/pages/assign-team-members/assignTeamMember.service.ts");
/* harmony import */ var app_pages_locations_locations_service__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! app/pages/locations/locations.service */ "./src/app/pages/locations/locations.service.ts");
/* harmony import */ var app_pages_lead_seat_booking_leadSeatBooking_service__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! app/pages/lead-seat-booking/leadSeatBooking.service */ "./src/app/pages/lead-seat-booking/leadSeatBooking.service.ts");
/* harmony import */ var app_shared_resolvers_getLocationResolver__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! app/shared/resolvers/getLocationResolver */ "./src/app/shared/resolvers/getLocationResolver.ts");
/* harmony import */ var app_pages_employee_seat_booking_employeeSeatBooking_service__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! app/pages/employee-seat-booking/employeeSeatBooking.service */ "./src/app/pages/employee-seat-booking/employeeSeatBooking.service.ts");
/* harmony import */ var app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! app/shared/resolvers/GetLocationListResolver */ "./src/app/shared/resolvers/GetLocationListResolver.ts");
/* harmony import */ var app_shared_resolvers_getTeamMemberResolver__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! app/shared/resolvers/getTeamMemberResolver */ "./src/app/shared/resolvers/getTeamMemberResolver.ts");
/* harmony import */ var app_pages_team_mates_team_mates_component__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! app/pages/team-mates/team-mates.component */ "./src/app/pages/team-mates/team-mates.component.ts");
/* harmony import */ var app_shared_resolvers_teamMateResolver__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! app/shared/resolvers/teamMateResolver */ "./src/app/shared/resolvers/teamMateResolver.ts");
/* harmony import */ var app_pages_team_mates_teamMates_service__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! app/pages/team-mates/teamMates.service */ "./src/app/pages/team-mates/teamMates.service.ts");
/* harmony import */ var app_pages_weekly_seat_booking_weekly_seat_booking_component__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! app/pages/weekly-seat-booking/weekly-seat-booking.component */ "./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.ts");
/* harmony import */ var app_pages_weekly_seat_booking_weeklySeatBooking_service__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! app/pages/weekly-seat-booking/weeklySeatBooking.service */ "./src/app/pages/weekly-seat-booking/weeklySeatBooking.service.ts");















// import { HotspotLocationComponent } from 'app/pages/hotspot-location/hotspot-location.component';























let AdminLayoutModule = class AdminLayoutModule {
};
AdminLayoutModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
        imports: [
            _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"],
            _angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"].forChild(_admin_layout_routing__WEBPACK_IMPORTED_MODULE_5__["AdminLayoutRoutes"]),
            _angular_forms__WEBPACK_IMPORTED_MODULE_4__["FormsModule"],
            _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_8__["NgbModule"],
            ngx_file_drop__WEBPACK_IMPORTED_MODULE_11__["NgxFileDropModule"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_4__["ReactiveFormsModule"],
            igniteui_angular__WEBPACK_IMPORTED_MODULE_13__["IgxDialogModule"],
            igniteui_angular__WEBPACK_IMPORTED_MODULE_13__["IgxRippleModule"],
            ngx_google_places_autocomplete__WEBPACK_IMPORTED_MODULE_16__["GooglePlaceModule"],
            ngx_chips__WEBPACK_IMPORTED_MODULE_23__["TagInputModule"],
            _agm_core__WEBPACK_IMPORTED_MODULE_15__["AgmCoreModule"].forRoot({
                apiKey: 'AIzaSyCcJC2HTmwCU7iglBwG0cpo8P8wShut0Kk',
                libraries: ["places"]
            })
        ],
        declarations: [
            _pages_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_6__["DashboardComponent"],
            _pages_user_user_component__WEBPACK_IMPORTED_MODULE_7__["UserComponent"],
            app_pages_user_role_list_user_role_list_component__WEBPACK_IMPORTED_MODULE_9__["UserRoleListComponent"],
            app_pages_roles_roles_component__WEBPACK_IMPORTED_MODULE_10__["RolesComponent"],
            app_pages_user_profile_user_profile_component__WEBPACK_IMPORTED_MODULE_12__["UserProfileComponent"],
            app_shared_directives_numbers_only_directive__WEBPACK_IMPORTED_MODULE_17__["NumberDirective"],
            app_shared_directives_prices_directive__WEBPACK_IMPORTED_MODULE_18__["PriceDirective"],
            // HotspotLocationComponent,
            app_pages_teams_teams_component__WEBPACK_IMPORTED_MODULE_19__["TeamsComponent"],
            app_pages_assign_team_members_assign_team_members_component__WEBPACK_IMPORTED_MODULE_20__["AssignTeamMembersComponent"],
            app_pages_clusters_clusters_component__WEBPACK_IMPORTED_MODULE_21__["ClustersComponent"],
            app_pages_locations_locations_component__WEBPACK_IMPORTED_MODULE_22__["LocationsComponent"],
            app_pages_employee_seat_booking_employee_seat_booking_component__WEBPACK_IMPORTED_MODULE_24__["EmployeeSeatBookingComponent"],
            app_pages_lead_seat_booking_lead_seat_booking_component__WEBPACK_IMPORTED_MODULE_25__["LeadSeatBookingComponent"],
            app_pages_team_mates_team_mates_component__WEBPACK_IMPORTED_MODULE_33__["TeamMatesComponent"],
            app_pages_weekly_seat_booking_weekly_seat_booking_component__WEBPACK_IMPORTED_MODULE_36__["WeeklySeatBookingComponent"]
        ],
        providers: [
            app_pages_user_profile_services_useProfileResolver__WEBPACK_IMPORTED_MODULE_14__["UseProfileResolver"],
            _angular_common__WEBPACK_IMPORTED_MODULE_3__["DatePipe"],
            // TeamsService,
            app_pages_assign_team_members_assignTeamMember_service__WEBPACK_IMPORTED_MODULE_26__["AssignTeamMemberService"],
            app_pages_locations_locations_service__WEBPACK_IMPORTED_MODULE_27__["LocationsService"],
            app_pages_lead_seat_booking_leadSeatBooking_service__WEBPACK_IMPORTED_MODULE_28__["LeadSeatBookingService"],
            app_shared_resolvers_getLocationResolver__WEBPACK_IMPORTED_MODULE_29__["GetLocationResolver"],
            app_pages_employee_seat_booking_employeeSeatBooking_service__WEBPACK_IMPORTED_MODULE_30__["EmployeeSeatBookingService"],
            app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_31__["GetLocationListResolver"],
            app_shared_resolvers_getTeamMemberResolver__WEBPACK_IMPORTED_MODULE_32__["GetTeamMemberResolver"],
            app_shared_resolvers_teamMateResolver__WEBPACK_IMPORTED_MODULE_34__["TeamMateResolver"],
            app_pages_team_mates_teamMates_service__WEBPACK_IMPORTED_MODULE_35__["TeamMatesService"],
            app_pages_weekly_seat_booking_weeklySeatBooking_service__WEBPACK_IMPORTED_MODULE_37__["WeeklySeatBookingService"]
        ],
        entryComponents: [],
    })
], AdminLayoutModule);



/***/ }),

/***/ "./src/app/layouts/admin-layout/admin-layout.routing.ts":
/*!**************************************************************!*\
  !*** ./src/app/layouts/admin-layout/admin-layout.routing.ts ***!
  \**************************************************************/
/*! exports provided: AdminLayoutRoutes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdminLayoutRoutes", function() { return AdminLayoutRoutes; });
/* harmony import */ var _pages_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pages/dashboard/dashboard.component */ "./src/app/pages/dashboard/dashboard.component.ts");
/* harmony import */ var _pages_user_user_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pages/user/user.component */ "./src/app/pages/user/user.component.ts");
/* harmony import */ var app_pages_user_role_list_user_role_list_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/pages/user-role-list/user-role-list.component */ "./src/app/pages/user-role-list/user-role-list.component.ts");
/* harmony import */ var app_pages_roles_roles_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/pages/roles/roles.component */ "./src/app/pages/roles/roles.component.ts");
/* harmony import */ var app_pages_roles_services_role_data_resolver_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/pages/roles/services/role-data-resolver.service */ "./src/app/pages/roles/services/role-data-resolver.service.ts");
/* harmony import */ var app_pages_user_profile_user_profile_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/pages/user-profile/user-profile.component */ "./src/app/pages/user-profile/user-profile.component.ts");
/* harmony import */ var app_pages_user_profile_services_useProfileResolver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/pages/user-profile/services/useProfileResolver */ "./src/app/pages/user-profile/services/useProfileResolver.ts");
/* harmony import */ var app_pages_teams_teams_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/pages/teams/teams.component */ "./src/app/pages/teams/teams.component.ts");
/* harmony import */ var app_pages_assign_team_members_assign_team_members_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/pages/assign-team-members/assign-team-members.component */ "./src/app/pages/assign-team-members/assign-team-members.component.ts");
/* harmony import */ var app_pages_clusters_clusters_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/pages/clusters/clusters.component */ "./src/app/pages/clusters/clusters.component.ts");
/* harmony import */ var app_pages_locations_locations_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/pages/locations/locations.component */ "./src/app/pages/locations/locations.component.ts");
/* harmony import */ var app_pages_employee_seat_booking_employee_seat_booking_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/pages/employee-seat-booking/employee-seat-booking.component */ "./src/app/pages/employee-seat-booking/employee-seat-booking.component.ts");
/* harmony import */ var app_pages_lead_seat_booking_lead_seat_booking_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/pages/lead-seat-booking/lead-seat-booking.component */ "./src/app/pages/lead-seat-booking/lead-seat-booking.component.ts");
/* harmony import */ var app_shared_resolvers_getLocationResolver__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/shared/resolvers/getLocationResolver */ "./src/app/shared/resolvers/getLocationResolver.ts");
/* harmony import */ var app_shared_resolvers_getTeamResolver__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/shared/resolvers/getTeamResolver */ "./src/app/shared/resolvers/getTeamResolver.ts");
/* harmony import */ var app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/shared/resolvers/GetLocationListResolver */ "./src/app/shared/resolvers/GetLocationListResolver.ts");
/* harmony import */ var app_shared_resolvers_getTeamMemberResolver__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/shared/resolvers/getTeamMemberResolver */ "./src/app/shared/resolvers/getTeamMemberResolver.ts");
/* harmony import */ var app_pages_team_mates_team_mates_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/pages/team-mates/team-mates.component */ "./src/app/pages/team-mates/team-mates.component.ts");
/* harmony import */ var app_shared_resolvers_teamMateResolver__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/shared/resolvers/teamMateResolver */ "./src/app/shared/resolvers/teamMateResolver.ts");
/* harmony import */ var app_pages_weekly_seat_booking_weekly_seat_booking_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/pages/weekly-seat-booking/weekly-seat-booking.component */ "./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.ts");




















// import { HotspotLocationComponent } from 'app/pages/hotspot-location/hotspot-location.component';
const AdminLayoutRoutes = [
    {
        path: 'dashboard',
        component: _pages_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_0__["DashboardComponent"]
    },
    {
        path: 'user',
        component: _pages_user_user_component__WEBPACK_IMPORTED_MODULE_1__["UserComponent"]
    },
    {
        path: 'userRoleList',
        component: app_pages_user_role_list_user_role_list_component__WEBPACK_IMPORTED_MODULE_2__["UserRoleListComponent"]
    },
    {
        path: 'roles',
        component: app_pages_roles_roles_component__WEBPACK_IMPORTED_MODULE_3__["RolesComponent"],
        resolve: {
            permissions: app_pages_roles_services_role_data_resolver_service__WEBPACK_IMPORTED_MODULE_4__["RoleDataResolverService"]
        }
    },
    {
        path: 'employeeSeatBooking',
        component: app_pages_employee_seat_booking_employee_seat_booking_component__WEBPACK_IMPORTED_MODULE_11__["EmployeeSeatBookingComponent"],
        resolve: {
            locationList: app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_15__["GetLocationListResolver"],
        }
    },
    {
        path: 'clusters',
        component: app_pages_clusters_clusters_component__WEBPACK_IMPORTED_MODULE_9__["ClustersComponent"],
        resolve: {}
    },
    {
        path: 'users',
        component: app_pages_user_profile_user_profile_component__WEBPACK_IMPORTED_MODULE_5__["UserProfileComponent"],
        resolve: {
            userProfileList: app_pages_user_profile_services_useProfileResolver__WEBPACK_IMPORTED_MODULE_6__["UseProfileResolver"],
        }
    },
    {
        path: 'locations',
        component: app_pages_locations_locations_component__WEBPACK_IMPORTED_MODULE_10__["LocationsComponent"],
        resolve: {
            locationList: app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_15__["GetLocationListResolver"]
        }
    },
    {
        path: 'assignMembers',
        component: app_pages_assign_team_members_assign_team_members_component__WEBPACK_IMPORTED_MODULE_8__["AssignTeamMembersComponent"],
        resolve: {
            teamList: app_shared_resolvers_getTeamResolver__WEBPACK_IMPORTED_MODULE_14__["GetTeamResolver"],
            teamMemberList: app_shared_resolvers_getTeamMemberResolver__WEBPACK_IMPORTED_MODULE_16__["GetTeamMemberResolver"]
        }
    },
    {
        path: 'teams',
        component: app_pages_teams_teams_component__WEBPACK_IMPORTED_MODULE_7__["TeamsComponent"],
        resolve: {
            locationList: app_shared_resolvers_getLocationResolver__WEBPACK_IMPORTED_MODULE_13__["GetLocationResolver"],
            teamList: app_shared_resolvers_getTeamResolver__WEBPACK_IMPORTED_MODULE_14__["GetTeamResolver"]
        }
    },
    {
        path: 'leadSeatBooking',
        component: app_pages_lead_seat_booking_lead_seat_booking_component__WEBPACK_IMPORTED_MODULE_12__["LeadSeatBookingComponent"],
        resolve: {
            locationList: app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_15__["GetLocationListResolver"],
            memberList: app_shared_resolvers_teamMateResolver__WEBPACK_IMPORTED_MODULE_18__["TeamMateResolver"]
        }
    },
    {
        path: 'teamMates',
        component: app_pages_team_mates_team_mates_component__WEBPACK_IMPORTED_MODULE_17__["TeamMatesComponent"],
        resolve: {
            memberList: app_shared_resolvers_teamMateResolver__WEBPACK_IMPORTED_MODULE_18__["TeamMateResolver"]
        }
    },
    {
        path: 'weeklySeatBooking',
        component: app_pages_weekly_seat_booking_weekly_seat_booking_component__WEBPACK_IMPORTED_MODULE_19__["WeeklySeatBookingComponent"],
        resolve: {
            locationList: app_shared_resolvers_GetLocationListResolver__WEBPACK_IMPORTED_MODULE_15__["GetLocationListResolver"],
            memberList: app_shared_resolvers_teamMateResolver__WEBPACK_IMPORTED_MODULE_18__["TeamMateResolver"]
        }
    },
];


/***/ }),

/***/ "./src/app/pages/assign-team-members/assign-team-members.component.scss":
/*!******************************************************************************!*\
  !*** ./src/app/pages/assign-team-members/assign-team-members.component.scss ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".switch {\n  position: relative;\n  display: inline-block;\n  width: 60px;\n  height: 34px;\n}\n\n.switch input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n/* Rounded sliders */\n\n.slider.round {\n  border-radius: 34px;\n}\n\n.slider.round:before {\n  border-radius: 50%;\n}\n\n.slider {\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  transition: 0.4s;\n}\n\n.slider:before {\n  position: absolute;\n  content: \"\";\n  height: 26px;\n  width: 26px;\n  left: 4px;\n  bottom: 4px;\n  background-color: white;\n  transition: 0.4s;\n}\n\ninput:checked + .slider {\n  background-color: #51cbce;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #51cbce;\n}\n\ninput:checked + .slider:before {\n  -webkit-transform: translateX(26px);\n  transform: translateX(26px);\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy9hc3NpZ24tdGVhbS1tZW1iZXJzL2Fzc2lnbi10ZWFtLW1lbWJlcnMuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL3BhZ2VzL2Fzc2lnbi10ZWFtLW1lbWJlcnMvYXNzaWduLXRlYW0tbWVtYmVycy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGtCQUFBO0VBQ0EscUJBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtBQ0NGOztBREVBO0VBQ0UsVUFBQTtFQUNBLFFBQUE7RUFDQSxTQUFBO0FDQ0Y7O0FER0Esb0JBQUE7O0FBQ0E7RUFDRSxtQkFBQTtBQ0FGOztBREdBO0VBQ0Usa0JBQUE7QUNBRjs7QURHQTtFQUNFLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLE1BQUE7RUFDQSxPQUFBO0VBQ0EsUUFBQTtFQUNBLFNBQUE7RUFDQSxzQkFBQTtFQUVBLGdCQUFBO0FDQUY7O0FER0E7RUFDRSxrQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0VBQ0EsdUJBQUE7RUFFQSxnQkFBQTtBQ0FGOztBRElBO0VBQ0UseUJBQUE7QUNERjs7QURJQTtFQUNFLDJCQUFBO0FDREY7O0FESUE7RUFDRSxtQ0FBQTtFQUVBLDJCQUFBO0FDREYiLCJmaWxlIjoic3JjL2FwcC9wYWdlcy9hc3NpZ24tdGVhbS1tZW1iZXJzL2Fzc2lnbi10ZWFtLW1lbWJlcnMuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuc3dpdGNoIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHdpZHRoOiA2MHB4O1xuICBoZWlnaHQ6IDM0cHg7XG59XG5cbi5zd2l0Y2ggaW5wdXQge1xuICBvcGFjaXR5OiAwO1xuICB3aWR0aDogMDtcbiAgaGVpZ2h0OiAwO1xufVxuXG5cbi8qIFJvdW5kZWQgc2xpZGVycyAqL1xuLnNsaWRlci5yb3VuZCB7XG4gIGJvcmRlci1yYWRpdXM6IDM0cHg7XG59XG5cbi5zbGlkZXIucm91bmQ6YmVmb3JlIHtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuXG4uc2xpZGVyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG4gIGJvdHRvbTogMDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAuNHM7XG4gIHRyYW5zaXRpb246IC40cztcbn1cblxuLnNsaWRlcjpiZWZvcmUge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGhlaWdodDogMjZweDtcbiAgd2lkdGg6IDI2cHg7XG4gIGxlZnQ6IDRweDtcbiAgYm90dG9tOiA0cHg7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAtd2Via2l0LXRyYW5zaXRpb246IC40cztcbiAgdHJhbnNpdGlvbjogLjRzO1xufVxuXG5cbmlucHV0OmNoZWNrZWQgKyAuc2xpZGVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzUxY2JjZTtcbn1cblxuaW5wdXQ6Zm9jdXMgKyAuc2xpZGVyIHtcbiAgYm94LXNoYWRvdzogMCAwIDFweCAjNTFjYmNlO1xufVxuXG5pbnB1dDpjaGVja2VkICsgLnNsaWRlcjpiZWZvcmUge1xuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xufVxuIiwiLnN3aXRjaCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB3aWR0aDogNjBweDtcbiAgaGVpZ2h0OiAzNHB4O1xufVxuXG4uc3dpdGNoIGlucHV0IHtcbiAgb3BhY2l0eTogMDtcbiAgd2lkdGg6IDA7XG4gIGhlaWdodDogMDtcbn1cblxuLyogUm91bmRlZCBzbGlkZXJzICovXG4uc2xpZGVyLnJvdW5kIHtcbiAgYm9yZGVyLXJhZGl1czogMzRweDtcbn1cblxuLnNsaWRlci5yb3VuZDpiZWZvcmUge1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG5cbi5zbGlkZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xuICAtd2Via2l0LXRyYW5zaXRpb246IDAuNHM7XG4gIHRyYW5zaXRpb246IDAuNHM7XG59XG5cbi5zbGlkZXI6YmVmb3JlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBjb250ZW50OiBcIlwiO1xuICBoZWlnaHQ6IDI2cHg7XG4gIHdpZHRoOiAyNnB4O1xuICBsZWZ0OiA0cHg7XG4gIGJvdHRvbTogNHB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAwLjRzO1xuICB0cmFuc2l0aW9uOiAwLjRzO1xufVxuXG5pbnB1dDpjaGVja2VkICsgLnNsaWRlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICM1MWNiY2U7XG59XG5cbmlucHV0OmZvY3VzICsgLnNsaWRlciB7XG4gIGJveC1zaGFkb3c6IDAgMCAxcHggIzUxY2JjZTtcbn1cblxuaW5wdXQ6Y2hlY2tlZCArIC5zbGlkZXI6YmVmb3JlIHtcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjZweCk7XG4gIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjZweCk7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcbn0iXX0= */"

/***/ }),

/***/ "./src/app/pages/assign-team-members/assign-team-members.component.ts":
/*!****************************************************************************!*\
  !*** ./src/app/pages/assign-team-members/assign-team-members.component.ts ***!
  \****************************************************************************/
/*! exports provided: AssignTeamMembersComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignTeamMembersComponent", function() { return AssignTeamMembersComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _models_assignTeamMemberRequest_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/assignTeamMemberRequest.model */ "./src/app/pages/assign-team-members/models/assignTeamMemberRequest.model.ts");
/* harmony import */ var _assignTeamMember_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assignTeamMember.service */ "./src/app/pages/assign-team-members/assignTeamMember.service.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");







let AssignTeamMembersComponent = class AssignTeamMembersComponent {
    constructor(fb, assignTeamMemberService, toaster, route) {
        this.fb = fb;
        this.assignTeamMemberService = assignTeamMemberService;
        this.toaster = toaster;
        this.route = route;
        this.assignMemberForm = fb.group({
            teamName: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required],
            adName: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required],
            name: [''],
            email: [''],
            isLead: [true]
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.teamList = data['teamList'].DATA;
            this.teamMemberList = data['teamMemberList'].DATA;
            console.log(this.teamMemberList);
        });
    }
    saveTeamMember() {
        const assignTeamMemberRequestModel = new _models_assignTeamMemberRequest_model__WEBPACK_IMPORTED_MODULE_3__["AssignTeamMemberRequestModel"];
        assignTeamMemberRequestModel.adName = this.assignMemberForm.get('adName').value;
        assignTeamMemberRequestModel.teamId = this.assignMemberForm.get('teamName').value;
        assignTeamMemberRequestModel.role = this.assignMemberForm.get('isLead').value ? 'LEAD' : 'EMPLOYEE';
        console.log(assignTeamMemberRequestModel, this.assignMemberForm.get('isLead'));
        this.assignTeamMemberService.saveTeamMember(assignTeamMemberRequestModel).subscribe(data => {
            this.clear();
            this.getTeamMembers();
            this.toaster.success('Team member added sucessfully!', '', { positionClass: 'toast-top-center' });
        }, err => {
            this.toaster.error('Something went wrong!', '', { positionClass: 'toast-top-center' });
        });
    }
    clear() {
        this.assignMemberForm.reset();
    }
    getTeamMembers() {
        this.assignTeamMemberService.getAllTeamMembers().subscribe(teamMembers => {
            this.teamMemberList = teamMembers.DATA;
        });
    }
};
AssignTeamMembersComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-assign-team-members',
        template: __webpack_require__(/*! raw-loader!./assign-team-members.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/assign-team-members/assign-team-members.component.html"),
        styles: [__webpack_require__(/*! ./assign-team-members.component.scss */ "./src/app/pages/assign-team-members/assign-team-members.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"], _assignTeamMember_service__WEBPACK_IMPORTED_MODULE_4__["AssignTeamMemberService"], ngx_toastr__WEBPACK_IMPORTED_MODULE_5__["ToastrService"],
        _angular_router__WEBPACK_IMPORTED_MODULE_6__["ActivatedRoute"]])
], AssignTeamMembersComponent);



/***/ }),

/***/ "./src/app/pages/assign-team-members/assignTeamMember.service.ts":
/*!***********************************************************************!*\
  !*** ./src/app/pages/assign-team-members/assignTeamMember.service.ts ***!
  \***********************************************************************/
/*! exports provided: AssignTeamMemberService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignTeamMemberService", function() { return AssignTeamMemberService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");






let AssignTeamMemberService = class AssignTeamMemberService {
    constructor(http) {
        this.http = http;
        this.URL = environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].BASE_URL;
    }
    saveTeamMember(assignTeamMemberRequestl) {
        return this.http.post(this.URL + "/assign", assignTeamMemberRequestl).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    getAllTeamMembers() {
        return this.http.get(this.URL + "/teams/employees");
    }
};
AssignTeamMemberService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_5__["HttpClient"]])
], AssignTeamMemberService);



/***/ }),

/***/ "./src/app/pages/assign-team-members/models/assignTeamMemberRequest.model.ts":
/*!***********************************************************************************!*\
  !*** ./src/app/pages/assign-team-members/models/assignTeamMemberRequest.model.ts ***!
  \***********************************************************************************/
/*! exports provided: AssignTeamMemberRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignTeamMemberRequestModel", function() { return AssignTeamMemberRequestModel; });
class AssignTeamMemberRequestModel {
}


/***/ }),

/***/ "./src/app/pages/clusters/clusters.component.scss":
/*!********************************************************!*\
  !*** ./src/app/pages/clusters/clusters.component.scss ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL2NsdXN0ZXJzL2NsdXN0ZXJzLmNvbXBvbmVudC5zY3NzIn0= */"

/***/ }),

/***/ "./src/app/pages/clusters/clusters.component.ts":
/*!******************************************************!*\
  !*** ./src/app/pages/clusters/clusters.component.ts ***!
  \******************************************************/
/*! exports provided: ClustersComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClustersComponent", function() { return ClustersComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");


let ClustersComponent = class ClustersComponent {
    // clusterForm: FormGroup;
    // constructor(private fb: FormBuilder) {
    //   this.clusterForm = fb.group({
    //     clusterName: ['', Validators.required],
    //     clusterdescription: [''],
    //     locations: [''],
    //     teamName: [''],
    //     dedicatedSeats: [''],
    //     hotseats: ['']
    //   })
    //  }
    ngOnInit() {
    }
};
ClustersComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-clusters',
        template: __webpack_require__(/*! raw-loader!./clusters.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/clusters/clusters.component.html"),
        styles: [__webpack_require__(/*! ./clusters.component.scss */ "./src/app/pages/clusters/clusters.component.scss")]
    })
], ClustersComponent);



/***/ }),

/***/ "./src/app/pages/dashboard/dashboard.component.ts":
/*!********************************************************!*\
  !*** ./src/app/pages/dashboard/dashboard.component.ts ***!
  \********************************************************/
/*! exports provided: DashboardComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardComponent", function() { return DashboardComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");


let DashboardComponent = class DashboardComponent {
    ngOnInit() { }
};
DashboardComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'dashboard-cmp',
        template: __webpack_require__(/*! raw-loader!./dashboard.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/dashboard/dashboard.component.html")
    })
], DashboardComponent);



/***/ }),

/***/ "./src/app/pages/employee-seat-booking/employee-seat-booking.component.scss":
/*!**********************************************************************************!*\
  !*** ./src/app/pages/employee-seat-booking/employee-seat-booking.component.scss ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".seat {\n  cursor: not-allowed;\n  background-color: #9D9999;\n  opacity: 0.6;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy9lbXBsb3llZS1zZWF0LWJvb2tpbmcvZW1wbG95ZWUtc2VhdC1ib29raW5nLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9wYWdlcy9lbXBsb3llZS1zZWF0LWJvb2tpbmcvZW1wbG95ZWUtc2VhdC1ib29raW5nLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsbUJBQUE7RUFDQSx5QkFBQTtFQUNBLFlBQUE7QUNDRiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL2VtcGxveWVlLXNlYXQtYm9va2luZy9lbXBsb3llZS1zZWF0LWJvb2tpbmcuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuc2VhdHtcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzlEOTk5OTtcbiAgb3BhY2l0eTogMC42O1xufVxuIiwiLnNlYXQge1xuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOUQ5OTk5O1xuICBvcGFjaXR5OiAwLjY7XG59Il19 */"

/***/ }),

/***/ "./src/app/pages/employee-seat-booking/employee-seat-booking.component.ts":
/*!********************************************************************************!*\
  !*** ./src/app/pages/employee-seat-booking/employee-seat-booking.component.ts ***!
  \********************************************************************************/
/*! exports provided: EmployeeSeatBookingComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmployeeSeatBookingComponent", function() { return EmployeeSeatBookingComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ng-bootstrap/ng-bootstrap */ "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
/* harmony import */ var _models_hSeatBookingRequest_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/hSeatBookingRequest.model */ "./src/app/pages/employee-seat-booking/models/hSeatBookingRequest.model.ts");
/* harmony import */ var _employeeSeatBooking_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./employeeSeatBooking.service */ "./src/app/pages/employee-seat-booking/employeeSeatBooking.service.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");
/* harmony import */ var _models_getAllSeatsRequest_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/getAllSeatsRequest.model */ "./src/app/pages/employee-seat-booking/models/getAllSeatsRequest.model.ts");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");









let EmployeeSeatBookingComponent = class EmployeeSeatBookingComponent {
    constructor(fb, calendar, toaster, employeeSeatBookingService, route) {
        this.fb = fb;
        this.calendar = calendar;
        this.toaster = toaster;
        this.employeeSeatBookingService = employeeSeatBookingService;
        this.route = route;
        this.isDisable = false;
        this.availableSeats = null;
        this.totalSeatsforTeam = null;
        this.DELIMITER = '-';
        this.startDate = null;
        this.selectedSeatId = null;
        this.locationSelected = false;
        this.allBookings = null;
        this.seatBookingForm = fb.group({
            location: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required],
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.locationList = data['locationList'].DATA;
        });
    }
    getAllSeatsForLocation(value) {
        this.locationSelected = true;
        this.isDisable = true;
        this.selectedSeatId = '';
        this.employeeSeatBookingService.getAllSeatsForLocation(value).subscribe(allSeats => {
            this.seats = allSeats.DATA.seatNos;
        });
    }
    selectToday() {
        this.model = this.calendar.getToday();
    }
    getSeats(date) {
        this.isDisable = true;
        this.getAllSeatsForLocation(this.seatBookingForm.get('location').value);
        this.startDate = date.year + this.DELIMITER + date.month + this.DELIMITER + date.day + '';
        let getAllSeatsRequestModel = new _models_getAllSeatsRequest_model__WEBPACK_IMPORTED_MODULE_7__["GetAllSeatsRequestModel"]();
        getAllSeatsRequestModel.bookDate = this.startDate;
        // getAllSeatsRequestModel.startDate = this.startDate;
        getAllSeatsRequestModel.clusterId = localStorage.getItem('clusterId');
        this.employeeSeatBookingService.getAllSeats(getAllSeatsRequestModel).subscribe(allSeats => {
            // this.seats = allSeats.DATA.totalSeatsforTeam;
            this.availableSeats = allSeats.DATA.availableSeats;
            this.totalSeatsforTeam = allSeats.DATA.totalSeatsforTeam;
            this.allBookings = allSeats.DATA.allBookings;
        });
    }
    changeBackground(seatId) {
        console.log('Inside change beckgorund');
        if (this.availableSeats != null) {
            for (let val of this.availableSeats) {
                console.log('val is' + val);
                console.log('response seatId ' + val.seatId + ' app seat id ' + seatId);
                if (val.seatId == seatId) {
                    if (val.type == 'Dedicated') {
                        return { 'border': '3px solid #4FB0F9' }; //blue
                    }
                    else if (val.type == 'Hot') {
                        console.log('this.availableSeats');
                        // this.isDisable=false;
                        return { 'border': '3px solid #53AA33', 'cursor': 'pointer', 'opacity': '1' }; //green
                    }
                }
            }
            for (let val of this.totalSeatsforTeam) {
                if (val.seatId == seatId) {
                    return { 'border': '3px solid red' };
                }
            }
        }
        else if (this.availableSeats == []) {
            return { 'cursor': 'not-allowed' };
        }
    }
    bookHotSeat() {
        if (this.startDate == null || this.selectedSeatId == null) {
            this.toaster.error('Some fields are empty', '', { positionClass: 'toast-top-center' });
            return;
        }
        const hSeatBookingRequestModel = new _models_hSeatBookingRequest_model__WEBPACK_IMPORTED_MODULE_4__["HSeatBookingRequestModel"]();
        let displayName = localStorage.getItem('userName');
        let userName = displayName.match(/[^_]+_[^_]+/g).toString();
        hSeatBookingRequestModel.empId = userName;
        hSeatBookingRequestModel.endDate = this.startDate;
        hSeatBookingRequestModel.startDate = this.startDate;
        hSeatBookingRequestModel.seatNo = this.selectedSeatId;
        hSeatBookingRequestModel.clusterId = localStorage.getItem('clusterId');
        let location = this.seatBookingForm.get('location').value;
        this.employeeSeatBookingService.bookHotSeat(hSeatBookingRequestModel).subscribe(data => {
            console.log('Seat Booking Request ' + hSeatBookingRequestModel);
            this.getAllSeatsForLocation(location);
            if (data.MESSAGE == 'SEAT_DOES_NOT_BELONG_TO_TEAM') {
                this.toaster.error('Seat does not belong to team !', '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == 'SEAT_ALREADY_BOOKED') {
                this.toaster.error('Seat already booked', '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == 'BOOKING_CREATED') {
                this.toaster.success('Hot seat booked sucessfully!', '', { positionClass: 'toast-top-center' });
            }
            else {
                this.toaster.error('Something went wrong', '', { positionClass: 'toast-top-center' });
            }
            // this.toaster.success('Hot  seat booked sucessfully!', '', { positionClass: 'toast-top-center' });
        }, err => {
            this.toaster.error('Something went wrong', '', { positionClass: 'toast-top-center' });
        });
    }
    selectedSeat(seatId) {
        this.selectedSeatId = seatId;
        this.buttonVisibility(seatId);
    }
    buttonVisibility(seatId) {
        this.isDisable = true;
        for (let val of this.availableSeats) {
            if (val.seatId == seatId) {
                if (val.type == 'Dedicated') {
                    this.isDisable = true;
                    return;
                }
                else if (val.type == 'Hot') {
                    this.isDisable = false;
                    return;
                }
            }
            else {
                this.isDisable = true;
            }
        }
    }
    yourSeat(seatId) {
        let displayName = localStorage.getItem('userName');
        let userName = displayName.match(/[^_]+_[^_]+/g).toString();
        if (this.allBookings != null) {
            for (let val of this.allBookings) {
                if (val.seatId === seatId) {
                    if (val.employeeId === userName) {
                        return { 'visibility': 'visible' };
                    }
                    else if (val.employeeId !== userName) {
                        return { 'visibility': 'hidden' };
                    }
                }
            }
            for (let val of this.seats) {
                return { 'visibility': 'hidden' };
            }
        }
    }
};
EmployeeSeatBookingComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-employee-seat-booking',
        template: __webpack_require__(/*! raw-loader!./employee-seat-booking.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/employee-seat-booking/employee-seat-booking.component.html"),
        styles: [__webpack_require__(/*! ./employee-seat-booking.component.scss */ "./src/app/pages/employee-seat-booking/employee-seat-booking.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"], _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_3__["NgbCalendar"], ngx_toastr__WEBPACK_IMPORTED_MODULE_6__["ToastrService"],
        _employeeSeatBooking_service__WEBPACK_IMPORTED_MODULE_5__["EmployeeSeatBookingService"], _angular_router__WEBPACK_IMPORTED_MODULE_8__["ActivatedRoute"]])
], EmployeeSeatBookingComponent);



/***/ }),

/***/ "./src/app/pages/employee-seat-booking/employeeSeatBooking.service.ts":
/*!****************************************************************************!*\
  !*** ./src/app/pages/employee-seat-booking/employeeSeatBooking.service.ts ***!
  \****************************************************************************/
/*! exports provided: EmployeeSeatBookingService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmployeeSeatBookingService", function() { return EmployeeSeatBookingService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");






let EmployeeSeatBookingService = class EmployeeSeatBookingService {
    constructor(http) {
        this.http = http;
        this.URL = environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].BASE_URL;
    }
    bookHotSeat(hSeatBookingRequest) {
        return this.http.post(this.URL + "/booking", hSeatBookingRequest).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            console.log('Booking Request1 {}', hSeatBookingRequest);
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    getAllSeats(getAllSeatsRequestModel) {
        return this.http.post(this.URL + "/view/seats", getAllSeatsRequestModel).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    getAllSeatsForLocation(value) {
        // let httpParams = new HttpParams().set("location", value);
        // let urlas = this.URL + '/seat?location=' + value;
        // // urlas.replcae
        //     console.log(urlas.replace(' ',''))
        return this.http.post(this.URL + '/seat/location', { 'location': value });
    }
};
EmployeeSeatBookingService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_5__["HttpClient"]])
], EmployeeSeatBookingService);



/***/ }),

/***/ "./src/app/pages/employee-seat-booking/models/getAllSeatsRequest.model.ts":
/*!********************************************************************************!*\
  !*** ./src/app/pages/employee-seat-booking/models/getAllSeatsRequest.model.ts ***!
  \********************************************************************************/
/*! exports provided: GetAllSeatsRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetAllSeatsRequestModel", function() { return GetAllSeatsRequestModel; });
class GetAllSeatsRequestModel {
}


/***/ }),

/***/ "./src/app/pages/employee-seat-booking/models/getweeklySeatsRequest.model.ts":
/*!***********************************************************************************!*\
  !*** ./src/app/pages/employee-seat-booking/models/getweeklySeatsRequest.model.ts ***!
  \***********************************************************************************/
/*! exports provided: GetweeklySeatsRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetweeklySeatsRequestModel", function() { return GetweeklySeatsRequestModel; });
class GetweeklySeatsRequestModel {
}


/***/ }),

/***/ "./src/app/pages/employee-seat-booking/models/hSeatBookingRequest.model.ts":
/*!*********************************************************************************!*\
  !*** ./src/app/pages/employee-seat-booking/models/hSeatBookingRequest.model.ts ***!
  \*********************************************************************************/
/*! exports provided: HSeatBookingRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSeatBookingRequestModel", function() { return HSeatBookingRequestModel; });
class HSeatBookingRequestModel {
}


/***/ }),

/***/ "./src/app/pages/lead-seat-booking/lead-seat-booking.component.scss":
/*!**************************************************************************!*\
  !*** ./src/app/pages/lead-seat-booking/lead-seat-booking.component.scss ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".seat {\n  cursor: not-allowed;\n  opacity: 0.6;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy9sZWFkLXNlYXQtYm9va2luZy9sZWFkLXNlYXQtYm9va2luZy5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvcGFnZXMvbGVhZC1zZWF0LWJvb2tpbmcvbGVhZC1zZWF0LWJvb2tpbmcuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxtQkFBQTtFQUVBLFlBQUE7QUNBRiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL2xlYWQtc2VhdC1ib29raW5nL2xlYWQtc2VhdC1ib29raW5nLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnNlYXR7XG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gIC8vIGJhY2tncm91bmQtY29sb3I6ICM5RDk5OTk7XG4gIG9wYWNpdHk6IDAuNjtcbn1cbiIsIi5zZWF0IHtcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgb3BhY2l0eTogMC42O1xufSJdfQ== */"

/***/ }),

/***/ "./src/app/pages/lead-seat-booking/lead-seat-booking.component.ts":
/*!************************************************************************!*\
  !*** ./src/app/pages/lead-seat-booking/lead-seat-booking.component.ts ***!
  \************************************************************************/
/*! exports provided: LeadSeatBookingComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LeadSeatBookingComponent", function() { return LeadSeatBookingComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ng-bootstrap/ng-bootstrap */ "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
/* harmony import */ var _leadSeatBooking_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./leadSeatBooking.service */ "./src/app/pages/lead-seat-booking/leadSeatBooking.service.ts");
/* harmony import */ var _employee_seat_booking_models_getAllSeatsRequest_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../employee-seat-booking/models/getAllSeatsRequest.model */ "./src/app/pages/employee-seat-booking/models/getAllSeatsRequest.model.ts");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _employee_seat_booking_models_hSeatBookingRequest_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../employee-seat-booking/models/hSeatBookingRequest.model */ "./src/app/pages/employee-seat-booking/models/hSeatBookingRequest.model.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");









let LeadSeatBookingComponent = class LeadSeatBookingComponent {
    constructor(calendar, leadSeatBookingService, fb, toaster, route) {
        this.calendar = calendar;
        this.leadSeatBookingService = leadSeatBookingService;
        this.fb = fb;
        this.toaster = toaster;
        this.route = route;
        this.startDateSelected = false;
        this.formatedstartDate = null;
        this.dedicatedSeatBookings = null;
        this.totalSeatsforTeam = null;
        this.totalSeats = null;
        this.allBookings = null;
        this.selectedSeatId = null;
        this.DELIMITER = '-';
        this.teamMemberList = [];
        this.locationSelected = false;
        this.isDisable = true;
        this.displayYourSeat = false;
        this.ownerName = '';
        this.userName = '';
        this.bookingForm = fb.group({
            adName: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_5__["Validators"].required],
            location: [''],
            bookingDate: ['']
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.locationList = data['locationList'].DATA;
            this.totalSeats = data['memberList'].DATA;
            console.log(this.teamMemberList);
        });
        this.loggedUserTeam = localStorage.getItem('clusterId');
        for (let emp of this.totalSeats) {
            if (this.loggedUserTeam == emp.team) {
                this.teamMemberList.push(emp);
                console.log(this.teamMemberList);
            }
        }
        let displayName = localStorage.getItem('userName');
        this.userName = displayName.match(/[^_]+_[^_]+/g).toString();
    }
    selectToday() {
        this.smodel = this.calendar.getToday();
        this.emodel = this.calendar.getToday();
    }
    addStartDate(date) {
        this.startDateSelected = true;
        this.formatedstartDate = this.formatDate(date);
    }
    formatDate(date) {
        console.log(date);
        return date.year + this.DELIMITER + date.month + this.DELIMITER + date.day + '';
    }
    getSeats(date) {
        this.isDisable = true;
        this.formatedstartDate = date.year + this.DELIMITER + date.month + this.DELIMITER + date.day + '';
        this.formatedEndDate = this.formatDate(date);
        let getAllSeatsRequestModel = new _employee_seat_booking_models_getAllSeatsRequest_model__WEBPACK_IMPORTED_MODULE_4__["GetAllSeatsRequestModel"]();
        getAllSeatsRequestModel.bookDate = this.formatedstartDate;
        // getAllSeatsRequestModel.startDate = this.formatedstartDate;
        getAllSeatsRequestModel.clusterId = localStorage.getItem('clusterId');
        this.leadSeatBookingService.getAllSeats(getAllSeatsRequestModel).subscribe(allSeats => {
            this.totalSeatsforTeam = allSeats.DATA.totalSeatsforTeam;
            this.dedicatedSeatBookings = allSeats.DATA.availableSeats;
            this.allBookings = allSeats.DATA.allBookings;
            console.log(this.seats);
        });
    }
    changeBackground(seatId) {
        if (this.dedicatedSeatBookings != null) {
            // }
            // console.log(this.dedicatedSeatBookings)
            for (let val of this.dedicatedSeatBookings) {
                if (val.seatId == seatId) {
                    if (val.type == 'Dedicated') {
                        return { 'border': '3px solid #4FB0F9', 'cursor': 'pointer', 'opacity': '1' }; //blue
                    }
                    else if (val.type == 'Hot') {
                        return { 'border': '3px solid #53AA33' }; //green
                    }
                }
            }
            for (let val of this.totalSeatsforTeam) {
                if (val.seatId == seatId) {
                    return { 'border': '3px solid red' };
                }
            }
        }
    }
    selectedSeat(seatId) {
        console.log('seatId', seatId);
        this.selectedSeatId = seatId;
        this.buttonVisibility(seatId);
    }
    bookDedicatedSeats() {
        if (!this.bookingForm.valid || this.formatedstartDate == null || this.selectedSeatId == null) {
            this.toaster.error('Some fields are empty', '', { positionClass: 'toast-top-center' });
            return;
        }
        const hSeatBookingRequestModel = new _employee_seat_booking_models_hSeatBookingRequest_model__WEBPACK_IMPORTED_MODULE_6__["HSeatBookingRequestModel"]();
        hSeatBookingRequestModel.empId = this.bookingForm.get('adName').value;
        hSeatBookingRequestModel.endDate = this.formatedstartDate;
        hSeatBookingRequestModel.startDate = this.formatedstartDate;
        hSeatBookingRequestModel.seatNo = this.selectedSeatId;
        hSeatBookingRequestModel.clusterId = localStorage.getItem('clusterId');
        let location = this.bookingForm.get('location').value;
        this.getAllSeatsForLocation(location);
        this.leadSeatBookingService.bookHotSeat(hSeatBookingRequestModel).subscribe(data => {
            if (data.MESSAGE == 'SEAT_DOES_NOT_BELONG_TO_TEAM') {
                this.toaster.error('Seat does not belong to team !', '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == 'SEAT_ALREADY_BOOKED') {
                this.toaster.error('Seat already booked', '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == 'BOOKING_CREATED') {
                this.toaster.success('Dedicated seat booked sucessfully!', '', { positionClass: 'toast-top-center' });
            }
            else {
                this.toaster.error('Something went wrong', '', { positionClass: 'toast-top-center' });
            }
        });
    }
    getAllSeatsForLocation(value) {
        this.locationSelected = true;
        this.selectedSeatId = '';
        this.isDisable = true;
        this.leadSeatBookingService.getAllSeatsForLocation(value).subscribe(allSeats => {
            this.seats = allSeats.DATA.seatNos;
            console.log(allSeats, this.seats);
        });
    }
    buttonVisibility(seatId) {
        this.isDisable = true;
        for (let val of this.dedicatedSeatBookings) {
            if (val.seatId == seatId) {
                if (val.type == 'Dedicated') {
                    console.log('Dedicated', seatId);
                    this.isDisable = false;
                    return;
                }
                else if (val.type == 'Hot') {
                    console.log('Hot', seatId);
                    this.isDisable = true;
                    return;
                }
            }
            else {
                this.isDisable = true;
            }
        }
    }
    yourSeat(seatId) {
        if (this.allBookings != null) {
            for (let val of this.allBookings) {
                if (val.seatId === seatId) {
                    if (val.employeeId === this.userName) {
                        return { 'visibility': 'visible' };
                    }
                    else if (val.employeeId !== this.userName) {
                        return { 'visibility': 'hidden' };
                    }
                }
            }
            for (let val of this.seats) {
                return { 'visibility': 'hidden' };
            }
        }
    }
    seatOwner(seatId) {
        if (this.allBookings != null) {
            for (let val of this.allBookings) {
                if (val.seatId === seatId) {
                    if (val.employeeId === this.userName) {
                        return { 'visibility': 'hidden' };
                    }
                    this.ownerName = val.employeeId.match(/[^_]+_[^_]+/g).toString();
                    return { 'visibility': 'visible' };
                }
            }
            for (let val of this.seats) {
                return { 'visibility': 'hidden' };
            }
        }
    }
};
LeadSeatBookingComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-lead-seat-booking',
        template: __webpack_require__(/*! raw-loader!./lead-seat-booking.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/lead-seat-booking/lead-seat-booking.component.html"),
        styles: [__webpack_require__(/*! ./lead-seat-booking.component.scss */ "./src/app/pages/lead-seat-booking/lead-seat-booking.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__["NgbCalendar"], _leadSeatBooking_service__WEBPACK_IMPORTED_MODULE_3__["LeadSeatBookingService"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["FormBuilder"],
        ngx_toastr__WEBPACK_IMPORTED_MODULE_7__["ToastrService"], _angular_router__WEBPACK_IMPORTED_MODULE_8__["ActivatedRoute"]])
], LeadSeatBookingComponent);



/***/ }),

/***/ "./src/app/pages/lead-seat-booking/leadSeatBooking.service.ts":
/*!********************************************************************!*\
  !*** ./src/app/pages/lead-seat-booking/leadSeatBooking.service.ts ***!
  \********************************************************************/
/*! exports provided: LeadSeatBookingService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LeadSeatBookingService", function() { return LeadSeatBookingService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");






let LeadSeatBookingService = class LeadSeatBookingService {
    constructor(http) {
        this.http = http;
        this.URL = environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].BASE_URL;
    }
    getAllSeats(getAllSeatsRequestModel) {
        return this.http.post(this.URL + "/view/seats", getAllSeatsRequestModel).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    bookHotSeat(hSeatBookingRequest) {
        return this.http.post(this.URL + "/booking", hSeatBookingRequest).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    getAllSeatsForLocation(value) {
        // let urlas = this.URL + '/seat?location=' + value;
        // // urlas.replcae
        //     console.log(urlas.replace(' ',''))
        return this.http.post(this.URL + '/seat/location', { 'location': value });
    }
};
LeadSeatBookingService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_5__["HttpClient"]])
], LeadSeatBookingService);



/***/ }),

/***/ "./src/app/pages/locations/locations.component.scss":
/*!**********************************************************!*\
  !*** ./src/app/pages/locations/locations.component.scss ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL2xvY2F0aW9ucy9sb2NhdGlvbnMuY29tcG9uZW50LnNjc3MifQ== */"

/***/ }),

/***/ "./src/app/pages/locations/locations.component.ts":
/*!********************************************************!*\
  !*** ./src/app/pages/locations/locations.component.ts ***!
  \********************************************************/
/*! exports provided: LocationsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationsComponent", function() { return LocationsComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _models_locationRequest_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/locationRequest.model */ "./src/app/pages/locations/models/locationRequest.model.ts");
/* harmony import */ var _locations_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./locations.service */ "./src/app/pages/locations/locations.service.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");







let LocationsComponent = class LocationsComponent {
    constructor(fb, locationsService, toaster, route) {
        this.fb = fb;
        this.locationsService = locationsService;
        this.toaster = toaster;
        this.route = route;
        this.locationForm = fb.group({
            location: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required],
            seatId: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required],
            description: [''],
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.locationList = data['locationList'].DATA;
        });
        console.log(this.locationList);
    }
    saveLocation() {
        const locationRequestModel = new _models_locationRequest_model__WEBPACK_IMPORTED_MODULE_3__["LocationRequestModel"]();
        locationRequestModel.seatId = this.locationForm.get('seatId').value;
        locationRequestModel.location = this.locationForm.get('location').value;
        locationRequestModel.description = this.locationForm.get('description').value;
        this.locationsService.saveLocation(locationRequestModel).subscribe(data => {
            this.clear();
            if (data.MESSAGE == 'SEAT_ALREADY_EXSIST') {
                this.toaster.error('Seat already exist', '', { positionClass: 'toast-top-center' });
            }
            else {
                this.locationsService.getAllLocations().subscribe(locationList => {
                    this.locationList = locationList.DATA;
                });
                this.toaster.success('Seat added sucessfully!', '', { positionClass: 'toast-top-center' });
            }
        }, err => {
            this.toaster.error('Something went wrong!', '', { positionClass: 'toast-top-center' });
        });
    }
    clear() {
        this.locationForm.reset();
    }
};
LocationsComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-locations',
        template: __webpack_require__(/*! raw-loader!./locations.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/locations/locations.component.html"),
        styles: [__webpack_require__(/*! ./locations.component.scss */ "./src/app/pages/locations/locations.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"], _locations_service__WEBPACK_IMPORTED_MODULE_4__["LocationsService"], ngx_toastr__WEBPACK_IMPORTED_MODULE_5__["ToastrService"], _angular_router__WEBPACK_IMPORTED_MODULE_6__["ActivatedRoute"]])
], LocationsComponent);



/***/ }),

/***/ "./src/app/pages/locations/locations.service.ts":
/*!******************************************************!*\
  !*** ./src/app/pages/locations/locations.service.ts ***!
  \******************************************************/
/*! exports provided: LocationsService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationsService", function() { return LocationsService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");






let LocationsService = class LocationsService {
    constructor(http) {
        this.http = http;
        this.URL = environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].BASE_URL;
    }
    saveLocation(locationRequestModel) {
        return this.http.post(this.URL + "/seat", locationRequestModel).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    getAllLocations() {
        return this.http.get(this.URL + "/locations");
    }
};
LocationsService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_5__["HttpClient"]])
], LocationsService);



/***/ }),

/***/ "./src/app/pages/locations/models/locationRequest.model.ts":
/*!*****************************************************************!*\
  !*** ./src/app/pages/locations/models/locationRequest.model.ts ***!
  \*****************************************************************/
/*! exports provided: LocationRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationRequestModel", function() { return LocationRequestModel; });
class LocationRequestModel {
}


/***/ }),

/***/ "./src/app/pages/roles/roles.component.scss":
/*!**************************************************!*\
  !*** ./src/app/pages/roles/roles.component.scss ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".checkboxText {\n  display: inline;\n  font-size: 14px;\n  padding-left: 8px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy9yb2xlcy9yb2xlcy5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvcGFnZXMvcm9sZXMvcm9sZXMuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDSSxlQUFBO0VBQ0EsZUFBQTtFQUNBLGlCQUFBO0FDQ0oiLCJmaWxlIjoic3JjL2FwcC9wYWdlcy9yb2xlcy9yb2xlcy5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5jaGVja2JveFRleHR7XG4gICAgZGlzcGxheTogaW5saW5lO1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBwYWRkaW5nLWxlZnQ6IDhweDtcbn0iLCIuY2hlY2tib3hUZXh0IHtcbiAgZGlzcGxheTogaW5saW5lO1xuICBmb250LXNpemU6IDE0cHg7XG4gIHBhZGRpbmctbGVmdDogOHB4O1xufSJdfQ== */"

/***/ }),

/***/ "./src/app/pages/roles/roles.component.ts":
/*!************************************************!*\
  !*** ./src/app/pages/roles/roles.component.ts ***!
  \************************************************/
/*! exports provided: RolesComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RolesComponent", function() { return RolesComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");



let RolesComponent = class RolesComponent {
    constructor(route) {
        this.route = route;
        this.permissions = [];
    }
    ngOnInit() {
        this.rolePermissions = this.route.snapshot.data['permissions']['DATA'];
    }
    onSelectChanged(value) {
        if (value != "")
            this.permissions = this.rolePermissions[value];
        else
            this.permissions = [];
    }
};
RolesComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-roles',
        template: __webpack_require__(/*! raw-loader!./roles.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/roles/roles.component.html"),
        styles: [__webpack_require__(/*! ./roles.component.scss */ "./src/app/pages/roles/roles.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_2__["ActivatedRoute"]])
], RolesComponent);



/***/ }),

/***/ "./src/app/pages/roles/services/role-data-resolver.service.ts":
/*!********************************************************************!*\
  !*** ./src/app/pages/roles/services/role-data-resolver.service.ts ***!
  \********************************************************************/
/*! exports provided: RoleDataResolverService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoleDataResolverService", function() { return RoleDataResolverService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _role_data_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./role-data.service */ "./src/app/pages/roles/services/role-data.service.ts");



let RoleDataResolverService = class RoleDataResolverService {
    constructor(roleDataService) {
        this.roleDataService = roleDataService;
    }
    resolve(route, state) {
        return this.roleDataService.getPermissions();
    }
};
RoleDataResolverService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
        providedIn: 'root'
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_role_data_service__WEBPACK_IMPORTED_MODULE_2__["RoleDataService"]])
], RoleDataResolverService);



/***/ }),

/***/ "./src/app/pages/roles/services/role-data.service.ts":
/*!***********************************************************!*\
  !*** ./src/app/pages/roles/services/role-data.service.ts ***!
  \***********************************************************/
/*! exports provided: RoleDataService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoleDataService", function() { return RoleDataService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");




let RoleDataService = class RoleDataService {
    constructor(http) {
        this.http = http;
        this.BASE_DATA_URL = environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].BASE_URL;
    }
    getPermissions() {
        return this.http.get(this.BASE_DATA_URL + '/admin/roles', { headers: { 'Authorization': 'Bearer ' + localStorage.getItem('access_token') } });
    }
};
RoleDataService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
        providedIn: 'root'
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"]])
], RoleDataService);



/***/ }),

/***/ "./src/app/pages/team-mates/team-mates.component.scss":
/*!************************************************************!*\
  !*** ./src/app/pages/team-mates/team-mates.component.scss ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL3RlYW0tbWF0ZXMvdGVhbS1tYXRlcy5jb21wb25lbnQuc2NzcyJ9 */"

/***/ }),

/***/ "./src/app/pages/team-mates/team-mates.component.ts":
/*!**********************************************************!*\
  !*** ./src/app/pages/team-mates/team-mates.component.ts ***!
  \**********************************************************/
/*! exports provided: TeamMatesComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamMatesComponent", function() { return TeamMatesComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");



let TeamMatesComponent = class TeamMatesComponent {
    constructor(route) {
        this.route = route;
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.teamMemberList = data['memberList'].DATA;
            console.log(this.teamMemberList);
        });
        this.loggedUserTeam = localStorage.getItem('clusterId');
    }
};
TeamMatesComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-team-mates',
        template: __webpack_require__(/*! raw-loader!./team-mates.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/team-mates/team-mates.component.html"),
        styles: [__webpack_require__(/*! ./team-mates.component.scss */ "./src/app/pages/team-mates/team-mates.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_2__["ActivatedRoute"]])
], TeamMatesComponent);



/***/ }),

/***/ "./src/app/pages/team-mates/teamMates.service.ts":
/*!*******************************************************!*\
  !*** ./src/app/pages/team-mates/teamMates.service.ts ***!
  \*******************************************************/
/*! exports provided: TeamMatesService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamMatesService", function() { return TeamMatesService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");




let TeamMatesService = class TeamMatesService {
    constructor(http) {
        this.http = http;
        this.URL = environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].BASE_URL;
    }
    getAllTeamMembers() {
        return this.http.get(this.URL + "/teams/employees");
    }
};
TeamMatesService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_3__["HttpClient"]])
], TeamMatesService);



/***/ }),

/***/ "./src/app/pages/teams/models/clusterRequest.model.ts":
/*!************************************************************!*\
  !*** ./src/app/pages/teams/models/clusterRequest.model.ts ***!
  \************************************************************/
/*! exports provided: ClusterRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClusterRequestModel", function() { return ClusterRequestModel; });
class ClusterRequestModel {
}


/***/ }),

/***/ "./src/app/pages/teams/models/teamRequest.model.ts":
/*!*********************************************************!*\
  !*** ./src/app/pages/teams/models/teamRequest.model.ts ***!
  \*********************************************************/
/*! exports provided: TeamRequestModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamRequestModel", function() { return TeamRequestModel; });
class TeamRequestModel {
}


/***/ }),

/***/ "./src/app/pages/teams/teams.component.scss":
/*!**************************************************!*\
  !*** ./src/app/pages/teams/teams.component.scss ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".error {\n  color: #dc3545;\n  margin-top: 5px;\n  margin-bottom: -10px !important;\n  font-size: 12.8px;\n  font-family: \"Titillium Web\", sans-serif;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy90ZWFtcy90ZWFtcy5jb21wb25lbnQuc2NzcyIsInNyYy9hcHAvcGFnZXMvdGVhbXMvdGVhbXMuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxjQUFBO0VBQ0EsZUFBQTtFQUNBLCtCQUFBO0VBQ0EsaUJBQUE7RUFDQSx3Q0FBQTtBQ0NGIiwiZmlsZSI6InNyYy9hcHAvcGFnZXMvdGVhbXMvdGVhbXMuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuZXJyb3J7XG4gIGNvbG9yOiAjZGMzNTQ1O1xuICBtYXJnaW4tdG9wOiA1cHg7XG4gIG1hcmdpbi1ib3R0b206IC0xMHB4ICFpbXBvcnRhbnQ7XG4gIGZvbnQtc2l6ZTogMTIuOHB4O1xuICBmb250LWZhbWlseTogJ1RpdGlsbGl1bSBXZWInLCBzYW5zLXNlcmlmO1xufVxuIiwiLmVycm9yIHtcbiAgY29sb3I6ICNkYzM1NDU7XG4gIG1hcmdpbi10b3A6IDVweDtcbiAgbWFyZ2luLWJvdHRvbTogLTEwcHggIWltcG9ydGFudDtcbiAgZm9udC1zaXplOiAxMi44cHg7XG4gIGZvbnQtZmFtaWx5OiBcIlRpdGlsbGl1bSBXZWJcIiwgc2Fucy1zZXJpZjtcbn0iXX0= */"

/***/ }),

/***/ "./src/app/pages/teams/teams.component.ts":
/*!************************************************!*\
  !*** ./src/app/pages/teams/teams.component.ts ***!
  \************************************************/
/*! exports provided: TeamsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamsComponent", function() { return TeamsComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _teams_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./teams.service */ "./src/app/pages/teams/teams.service.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");
/* harmony import */ var _models_teamRequest_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/teamRequest.model */ "./src/app/pages/teams/models/teamRequest.model.ts");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");
/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ng-bootstrap/ng-bootstrap */ "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
/* harmony import */ var _models_clusterRequest_model__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./models/clusterRequest.model */ "./src/app/pages/teams/models/clusterRequest.model.ts");









let TeamsComponent = class TeamsComponent {
    constructor(fb, calendar, teamsService, toaster, route) {
        this.fb = fb;
        this.calendar = calendar;
        this.teamsService = teamsService;
        this.toaster = toaster;
        this.route = route;
        this.startDateSelected = false;
        this.DELIMITER = '-';
        // items: any[];
        this.dedicatedSeats = [];
        this.hotSeats = [];
        this.duplicates = [];
        this.teamForm = fb.group({
            teamName: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required],
            description: [''],
            location: [''],
        });
        this.clusterForm = fb.group({
            // clusterName: ['', Validators.required],
            // clusterdescription: [''],
            location: [''],
            teamName: [''],
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.locationList = data['locationList'].DATA;
            this.teamList = data['teamList'].DATA;
        });
        console.log(this.locationList[0].locationId);
    }
    onItemAddedToHot(event) {
        console.log(event);
        this.hotSeats.push(event);
        this.checkDuplicated();
    }
    onItemAddedToDedicated(event) {
        console.log(event);
        this.dedicatedSeats.push(event);
        console.log(this.dedicatedSeats);
        this.checkDuplicated();
    }
    removeHotSeats(event) {
        console.log(event);
        this.hotSeats = this.hotSeats.filter(({ value }) => value !== event.value);
        console.log(this.hotSeats);
        this.checkDuplicated();
    }
    removeDedicatedSeats(event) {
        console.log(event);
        this.dedicatedSeats = this.dedicatedSeats.filter(({ value }) => value !== event.value);
        console.log(this.dedicatedSeats);
        this.checkDuplicated();
    }
    saveTeams() {
        const teamRequestModel = new _models_teamRequest_model__WEBPACK_IMPORTED_MODULE_5__["TeamRequestModel"]();
        teamRequestModel.teamId = this.teamForm.get('teamName').value;
        teamRequestModel.description = this.teamForm.get('description').value;
        teamRequestModel.location = this.teamForm.get('location').value;
        this.teamsService.saveTeams(teamRequestModel).subscribe(data => {
            this.clear();
            this.getAllTeams();
            this.toaster.success('Team added sucessfully!', '', { positionClass: 'toast-top-center' });
        }, err => {
            this.toaster.error('Something went wrong!', '', { positionClass: 'toast-top-center' });
        });
    }
    clear() {
        this.teamForm.reset();
    }
    selectToday() {
        this.smodel = this.calendar.getToday();
        this.emodel = this.calendar.getToday();
    }
    getSeats(date) {
        this.formatedEndDate = this.formatDate(date);
        const request = {
            'startDate': this.formatedstartDate,
            'endDate': this.formatedEndDate,
            'location': this.clusterForm.get('location').value
        };
        this.teamsService.getSeats(request).subscribe(seats => {
            let seatList = seats.DATA;
            console.log(seatList);
            this.items = seatList;
        });
    }
    addStartDate(date) {
        this.startDateSelected = true;
        this.formatedstartDate = this.formatDate(date);
    }
    formatDate(date) {
        return date.year + this.DELIMITER + date.month + this.DELIMITER + date.day + '';
    }
    checkDuplicated() {
        // const firstArray = [1,2,3,4,5,6 ],
        // secondArray = [2,4,6,8],
        console.log(this.hotSeats);
        this.duplicates = this.hotSeats.filter(o => this.dedicatedSeats.some(({ display, value }) => o.display === display && o.value === value));
        console.log(this.duplicates);
    }
    saveSeatsForTeam() {
        let teamSeatCreateRequest = [];
        for (let hotseat of this.hotSeats) {
            let clusterRequestModel = new _models_clusterRequest_model__WEBPACK_IMPORTED_MODULE_8__["ClusterRequestModel"]();
            clusterRequestModel.location = this.clusterForm.get('location').value;
            // this.clusterForm.get('location').value;
            clusterRequestModel.startDate = this.formatedstartDate;
            clusterRequestModel.endDate = this.formatedEndDate;
            clusterRequestModel.seatId = hotseat.value;
            clusterRequestModel.type = 'Hot';
            clusterRequestModel.teamId = this.clusterForm.get('teamName').value;
            console.log(clusterRequestModel);
            teamSeatCreateRequest.push(clusterRequestModel);
        }
        for (let dedicatedSeat of this.dedicatedSeats) {
            let clusterRequestModel = new _models_clusterRequest_model__WEBPACK_IMPORTED_MODULE_8__["ClusterRequestModel"]();
            clusterRequestModel.location = this.clusterForm.get('location').value;
            // this.clusterForm.get('location').value;
            clusterRequestModel.type = 'Dedicated';
            clusterRequestModel.startDate = this.formatedstartDate;
            clusterRequestModel.endDate = this.formatedEndDate;
            clusterRequestModel.seatId = dedicatedSeat.value;
            clusterRequestModel.teamId = this.clusterForm.get('teamName').value;
            console.log(clusterRequestModel);
            teamSeatCreateRequest.push(clusterRequestModel);
        }
        console.log(teamSeatCreateRequest);
        let teamSeats = {
            teamSeatCreateRequest
        };
        this.teamsService.saveSeatsForTeam(teamSeats).subscribe(data => {
            this.clearClusterForm();
            if (data.MESSAGE === 'SEAT_ALREADY_BOOKED') {
                this.teamsService.getAllTeams().subscribe(teamList => {
                    this.teamList = teamList.DATA;
                });
                this.toaster.error('Some seats are already booked!', '', { positionClass: 'toast-top-center' });
            }
            else {
                this.toaster.success('Seats added sucessfully!', '', { positionClass: 'toast-top-center' });
            }
        });
    }
    clearClusterForm() {
        this.clusterForm.reset();
    }
    getAllTeams() {
        this.teamsService.getAllTeams().subscribe(teamList => {
            this.teamList = teamList.DATA;
        });
    }
};
TeamsComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-teams',
        template: __webpack_require__(/*! raw-loader!./teams.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/teams/teams.component.html"),
        styles: [__webpack_require__(/*! ./teams.component.scss */ "./src/app/pages/teams/teams.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"], _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_7__["NgbCalendar"], _teams_service__WEBPACK_IMPORTED_MODULE_3__["TeamsService"], ngx_toastr__WEBPACK_IMPORTED_MODULE_4__["ToastrService"], _angular_router__WEBPACK_IMPORTED_MODULE_6__["ActivatedRoute"]])
], TeamsComponent);



/***/ }),

/***/ "./src/app/pages/user-profile/services/useProfileResolver.ts":
/*!*******************************************************************!*\
  !*** ./src/app/pages/user-profile/services/useProfileResolver.ts ***!
  \*******************************************************************/
/*! exports provided: UseProfileResolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UseProfileResolver", function() { return UseProfileResolver; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _userProfileService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./userProfileService */ "./src/app/pages/user-profile/services/userProfileService.ts");



let UseProfileResolver = class UseProfileResolver {
    constructor(userProfileService) {
        this.userProfileService = userProfileService;
    }
    resolve(route, state) {
        return this.userProfileService.getAllUsers();
    }
};
UseProfileResolver = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_userProfileService__WEBPACK_IMPORTED_MODULE_2__["UserProfileService"]])
], UseProfileResolver);



/***/ }),

/***/ "./src/app/pages/user-profile/user-profile.component.scss":
/*!****************************************************************!*\
  !*** ./src/app/pages/user-profile/user-profile.component.scss ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".switch {\n  position: relative;\n  display: inline-block;\n  width: 60px;\n  height: 34px;\n}\n\n.switch input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n/* Rounded sliders */\n\n.slider.round {\n  border-radius: 34px;\n}\n\n.slider.round:before {\n  border-radius: 50%;\n}\n\n.slider {\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  transition: 0.4s;\n}\n\n.slider:before {\n  position: absolute;\n  content: \"\";\n  height: 26px;\n  width: 26px;\n  left: 4px;\n  bottom: 4px;\n  background-color: white;\n  transition: 0.4s;\n}\n\ninput:checked + .slider {\n  background-color: #51cbce;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #51cbce;\n}\n\ninput:checked + .slider:before {\n  -webkit-transform: translateX(26px);\n  transform: translateX(26px);\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy91c2VyLXByb2ZpbGUvdXNlci1wcm9maWxlLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9wYWdlcy91c2VyLXByb2ZpbGUvdXNlci1wcm9maWxlLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0ksa0JBQUE7RUFDQSxxQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0FDQ0o7O0FERUU7RUFDRSxVQUFBO0VBQ0EsUUFBQTtFQUNBLFNBQUE7QUNDSjs7QURHRSxvQkFBQTs7QUFDRjtFQUNJLG1CQUFBO0FDQUo7O0FER0U7RUFDRSxrQkFBQTtBQ0FKOztBREdFO0VBQ0Usa0JBQUE7RUFDQSxlQUFBO0VBQ0EsTUFBQTtFQUNBLE9BQUE7RUFDQSxRQUFBO0VBQ0EsU0FBQTtFQUNBLHNCQUFBO0VBRUEsZ0JBQUE7QUNBSjs7QURHRTtFQUNFLGtCQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0VBQ0EsU0FBQTtFQUNBLFdBQUE7RUFDQSx1QkFBQTtFQUVBLGdCQUFBO0FDQUo7O0FESUU7RUFDRSx5QkFBQTtBQ0RKOztBRElFO0VBQ0UsMkJBQUE7QUNESjs7QURJRTtFQUNFLG1DQUFBO0VBRUEsMkJBQUE7QUNESiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL3VzZXItcHJvZmlsZS91c2VyLXByb2ZpbGUuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuc3dpdGNoIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHdpZHRoOiA2MHB4O1xuICAgIGhlaWdodDogMzRweDtcbiAgfVxuICBcbiAgLnN3aXRjaCBpbnB1dCB7IFxuICAgIG9wYWNpdHk6IDA7XG4gICAgd2lkdGg6IDA7XG4gICAgaGVpZ2h0OiAwO1xuICB9XG5cbiAgXG4gIC8qIFJvdW5kZWQgc2xpZGVycyAqL1xuLnNsaWRlci5yb3VuZCB7XG4gICAgYm9yZGVyLXJhZGl1czogMzRweDtcbiAgfVxuICBcbiAgLnNsaWRlci5yb3VuZDpiZWZvcmUge1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgfVxuXG4gIC5zbGlkZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNjY2M7XG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiAuNHM7XG4gICAgdHJhbnNpdGlvbjogLjRzO1xuICB9XG4gIFxuICAuc2xpZGVyOmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgaGVpZ2h0OiAyNnB4O1xuICAgIHdpZHRoOiAyNnB4O1xuICAgIGxlZnQ6IDRweDtcbiAgICBib3R0b206IDRweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IC40cztcbiAgICB0cmFuc2l0aW9uOiAuNHM7XG4gIH1cblxuICBcbiAgaW5wdXQ6Y2hlY2tlZCArIC5zbGlkZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1MWNiY2U7XG4gIH1cbiAgXG4gIGlucHV0OmZvY3VzICsgLnNsaWRlciB7XG4gICAgYm94LXNoYWRvdzogMCAwIDFweCAjNTFjYmNlO1xuICB9XG4gIFxuICBpbnB1dDpjaGVja2VkICsgLnNsaWRlcjpiZWZvcmUge1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjZweCk7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xuICB9IiwiLnN3aXRjaCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB3aWR0aDogNjBweDtcbiAgaGVpZ2h0OiAzNHB4O1xufVxuXG4uc3dpdGNoIGlucHV0IHtcbiAgb3BhY2l0eTogMDtcbiAgd2lkdGg6IDA7XG4gIGhlaWdodDogMDtcbn1cblxuLyogUm91bmRlZCBzbGlkZXJzICovXG4uc2xpZGVyLnJvdW5kIHtcbiAgYm9yZGVyLXJhZGl1czogMzRweDtcbn1cblxuLnNsaWRlci5yb3VuZDpiZWZvcmUge1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG5cbi5zbGlkZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xuICAtd2Via2l0LXRyYW5zaXRpb246IDAuNHM7XG4gIHRyYW5zaXRpb246IDAuNHM7XG59XG5cbi5zbGlkZXI6YmVmb3JlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBjb250ZW50OiBcIlwiO1xuICBoZWlnaHQ6IDI2cHg7XG4gIHdpZHRoOiAyNnB4O1xuICBsZWZ0OiA0cHg7XG4gIGJvdHRvbTogNHB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAwLjRzO1xuICB0cmFuc2l0aW9uOiAwLjRzO1xufVxuXG5pbnB1dDpjaGVja2VkICsgLnNsaWRlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICM1MWNiY2U7XG59XG5cbmlucHV0OmZvY3VzICsgLnNsaWRlciB7XG4gIGJveC1zaGFkb3c6IDAgMCAxcHggIzUxY2JjZTtcbn1cblxuaW5wdXQ6Y2hlY2tlZCArIC5zbGlkZXI6YmVmb3JlIHtcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjZweCk7XG4gIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjZweCk7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcbn0iXX0= */"

/***/ }),

/***/ "./src/app/pages/user-profile/user-profile.component.ts":
/*!**************************************************************!*\
  !*** ./src/app/pages/user-profile/user-profile.component.ts ***!
  \**************************************************************/
/*! exports provided: UserProfileComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserProfileComponent", function() { return UserProfileComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ng-bootstrap/ng-bootstrap */ "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
/* harmony import */ var _ngbd_modal_content_ngbd_modal_content_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ngbd-modal-content/ngbd-modal-content.component */ "./src/app/pages/ngbd-modal-content/ngbd-modal-content.component.ts");
/* harmony import */ var _services_userProfileService__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./services/userProfileService */ "./src/app/pages/user-profile/services/userProfileService.ts");
/* harmony import */ var app_services_user_permission_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/services/user-permission.service */ "./src/app/services/user-permission.service.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");









let UserProfileComponent = class UserProfileComponent {
    constructor(route, fb, modalService, userProfileService, userPermissionService, toaster) {
        this.route = route;
        this.fb = fb;
        this.modalService = modalService;
        this.userProfileService = userProfileService;
        this.userPermissionService = userPermissionService;
        this.toaster = toaster;
        this.submitted = false;
        this.validateRequiredFeilds = false;
        this.userForm = fb.group({
            adName: ["", _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required],
            name: [""],
            email: [""],
            userRole: [""],
            isEnable: [""]
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.userList = data['userProfileList'].DATA;
            console.log(this.userList, data['userProfileList']);
        });
        this.userPermissionService.getUserName().subscribe(data => {
            console.log(data);
            this.userName = data;
        });
    }
    // convenience getter for easy access to form fields
    get formFileds() { return this.userForm.controls; }
    openConfirmation(id, status, type) {
        const modalRef = this.modalService.open(_ngbd_modal_content_ngbd_modal_content_component__WEBPACK_IMPORTED_MODULE_5__["NgbdModalContentComponent"], {
            beforeDismiss: () => this.getAllUsers()
        });
        modalRef.componentInstance.id = id;
        modalRef.componentInstance.type = type;
        if (status) {
            status = false;
        }
        else {
            status = true;
        }
        modalRef.componentInstance.status = status;
        modalRef.componentInstance.question = "Do you want to change the status of this user?";
    }
    getAllUsers() {
        this.userProfileService.getAllUsers().subscribe(users => {
            this.userList = users.DATA;
        });
        return true;
    }
    clear() {
        this.userForm.reset();
        this.submitted = false;
        this.userForm.get('adName').enable();
        this.validateRequiredFeilds = false;
    }
    save() {
        this.submitted = true;
        if (!this.userForm.valid) {
            this.userForm.markAllAsTouched();
            return;
        }
        let user = {
            adName: this.userForm.get('adName').value,
            adminName: this.userForm.get('name').value,
            adminEmail: this.userForm.get('email').value,
            adminUserRole: this.userForm.get('userRole').value,
            isActiveAdmin: this.userForm.get('isEnable').value
        };
        console.log(user);
        this.userProfileService.addAdminDetail(user).subscribe(data => {
            if (data.MESSAGE == "USER_ADDED") {
                this.toaster.success("User added successfully!", '', { positionClass: 'toast-top-center' });
                this.getAllUsers();
            }
            else if (data.MESSAGE == "USER_ADDED_FAILED") {
                this.toaster.error("Sorry, failed to add the selected user. Please try again.", '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == "USER_ALREADY_EXISTS") {
                this.toaster.error("Sorry, user already exists.", '', { positionClass: 'toast-top-center' });
            }
        });
        this.clear();
    }
    searchLdapUser() {
        this.submitted = true;
        if (!this.userForm.valid) {
            this.userForm.markAllAsTouched();
            return;
        }
        let userName = this.userForm.get('adName').value;
        this.userProfileService.searchLdapUserDetails(userName).subscribe(userDetails => {
            if (userDetails.MESSAGE == "SEARCH_SUCCESS") {
                this.validateRequiredFeilds = true;
                this.userForm.get('name').patchValue(userDetails.DATA.fullName);
                this.userForm.get('email').patchValue(userDetails.DATA.email);
                this.userForm.get('isEnable').patchValue(true);
                this.userForm.get('userRole').patchValue("ADMIN");
                this.userForm.get('adName').disable();
            }
            else if (userDetails.MESSAGE == "SEARCH_FAILED") {
                this.toaster.error("Sorry, we cannot find a user in the name you entered. Please check the name and try again.", '', { positionClass: 'toast-top-center' });
            }
            else if (userDetails.MESSAGE == "USER_NOT_FOUND") {
                this.toaster.error("Sorry, we cannot find a user in the name you entered. Please check the name and try again.", '', { positionClass: 'toast-top-center' });
            }
        });
    }
};
UserProfileComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-user-profile',
        template: __webpack_require__(/*! raw-loader!./user-profile.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/user-profile/user-profile.component.html"),
        styles: [__webpack_require__(/*! ./user-profile.component.scss */ "./src/app/pages/user-profile/user-profile.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_2__["ActivatedRoute"], _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"], _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_4__["NgbModal"],
        _services_userProfileService__WEBPACK_IMPORTED_MODULE_6__["UserProfileService"], app_services_user_permission_service__WEBPACK_IMPORTED_MODULE_7__["UserPermissionService"],
        ngx_toastr__WEBPACK_IMPORTED_MODULE_8__["ToastrService"]])
], UserProfileComponent);



/***/ }),

/***/ "./src/app/pages/user-role-list/user-role-list.component.scss":
/*!********************************************************************!*\
  !*** ./src/app/pages/user-role-list/user-role-list.component.scss ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3BhZ2VzL3VzZXItcm9sZS1saXN0L3VzZXItcm9sZS1saXN0LmNvbXBvbmVudC5zY3NzIn0= */"

/***/ }),

/***/ "./src/app/pages/user-role-list/user-role-list.component.ts":
/*!******************************************************************!*\
  !*** ./src/app/pages/user-role-list/user-role-list.component.ts ***!
  \******************************************************************/
/*! exports provided: UserRoleListComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserRoleListComponent", function() { return UserRoleListComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");


let UserRoleListComponent = class UserRoleListComponent {
    ngOnInit() {
        this.tableData1 = {
            headerRow: ['ID', 'Name', 'Country', 'City', 'Salary'],
            dataRows: [
                ['1', 'Dakota Rice', 'Niger', 'Oud-Turnhout', '$36,738'],
                ['2', 'Minerva Hooper', 'Curaçao', 'Sinaai-Waas', '$23,789'],
                ['3', 'Sage Rodriguez', 'Netherlands', 'Baileux', '$56,142'],
                ['4', 'Philip Chaney', 'Korea, South', 'Overland Park', '$38,735'],
                ['5', 'Doris Greene', 'Malawi', 'Feldkirchen in Kärnten', '$63,542'],
                ['6', 'Mason Porter', 'Chile', 'Gloucester', '$78,615']
            ]
        };
        this.tableData2 = {
            headerRow: ['ID', 'Name', 'Salary', 'Country', 'City'],
            dataRows: [
                ['1', 'Dakota Rice', '$36,738', 'Niger', 'Oud-Turnhout'],
                ['2', 'Minerva Hooper', '$23,789', 'Curaçao', 'Sinaai-Waas'],
                ['3', 'Sage Rodriguez', '$56,142', 'Netherlands', 'Baileux'],
                ['4', 'Philip Chaney', '$38,735', 'Korea, South', 'Overland Park'],
                ['5', 'Doris Greene', '$63,542', 'Malawi', 'Feldkirchen in Kärnten',],
                ['6', 'Mason Porter', '$78,615', 'Chile', 'Gloucester']
            ]
        };
    }
};
UserRoleListComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-user-role-list',
        template: __webpack_require__(/*! raw-loader!./user-role-list.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/user-role-list/user-role-list.component.html"),
        styles: [__webpack_require__(/*! ./user-role-list.component.scss */ "./src/app/pages/user-role-list/user-role-list.component.scss")]
    })
], UserRoleListComponent);



/***/ }),

/***/ "./src/app/pages/user/user.component.ts":
/*!**********************************************!*\
  !*** ./src/app/pages/user/user.component.ts ***!
  \**********************************************/
/*! exports provided: UserComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserComponent", function() { return UserComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");


let UserComponent = class UserComponent {
    ngOnInit() {
    }
};
UserComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'user-cmp',
        template: __webpack_require__(/*! raw-loader!./user.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/user/user.component.html")
    })
], UserComponent);



/***/ }),

/***/ "./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.scss":
/*!******************************************************************************!*\
  !*** ./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.scss ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".seat {\n  cursor: not-allowed;\n  opacity: 0.6;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXJpeWFua2Fua2lydXBhaGFyYW4vRGVza3RvcC9GaXJzdFllYXIvNTM2L0hvdERlc2tTYW1wbGUvRnJvbnRFbmQvTGF0ZXN0L2FkbC1ob3N0LWRlc2stZnJvbnRlbmQvc3JjL2FwcC9wYWdlcy93ZWVrbHktc2VhdC1ib29raW5nL3dlZWtseS1zZWF0LWJvb2tpbmcuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL3BhZ2VzL3dlZWtseS1zZWF0LWJvb2tpbmcvd2Vla2x5LXNlYXQtYm9va2luZy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLG1CQUFBO0VBQ0EsWUFBQTtBQ0NGIiwiZmlsZSI6InNyYy9hcHAvcGFnZXMvd2Vla2x5LXNlYXQtYm9va2luZy93ZWVrbHktc2VhdC1ib29raW5nLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnNlYXR7XG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gIG9wYWNpdHk6IDAuNjtcbn1cbiIsIi5zZWF0IHtcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgb3BhY2l0eTogMC42O1xufSJdfQ== */"

/***/ }),

/***/ "./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.ts":
/*!****************************************************************************!*\
  !*** ./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.ts ***!
  \****************************************************************************/
/*! exports provided: WeeklySeatBookingComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WeeklySeatBookingComponent", function() { return WeeklySeatBookingComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ng-bootstrap/ng-bootstrap */ "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
/* harmony import */ var _employee_seat_booking_models_hSeatBookingRequest_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../employee-seat-booking/models/hSeatBookingRequest.model */ "./src/app/pages/employee-seat-booking/models/hSeatBookingRequest.model.ts");
/* harmony import */ var ngx_toastr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ngx-toastr */ "./node_modules/ngx-toastr/fesm2015/ngx-toastr.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");
/* harmony import */ var _weeklySeatBooking_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./weeklySeatBooking.service */ "./src/app/pages/weekly-seat-booking/weeklySeatBooking.service.ts");
/* harmony import */ var _employee_seat_booking_models_getweeklySeatsRequest_model__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../employee-seat-booking/models/getweeklySeatsRequest.model */ "./src/app/pages/employee-seat-booking/models/getweeklySeatsRequest.model.ts");









let WeeklySeatBookingComponent = class WeeklySeatBookingComponent {
    constructor(calendar, fb, weeklySeatBookingService, toaster, route) {
        this.calendar = calendar;
        this.fb = fb;
        this.weeklySeatBookingService = weeklySeatBookingService;
        this.toaster = toaster;
        this.route = route;
        this.startDateSelected = false;
        this.formatedstartDate = null;
        this.dedicatedSeatBookings = null;
        this.totalSeatsforTeam = null;
        this.totalSeats = null;
        this.allBookings = null;
        this.selectedSeatId = null;
        this.DELIMITER = '-';
        this.teamMemberList = [];
        this.locationSelected = false;
        this.isDisable = true;
        this.displayYourSeat = false;
        this.userName = '';
        this.bookingForm = fb.group({
            adName: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required],
            location: [''],
        });
    }
    ngOnInit() {
        this.route.data.subscribe(data => {
            this.locationList = data['locationList'].DATA;
            this.totalSeats = data['memberList'].DATA;
            console.log(this.teamMemberList);
        });
        this.loggedUserTeam = localStorage.getItem('clusterId');
        for (let emp of this.totalSeats) {
            if (this.loggedUserTeam == emp.team) {
                this.teamMemberList.push(emp);
                console.log(this.teamMemberList);
            }
        }
        let displayName = localStorage.getItem('userName');
        this.userName = displayName.match(/[^_]+_[^_]+/g).toString();
    }
    getAllSeatsForLocation(value) {
        this.locationSelected = true;
        this.selectedSeatId = '';
        this.isDisable = true;
        this.weeklySeatBookingService.getAllSeatsForLocation(value).subscribe(allSeats => {
            this.seats = allSeats.DATA.seatNos;
            console.log(allSeats, this.seats);
        });
    }
    changeBackground(seatId) {
        if (this.dedicatedSeatBookings != null) {
            for (let val of this.dedicatedSeatBookings) {
                if (val.seatId == seatId) {
                    if (val.type == 'Dedicated') {
                        return { 'border': '3px solid #4FB0F9', 'cursor': 'pointer', 'opacity': '1' }; //blue
                    }
                    else if (val.type == 'Hot') {
                        return { 'border': '3px solid #53AA33' }; //green
                    }
                }
            }
            for (let val of this.totalSeatsforTeam) {
                if (val.seatId == seatId) {
                    return { 'border': '3px solid red' };
                }
            }
        }
    }
    getSeats(date) {
        this.isDisable = true;
        // this.formatedstartDate = date.year + this.DELIMITER + date.month + this.DELIMITER + date.day + '';
        this.formatedEndDate = this.formatDate(date);
        let getweeklySeatsRequestModel = new _employee_seat_booking_models_getweeklySeatsRequest_model__WEBPACK_IMPORTED_MODULE_8__["GetweeklySeatsRequestModel"]();
        getweeklySeatsRequestModel.startDate = this.formatedstartDate;
        getweeklySeatsRequestModel.endDate = this.formatedEndDate;
        getweeklySeatsRequestModel.clusterId = localStorage.getItem('clusterId');
        this.weeklySeatBookingService.getAllSeats(getweeklySeatsRequestModel).subscribe(allSeats => {
            this.totalSeatsforTeam = allSeats.DATA.totalSeatsforTeam;
            this.dedicatedSeatBookings = allSeats.DATA.availableSeats;
            this.allBookings = allSeats.DATA.allBookings;
        });
    }
    formatDate(date) {
        console.log(date);
        return date.year + this.DELIMITER + date.month + this.DELIMITER + date.day + '';
    }
    addStartDate(date) {
        console.log("addStartDate");
        this.startDateSelected = true;
        this.formatedstartDate = this.formatDate(date);
    }
    yourSeat(seatId) {
        if (this.allBookings != null) {
            for (let val of this.allBookings) {
                if (val.seatId === seatId) {
                    if (val.employeeId === this.userName) {
                        return { 'visibility': 'visible' };
                    }
                    else if (val.employeeId !== this.userName) {
                        return { 'visibility': 'hidden' };
                    }
                }
            }
            for (let val of this.seats) {
                return { 'visibility': 'hidden' };
            }
        }
    }
    selectedSeat(seatId) {
        console.log('seatId', seatId);
        this.selectedSeatId = seatId;
        this.buttonVisibility(seatId);
    }
    buttonVisibility(seatId) {
        this.isDisable = true;
        for (let val of this.dedicatedSeatBookings) {
            if (val.seatId == seatId) {
                if (val.type == 'Dedicated') {
                    console.log('Dedicated', seatId);
                    this.isDisable = false;
                    return;
                }
                else if (val.type == 'Hot') {
                    console.log('Hot', seatId);
                    this.isDisable = true;
                    return;
                }
            }
            else {
                this.isDisable = true;
            }
        }
    }
    bookDedicatedSeats() {
        if (!this.bookingForm.valid || this.formatedstartDate == null || this.selectedSeatId == null) {
            this.toaster.error('Some fields are empty', '', { positionClass: 'toast-top-center' });
            return;
        }
        const hSeatBookingRequestModel = new _employee_seat_booking_models_hSeatBookingRequest_model__WEBPACK_IMPORTED_MODULE_4__["HSeatBookingRequestModel"]();
        hSeatBookingRequestModel.empId = this.bookingForm.get('adName').value;
        hSeatBookingRequestModel.endDate = this.formatedEndDate;
        hSeatBookingRequestModel.startDate = this.formatedstartDate;
        hSeatBookingRequestModel.seatNo = this.selectedSeatId;
        hSeatBookingRequestModel.clusterId = localStorage.getItem('clusterId');
        let location = this.bookingForm.get('location').value;
        this.getAllSeatsForLocation(location);
        this.weeklySeatBookingService.bookHotSeat(hSeatBookingRequestModel).subscribe(data => {
            if (data.MESSAGE == 'SEAT_DOES_NOT_BELONG_TO_TEAM') {
                this.toaster.error('Seat does not belong to team !', '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == 'SEAT_ALREADY_BOOKED') {
                this.toaster.error('Seat already booked', '', { positionClass: 'toast-top-center' });
            }
            else if (data.MESSAGE == 'BOOKING_CREATED') {
                this.toaster.success('Dedicated seat booked sucessfully!', '', { positionClass: 'toast-top-center' });
                this.bookingForm.reset();
            }
            else {
                this.toaster.error('Something went wrong', '', { positionClass: 'toast-top-center' });
            }
        });
    }
};
WeeklySeatBookingComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
        selector: 'app-weekly-seat-booking',
        template: __webpack_require__(/*! raw-loader!./weekly-seat-booking.component.html */ "./node_modules/raw-loader/index.js!./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.html"),
        styles: [__webpack_require__(/*! ./weekly-seat-booking.component.scss */ "./src/app/pages/weekly-seat-booking/weekly-seat-booking.component.scss")]
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__["NgbCalendar"], _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"], _weeklySeatBooking_service__WEBPACK_IMPORTED_MODULE_7__["WeeklySeatBookingService"],
        ngx_toastr__WEBPACK_IMPORTED_MODULE_5__["ToastrService"], _angular_router__WEBPACK_IMPORTED_MODULE_6__["ActivatedRoute"]])
], WeeklySeatBookingComponent);



/***/ }),

/***/ "./src/app/pages/weekly-seat-booking/weeklySeatBooking.service.ts":
/*!************************************************************************!*\
  !*** ./src/app/pages/weekly-seat-booking/weeklySeatBooking.service.ts ***!
  \************************************************************************/
/*! exports provided: WeeklySeatBookingService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WeeklySeatBookingService", function() { return WeeklySeatBookingService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");






let WeeklySeatBookingService = class WeeklySeatBookingService {
    constructor(http) {
        this.http = http;
        this.URL = environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].BASE_URL;
    }
    getAllSeatsForLocation(value) {
        return this.http.post(this.URL + '/seat/location', { 'location': value });
    }
    getAllSeats(getweeklySeatsRequestModel) {
        return this.http.post(this.URL + "/seats/available/bulk", getweeklySeatsRequestModel).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
    bookHotSeat(hSeatBookingRequest) {
        return this.http.post(this.URL + "/booking", hSeatBookingRequest).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])((error) => {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])(error);
        }));
    }
};
WeeklySeatBookingService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_5__["HttpClient"]])
], WeeklySeatBookingService);



/***/ }),

/***/ "./src/app/shared/directives/numbers-only.directive.ts":
/*!*************************************************************!*\
  !*** ./src/app/shared/directives/numbers-only.directive.ts ***!
  \*************************************************************/
/*! exports provided: NumberDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberDirective", function() { return NumberDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");


let NumberDirective = class NumberDirective {
    constructor(_el) {
        this._el = _el;
    }
    onInputChange(event) {
        const initalValue = this._el.nativeElement.value;
        this._el.nativeElement.value = initalValue.replace(/[^0-9]*/g, '');
        if (initalValue !== this._el.nativeElement.value) {
            event.stopPropagation();
        }
    }
};
tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('input', ['$event']),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object]),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
], NumberDirective.prototype, "onInputChange", null);
NumberDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'input[numbersOnly]'
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
], NumberDirective);



/***/ }),

/***/ "./src/app/shared/directives/prices.directive.ts":
/*!*******************************************************!*\
  !*** ./src/app/shared/directives/prices.directive.ts ***!
  \*******************************************************/
/*! exports provided: PriceDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PriceDirective", function() { return PriceDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");


let PriceDirective = class PriceDirective {
    constructor(_el) {
        this._el = _el;
    }
    onInputChange(event) {
        const initalValue = this._el.nativeElement.value;
        this._el.nativeElement.value = initalValue.replace(/[^0-9.]*/g, '');
        if (initalValue !== this._el.nativeElement.value) {
            event.stopPropagation();
        }
    }
};
tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('input', ['$event']),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object]),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
], PriceDirective.prototype, "onInputChange", null);
PriceDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
        selector: 'input[priceOnly]'
    }),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
], PriceDirective);



/***/ }),

/***/ "./src/app/shared/resolvers/GetLocationListResolver.ts":
/*!*************************************************************!*\
  !*** ./src/app/shared/resolvers/GetLocationListResolver.ts ***!
  \*************************************************************/
/*! exports provided: GetLocationListResolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetLocationListResolver", function() { return GetLocationListResolver; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var app_pages_locations_locations_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/pages/locations/locations.service */ "./src/app/pages/locations/locations.service.ts");



let GetLocationListResolver = class GetLocationListResolver {
    constructor(locationsService) {
        this.locationsService = locationsService;
    }
    resolve(route, state) {
        return this.locationsService.getAllLocations();
    }
};
GetLocationListResolver = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_pages_locations_locations_service__WEBPACK_IMPORTED_MODULE_2__["LocationsService"]])
], GetLocationListResolver);



/***/ }),

/***/ "./src/app/shared/resolvers/getLocationResolver.ts":
/*!*********************************************************!*\
  !*** ./src/app/shared/resolvers/getLocationResolver.ts ***!
  \*********************************************************/
/*! exports provided: GetLocationResolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetLocationResolver", function() { return GetLocationResolver; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var app_pages_locations_locations_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/pages/locations/locations.service */ "./src/app/pages/locations/locations.service.ts");



let GetLocationResolver = class GetLocationResolver {
    constructor(locationsService) {
        this.locationsService = locationsService;
    }
    resolve(route, state) {
        return this.locationsService.getAllLocations();
    }
};
GetLocationResolver = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_pages_locations_locations_service__WEBPACK_IMPORTED_MODULE_2__["LocationsService"]])
], GetLocationResolver);



/***/ }),

/***/ "./src/app/shared/resolvers/getTeamMemberResolver.ts":
/*!***********************************************************!*\
  !*** ./src/app/shared/resolvers/getTeamMemberResolver.ts ***!
  \***********************************************************/
/*! exports provided: GetTeamMemberResolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetTeamMemberResolver", function() { return GetTeamMemberResolver; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var app_pages_teams_teams_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/pages/teams/teams.service */ "./src/app/pages/teams/teams.service.ts");



let GetTeamMemberResolver = class GetTeamMemberResolver {
    constructor(teamsService) {
        this.teamsService = teamsService;
    }
    resolve(route, state) {
        return this.teamsService.getAllTeamMembers();
    }
};
GetTeamMemberResolver = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_pages_teams_teams_service__WEBPACK_IMPORTED_MODULE_2__["TeamsService"]])
], GetTeamMemberResolver);



/***/ }),

/***/ "./src/app/shared/resolvers/teamMateResolver.ts":
/*!******************************************************!*\
  !*** ./src/app/shared/resolvers/teamMateResolver.ts ***!
  \******************************************************/
/*! exports provided: TeamMateResolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamMateResolver", function() { return TeamMateResolver; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
/* harmony import */ var app_pages_team_mates_teamMates_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/pages/team-mates/teamMates.service */ "./src/app/pages/team-mates/teamMates.service.ts");



let TeamMateResolver = class TeamMateResolver {
    constructor(teamMatesService) {
        this.teamMatesService = teamMatesService;
    }
    resolve(route, state) {
        return this.teamMatesService.getAllTeamMembers();
    }
};
TeamMateResolver = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
    tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_pages_team_mates_teamMates_service__WEBPACK_IMPORTED_MODULE_2__["TeamMatesService"]])
], TeamMateResolver);



/***/ })

}]);
//# sourceMappingURL=layouts-admin-layout-admin-layout-module-es2015.js.map